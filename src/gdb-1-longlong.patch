diff --git a/bfd/aix5ppc-core.c b/bfd/aix5ppc-core.c
index 0922c18..aa0e8d0 100644
--- a/bfd/aix5ppc-core.c
+++ b/bfd/aix5ppc-core.c
@@ -52,7 +52,7 @@ const bfd_target *
 xcoff64_core_p (bfd *abfd)
 {
   enum bfd_architecture arch;
-  unsigned long mach;
+  unsigned long long mach;
   struct core_dumpxx core, *new_core_hdr;
   struct stat statbuf;
   asection *sec;
diff --git a/bfd/aout-target.h b/bfd/aout-target.h
index 9123afc..b315758 100644
--- a/bfd/aout-target.h
+++ b/bfd/aout-target.h
@@ -39,7 +39,7 @@ MY (callback) (bfd *abfd)
 {
   struct internal_exec *execp = exec_hdr (abfd);
   unsigned int arch_align_power;
-  unsigned long arch_align;
+  unsigned long long arch_align;
 
   /* Calculate the file positions of the parts of a newly read aout header.  */
   obj_textsec (abfd)->size = N_TXTSIZE (execp);
diff --git a/bfd/aout-tic30.c b/bfd/aout-tic30.c
index ddeaaaa..fcc23a1 100644
--- a/bfd/aout-tic30.c
+++ b/bfd/aout-tic30.c
@@ -336,7 +336,7 @@ tic30_aout_callback (bfd *abfd)
 {
   struct internal_exec *execp = exec_hdr (abfd);
   unsigned int arch_align_power;
-  unsigned long arch_align;
+  unsigned long long arch_align;
 
   /* Calculate the file positions of the parts of a newly read aout header.  */
   obj_textsec (abfd)->size = N_TXTSIZE (execp);
@@ -768,7 +768,7 @@ MY_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
 
 static enum machine_type
 tic30_aout_machine_type (enum bfd_architecture arch,
-			 unsigned long machine ATTRIBUTE_UNUSED,
+			 unsigned long long machine ATTRIBUTE_UNUSED,
 			 bfd_boolean *unknown)
 {
   enum machine_type arch_flags;
@@ -792,7 +792,7 @@ tic30_aout_machine_type (enum bfd_architecture arch,
 static bfd_boolean
 tic30_aout_set_arch_mach (bfd *abfd,
 			  enum bfd_architecture arch,
-			  unsigned long machine)
+			  unsigned long long machine)
 {
   if (!bfd_default_set_arch_mach (abfd, arch, machine))
     return FALSE;
diff --git a/bfd/aoutx.h b/bfd/aoutx.h
index 023843b..1be5eca 100644
--- a/bfd/aoutx.h
+++ b/bfd/aoutx.h
@@ -710,7 +710,7 @@ DESCRIPTION
 
 enum machine_type
 NAME (aout, machine_type) (enum bfd_architecture arch,
-			   unsigned long machine,
+			   unsigned long long machine,
 			   bfd_boolean *unknown)
 {
   enum machine_type arch_flags;
@@ -855,7 +855,7 @@ DESCRIPTION
 bfd_boolean
 NAME (aout, set_arch_mach) (bfd *abfd,
 			    enum bfd_architecture arch,
-			    unsigned long machine)
+			    unsigned long long machine)
 {
   if (! bfd_default_set_arch_mach (abfd, arch, machine))
     return FALSE;
@@ -1921,7 +1921,7 @@ error_return:
   return FALSE;
 }
 
-long
+long long
 NAME (aout, canonicalize_symtab) (bfd *abfd, asymbol **location)
 {
   unsigned int counter = 0;
@@ -2447,7 +2447,7 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)
 
 /* This is stupid.  This function should be a boolean predicate.  */
 
-long
+long long
 NAME (aout, canonicalize_reloc) (bfd *abfd,
 				 sec_ptr section,
 				 arelent **relptr,
@@ -2488,7 +2488,7 @@ NAME (aout, canonicalize_reloc) (bfd *abfd,
   return section->reloc_count;
 }
 
-long
+long long
 NAME (aout, get_reloc_upper_bound) (bfd *abfd, sec_ptr asect)
 {
   if (bfd_get_format (abfd) != bfd_object)
@@ -2520,7 +2520,7 @@ NAME (aout, get_reloc_upper_bound) (bfd *abfd, sec_ptr asect)
   return -1;
 }
 
-long
+long long
 NAME (aout, get_symtab_upper_bound) (bfd *abfd)
 {
   if (!NAME (aout, slurp_symbol_table) (abfd))
@@ -2609,7 +2609,7 @@ NAME (aout, print_symbol) (bfd *abfd,
    symbols.  The minisymbol_to_symbol function translates these into
    BFD asymbol structures.  */
 
-long
+long long
 NAME (aout, read_minisymbols) (bfd *abfd,
 			       bfd_boolean dynamic,
 			       void * *minisymsp,
diff --git a/bfd/arc-got.h b/bfd/arc-got.h
index a86061b..59388a3 100644
--- a/bfd/arc-got.h
+++ b/bfd/arc-got.h
@@ -118,7 +118,7 @@ new_got_entry_to_list (struct got_entry **list,
 
   ARC_DEBUG ("New GOT got entry added to list: "
 	     "type: %d, offset: %ld, existing_entries: %d\n",
-	     type, (long) offset, existing_entries);
+	     type, (long long) offset, existing_entries);
 
   /* Add the entry to the end of the list.  */
   *p = entry;
@@ -153,7 +153,7 @@ tls_type_for_reloc (reloc_howto_type *howto)
 
 static struct got_entry **
 get_got_entry_list_for_symbol (bfd *abfd,
-			       unsigned long r_symndx,
+			       unsigned long long r_symndx,
 			       struct elf_link_hash_entry *h)
 {
   if (h != NULL)
@@ -266,7 +266,7 @@ relocate_fix_got_relocs_for_got_info (struct got_entry **	   list_p,
 				      enum tls_type_e		   type,
 				      struct bfd_link_info *	   info,
 				      bfd *			   output_bfd,
-				      unsigned long		   r_symndx,
+				      unsigned long long		   r_symndx,
 				      Elf_Internal_Sym *	   local_syms,
 				      asection **		   local_sections,
 				      struct elf_link_hash_entry * h,
@@ -339,8 +339,8 @@ relocate_fix_got_relocs_for_got_info (struct got_entry **	   list_p,
 			   "@ %lx, for symbol %s\n",
 			   (entry->type == GOT_TLS_GD ? "GOT_TLS_GD" :
 			    "GOT_TLS_IE"),
-			   (long) (sym_value - sec_vma),
-			   (long) (htab->sgot->output_section->vma
+			   (long long) (sym_value - sec_vma),
+			   (long long) (htab->sgot->output_section->vma
 			      + htab->sgot->output_offset->vma
 			      + entry->offset
 			      + (entry->existing_entries == TLS_GOT_MOD_AND_OFF
@@ -366,8 +366,8 @@ relocate_fix_got_relocs_for_got_info (struct got_entry **	   list_p,
 			   "@ %p, for symbol %s\n",
 			   (entry->type == GOT_TLS_GD ? "GOT_TLS_GD" :
 			    "GOT_TLS_IE"),
-			   (long) (sym_value - sec_vma),
-			   (long) (htab->sgot->output_section->vma
+			   (long long) (sym_value - sec_vma),
+			   (long long) (htab->sgot->output_section->vma
 			      + htab->sgot->output_offset->vma
 			      + entry->offset
 			      + (entry->existing_entries == TLS_GOT_MOD_AND_OFF
@@ -387,11 +387,11 @@ relocate_fix_got_relocs_for_got_info (struct got_entry **	   list_p,
 		  ARC_DEBUG ("arc_info: PATCHED: NOT_PATCHED "
 			     "@ %#08lx for sym %s in got offset %#lx "
 			     "(is undefweak)\n",
-			     (long) (htab->sgot->output_section->vma
+			     (long long) (htab->sgot->output_section->vma
 				     + htab->sgot->output_offset
 				     + entry->offset),
 			     symbol_name,
-			     (long) entry->offset);
+			     (long long) entry->offset);
 		else
 		  {
 		    bfd_put_32 (output_bfd,
@@ -399,11 +399,11 @@ relocate_fix_got_relocs_for_got_info (struct got_entry **	   list_p,
 				htab->sgot->contents + entry->offset);
 		    ARC_DEBUG ("arc_info: PATCHED: %#08lx "
 			       "@ %#08lx for sym %s in got offset %#lx\n",
-			       (long) (reloc_data->sym_value + sec_vma),
-			       (long) (htab->sgot->output_section->vma
+			       (long long) (reloc_data->sym_value + sec_vma),
+			       (long long) (htab->sgot->output_section->vma
 				       + htab->sgot->output_offset + entry->offset),
 			       symbol_name,
-			       (long) entry->offset);
+			       (long long) entry->offset);
 		  }
 	      }
 	      break;
@@ -471,10 +471,10 @@ create_got_dynrelocs_for_single_entry (struct got_entry *list,
 	      ARC_DEBUG ("arc_info: TLS_DYNRELOC: type = %d, \
 GOT_OFFSET = %#lx, GOT_VMA = %#lx, INDEX = %ld, ADDEND = 0x0\n",
 			 list->type,
-			 (long) got_offset,
-			 (long) (htab->sgot->output_section->vma
+			 (long long) got_offset,
+			 (long long) (htab->sgot->output_section->vma
 				 + htab->sgot->output_offset + got_offset),
-			 (long) dynindx);
+			 (long long) dynindx);
 	}
 
       if (e == TLS_GOT_MOD_AND_OFF || e == TLS_GOT_OFF)
@@ -496,10 +496,10 @@ GOT_OFFSET = %#lx, GOT_VMA = %#lx, INDEX = %ld, ADDEND = 0x0\n",
 	  ARC_DEBUG ("arc_info: TLS_DYNRELOC: type = %d, \
 GOT_OFFSET = %#lx, GOT_VMA = %#lx, INDEX = %ld, ADDEND = %#lx\n",
 		     list->type,
-		     (long) got_offset,
-		     (long) (htab->sgot->output_section->vma
+		     (long long) got_offset,
+		     (long long) (htab->sgot->output_section->vma
 			     + htab->sgot->output_offset + got_offset),
-		     (long) dynindx, (long) addend);
+		     (long long) dynindx, (long long) addend);
 	}
       list->created_dyn_relocation = TRUE;
     }
diff --git a/bfd/archive.c b/bfd/archive.c
index a51c135..9466f94 100644
--- a/bfd/archive.c
+++ b/bfd/archive.c
@@ -170,7 +170,7 @@ struct ar_cache
   (NAME[0] == '#'  && NAME[1] == '1' && NAME[2] == '/' && ISDIGIT (NAME[3]))
 
 void
-_bfd_ar_spacepad (char *p, size_t n, const char *fmt, long val)
+_bfd_ar_spacepad (char *p, size_t n, const char *fmt, long long val)
 {
   static char buf[20];
   size_t len;
@@ -431,7 +431,7 @@ find_nested_archive (const char *filename, bfd *arch_bfd)
 static char *
 get_extended_arelt_filename (bfd *arch, const char *name, file_ptr *originp)
 {
-  unsigned long table_index = 0;
+  unsigned long long table_index = 0;
   const char *endp;
 
   /* Should extract string so that I can guarantee not to overflow into
@@ -1017,7 +1017,7 @@ do_slurp_coff_armap (bfd *abfd)
   carsym *carsyms;
   bfd_size_type nsymz;		/* Number of symbols in armap.  */
   bfd_vma (*swap) (const void *);
-  char int_buf[sizeof (long)];
+  char int_buf[sizeof (long long)];
   bfd_size_type carsym_size, ptrsize;
   unsigned int i;
 
@@ -1501,7 +1501,7 @@ _bfd_construct_extended_name_table (bfd *abfd,
   bfd *current;
   char *strptr;
   const char *last_filename;
-  long last_stroff;
+  long long last_stroff;
 
   *tablen = 0;
   last_filename = NULL;
@@ -1606,7 +1606,7 @@ _bfd_construct_extended_name_table (bfd *abfd,
     {
       const char *normal;
       unsigned int thislen;
-      long stroff;
+      long long stroff;
       const char *filename = current->filename;
 
       if (bfd_is_thin_archive (abfd))
@@ -1793,7 +1793,7 @@ _bfd_noarchive_write_ar_hdr (bfd *archive, bfd *abfd ATTRIBUTE_UNUSED)
 /* Function to encode large UID/GID values according to HP.  */
 
 static void
-hpux_uid_gid_encode (char str[6], long int id)
+hpux_uid_gid_encode (char str[6], long long int id)
 {
   int cnt;
 
@@ -1867,7 +1867,7 @@ bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
   /* HP has a very "special" way to handle UID/GID's with numeric values
      > 99999.  */
   if (status.st_uid > 99999)
-    hpux_uid_gid_encode (hdr->ar_uid, (long) status.st_uid);
+    hpux_uid_gid_encode (hdr->ar_uid, (long long) status.st_uid);
   else
 #endif
     _bfd_ar_spacepad (hdr->ar_uid, sizeof (hdr->ar_uid), "%ld",
@@ -1876,7 +1876,7 @@ bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
   /* HP has a very "special" way to handle UID/GID's with numeric values
      > 99999.  */
   if (status.st_gid > 99999)
-    hpux_uid_gid_encode (hdr->ar_gid, (long) status.st_gid);
+    hpux_uid_gid_encode (hdr->ar_gid, (long long) status.st_gid);
   else
 #endif
     _bfd_ar_spacepad (hdr->ar_gid, sizeof (hdr->ar_gid), "%ld",
@@ -2236,7 +2236,7 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
   unsigned int orl_count = 0;
   int stridx = 0;
   asymbol **syms = NULL;
-  long syms_max = 0;
+  long long syms_max = 0;
   bfd_boolean ret;
   bfd_size_type amt;
 
@@ -2269,9 +2269,9 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
       if (bfd_check_format (current, bfd_object)
 	  && (bfd_get_file_flags (current) & HAS_SYMS) != 0)
 	{
-	  long storage;
-	  long symcount;
-	  long src_count;
+	  long long storage;
+	  long long symcount;
+	  long long src_count;
 
 	  storage = bfd_get_symtab_upper_bound (current);
 	  if (storage < 0)
@@ -2397,7 +2397,7 @@ _bfd_bsd_write_armap (bfd *arch,
   bfd_byte temp[4];
   unsigned int count;
   struct ar_hdr hdr;
-  long uid, gid;
+  long long uid, gid;
 
   first = mapsize + elength + sizeof (struct ar_hdr) + SARMAG;
 
@@ -2561,7 +2561,7 @@ _bfd_archive_bsd_update_armap_timestamp (bfd *arch)
       /* Can't read mod time for some reason.  */
       return TRUE;
     }
-  if (((long) archstat.st_mtime) <= bfd_ardata (arch)->armap_timestamp)
+  if (((long long) archstat.st_mtime) <= bfd_ardata (arch)->armap_timestamp)
     /* OK by the linker's rules.  */
     return TRUE;
 
diff --git a/bfd/archures.c b/bfd/archures.c
index 282e983..45a2df5 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -951,7 +951,7 @@ DESCRIPTION
 bfd_boolean
 bfd_default_set_arch_mach (bfd *abfd,
 			   enum bfd_architecture arch,
-			   unsigned long mach)
+			   unsigned long long mach)
 {
   abfd->arch_info = bfd_lookup_arch (arch, mach);
   if (abfd->arch_info != NULL)
@@ -992,7 +992,7 @@ DESCRIPTION
 	machine.
 */
 
-unsigned long
+unsigned long long
 bfd_get_mach (bfd *abfd)
 {
   return abfd->arch_info->mach;
@@ -1083,7 +1083,7 @@ bfd_default_scan (const bfd_arch_info_type *info, const char *string)
 {
   const char *ptr_src;
   const char *ptr_tst;
-  unsigned long number;
+  unsigned long long number;
   enum bfd_architecture arch;
   const char *printable_name_colon;
 
@@ -1303,7 +1303,7 @@ DESCRIPTION
 */
 
 const bfd_arch_info_type *
-bfd_lookup_arch (enum bfd_architecture arch, unsigned long machine)
+bfd_lookup_arch (enum bfd_architecture arch, unsigned long long machine)
 {
   const bfd_arch_info_type * const *app, *ap;
 
@@ -1337,7 +1337,7 @@ DESCRIPTION
 */
 
 const char *
-bfd_printable_arch_mach (enum bfd_architecture arch, unsigned long machine)
+bfd_printable_arch_mach (enum bfd_architecture arch, unsigned long long machine)
 {
   const bfd_arch_info_type *ap = bfd_lookup_arch (arch, machine);
 
@@ -1383,7 +1383,7 @@ DESCRIPTION
 
 unsigned int
 bfd_arch_mach_octets_per_byte (enum bfd_architecture arch,
-			       unsigned long mach)
+			       unsigned long long mach)
 {
   const bfd_arch_info_type *ap = bfd_lookup_arch (arch, mach);
 
@@ -1421,7 +1421,7 @@ bfd_arch_default_fill (bfd_size_type count,
 bfd_boolean
 _bfd_nowrite_set_arch_mach (bfd *abfd,
 			    enum bfd_architecture arch ATTRIBUTE_UNUSED,
-			    unsigned long mach ATTRIBUTE_UNUSED)
+			    unsigned long long mach ATTRIBUTE_UNUSED)
 {
   return _bfd_bool_bfd_false_error (abfd);
 }
diff --git a/bfd/bfd-in.h b/bfd/bfd-in.h
index 1d477c3..1f9b201 100644
--- a/bfd/bfd-in.h
+++ b/bfd/bfd-in.h
@@ -173,16 +173,16 @@ typedef BFD_HOST_U_64_BIT symvalue;
 /* Represent a target address.  Also used as a generic unsigned type
    which is guaranteed to be big enough to hold any arithmetic types
    we need to deal with.  */
-typedef unsigned long bfd_vma;
+typedef unsigned long long bfd_vma;
 
 /* A generic signed type which is guaranteed to be big enough to hold any
    arithmetic types we need to deal with.  Can be assumed to be compatible
    with bfd_vma in the same way that signed and unsigned ints are compatible
    (as parameters, in assignment, etc).  */
-typedef long bfd_signed_vma;
+typedef long long bfd_signed_vma;
 
-typedef unsigned long symvalue;
-typedef unsigned long bfd_size_type;
+typedef unsigned long long symvalue;
+typedef unsigned long long bfd_size_type;
 
 /* Print a bfd_vma x on stream s.  */
 #define BFD_VMA_FMT "l"
@@ -232,7 +232,7 @@ bfd_format;
 /* Symbols and relocation.  */
 
 /* A count of carsyms (canonical archive symbols).  */
-typedef unsigned long symindex;
+typedef unsigned long long symindex;
 
 /* How to perform a relocation.  */
 typedef const struct reloc_howto_struct reloc_howto_type;
@@ -372,7 +372,7 @@ struct bfd_hash_entry
   const char *string;
   /* Hash code.  This is the full hash code, not the index into the
      table.  */
-  unsigned long hash;
+  unsigned long long hash;
 };
 
 /* A hash table.  */
@@ -433,7 +433,7 @@ extern struct bfd_hash_entry *bfd_hash_lookup
 
 /* Insert an entry in a hash table.  */
 extern struct bfd_hash_entry *bfd_hash_insert
-  (struct bfd_hash_table *, const char *, unsigned long);
+  (struct bfd_hash_table *, const char *, unsigned long long);
 
 /* Rename an entry in a hash table.  */
 extern void bfd_hash_rename
@@ -463,7 +463,7 @@ extern void bfd_hash_traverse
 /* Allows the default size of a hash table to be configured. New hash
    tables allocated using bfd_hash_table_init will be created with
    this size.  */
-extern unsigned long bfd_hash_set_default_size (unsigned long);
+extern unsigned long long bfd_hash_set_default_size (unsigned long long);
 
 /* Types of compressed DWARF debug sections.  We currently support
    zlib.  */
@@ -561,7 +561,7 @@ extern bfd_boolean bfd_cache_close
 extern bfd_boolean bfd_cache_close_all (void);
 
 extern bfd_boolean bfd_record_phdr
-  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
+  (bfd *, unsigned long long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
    bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
 
 /* Byte swapping routines.  */
@@ -614,8 +614,8 @@ extern bfd_boolean _bfd_handle_already_linked
 extern bfd_boolean bfd_ecoff_set_gp_value
   (bfd *abfd, bfd_vma gp_value);
 extern bfd_boolean bfd_ecoff_set_regmasks
-  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
-   unsigned long *cprmask);
+  (bfd *abfd, unsigned long long gprmask, unsigned long long fprmask,
+   unsigned long long *cprmask);
 extern void *bfd_ecoff_debug_init
   (bfd *output_bfd, struct ecoff_debug_info *output_debug,
    const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
@@ -706,7 +706,7 @@ extern unsigned int _bfd_elf_default_action_discarded
 /* Return an upper bound on the number of bytes required to store a
    copy of ABFD's program header table entries.  Return -1 if an error
    occurs; bfd_get_error will return an appropriate code.  */
-extern long bfd_get_elf_phdr_upper_bound
+extern long long bfd_get_elf_phdr_upper_bound
   (bfd *abfd);
 
 /* Copy ABFD's program header table entries to *PHDRS.  The entries
@@ -828,7 +828,7 @@ extern bfd_boolean bfd_xcoff_record_link_assignment
   (bfd *, struct bfd_link_info *, const char *);
 extern bfd_boolean bfd_xcoff_size_dynamic_sections
   (bfd *, struct bfd_link_info *, const char *, const char *,
-   unsigned long, unsigned long, unsigned long, bfd_boolean,
+   unsigned long long, unsigned long long, unsigned long long, bfd_boolean,
    int, bfd_boolean, unsigned int, struct bfd_section **, bfd_boolean);
 extern bfd_boolean bfd_xcoff_link_generate_rtinit
   (bfd *, const char *, const char *, bfd_boolean);
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 93745bd..f4805bb 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -180,16 +180,16 @@ typedef BFD_HOST_U_64_BIT symvalue;
 /* Represent a target address.  Also used as a generic unsigned type
    which is guaranteed to be big enough to hold any arithmetic types
    we need to deal with.  */
-typedef unsigned long bfd_vma;
+typedef unsigned long long bfd_vma;
 
 /* A generic signed type which is guaranteed to be big enough to hold any
    arithmetic types we need to deal with.  Can be assumed to be compatible
    with bfd_vma in the same way that signed and unsigned ints are compatible
    (as parameters, in assignment, etc).  */
-typedef long bfd_signed_vma;
+typedef long long bfd_signed_vma;
 
-typedef unsigned long symvalue;
-typedef unsigned long bfd_size_type;
+typedef unsigned long long symvalue;
+typedef unsigned long long bfd_size_type;
 
 /* Print a bfd_vma x on stream s.  */
 #define BFD_VMA_FMT "l"
@@ -239,7 +239,7 @@ bfd_format;
 /* Symbols and relocation.  */
 
 /* A count of carsyms (canonical archive symbols).  */
-typedef unsigned long symindex;
+typedef unsigned long long symindex;
 
 /* How to perform a relocation.  */
 typedef const struct reloc_howto_struct reloc_howto_type;
@@ -379,7 +379,7 @@ struct bfd_hash_entry
   const char *string;
   /* Hash code.  This is the full hash code, not the index into the
      table.  */
-  unsigned long hash;
+  unsigned long long hash;
 };
 
 /* A hash table.  */
@@ -440,7 +440,7 @@ extern struct bfd_hash_entry *bfd_hash_lookup
 
 /* Insert an entry in a hash table.  */
 extern struct bfd_hash_entry *bfd_hash_insert
-  (struct bfd_hash_table *, const char *, unsigned long);
+  (struct bfd_hash_table *, const char *, unsigned long long);
 
 /* Rename an entry in a hash table.  */
 extern void bfd_hash_rename
@@ -470,7 +470,7 @@ extern void bfd_hash_traverse
 /* Allows the default size of a hash table to be configured. New hash
    tables allocated using bfd_hash_table_init will be created with
    this size.  */
-extern unsigned long bfd_hash_set_default_size (unsigned long);
+extern unsigned long long bfd_hash_set_default_size (unsigned long long);
 
 /* Types of compressed DWARF debug sections.  We currently support
    zlib.  */
@@ -568,7 +568,7 @@ extern bfd_boolean bfd_cache_close
 extern bfd_boolean bfd_cache_close_all (void);
 
 extern bfd_boolean bfd_record_phdr
-  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
+  (bfd *, unsigned long long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
    bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
 
 /* Byte swapping routines.  */
@@ -621,8 +621,8 @@ extern bfd_boolean _bfd_handle_already_linked
 extern bfd_boolean bfd_ecoff_set_gp_value
   (bfd *abfd, bfd_vma gp_value);
 extern bfd_boolean bfd_ecoff_set_regmasks
-  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
-   unsigned long *cprmask);
+  (bfd *abfd, unsigned long long gprmask, unsigned long long fprmask,
+   unsigned long long *cprmask);
 extern void *bfd_ecoff_debug_init
   (bfd *output_bfd, struct ecoff_debug_info *output_debug,
    const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
@@ -713,7 +713,7 @@ extern unsigned int _bfd_elf_default_action_discarded
 /* Return an upper bound on the number of bytes required to store a
    copy of ABFD's program header table entries.  Return -1 if an error
    occurs; bfd_get_error will return an appropriate code.  */
-extern long bfd_get_elf_phdr_upper_bound
+extern long long bfd_get_elf_phdr_upper_bound
   (bfd *abfd);
 
 /* Copy ABFD's program header table entries to *PHDRS.  The entries
@@ -835,7 +835,7 @@ extern bfd_boolean bfd_xcoff_record_link_assignment
   (bfd *, struct bfd_link_info *, const char *);
 extern bfd_boolean bfd_xcoff_size_dynamic_sections
   (bfd *, struct bfd_link_info *, const char *, const char *,
-   unsigned long, unsigned long, unsigned long, bfd_boolean,
+   unsigned long long, unsigned long long, unsigned long long, bfd_boolean,
    int, bfd_boolean, unsigned int, struct bfd_section **, bfd_boolean);
 extern bfd_boolean bfd_xcoff_link_generate_rtinit
   (bfd *, const char *, const char *, bfd_boolean);
@@ -1117,10 +1117,10 @@ void *bfd_alloc (bfd *abfd, bfd_size_type wanted);
 
 void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);
 
-unsigned long bfd_calc_gnu_debuglink_crc32
-   (unsigned long crc, const unsigned char *buf, bfd_size_type len);
+unsigned long long bfd_calc_gnu_debuglink_crc32
+   (unsigned long long crc, const unsigned char *buf, bfd_size_type len);
 
-char *bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out);
+char *bfd_get_debug_link_info (bfd *abfd, unsigned long long *crc32_out);
 
 char *bfd_get_alt_debug_link_info (bfd * abfd,
     bfd_size_type *buildid_len,
@@ -1252,7 +1252,7 @@ char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);
 
 
 /* Extracted from bfdio.c.  */
-long bfd_get_mtime (bfd *abfd);
+long long bfd_get_mtime (bfd *abfd);
 
 ufile_ptr bfd_get_size (bfd *abfd);
 
@@ -2409,7 +2409,7 @@ typedef struct bfd_arch_info
   int bits_per_address;
   int bits_per_byte;
   enum bfd_architecture arch;
-  unsigned long mach;
+  unsigned long long mach;
   const char *arch_name;
   const char *printable_name;
   unsigned int section_align_power;
@@ -2444,11 +2444,11 @@ const bfd_arch_info_type *bfd_arch_get_compatible
 void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);
 
 bfd_boolean bfd_default_set_arch_mach
-   (bfd *abfd, enum bfd_architecture arch, unsigned long mach);
+   (bfd *abfd, enum bfd_architecture arch, unsigned long long mach);
 
 enum bfd_architecture bfd_get_arch (bfd *abfd);
 
-unsigned long bfd_get_mach (bfd *abfd);
+unsigned long long bfd_get_mach (bfd *abfd);
 
 unsigned int bfd_arch_bits_per_byte (bfd *abfd);
 
@@ -2457,15 +2457,15 @@ unsigned int bfd_arch_bits_per_address (bfd *abfd);
 const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);
 
 const bfd_arch_info_type *bfd_lookup_arch
-   (enum bfd_architecture arch, unsigned long machine);
+   (enum bfd_architecture arch, unsigned long long machine);
 
 const char *bfd_printable_arch_mach
-   (enum bfd_architecture arch, unsigned long machine);
+   (enum bfd_architecture arch, unsigned long long machine);
 
 unsigned int bfd_octets_per_byte (bfd *abfd);
 
 unsigned int bfd_arch_mach_octets_per_byte
-   (enum bfd_architecture arch, unsigned long machine);
+   (enum bfd_architecture arch, unsigned long long machine);
 
 /* Extracted from reloc.c.  */
 
@@ -6811,7 +6811,7 @@ struct bfd
   ufile_ptr where;
 
   /* File modified time, if mtime_set is TRUE.  */
-  long mtime;
+  long long mtime;
 
   /* A unique identifier of the BFD  */
   unsigned int id;
@@ -7143,9 +7143,9 @@ typedef void (*bfd_assert_handler_type) (const char *bfd_formatmsg,
 
 bfd_assert_handler_type bfd_set_assert_handler (bfd_assert_handler_type);
 
-long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
+long long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
 
-long bfd_canonicalize_reloc
+long long bfd_canonicalize_reloc
    (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
 
 void bfd_set_reloc
@@ -7579,8 +7579,8 @@ typedef struct bfd_target
   NAME##_read_minisymbols, \
   NAME##_minisymbol_to_symbol
 
-  long        (*_bfd_get_symtab_upper_bound) (bfd *);
-  long        (*_bfd_canonicalize_symtab) (bfd *, struct bfd_symbol **);
+  long long        (*_bfd_get_symtab_upper_bound) (bfd *);
+  long long        (*_bfd_canonicalize_symtab) (bfd *, struct bfd_symbol **);
   struct bfd_symbol *
               (*_bfd_make_empty_symbol) (bfd *);
   void        (*_bfd_print_symbol) (bfd *, void *, struct bfd_symbol *,
@@ -7610,10 +7610,10 @@ typedef struct bfd_target
  /* Back-door to allow format-aware applications to create debug symbols
     while using BFD for everything else.  Currently used by the assembler
     when creating COFF files.  */
-  asymbol *   (*_bfd_make_debug_symbol) (bfd *, void *, unsigned long size);
+  asymbol *   (*_bfd_make_debug_symbol) (bfd *, void *, unsigned long long size);
 #define bfd_read_minisymbols(b, d, m, s) \
        BFD_SEND (b, _read_minisymbols, (b, d, m, s))
-  long        (*_read_minisymbols) (bfd *, bfd_boolean, void **,
+  long long        (*_read_minisymbols) (bfd *, bfd_boolean, void **,
                                     unsigned int *);
 #define bfd_minisymbol_to_symbol(b, d, m, f) \
        BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
@@ -7628,8 +7628,8 @@ typedef struct bfd_target
   NAME##_bfd_reloc_type_lookup, \
   NAME##_bfd_reloc_name_lookup
 
-  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
-  long        (*_bfd_canonicalize_reloc) (bfd *, sec_ptr, arelent **,
+  long long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
+  long long        (*_bfd_canonicalize_reloc) (bfd *, sec_ptr, arelent **,
                                           struct bfd_symbol **);
   void        (*_bfd_set_reloc) (bfd *, sec_ptr, arelent **, unsigned int);
   /* See documentation on reloc types.  */
@@ -7644,7 +7644,7 @@ typedef struct bfd_target
   NAME##_set_section_contents
 
   bfd_boolean (*_bfd_set_arch_mach) (bfd *, enum bfd_architecture,
-                                     unsigned long);
+                                     unsigned long long);
   bfd_boolean (*_bfd_set_section_contents) (bfd *, sec_ptr, const void *,
                                             file_ptr, bfd_size_type);
 
@@ -7752,17 +7752,17 @@ typedef struct bfd_target
   NAME##_canonicalize_dynamic_reloc
 
   /* Get the amount of memory required to hold the dynamic symbols.  */
-  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
+  long long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
   /* Read in the dynamic symbols.  */
-  long        (*_bfd_canonicalize_dynamic_symtab) (bfd *, struct bfd_symbol **);
+  long long        (*_bfd_canonicalize_dynamic_symtab) (bfd *, struct bfd_symbol **);
   /* Create synthetized symbols.  */
-  long        (*_bfd_get_synthetic_symtab) (bfd *, long, struct bfd_symbol **,
-                                            long, struct bfd_symbol **,
+  long long        (*_bfd_get_synthetic_symtab) (bfd *, long long, struct bfd_symbol **,
+                                            long long, struct bfd_symbol **,
                                             struct bfd_symbol **);
   /* Get the amount of memory required to hold the dynamic relocs.  */
-  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
+  long long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
   /* Read in the dynamic relocs.  */
-  long        (*_bfd_canonicalize_dynamic_reloc) (bfd *, arelent **,
+  long long        (*_bfd_canonicalize_dynamic_reloc) (bfd *, arelent **,
                                                   struct bfd_symbol **);
 
   /* Opposite endian version of this target.  */
diff --git a/bfd/bfd.c b/bfd/bfd.c
index 8517104..9a6a716 100644
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -626,7 +626,7 @@ static const char *_bfd_error_program_name;
 union _bfd_doprnt_args
 {
   int i;
-  long l;
+  long long l;
   long long ll;
   double d;
   long double ld;
@@ -798,7 +798,7 @@ _bfd_doprnt (FILE *stream, const char *format, union _bfd_doprnt_args *args)
 			PRINT_TYPE (int, i);
 			break;
 		      case 1:
-			PRINT_TYPE (long, l);
+			PRINT_TYPE (long long, l);
 			break;
 		      case 2:
 		      default:
@@ -813,7 +813,7 @@ _bfd_doprnt (FILE *stream, const char *format, union _bfd_doprnt_args *args)
 			PRINT_TYPE (long long, ll);
 #else
 			/* Fake it and hope for the best.  */
-			PRINT_TYPE (long, l);
+			PRINT_TYPE (long long, l);
 #endif
 			break;
 		      }
@@ -1106,7 +1106,7 @@ error_handler_internal (const char *fmt, va_list ap)
 	  args[i].i = va_arg (ap, int);
 	  break;
 	case Long:
-	  args[i].l = va_arg (ap, long);
+	  args[i].l = va_arg (ap, long long);
 	  break;
 	case LongLong:
 	  args[i].ll = va_arg (ap, long long);
@@ -1311,7 +1311,7 @@ DESCRIPTION
 
 */
 
-long
+long long
 bfd_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
 {
   if (abfd->format != bfd_object)
@@ -1344,7 +1344,7 @@ DESCRIPTION
 	reasons.
 
 */
-long
+long long
 bfd_canonicalize_reloc (bfd *abfd,
 			sec_ptr asect,
 			arelent **location,
@@ -1670,7 +1670,7 @@ bfd_scan_vma (const char *string, const char **end, int base)
   int overflow;
 
   /* Let the host do it if possible.  */
-  if (sizeof (bfd_vma) <= sizeof (unsigned long))
+  if (sizeof (bfd_vma) <= sizeof (unsigned long long))
     return strtoul (string, (char **) end, base);
 
 #if defined (HAVE_STRTOULL) && defined (HAVE_LONG_LONG)
@@ -1930,7 +1930,7 @@ bfd_get_relocated_section_contents (bfd *abfd,
 
 bfd_boolean
 bfd_record_phdr (bfd *abfd,
-		 unsigned long type,
+		 unsigned long long type,
 		 bfd_boolean flags_valid,
 		 flagword flags,
 		 bfd_boolean at_valid,
@@ -1996,7 +1996,7 @@ bfd_sprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, char *buf, bfd_vma value)
 #ifdef BFD64
   if (is32bit (abfd))
     {
-      sprintf (buf, "%08lx", (unsigned long) value & 0xffffffff);
+      sprintf (buf, "%08lx", (unsigned long long) value & 0xffffffff);
       return;
     }
 #endif
@@ -2009,7 +2009,7 @@ bfd_fprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, void *stream, bfd_vma value)
 #ifdef BFD64
   if (is32bit (abfd))
     {
-      fprintf ((FILE *) stream, "%08lx", (unsigned long) value & 0xffffffff);
+      fprintf ((FILE *) stream, "%08lx", (unsigned long long) value & 0xffffffff);
       return;
     }
 #endif
diff --git a/bfd/bfdio.c b/bfd/bfdio.c
index 1f4caca..7ab02c4 100644
--- a/bfd/bfdio.c
+++ b/bfd/bfdio.c
@@ -369,7 +369,7 @@ DESCRIPTION
 
 */
 
-long
+long long
 bfd_get_mtime (bfd *abfd)
 {
   struct stat buf;
diff --git a/bfd/bfdwin.c b/bfd/bfdwin.c
index f5db530..895ac78 100644
--- a/bfd/bfdwin.c
+++ b/bfd/bfdwin.c
@@ -77,7 +77,7 @@ bfd_free_window (bfd_window *windowp)
   i->refcount--;
   if (debug_windows)
     fprintf (stderr, "freeing window @%p<%p,%lx,%p>\n",
-	     windowp, windowp->data, (unsigned long) windowp->size, windowp->i);
+	     windowp, windowp->data, (unsigned long long) windowp->size, windowp->i);
   if (i->refcount != 0)
     return;
 
@@ -117,8 +117,8 @@ bfd_get_file_window (bfd *abfd,
 
   if (debug_windows)
     fprintf (stderr, "bfd_get_file_window (%p, %6ld, %6ld, %p<%p,%lx,%p>, %d)",
-	     abfd, (long) offset, (long) size,
-	     windowp, windowp->data, (unsigned long) windowp->size,
+	     abfd, (long long) offset, (long long) size,
+	     windowp, windowp->data, (unsigned long long) windowp->size,
 	     windowp->i, writable);
 
   /* Make sure we know the page size, so we can be friendly to mmap.  */
@@ -191,7 +191,7 @@ bfd_get_file_window (bfd *abfd,
 	}
       if (debug_windows)
 	fprintf (stderr, "\n\tmapped %ld at %p, offset is %ld\n",
-		 (long) real_size, i->data, (long) offset2);
+		 (long long) real_size, i->data, (long long) offset2);
       i->size = real_size;
       windowp->data = (bfd_byte *) i->data + offset2;
       windowp->size = size;
@@ -204,7 +204,7 @@ bfd_get_file_window (bfd *abfd,
     {
       if (ok_to_map)
 	fprintf (stderr, _("not mapping: data=%lx mapped=%d\n"),
-		 (unsigned long) i->data, (int) i->mapped);
+		 (unsigned long long) i->data, (int) i->mapped);
       else
 	fprintf (stderr, _("not mapping: env var not set\n"));
     }
@@ -221,7 +221,7 @@ bfd_get_file_window (bfd *abfd,
 #endif
   if (debug_windows)
     fprintf (stderr, "\n\t%s(%6ld)",
-	     i->data ? "realloc" : " malloc", (long) size_to_alloc);
+	     i->data ? "realloc" : " malloc", (long long) size_to_alloc);
   i->data = bfd_realloc_or_free (i->data, size_to_alloc);
   if (debug_windows)
     fprintf (stderr, "\t-> %p\n", i->data);
@@ -246,7 +246,7 @@ bfd_get_file_window (bfd *abfd,
     {
       if (debug_windows)
 	fprintf (stderr, "\tmprotect (%p, %ld, PROT_READ)\n", i->data,
-		 (long) i->size);
+		 (long long) i->size);
       mprotect (i->data, i->size, PROT_READ);
     }
 #endif
diff --git a/bfd/binary.c b/bfd/binary.c
index c467b42..81e6e05 100644
--- a/bfd/binary.c
+++ b/bfd/binary.c
@@ -110,7 +110,7 @@ binary_get_section_contents (bfd *abfd,
 
 /* Return the amount of memory needed to read the symbol table.  */
 
-static long
+static long long
 binary_get_symtab_upper_bound (bfd *abfd ATTRIBUTE_UNUSED)
 {
   return (BIN_SYMS + 1) * sizeof (asymbol *);
@@ -145,7 +145,7 @@ mangle_name (bfd *abfd, char *suffix)
 
 /* Return the symbol table.  */
 
-static long
+static long long
 binary_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
   asection *sec = (asection *) abfd->tdata.any;
diff --git a/bfd/coff-alpha.c b/bfd/coff-alpha.c
index 699398f..3e8a251 100644
--- a/bfd/coff-alpha.c
+++ b/bfd/coff-alpha.c
@@ -542,7 +542,7 @@ alpha_ecoff_swap_reloc_out (bfd *abfd,
 			    void * dst)
 {
   RELOC *ext = (RELOC *) dst;
-  long symndx;
+  long long symndx;
   unsigned char size;
 
   /* Undo the hackery done in swap_reloc_in.  */
@@ -732,9 +732,9 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,
 {
   bfd *input_bfd = link_order->u.indirect.section->owner;
   asection *input_section = link_order->u.indirect.section;
-  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
+  long long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
   arelent **reloc_vector = NULL;
-  long reloc_count;
+  long long reloc_count;
   bfd *output_bfd = relocatable ? abfd : (bfd *) NULL;
   bfd_vma gp;
   bfd_size_type sz;
@@ -869,7 +869,7 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,
 	     not currently implemented.  */
 
 	  {
-	    unsigned long insn;
+	    unsigned long long insn;
 
 	    /* I believe that the LITERAL reloc will only apply to a
 	       ldq or ldl instruction, so check my assumption.  */
@@ -902,7 +902,7 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,
 	     ahead; it used to be marked with an ALPHA_R_IGNORE reloc,
 	     but that no longer happens in OSF/1 3.2.  */
 	  {
-	    unsigned long insn1, insn2;
+	    unsigned long long insn1, insn2;
 	    bfd_vma addend;
 
 	    /* Get the two instructions.  */
@@ -1218,7 +1218,7 @@ alpha_convert_external_reloc (bfd *output_bfd ATTRIBUTE_UNUSED,
 			      struct external_reloc *ext_rel,
 			      struct ecoff_link_hash_entry *h)
 {
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   bfd_vma relocation;
 
   BFD_ASSERT (bfd_link_relocatable (info));
@@ -1239,7 +1239,7 @@ alpha_convert_external_reloc (bfd *output_bfd ATTRIBUTE_UNUSED,
       hsec = h->root.u.def.section;
       name = bfd_get_section_name (output_bfd, hsec->output_section);
 
-      r_symndx = (unsigned long) -1;
+      r_symndx = (unsigned long long) -1;
       switch (name[1])
 	{
 	case 'A':
@@ -1296,7 +1296,7 @@ alpha_convert_external_reloc (bfd *output_bfd ATTRIBUTE_UNUSED,
 	  break;
 	}
 
-      if (r_symndx == (unsigned long) -1)
+      if (r_symndx == (unsigned long long) -1)
 	abort ();
 
       /* Add the section VMA and the symbol value.  */
@@ -1309,7 +1309,7 @@ alpha_convert_external_reloc (bfd *output_bfd ATTRIBUTE_UNUSED,
       /* Change the symndx value to the right one for
 	 the output BFD.  */
       r_symndx = h->indx;
-      if (r_symndx == (unsigned long) -1)
+      if (r_symndx == (unsigned long long) -1)
 	{
 	  /* Caller must give an error.  */
 	  r_symndx = 0;
@@ -1468,7 +1468,7 @@ alpha_relocate_section (bfd *output_bfd,
   for (; ext_rel < ext_rel_end; ext_rel++)
     {
       bfd_vma r_vaddr;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       int r_type;
       int r_extern;
       int r_offset;
@@ -1574,7 +1574,7 @@ alpha_relocate_section (bfd *output_bfd,
 	  /* I believe that the LITERAL reloc will only apply to a ldq
 	     or ldl instruction, so check my assumption.  */
 	  {
-	    unsigned long insn;
+	    unsigned long long insn;
 
 	    insn = bfd_get_32 (input_bfd,
 			       contents + r_vaddr - input_section->vma);
@@ -1599,7 +1599,7 @@ alpha_relocate_section (bfd *output_bfd,
 	     bytes ahead.  It used to be marked with an ALPHA_R_IGNORE
 	     reloc, but OSF/1 3.2 no longer does that.  */
 	  {
-	    unsigned long insn1, insn2;
+	    unsigned long long insn1, insn2;
 
 	    /* Get the two instructions.  */
 	    insn1 = bfd_get_32 (input_bfd,
diff --git a/bfd/coff-arm.c b/bfd/coff-arm.c
index f0e3e30..347f1cf 100644
--- a/bfd/coff-arm.c
+++ b/bfd/coff-arm.c
@@ -73,7 +73,7 @@
 
 typedef enum {bunknown, b9, b12, b23} thumb_pcrel_branchtype;
 /* Some typedefs for holding instructions.  */
-typedef unsigned long int insn32;
+typedef unsigned long long int insn32;
 typedef unsigned short int insn16;
 
 /* The linker script knows the section names for placement.
@@ -139,7 +139,7 @@ coff_arm_reloc (bfd *abfd,
 
 	case 2:
 	  {
-	    long x = bfd_get_32 (abfd, addr);
+	    long long x = bfd_get_32 (abfd, addr);
 	    DOIT (x);
 	    bfd_put_32 (abfd, (bfd_vma) x, addr);
 	  }
@@ -598,7 +598,7 @@ aoutarm_fix_pcrel_26 (bfd *abfd,
 {
   bfd_vma relocation;
   bfd_size_type addr = reloc_entry->address;
-  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
+  long long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
   bfd_reloc_status_type flag = bfd_reloc_ok;
 
   /* If this is an undefined symbol, return error.  */
@@ -657,7 +657,7 @@ coff_thumb_pcrel_common (bfd *abfd,
 {
   bfd_vma relocation = 0;
   bfd_size_type addr = reloc_entry->address;
-  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
+  long long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
   bfd_reloc_status_type flag = bfd_reloc_ok;
   bfd_vma dstmsk;
   bfd_vma offmsk;
@@ -1182,7 +1182,7 @@ coff_arm_relocate_section (bfd *output_bfd,
   for (; rel < relend; rel++)
     {
       int			     done = 0;
-      long			     symndx;
+      long long			     symndx;
       struct coff_link_hash_entry *  h;
       struct internal_syment *	     sym;
       bfd_vma			     addend;
@@ -1333,10 +1333,10 @@ coff_arm_relocate_section (bfd *output_bfd,
 		      || h->symbol_class == C_THUMBEXTFUNC)
 		    {
 		      /* Arm code calling a Thumb function.  */
-		      unsigned long int			tmp;
+		      unsigned long long int			tmp;
 		      bfd_vma				my_offset;
 		      asection *			s;
-		      long int				ret_offset;
+		      long long int				ret_offset;
 		      struct coff_link_hash_entry *	myh;
 		      struct coff_arm_link_hash_table * globals;
 
@@ -1423,8 +1423,8 @@ coff_arm_relocate_section (bfd *output_bfd,
 		      /* Thumb code calling an ARM function.  */
 		      asection *			 s = 0;
 		      bfd_vma				 my_offset;
-		      unsigned long int			 tmp;
-		      long int				 ret_offset;
+		      unsigned long long int			 tmp;
+		      long long int				 ret_offset;
 		      struct coff_link_hash_entry *	 myh;
 		      struct coff_arm_link_hash_table *	 globals;
 
@@ -2060,7 +2060,7 @@ bfd_arm_process_before_allocation (bfd *		   abfd,
       for (rel = i; rel < i + sec->reloc_count; ++rel)
 	{
 	  unsigned short		 r_type	 = rel->r_type;
-	  long				 symndx;
+	  long long				 symndx;
 	  struct coff_link_hash_entry *	 h;
 
 	  symndx = rel->r_symndx;
diff --git a/bfd/coff-bfd.h b/bfd/coff-bfd.h
index e471319..c86afa2 100644
--- a/bfd/coff-bfd.h
+++ b/bfd/coff-bfd.h
@@ -33,7 +33,7 @@ struct coff_comdat_info
      comdat section.  This is only meaningful to the object file format
      specific code; it is not an index into the list returned by
      bfd_canonicalize_symtab.  */
-  long symbol;
+  long long symbol;
 };
 
 /* The used_by_bfd field of a section may be set to a pointer to this
diff --git a/bfd/coff-i386.c b/bfd/coff-i386.c
index 9782206..8f03a7d 100644
--- a/bfd/coff-i386.c
+++ b/bfd/coff-i386.c
@@ -169,7 +169,7 @@ coff_i386_reloc (bfd *abfd,
 
 	case 2:
 	  {
-	    long x = bfd_get_32 (abfd, addr);
+	    long long x = bfd_get_32 (abfd, addr);
 	    DOIT (x);
 	    bfd_put_32 (abfd, (bfd_vma) x, addr);
 	  }
diff --git a/bfd/coff-mcore.c b/bfd/coff-mcore.c
index 2327d72..158c489 100644
--- a/bfd/coff-mcore.c
+++ b/bfd/coff-mcore.c
@@ -195,10 +195,10 @@ typedef struct coff_mcore_link_hash_table
   struct coff_link_hash_table	root;
 
   bfd *				bfd_of_toc_owner;
-  long int			global_toc_size;
-  long int			import_table_size;
-  long int			first_thunk_address;
-  long int			thunk_size;
+  long long int			global_toc_size;
+  long long int			import_table_size;
+  long long int			first_thunk_address;
+  long long int			thunk_size;
 }
 mcore_hash_table;
 
@@ -382,7 +382,7 @@ coff_mcore_relocate_section (bfd * output_bfd,
 
   for (; rel < relend; rel++)
     {
-      long			     symndx;
+      long long			     symndx;
       struct internal_syment *	     sym;
       bfd_vma			     val;
       bfd_vma			     addend;
diff --git a/bfd/coff-mips.c b/bfd/coff-mips.c
index d83e10d..e8b090e 100644
--- a/bfd/coff-mips.c
+++ b/bfd/coff-mips.c
@@ -308,7 +308,7 @@ mips_ecoff_swap_reloc_out (bfd * abfd,
 			   void * dst)
 {
   RELOC *ext = (RELOC *) dst;
-  long r_symndx;
+  long long r_symndx;
 
   BFD_ASSERT (intern->r_extern
 	      || (intern->r_symndx >= 0 && intern->r_symndx <= 12));
@@ -499,9 +499,9 @@ mips_reflo_reloc (bfd *abfd ATTRIBUTE_UNUSED,
       l = mips_refhi_list;
       while (l != NULL)
 	{
-	  unsigned long insn;
-	  unsigned long val;
-	  unsigned long vallo;
+	  unsigned long long insn;
+	  unsigned long long val;
+	  unsigned long long vallo;
 	  struct mips_hi *next;
 
 	  if (! bfd_reloc_offset_in_range (reloc_entry->howto, abfd,
@@ -562,8 +562,8 @@ mips_gprel_reloc (bfd *abfd ATTRIBUTE_UNUSED,
   bfd_boolean relocatable;
   bfd_vma gp;
   bfd_vma relocation;
-  unsigned long val;
-  unsigned long insn;
+  unsigned long long val;
+  unsigned long long insn;
 
   /* If we're relocating, and this is an external symbol with no
      addend, we don't want to change anything.  We will only have an
@@ -675,7 +675,7 @@ mips_gprel_reloc (bfd *abfd ATTRIBUTE_UNUSED,
     reloc_entry->address += input_section->output_offset;
 
   /* Make sure it fit in 16 bits.  */
-  if ((long) val >= 0x8000 || (long) val < -0x8000)
+  if ((long long) val >= 0x8000 || (long long) val < -0x8000)
     return bfd_reloc_overflow;
 
   return bfd_reloc_ok;
@@ -752,9 +752,9 @@ mips_relocate_hi (struct internal_reloc *refhi,
 		  bfd_byte *contents,
 		  bfd_vma relocation)
 {
-  unsigned long insn;
-  unsigned long val;
-  unsigned long vallo;
+  unsigned long long insn;
+  unsigned long long val;
+  unsigned long long vallo;
 
   if (refhi == NULL)
     return;
diff --git a/bfd/coff-ppc.c b/bfd/coff-ppc.c
index 375ed18..907c598 100644
--- a/bfd/coff-ppc.c
+++ b/bfd/coff-ppc.c
@@ -109,7 +109,7 @@ struct ppc_coff_link_hash_entry
      here.  */
   bfd_vma toc_offset;		    /* Our addition, as required.  */
   int symbol_is_glue;
-  unsigned long int glue_insn;
+  unsigned long long int glue_insn;
 
   HASH_CHECK_DCL
 };
@@ -733,10 +733,10 @@ static reloc_howto_type ppc_coff_howto_table[] =
    of the compilations.  FIXME: This is confusing and weird.  Also,
    BFD should not use global variables.  */
 extern bfd *    bfd_of_toc_owner;
-extern long int global_toc_size;
-extern long int import_table_size;
-extern long int first_thunk_address;
-extern long int thunk_size;
+extern long long int global_toc_size;
+extern long long int import_table_size;
+extern long long int first_thunk_address;
+extern long long int thunk_size;
 
 enum toc_type
 {
@@ -955,7 +955,7 @@ coff_ppc_relocate_section (bfd *output_bfd,
   relend = rel + input_section->reloc_count;
   for (; rel < relend; rel++)
     {
-      long symndx;
+      long long symndx;
       struct ppc_coff_link_hash_entry *h;
       struct internal_syment *sym;
       bfd_vma val;
@@ -1443,13 +1443,13 @@ coff_ppc_relocate_section (bfd *output_bfd,
    twice, and these variables are shared.  This is confusing and
    weird.  */
 
-long int global_toc_size = 4;
+long long int global_toc_size = 4;
 
 bfd* bfd_of_toc_owner = 0;
 
-long int import_table_size;
-long int first_thunk_address;
-long int thunk_size;
+long long int import_table_size;
+long long int first_thunk_address;
+long long int thunk_size;
 
 struct list_ele *head;
 struct list_ele *tail;
@@ -1491,14 +1491,14 @@ dump_toc (void * vfile)
 	      fprintf (file,
 		       /* xgettext: c-format */
 		      _("**** global_toc_size %ld(%lx), thunk_size %ld(%lx)\n"),
-		       global_toc_size, (unsigned long) global_toc_size,
-		       thunk_size, (unsigned long) thunk_size);
+		       global_toc_size, (unsigned long long) global_toc_size,
+		       thunk_size, (unsigned long long) thunk_size);
 	      cat = _("Out of bounds!");
 	    }
 	}
 
       fprintf (file,
-	      " %04lx    (%d)", (unsigned long) t->offset, t->offset - 32768);
+	      " %04lx    (%d)", (unsigned long long) t->offset, t->offset - 32768);
       fprintf (file,
 	      "    %s %s\n",
 	      cat, t->name);
@@ -2172,8 +2172,8 @@ ppc_bfd_coff_final_link (bfd *abfd, struct bfd_link_info *info)
   flaginfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
   amt = max_sym_count * sizeof (asection *);
   flaginfo.sec_ptrs = (asection **) bfd_malloc (amt);
-  amt = max_sym_count * sizeof (long);
-  flaginfo.sym_indices = (long *) bfd_malloc (amt);
+  amt = max_sym_count * sizeof (long long);
+  flaginfo.sym_indices = (long long *) bfd_malloc (amt);
   amt = (max_sym_count + 1) * symesz;
   flaginfo.outsyms = (bfd_byte *) bfd_malloc (amt);
   amt = max_lineno_count * bfd_coff_linesz (abfd);
diff --git a/bfd/coff-rs6000.c b/bfd/coff-rs6000.c
index 053ab18..53ec907 100644
--- a/bfd/coff-rs6000.c
+++ b/bfd/coff-rs6000.c
@@ -1190,7 +1190,7 @@ bfd_xcoff_ar_archive_set_magic (bfd *abfd ATTRIBUTE_UNUSED,
    take a maximum length as an additional parameter.  Also - just to save space,
    we omit the endptr return parameter, since we know that it is never used.  */
 
-static long
+static long long
 _bfd_strntol (const char * nptr, int base, unsigned int maxlen)
 {
   char buf[24]; /* Should be enough.  */
@@ -1218,14 +1218,14 @@ _bfd_strntoll (const char * nptr, int base, unsigned int maxlen)
 #define GET_VALUE_IN_FIELD(VAR, FIELD)		  \
   do						  \
     {						  \
-      (VAR) = sizeof (VAR) > sizeof (long)	  \
+      (VAR) = sizeof (VAR) > sizeof (long long)	  \
 	? _bfd_strntoll (FIELD, 10, sizeof FIELD) \
 	: _bfd_strntol (FIELD, 10, sizeof FIELD); \
     }						  \
   while (0)
 
 #define EQ_VALUE_IN_FIELD(VAR, FIELD)			\
-  (sizeof (VAR) > sizeof (long)				\
+  (sizeof (VAR) > sizeof (long long)				\
    ? (VAR) ==_bfd_strntoll (FIELD, 10, sizeof FIELD)	\
    : (VAR) == _bfd_strntol (FIELD, 10, sizeof FIELD))
 
@@ -1682,7 +1682,7 @@ xcoff_write_armap_old (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,
   unsigned int i;
 
   memset (&hdr, 0, sizeof hdr);
-  sprintf (hdr.size, "%ld", (long) (4 + orl_count * 4 + stridx));
+  sprintf (hdr.size, "%ld", (long long) (4 + orl_count * 4 + stridx));
   sprintf (hdr.nextoff, "%d", 0);
   memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, XCOFFARMAG_ELEMENT_SIZE);
   sprintf (hdr.date, "%d", 0);
@@ -2121,10 +2121,10 @@ xcoff_write_archive_contents_old (bfd *abfd)
 	  if (ahdrp == NULL)
 	    return FALSE;
 
-	  sprintf (ahdrp->size, "%ld", (long) s.st_size);
-	  sprintf (ahdrp->date, "%ld", (long) s.st_mtime);
-	  sprintf (ahdrp->uid, "%ld", (long) s.st_uid);
-	  sprintf (ahdrp->gid, "%ld", (long) s.st_gid);
+	  sprintf (ahdrp->size, "%ld", (long long) s.st_size);
+	  sprintf (ahdrp->date, "%ld", (long long) s.st_mtime);
+	  sprintf (ahdrp->uid, "%ld", (long long) s.st_uid);
+	  sprintf (ahdrp->gid, "%ld", (long long) s.st_gid);
 	  sprintf (ahdrp->mode, "%o", (unsigned int) s.st_mode);
 
 	  arch_eltdata (sub)->arch_header = (char *) ahdrp;
@@ -2155,9 +2155,9 @@ xcoff_write_archive_contents_old (bfd *abfd)
 	}
 
       ahdrp = arch_xhdr (iterator.current.member);
-      sprintf (ahdrp->prevoff, "%ld", (long) prevoff);
-      sprintf (ahdrp->namlen, "%ld", (long) iterator.current.namlen);
-      sprintf (ahdrp->nextoff, "%ld", (long) iterator.next.offset);
+      sprintf (ahdrp->prevoff, "%ld", (long long) prevoff);
+      sprintf (ahdrp->namlen, "%ld", (long long) iterator.current.namlen);
+      sprintf (ahdrp->nextoff, "%ld", (long long) iterator.next.offset);
 
       /* We need spaces, not null bytes, in the header.  */
       for (p = (char *) ahdrp; p < (char *) ahdrp + SIZEOF_AR_HDR; p++)
@@ -2181,19 +2181,19 @@ xcoff_write_archive_contents_old (bfd *abfd)
       prevoff = iterator.current.offset;
     }
 
-  sprintf (fhdr.lastmemoff, "%ld", (long) prevoff);
+  sprintf (fhdr.lastmemoff, "%ld", (long long) prevoff);
 
   /* Write out the member table.  */
 
   nextoff = iterator.next.offset;
   BFD_ASSERT (nextoff == bfd_tell (abfd));
-  sprintf (fhdr.memoff, "%ld", (long) nextoff);
+  sprintf (fhdr.memoff, "%ld", (long long) nextoff);
 
   memset (&ahdr, 0, sizeof ahdr);
-  sprintf (ahdr.size, "%ld", (long) (XCOFFARMAG_ELEMENT_SIZE
+  sprintf (ahdr.size, "%ld", (long long) (XCOFFARMAG_ELEMENT_SIZE
 				     + count * XCOFFARMAG_ELEMENT_SIZE
 				     + total_namlen));
-  sprintf (ahdr.prevoff, "%ld", (long) prevoff);
+  sprintf (ahdr.prevoff, "%ld", (long long) prevoff);
   sprintf (ahdr.date, "%d", 0);
   sprintf (ahdr.uid, "%d", 0);
   sprintf (ahdr.gid, "%d", 0);
@@ -2210,7 +2210,7 @@ xcoff_write_archive_contents_old (bfd *abfd)
   nextoff += size + (size & 1);
 
   if (makemap && hasobjects)
-    sprintf (ahdr.nextoff, "%ld", (long) nextoff);
+    sprintf (ahdr.nextoff, "%ld", (long long) nextoff);
   else
     sprintf (ahdr.nextoff, "%d", 0);
 
@@ -2225,13 +2225,13 @@ xcoff_write_archive_contents_old (bfd *abfd)
 	  != SXCOFFARFMAG))
     return FALSE;
 
-  sprintf (decbuf, "%-12ld", (long) count);
+  sprintf (decbuf, "%-12ld", (long long) count);
   if (bfd_bwrite (decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE, abfd)
       != XCOFFARMAG_ELEMENT_SIZE)
     return FALSE;
   for (i = 0; i < (size_t) count; i++)
     {
-      sprintf (decbuf, "%-12ld", (long) offsets[i]);
+      sprintf (decbuf, "%-12ld", (long long) offsets[i]);
       if (bfd_bwrite (decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE,
 		      abfd) != XCOFFARMAG_ELEMENT_SIZE)
 	return FALSE;
@@ -2256,7 +2256,7 @@ xcoff_write_archive_contents_old (bfd *abfd)
   else
     {
       BFD_ASSERT (nextoff == bfd_tell (abfd));
-      sprintf (fhdr.symoff, "%ld", (long) nextoff);
+      sprintf (fhdr.symoff, "%ld", (long long) nextoff);
       bfd_ardata (abfd)->tdata = &fhdr;
       if (! _bfd_compute_and_write_armap (abfd, 0))
 	return FALSE;
@@ -2926,7 +2926,7 @@ xcoff_reloc_type_br (bfd *input_bfd,
       && section_offset + 8 <= input_section->size)
     {
       bfd_byte *pnext;
-      unsigned long next;
+      unsigned long long next;
 
       pnext = contents + section_offset + 4;
       next = bfd_get_32 (input_bfd, pnext);
@@ -3334,7 +3334,7 @@ xcoff_ppc_relocate_section (bfd *output_bfd,
   relend = rel + input_section->reloc_count;
   for (; rel < relend; rel++)
     {
-      long symndx;
+      long long symndx;
       struct xcoff_link_hash_entry *h;
       struct internal_syment *sym;
       bfd_vma addend;
@@ -3942,7 +3942,7 @@ HOWTO (0,			/* type */
    The first word of global linkage code must be modified by filling in
    the correct TOC offset.  */
 
-static unsigned long xcoff_glink_code[9] =
+static unsigned long long xcoff_glink_code[9] =
   {
     0x81820000,	/* lwz r12,0(r2) */
     0x90410014,	/* stw r2,20(r1) */
diff --git a/bfd/coff-sh.c b/bfd/coff-sh.c
index 3251d41..49ad1f3 100644
--- a/bfd/coff-sh.c
+++ b/bfd/coff-sh.c
@@ -392,7 +392,7 @@ static reloc_howto_type sh_coff_howtos[] =
 
 /* Get the value of a symbol, when performing a relocation.  */
 
-static long
+static long long
 get_symbol_value (asymbol *symbol)
 {
   bfd_vma relocation;
@@ -567,7 +567,7 @@ sh_reloc (bfd *      abfd,
 	  bfd *      output_bfd,
 	  char **    error_message ATTRIBUTE_UNUSED)
 {
-  unsigned long insn;
+  unsigned long long insn;
   bfd_vma sym_value;
   unsigned short r_type;
   bfd_vma addr = reloc_entry->address;
@@ -1247,7 +1247,7 @@ sh_relax_delete_bytes (bfd *abfd,
 	     both the r_offset field and the section contents.  */
 
 	  start = irel->r_vaddr - sec->vma;
-	  stop = (bfd_vma) ((bfd_signed_vma) start - (long) irel->r_offset);
+	  stop = (bfd_vma) ((bfd_signed_vma) start - (long long) irel->r_offset);
 
 	  if (start > addr
 	      && start < toaddr
@@ -1273,7 +1273,7 @@ sh_relax_delete_bytes (bfd *abfd,
 	case R_SH_USES:
 	  start = irel->r_vaddr - sec->vma;
 	  stop = (bfd_vma) ((bfd_signed_vma) start
-			    + (long) irel->r_offset
+			    + (long long) irel->r_offset
 			    + 4);
 	  break;
 	}
@@ -1547,7 +1547,7 @@ struct sh_opcode
      mask value in the sh_major_opcode structure.  */
   unsigned short opcode;
   /* Flags for this instruction.  */
-  unsigned long flags;
+  unsigned long long flags;
 };
 
 /* Flag which appear in the sh_opcode structure.  */
@@ -2750,7 +2750,7 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   relend = rel + input_section->reloc_count;
   for (; rel < relend; rel++)
     {
-      long symndx;
+      long long symndx;
       struct coff_link_hash_entry *h;
       struct internal_syment *sym;
       bfd_vma addend;
@@ -2778,7 +2778,7 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
       else
 	{
 	  if (symndx < 0
-	      || (unsigned long) symndx >= obj_raw_syment_count (input_bfd))
+	      || (unsigned long long) symndx >= obj_raw_syment_count (input_bfd))
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
diff --git a/bfd/coff-stgo32.c b/bfd/coff-stgo32.c
index edb9a28..c0e0fe5 100644
--- a/bfd/coff-stgo32.c
+++ b/bfd/coff-stgo32.c
@@ -288,8 +288,8 @@ create_go32_stub (bfd *abfd)
       int f;
       unsigned char header[10];
       char magic[8];
-      unsigned long coff_start;
-      long exe_start;
+      unsigned long long coff_start;
+      long long exe_start;
 
       /* Check at first the environment variable $(GO32STUB).  */
       stub = getenv ("GO32STUB");
@@ -319,9 +319,9 @@ create_go32_stub (bfd *abfd)
 	}
       /* Compute the size of the stub (it is every thing up
 	 to the beginning of the coff image).  */
-      coff_start = (long) _H (2) * 512L;
+      coff_start = (long long) _H (2) * 512L;
       if (_H (1))
-	coff_start += (long) _H (1) - 512L;
+	coff_start += (long long) _H (1) - 512L;
 
       /* Currently there is only a fixed stub size of 2048 bytes
 	 supported.  */
@@ -331,7 +331,7 @@ create_go32_stub (bfd *abfd)
 	  goto stub_end;
 	}
       exe_start = _H (4) * 16;
-      if ((long) lseek (f, exe_start, SEEK_SET) != exe_start)
+      if ((long long) lseek (f, exe_start, SEEK_SET) != exe_start)
 	{
 	  close (f);
 	  goto stub_end;
@@ -354,7 +354,7 @@ create_go32_stub (bfd *abfd)
 	  return;
 	}
       lseek (f, 0L, SEEK_SET);
-      if ((unsigned long) read (f, coff_data (abfd)->go32stub, coff_start)
+      if ((unsigned long long) read (f, coff_data (abfd)->go32stub, coff_start)
 	  != coff_start)
 	{
 	  bfd_release (abfd, coff_data (abfd)->go32stub);
diff --git a/bfd/coff-tic54x.c b/bfd/coff-tic54x.c
index 75b9fb8..5b47aaf 100644
--- a/bfd/coff-tic54x.c
+++ b/bfd/coff-tic54x.c
@@ -45,12 +45,12 @@ static bfd_vma
 tic54x_getl32 (const void *p)
 {
   const bfd_byte *addr = p;
-  unsigned long v;
+  unsigned long long v;
 
-  v  = (unsigned long) addr[2];
-  v |= (unsigned long) addr[3] << 8;
-  v |= (unsigned long) addr[0] << 16;
-  v |= (unsigned long) addr[1] << 24;
+  v  = (unsigned long long) addr[2];
+  v |= (unsigned long long) addr[3] << 8;
+  v |= (unsigned long long) addr[0] << 16;
+  v |= (unsigned long long) addr[1] << 24;
   return v;
 }
 
@@ -68,14 +68,14 @@ static bfd_signed_vma
 tic54x_getl_signed_32 (const void *p)
 {
   const bfd_byte *addr = p;
-  unsigned long v;
+  unsigned long long v;
 
-  v  = (unsigned long) addr[2];
-  v |= (unsigned long) addr[3] << 8;
-  v |= (unsigned long) addr[0] << 16;
-  v |= (unsigned long) addr[1] << 24;
+  v  = (unsigned long long) addr[2];
+  v |= (unsigned long long) addr[3] << 8;
+  v |= (unsigned long long) addr[0] << 16;
+  v |= (unsigned long long) addr[1] << 24;
 #define COERCE32(x) \
-  ((bfd_signed_vma) (long) (((unsigned long) (x) ^ 0x80000000) - 0x80000000))
+  ((bfd_signed_vma) (long long) (((unsigned long long) (x) ^ 0x80000000) - 0x80000000))
   return COERCE32 (v);
 }
 
@@ -115,7 +115,7 @@ bfd_ticoff_get_section_load_page (asection *sect)
 static bfd_boolean
 tic54x_set_arch_mach (bfd *abfd,
 		      enum bfd_architecture arch,
-		      unsigned long machine)
+		      unsigned long long machine)
 {
   if (arch == bfd_arch_unknown)
     arch = bfd_arch_tic54x;
diff --git a/bfd/coff-tic80.c b/bfd/coff-tic80.c
index 4120b60..8420bc1 100644
--- a/bfd/coff-tic80.c
+++ b/bfd/coff-tic80.c
@@ -493,7 +493,7 @@ coff_tic80_relocate_section (bfd *output_bfd,
   relend = rel + input_section->reloc_count;
   for (; rel < relend; rel++)
     {
-      long symndx;
+      long long symndx;
       struct coff_link_hash_entry *h;
       struct internal_syment *sym;
       bfd_vma addend;
diff --git a/bfd/coff-x86_64.c b/bfd/coff-x86_64.c
index f0108ea..ef549b3 100644
--- a/bfd/coff-x86_64.c
+++ b/bfd/coff-x86_64.c
@@ -168,7 +168,7 @@ coff_amd64_reloc (bfd *abfd,
 
 	case 2:
 	  {
-	    long x = bfd_get_32 (abfd, addr);
+	    long long x = bfd_get_32 (abfd, addr);
 	    DOIT (x);
 	    bfd_put_32 (abfd, (bfd_vma) x, addr);
 	  }
diff --git a/bfd/coff64-rs6000.c b/bfd/coff64-rs6000.c
index 2135001..90e7687 100644
--- a/bfd/coff64-rs6000.c
+++ b/bfd/coff64-rs6000.c
@@ -723,8 +723,8 @@ xcoff64_write_object_contents (bfd *abfd)
   file_ptr reloc_base;
   file_ptr lineno_base;
   file_ptr sym_base;
-  unsigned long reloc_size = 0;
-  unsigned long lnno_size = 0;
+  unsigned long long reloc_size = 0;
+  unsigned long long lnno_size = 0;
   asection *text_sec = NULL;
   asection *data_sec = NULL;
   asection *bss_sec = NULL;
@@ -1094,7 +1094,7 @@ xcoff64_reloc_type_br (bfd *input_bfd,
       && section_offset + 8 <= input_section->size)
     {
       bfd_byte *pnext;
-      unsigned long next;
+      unsigned long long next;
 
       pnext = contents + section_offset + 4;
       next = bfd_get_32 (input_bfd, pnext);
@@ -1184,7 +1184,7 @@ xcoff64_ppc_relocate_section (bfd *output_bfd,
   relend = rel + input_section->reloc_count;
   for (; rel < relend; rel++)
     {
-      long symndx;
+      long long symndx;
       struct xcoff_link_hash_entry *h;
       struct internal_syment *sym;
       bfd_vma addend;
@@ -1858,7 +1858,7 @@ xcoff64_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
    take a maximum length as an additional parameter.  Also - just to save space,
    we omit the endptr return parameter, since we know that it is never used.  */
 
-static long
+static long long
 _bfd_strntol (const char * nptr, int base, unsigned int maxlen)
 {
   char buf[24]; /* Should be enough.  */
@@ -1886,7 +1886,7 @@ _bfd_strntoll (const char * nptr, int base, unsigned int maxlen)
 #define GET_VALUE_IN_FIELD(VAR, FIELD)		  \
   do						  \
     {						  \
-      (VAR) = sizeof (VAR) > sizeof (long)	  \
+      (VAR) = sizeof (VAR) > sizeof (long long)	  \
 	? _bfd_strntoll (FIELD, 10, sizeof FIELD) \
 	: _bfd_strntol (FIELD, 10, sizeof FIELD); \
     }						  \
@@ -2536,7 +2536,7 @@ HOWTO (0,			/* type */
        MINUS_ONE,		/* dst_mask */
        FALSE);			/* pcrel_offset */
 
-static unsigned long xcoff64_glink_code[10] =
+static unsigned long long xcoff64_glink_code[10] =
 {
   0xe9820000,	/* ld r12,0(r2) */
   0xf8410028,	/* std r2,40(r1) */
diff --git a/bfd/coffcode.h b/bfd/coffcode.h
index 11c22ab..2f99a4d 100644
--- a/bfd/coffcode.h
+++ b/bfd/coffcode.h
@@ -398,7 +398,7 @@ static bfd_boolean bfd_coff_set_long_section_names_allowed
 static bfd_boolean bfd_coff_set_long_section_names_disallowed
   (bfd *, int);
 #endif /* defined (COFF_LONG_SECTION_NAMES) */
-static long sec_to_styp_flags
+static long long sec_to_styp_flags
   (const char *, flagword);
 static bfd_boolean styp_to_sec_flags
   (bfd *, void *, const char *, asection *, flagword *);
@@ -416,7 +416,7 @@ static bfd_boolean coff_write_relocs
 static bfd_boolean coff_set_flags
   (bfd *, unsigned int *, unsigned short *);
 static bfd_boolean coff_set_arch_mach
-  (bfd *, enum bfd_architecture, unsigned long) ATTRIBUTE_UNUSED;
+  (bfd *, enum bfd_architecture, unsigned long long) ATTRIBUTE_UNUSED;
 static bfd_boolean coff_compute_section_file_positions
   (bfd *);
 static bfd_boolean coff_write_object_contents
@@ -433,7 +433,7 @@ static enum coff_symbol_classification coff_classify_symbol
   (bfd *, struct internal_syment *);
 static bfd_boolean coff_slurp_reloc_table
   (bfd *, asection *, asymbol **);
-static long coff_canonicalize_reloc
+static long long coff_canonicalize_reloc
   (bfd *, asection *, arelent **, asymbol **);
 #ifndef coff_mkobject_hook
 static void * coff_mkobject_hook
@@ -498,10 +498,10 @@ bfd_coff_set_long_section_names_disallowed (bfd *abfd, int enable)
 #define STYP_DEBUG_INFO STYP_INFO
 #endif
 
-static long
+static long long
 sec_to_styp_flags (const char *sec_name, flagword sec_flags)
 {
-  long styp_flags = 0;
+  long long styp_flags = 0;
 
   if (!strcmp (sec_name, _TEXT))
     {
@@ -634,10 +634,10 @@ sec_to_styp_flags (const char *sec_name, flagword sec_flags)
    should be set up properly in gas (or whatever assembler is in use),
    and honor whatever objcopy/strip, etc. sent us as input.  */
 
-static long
+static long long
 sec_to_styp_flags (const char *sec_name, flagword sec_flags)
 {
-  long styp_flags = 0;
+  long long styp_flags = 0;
   bfd_boolean is_dbg = FALSE;
 
   if (CONST_STRNEQ (sec_name, DOT_DEBUG)
@@ -726,7 +726,7 @@ styp_to_sec_flags (bfd *abfd ATTRIBUTE_UNUSED,
 		   flagword *flags_ptr)
 {
   struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
-  long styp_flags = internal_s->s_flags;
+  long long styp_flags = internal_s->s_flags;
   flagword sec_flags = 0;
 
 #ifdef STYP_BLOCK
@@ -1166,7 +1166,7 @@ styp_to_sec_flags (bfd *abfd,
 		   flagword *flags_ptr)
 {
   struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
-  unsigned long styp_flags = internal_s->s_flags;
+  unsigned long long styp_flags = internal_s->s_flags;
   flagword sec_flags;
   bfd_boolean result = TRUE;
   bfd_boolean is_dbg = FALSE;
@@ -1189,7 +1189,7 @@ styp_to_sec_flags (bfd *abfd,
   /* Process each flag bit in styp_flags in turn.  */
   while (styp_flags)
     {
-      unsigned long flag = styp_flags & - styp_flags;
+      unsigned long long flag = styp_flags & - styp_flags;
       char * unhandled = NULL;
 
       styp_flags &= ~ flag;
@@ -2086,7 +2086,7 @@ coff_mkobject_hook (bfd * abfd,
 static bfd_boolean
 coff_set_arch_mach_hook (bfd *abfd, void * filehdr)
 {
-  unsigned long machine;
+  unsigned long long machine;
   enum bfd_architecture arch;
   struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
 
@@ -2426,7 +2426,7 @@ coff_print_aux (bfd *abfd ATTRIBUTE_UNUSED,
 		     aux->u.auxent.x_csect.x_scnlen.l);
 	  else
 	    fprintf (file, "%4ld",
-		     (long) (aux->u.auxent.x_csect.x_scnlen.p - table_base));
+		     (long long) (aux->u.auxent.x_csect.x_scnlen.p - table_base));
 	}
       fprintf (file,
 	       " prmhsh %ld snhsh %u typ %d algn %d clss %u stb %ld snstb %u",
@@ -2833,7 +2833,7 @@ coff_set_flags (bfd * abfd,
 static bfd_boolean
 coff_set_arch_mach (bfd * abfd,
 		    enum bfd_architecture arch,
-		    unsigned long machine)
+		    unsigned long long machine)
 {
   unsigned dummy1;
   unsigned short dummy2;
@@ -3347,8 +3347,8 @@ coff_write_object_contents (bfd * abfd)
   file_ptr reloc_base;
   file_ptr lineno_base;
   file_ptr sym_base;
-  unsigned long reloc_size = 0, reloc_count = 0;
-  unsigned long lnno_size = 0;
+  unsigned long long reloc_size = 0, reloc_count = 0;
+  unsigned long long lnno_size = 0;
   bfd_boolean long_section_names;
   asection *text_sec = NULL;
   asection *data_sec = NULL;
@@ -3487,14 +3487,14 @@ coff_write_object_contents (bfd * abfd)
 		  _bfd_error_handler
 		    /* xgettext:c-format */
 		    (_("%pB: section %pA: string table overflow at offset %ld"),
-		    abfd, current, (unsigned long) string_size);
+		    abfd, current, (unsigned long long) string_size);
 		  return FALSE;
 		}
 
 	      /* We do not need to use snprintf here as we have already verfied
 		 that string_size is not too big, plus we have an overlarge
 		 buffer, just in case.  */
-	      sprintf (s_name_buf, "/%lu", (unsigned long) string_size);
+	      sprintf (s_name_buf, "/%lu", (unsigned long long) string_size);
 	      /* Then strncpy takes care of any padding for us.  */
 	      strncpy (section.s_name, s_name_buf, SCNNMLEN);
 	      string_size += len + 1;
@@ -4274,7 +4274,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
     {
       _bfd_error_handler
 	(_("%pB: warning: line number count (%#lx) exceeds section size (%#lx)"),
-	 abfd, (unsigned long) asect->lineno_count, (unsigned long) asect->size);
+	 abfd, (unsigned long long) asect->lineno_count, (unsigned long long) asect->size);
       return FALSE;
     }
 
@@ -4313,7 +4313,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
       if (cache_ptr->line_number == 0)
 	{
 	  combined_entry_type * ent;
-	  unsigned long symndx;
+	  unsigned long long symndx;
 	  coff_symbol_type *sym;
 
 	  have_func = FALSE;
@@ -4705,7 +4705,7 @@ coff_slurp_symbol_table (bfd * abfd)
 		 to the symbol instead of the index.  FIXME: This
 		 should use a union.  */
 	      src->u.syment.n_value =
-		(long) (intptr_t) (native_symbols + src->u.syment.n_value);
+		(long long) (intptr_t) (native_symbols + src->u.syment.n_value);
 	      dst->symbol.value = src->u.syment.n_value;
 	      src->fix_value = 1;
 	      break;
@@ -5091,7 +5091,7 @@ coff_rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
 
 /* This is stupid.  This function should be a boolean predicate.  */
 
-static long
+static long long
 coff_canonicalize_reloc (bfd * abfd,
 			 sec_ptr section,
 			 arelent ** relptr,
diff --git a/bfd/coffgen.c b/bfd/coffgen.c
index b9e4872..bd56e41 100644
--- a/bfd/coffgen.c
+++ b/bfd/coffgen.c
@@ -67,7 +67,7 @@ make_a_section_from_file (bfd *abfd,
       && hdr->s_name[0] == '/')
     {
       char buf[SCNNMLEN];
-      long strindex;
+      long long strindex;
       char *p;
       const char *strings;
 
@@ -413,7 +413,7 @@ coff_section_from_bfd_index (bfd *abfd, int section_index)
 
 /* Get the upper bound of a COFF symbol table.  */
 
-long
+long long
 coff_get_symtab_upper_bound (bfd *abfd)
 {
   if (!bfd_coff_slurp_symbol_table (abfd))
@@ -424,7 +424,7 @@ coff_get_symtab_upper_bound (bfd *abfd)
 
 /* Canonicalize a COFF symbol table.  */
 
-long
+long long
 coff_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
   unsigned int counter;
@@ -1549,7 +1549,7 @@ coff_pointerize_aux (bfd *abfd,
        || n_sclass == C_FCN)
       && auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l > 0
       && auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l
-      < (long) obj_raw_syment_count (abfd))
+      < (long long) obj_raw_syment_count (abfd))
     {
       auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p =
 	table_base + auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l;
@@ -1557,7 +1557,7 @@ coff_pointerize_aux (bfd *abfd,
     }
   /* A negative tagndx is meaningless, but the SCO 3.2v4 cc can
      generate one, so we must be careful to ignore it.  */
-  if ((unsigned long) auxent->u.auxent.x_sym.x_tagndx.l
+  if ((unsigned long long) auxent->u.auxent.x_sym.x_tagndx.l
       < obj_raw_syment_count (abfd))
     {
       auxent->u.auxent.x_sym.x_tagndx.p =
@@ -2001,7 +2001,7 @@ coff_get_normalized_symtab (bfd *abfd)
   return internal;
 }
 
-long
+long long
 coff_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
 {
   if (bfd_get_format (abfd) != bfd_object)
@@ -2034,7 +2034,7 @@ coff_make_empty_symbol (bfd *abfd)
 asymbol *
 coff_bfd_make_debug_symbol (bfd *abfd,
 			    void * ptr ATTRIBUTE_UNUSED,
-			    unsigned long sz ATTRIBUTE_UNUSED)
+			    unsigned long long sz ATTRIBUTE_UNUSED)
 {
   bfd_size_type amt = sizeof (coff_symbol_type);
   coff_symbol_type *new_symbol = (coff_symbol_type *) bfd_alloc (abfd, amt);
@@ -2100,7 +2100,7 @@ coff_print_symbol (bfd *abfd,
 	  combined_entry_type *root = obj_raw_syments (abfd);
 	  struct lineno_cache_entry *l = coffsymbol (symbol)->lineno;
 
-	  fprintf (file, "[%3ld]", (long) (combined - root));
+	  fprintf (file, "[%3ld]", (long long) (combined - root));
 
 	  /* PR 17512: file: 079-33786-0.001:0.1.  */
 	  if (combined < obj_raw_syments (abfd)
@@ -2128,7 +2128,7 @@ coff_print_symbol (bfd *abfd,
 	  for (aux = 0; aux < combined->u.syment.n_numaux; aux++)
 	    {
 	      combined_entry_type *auxp = combined + aux + 1;
-	      long tagndx;
+	      long long tagndx;
 
 	      BFD_ASSERT (! auxp->is_sym);
 	      if (auxp->fix_tag)
@@ -2152,7 +2152,7 @@ coff_print_symbol (bfd *abfd,
 		    /* Probably a section symbol ?  */
 		    {
 		      fprintf (file, "AUX scnlen 0x%lx nreloc %d nlnno %d",
-			       (unsigned long) auxp->u.auxent.x_scn.x_scnlen,
+			       (unsigned long long) auxp->u.auxent.x_scn.x_scnlen,
 			       auxp->u.auxent.x_scn.x_nreloc,
 			       auxp->u.auxent.x_scn.x_nlinno);
 		      if (auxp->u.auxent.x_scn.x_checksum != 0
@@ -2169,7 +2169,7 @@ coff_print_symbol (bfd *abfd,
 		case C_AIX_WEAKEXT:
 		  if (ISFCN (combined->u.syment.n_type))
 		    {
-		      long next, llnos;
+		      long long next, llnos;
 
 		      if (auxp->fix_end)
 			next = (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
@@ -2180,7 +2180,7 @@ coff_print_symbol (bfd *abfd,
 		      fprintf (file,
 			       "AUX tagndx %ld ttlsiz 0x%lx lnnos %ld next %ld",
 			       tagndx,
-			       (unsigned long) auxp->u.auxent.x_sym.x_misc.x_fsize,
+			       (unsigned long long) auxp->u.auxent.x_sym.x_misc.x_fsize,
 			       llnos, next);
 		      break;
 		    }
@@ -2192,7 +2192,7 @@ coff_print_symbol (bfd *abfd,
 			   tagndx);
 		  if (auxp->fix_end)
 		    fprintf (file, " endndx %ld",
-			     ((long)
+			     ((long long)
 			      (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
 			       - root)));
 		  break;
diff --git a/bfd/cofflink.c b/bfd/cofflink.c
index 2f73f72..91f01fd 100644
--- a/bfd/cofflink.c
+++ b/bfd/cofflink.c
@@ -798,8 +798,8 @@ _bfd_coff_final_link (bfd *abfd,
   flaginfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
   amt = max_sym_count * sizeof (asection *);
   flaginfo.sec_ptrs = (asection **) bfd_malloc (amt);
-  amt = max_sym_count * sizeof (long);
-  flaginfo.sym_indices = (long int *) bfd_malloc (amt);
+  amt = max_sym_count * sizeof (long long);
+  flaginfo.sym_indices = (long long int *) bfd_malloc (amt);
   flaginfo.outsyms = (bfd_byte *) bfd_malloc ((max_sym_count + 1) * symesz);
   amt = max_lineno_count * bfd_coff_linesz (abfd);
   flaginfo.linenos = (bfd_byte *) bfd_malloc (amt);
@@ -1404,7 +1404,7 @@ mark_relocs (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 	 in the relocation table.  This will then be picked up in the
 	 skip/don't-skip pass.  */
       for (; irel < irelend; irel++)
-	if ((unsigned long) irel->r_symndx < obj_raw_syment_count (input_bfd))
+	if ((unsigned long long) irel->r_symndx < obj_raw_syment_count (input_bfd))
 	  flaginfo->sym_indices[irel->r_symndx] = -1;
     }
 }
@@ -1431,8 +1431,8 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
   bfd_byte *esym_end;
   struct internal_syment *isymp;
   asection **secpp;
-  long *indexp;
-  unsigned long output_index;
+  long long *indexp;
+  unsigned long long output_index;
   bfd_byte *outsym;
   struct coff_link_hash_entry **sym_hash;
   asection *o;
@@ -1716,7 +1716,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 		  && islp->n_sclass != C_EOS)
 		{
 		  union internal_auxent eleaux;
-		  long indx;
+		  long long indx;
 
 		  bfd_coff_swap_aux_in (input_bfd, (esl + isymesz),
 					islp->n_type, islp->n_sclass, 0,
@@ -1731,7 +1731,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 		      && (indx
 			  < ((esym -
 			      (bfd_byte *) obj_coff_external_syms (input_bfd))
-			     / (long) isymesz)))
+			     / (long long) isymesz)))
 		    {
 		      (*epp)->tagndx = flaginfo->sym_indices[indx];
 		      if ((*epp)->tagndx < 0)
@@ -1932,7 +1932,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 
 	  if (global)
 	    {
-	      long indx;
+	      long long indx;
 	      struct coff_link_hash_entry *h;
 
 	      indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
@@ -2055,7 +2055,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 	      else if ((isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
 		       && isymp->n_sclass != C_NT_WEAK)
 		{
-		  unsigned long indx;
+		  unsigned long long indx;
 
 		  if (ISFCN (isymp->n_type)
 		      || ISTAG (isymp->n_sclass)
@@ -2086,7 +2086,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 		  indx = auxp->x_sym.x_tagndx.l;
 		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
 		    {
-		      long symindx;
+		      long long symindx;
 
 		      symindx = flaginfo->sym_indices[indx];
 		      if (symindx < 0)
@@ -2236,10 +2236,10 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 	      if (iline.l_lnno != 0)
 		iline.l_addr.l_paddr += offset;
 	      else if (iline.l_addr.l_symndx >= 0
-		       && ((unsigned long) iline.l_addr.l_symndx
+		       && ((unsigned long long) iline.l_addr.l_symndx
 			   < obj_raw_syment_count (input_bfd)))
 		{
-		  long indx;
+		  long long indx;
 
 		  indx = flaginfo->sym_indices[iline.l_addr.l_symndx];
 
@@ -2415,7 +2415,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 	    {
 	      struct coff_link_hash_entry *h;
 	      asection *ps = NULL;
-	      long symndx = irel->r_symndx;
+	      long long symndx = irel->r_symndx;
 	      if (symndx < 0)
 		continue;
 	      h = obj_coff_sym_hashes (input_bfd)[symndx];
@@ -2502,7 +2502,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 		    }
 		  else
 		    {
-		      long indx;
+		      long long indx;
 
 		      indx = flaginfo->sym_indices[irel->r_symndx];
 		      if (indx != -1)
@@ -2941,7 +2941,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,
   relend = rel + input_section->reloc_count;
   for (; rel < relend; rel++)
     {
-      long symndx;
+      long long symndx;
       struct coff_link_hash_entry *h;
       struct internal_syment *sym;
       bfd_vma addend;
@@ -2958,7 +2958,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,
 	  sym = NULL;
 	}
       else if (symndx < 0
-	       || (unsigned long) symndx >= obj_raw_syment_count (input_bfd))
+	       || (unsigned long long) symndx >= obj_raw_syment_count (input_bfd))
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
diff --git a/bfd/cpu-arm.c b/bfd/cpu-arm.c
index 4ef409b..ed0d98f 100644
--- a/bfd/cpu-arm.c
+++ b/bfd/cpu-arm.c
@@ -243,9 +243,9 @@ arm_check_note (bfd *abfd,
 		const char *expected_name,
 		char **description_return)
 {
-  unsigned long namesz;
-  unsigned long descsz;
-  unsigned long type;
+  unsigned long long namesz;
+  unsigned long long descsz;
+  unsigned long long type;
   char *	descr;
 
   if (buffer_size < offsetof (arm_Note, name))
diff --git a/bfd/cpu-sh.c b/bfd/cpu-sh.c
index f6c493f..b34c10b 100644
--- a/bfd/cpu-sh.c
+++ b/bfd/cpu-sh.c
@@ -358,7 +358,7 @@ const bfd_arch_info_type bfd_sh_arch =
    The prototypes for these SH specific functions are found in
    sh-opc.h .  */
 
-static struct { unsigned long bfd_mach, arch, arch_up; } bfd_to_arch_table[] =
+static struct { unsigned long long bfd_mach, arch, arch_up; } bfd_to_arch_table[] =
 {
   { bfd_mach_sh,	      arch_sh1,		    arch_sh_up },
   { bfd_mach_sh2,	      arch_sh2,		    arch_sh2_up },
@@ -390,7 +390,7 @@ static struct { unsigned long bfd_mach, arch, arch_up; } bfd_to_arch_table[] =
    using the table above.  */
 
 unsigned int
-sh_get_arch_from_bfd_mach (unsigned long mach)
+sh_get_arch_from_bfd_mach (unsigned long long mach)
 {
   int i = 0;
 
@@ -412,7 +412,7 @@ sh_get_arch_from_bfd_mach (unsigned long mach)
    using the table above.  */
 
 unsigned int
-sh_get_arch_up_from_bfd_mach (unsigned long mach)
+sh_get_arch_up_from_bfd_mach (unsigned long long mach)
 {
   int i = 0;
 
@@ -434,10 +434,10 @@ sh_get_arch_up_from_bfd_mach (unsigned long mach)
    architecture which supports all the required features, and
    return the corresponding BFD mach.  */
 
-unsigned long
+unsigned long long
 sh_get_bfd_mach_from_arch_set (unsigned int arch_set)
 {
-  unsigned long result = 0;
+  unsigned long long result = 0;
   unsigned int best = ~arch_set;
   unsigned int co_mask = ~0;
   int i = 0;
diff --git a/bfd/doc/chew.c b/bfd/doc/chew.c
index da229df..6c9c023 100644
--- a/bfd/doc/chew.c
+++ b/bfd/doc/chew.c
@@ -101,8 +101,8 @@ int warning;
 typedef struct buffer
 {
   char *ptr;
-  unsigned long write_idx;
-  unsigned long size;
+  unsigned long long write_idx;
+  unsigned long long size;
 } string_type;
 
 #ifdef __STDC__
@@ -291,8 +291,8 @@ typedef void (*stinst_type)();
 stinst_type *pc;
 stinst_type sstack[STACK];
 stinst_type *ssp = &sstack[0];
-long istack[STACK];
-long *isp = &istack[0];
+long long istack[STACK];
+long long *isp = &istack[0];
 
 typedef int *word_type;
 
@@ -413,7 +413,7 @@ push_number ()
   isp++;
   icheck_range ();
   pc++;
-  *isp = (long) (*pc);
+  *isp = (long long) (*pc);
   pc++;
 }
 
@@ -490,9 +490,9 @@ static void
 print_stack_level ()
 {
   fprintf (stderr, "current string stack depth = %ld, ",
-	   (long) (tos - stack));
+	   (long long) (tos - stack));
   fprintf (stderr, "current integer stack depth = %ld\n",
-	   (long) (isp - istack));
+	   (long long) (isp - istack));
   pc++;
 }
 
@@ -1438,7 +1438,7 @@ compile (string)
 static void
 bang ()
 {
-  *(long *) ((isp[0])) = isp[-1];
+  *(long long *) ((isp[0])) = isp[-1];
   isp -= 2;
   icheck_range ();
   pc++;
@@ -1447,7 +1447,7 @@ bang ()
 static void
 atsign ()
 {
-  isp[0] = *(long *) (isp[0]);
+  isp[0] = *(long long *) (isp[0]);
   pc++;
 }
 
@@ -1623,7 +1623,7 @@ main (ac, av)
   if (tos != stack)
     {
       fprintf (stderr, "finishing with current stack level %ld\n",
-	       (long) (tos - stack));
+	       (long long) (tos - stack));
       return 1;
     }
   return 0;
diff --git a/bfd/dwarf1.c b/bfd/dwarf1.c
index f272ea8..b810fc8 100644
--- a/bfd/dwarf1.c
+++ b/bfd/dwarf1.c
@@ -68,20 +68,20 @@ struct dwarf1_unit
   char *name;
 
   /* The highest and lowest address used in the compilation unit.  */
-  unsigned long low_pc;
-  unsigned long high_pc;
+  unsigned long long low_pc;
+  unsigned long long high_pc;
 
   /* Does this unit have a statement list?  */
   int has_stmt_list;
 
   /* If any, the offset of the line number table in the .line section.  */
-  unsigned long stmt_list_offset;
+  unsigned long long stmt_list_offset;
 
   /* If non-zero, a pointer to the first child of this unit.  */
   bfd_byte *first_child;
 
   /* How many line entries?  */
-  unsigned long line_count;
+  unsigned long long line_count;
 
   /* The decoded line number table (line_count entries).  */
   struct linenumber* linenumber_table;
@@ -101,18 +101,18 @@ struct dwarf1_func
   char* name;
 
   /* The highest and lowest address used in the compilation unit.  */
-  unsigned long low_pc;
-  unsigned long high_pc;
+  unsigned long long low_pc;
+  unsigned long long high_pc;
 };
 
 /* Used to return info about a parsed die.  */
 struct die_info
 {
-  unsigned long length;
-  unsigned long sibling;
-  unsigned long low_pc;
-  unsigned long high_pc;
-  unsigned long stmt_list_offset;
+  unsigned long long length;
+  unsigned long long sibling;
+  unsigned long long low_pc;
+  unsigned long long high_pc;
+  unsigned long long stmt_list_offset;
 
   char* name;
 
@@ -125,10 +125,10 @@ struct die_info
 struct linenumber
 {
   /* First address in the line.  */
-  unsigned long addr;
+  unsigned long long addr;
 
   /* The line number.  */
-  unsigned long linenumber;
+  unsigned long long linenumber;
 };
 
 /* Find the form of an attr, from the attr field.  */
@@ -320,9 +320,9 @@ parse_line_table (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)
   xptr = stash->line_section + aUnit->stmt_list_offset;
   if (xptr + 8 <= stash->line_section_end)
     {
-      unsigned long eachLine;
+      unsigned long long eachLine;
       bfd_byte *tblend;
-      unsigned long base;
+      unsigned long long base;
       bfd_size_type amt;
 
       /* First comes the length.  */
@@ -420,7 +420,7 @@ parse_functions_in_unit (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)
 static bfd_boolean
 dwarf1_unit_find_nearest_line (struct dwarf1_debug* stash,
 			       struct dwarf1_unit* aUnit,
-			       unsigned long addr,
+			       unsigned long long addr,
 			       const char **filename_ptr,
 			       const char **functionname_ptr,
 			       unsigned int *linenumber_ptr)
@@ -432,7 +432,7 @@ dwarf1_unit_find_nearest_line (struct dwarf1_debug* stash,
     {
       if (aUnit->has_stmt_list)
 	{
-	  unsigned long i;
+	  unsigned long long i;
 	  struct dwarf1_func* eachFunc;
 
 	  if (! aUnit->linenumber_table)
@@ -494,7 +494,7 @@ _bfd_dwarf1_find_nearest_line (bfd *abfd,
   struct dwarf1_unit* eachUnit;
 
   /* What address are we looking for? */
-  unsigned long addr = (unsigned long)(offset + section->vma);
+  unsigned long long addr = (unsigned long long)(offset + section->vma);
 
   *filename_ptr = NULL;
   *functionname_ptr = NULL;
diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
index 0f8257f..a24a00e 100644
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -250,7 +250,7 @@ struct comp_unit
   bfd_byte *info_ptr_unit;
 
   /* The offset into .debug_line of the line number table.  */
-  unsigned long line_offset;
+  unsigned long long line_offset;
 
   /* Pointer to the first child die for the comp unit.  */
   bfd_byte *first_child_die_ptr;
@@ -2079,7 +2079,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	/* xgettext: c-format */
 	(_("DWARF error: line info data is bigger (%#" PRIx64 ")"
 	   " than the space remaining in the section (%#lx)"),
-	 (uint64_t) lh.total_length, (unsigned long) (line_end - line_ptr));
+	 (uint64_t) lh.total_length, (unsigned long long) (line_end - line_ptr));
       bfd_set_error (bfd_error_bad_value);
       return NULL;
     }
diff --git a/bfd/ecoff.c b/bfd/ecoff.c
index b01f572..3dcf9ec 100644
--- a/bfd/ecoff.c
+++ b/bfd/ecoff.c
@@ -199,7 +199,7 @@ _bfd_ecoff_set_arch_mach_hook (bfd *abfd, void * filehdr)
 {
   struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
   enum bfd_architecture arch;
-  unsigned long mach;
+  unsigned long long mach;
 
   switch (internal_f->f_magic)
     {
@@ -290,14 +290,14 @@ ecoff_get_magic (bfd *abfd)
 
 /* Get the section s_flags to use for a section.  */
 
-static long
+static long long
 ecoff_sec_to_styp_flags (const char *name, flagword flags)
 {
   unsigned int i;
   static struct
   {
     const char * name;
-    long flags;
+    long long flags;
   }
   styp_flags [] =
   {
@@ -325,7 +325,7 @@ ecoff_sec_to_styp_flags (const char *name, flagword flags)
     { _DYNSYM,	STYP_DYNSYM	},
     { _RCONST,	STYP_RCONST	}
   };
-  long styp = 0;
+  long long styp = 0;
 
   for (i = 0; i < ARRAY_SIZE (styp_flags); i++)
     if (streq (name, styp_flags[i].name))
@@ -369,7 +369,7 @@ _bfd_ecoff_styp_to_sec_flags (bfd *abfd ATTRIBUTE_UNUSED,
 			      flagword * flags_ptr)
 {
   struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
-  long styp_flags = internal_s->s_flags;
+  long long styp_flags = internal_s->s_flags;
   flagword sec_flags = 0;
 
   if (styp_flags & STYP_NOLOAD)
@@ -980,7 +980,7 @@ _bfd_ecoff_slurp_symbol_table (bfd *abfd)
 
 /* Return the amount of space needed for the canonical symbols.  */
 
-long
+long long
 _bfd_ecoff_get_symtab_upper_bound (bfd *abfd)
 {
   if (! _bfd_ecoff_slurp_symbolic_info (abfd, NULL,
@@ -995,7 +995,7 @@ _bfd_ecoff_get_symtab_upper_bound (bfd *abfd)
 
 /* Get the canonical symbols.  */
 
-long
+long long
 _bfd_ecoff_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
   unsigned int counter = 0;
@@ -1028,7 +1028,7 @@ ecoff_emit_aggregate (bfd *abfd,
 		      FDR *fdr,
 		      char *string,
 		      RNDXR *rndx,
-		      long isym,
+		      long long isym,
 		      const char *which)
 {
   const struct ecoff_debug_swap * const debug_swap =
@@ -1079,7 +1079,7 @@ ecoff_emit_aggregate (bfd *abfd,
   sprintf (string,
 	   "%s %s { ifd = %u, index = %lu }",
 	   which, name, ifd,
-	   ((unsigned long) indx
+	   ((unsigned long long) indx
 	    + debug_info->symbolic_header.iextMax));
 }
 
@@ -1187,7 +1187,7 @@ ecoff_type_to_string (bfd *abfd, FDR *fdr, unsigned int indx)
     case btStruct:		/* Structure (Record).  */
       _bfd_ecoff_swap_rndx_in (bigendian, &aux_ptr[indx].a_rndx, &rndx);
       ecoff_emit_aggregate (abfd, fdr, p1, &rndx,
-			    (long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
+			    (long long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
 			    "struct");
       indx++;			/* Skip aux words.  */
       break;
@@ -1199,7 +1199,7 @@ ecoff_type_to_string (bfd *abfd, FDR *fdr, unsigned int indx)
     case btUnion:		/* Union.  */
       _bfd_ecoff_swap_rndx_in (bigendian, &aux_ptr[indx].a_rndx, &rndx);
       ecoff_emit_aggregate (abfd, fdr, p1, &rndx,
-			    (long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
+			    (long long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
 			    "union");
       indx++;			/* Skip aux words.  */
       break;
@@ -1211,7 +1211,7 @@ ecoff_type_to_string (bfd *abfd, FDR *fdr, unsigned int indx)
     case btEnum:		/* Enumeration.  */
       _bfd_ecoff_swap_rndx_in (bigendian, &aux_ptr[indx].a_rndx, &rndx);
       ecoff_emit_aggregate (abfd, fdr, p1, &rndx,
-			    (long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
+			    (long long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
 			    "enum");
       indx++;			/* Skip aux words.  */
       break;
@@ -1351,18 +1351,18 @@ ecoff_type_to_string (bfd *abfd, FDR *fdr, unsigned int indx)
 		    if (qualifiers[j].low_bound != 0)
 		      sprintf (p2,
 			       "%ld:%ld {%ld bits}",
-			       (long) qualifiers[j].low_bound,
-			       (long) qualifiers[j].high_bound,
-			       (long) qualifiers[j].stride);
+			       (long long) qualifiers[j].low_bound,
+			       (long long) qualifiers[j].high_bound,
+			       (long long) qualifiers[j].stride);
 
 		    else if (qualifiers[j].high_bound != -1)
 		      sprintf (p2,
 			       "%ld {%ld bits}",
-			       (long) (qualifiers[j].high_bound + 1),
-			       (long) (qualifiers[j].stride));
+			       (long long) (qualifiers[j].high_bound + 1),
+			       (long long) (qualifiers[j].stride));
 
 		    else
-		      sprintf (p2, " {%ld bits}", (long) (qualifiers[j].stride));
+		      sprintf (p2, " {%ld bits}", (long long) (qualifiers[j].stride));
 
 		    p2 += strlen (p2);
 		    strcpy (p2, "] of ");
@@ -1523,17 +1523,17 @@ _bfd_ecoff_print_symbol (bfd *abfd,
 	      case stFile:
 	      case stBlock:
 		fprintf (file, _("\n      End+1 symbol: %ld"),
-			 (long) (indx + sym_base));
+			 (long long) (indx + sym_base));
 		break;
 
 	      case stEnd:
 		if (ecoff_ext.asym.sc == scText
 		    || ecoff_ext.asym.sc == scInfo)
 		  fprintf (file, _("\n      First symbol: %ld"),
-			   (long) (indx + sym_base));
+			   (long long) (indx + sym_base));
 		else
 		  fprintf (file, _("\n      First symbol: %ld"),
-			   ((long)
+			   ((long long)
 			    (AUX_GET_ISYM (bigendian,
 					   &aux_base[ecoff_ext.asym.index])
 			     + sym_base)));
@@ -1546,32 +1546,32 @@ _bfd_ecoff_print_symbol (bfd *abfd,
 		else if (ecoffsymbol (symbol)->local)
 		  /* xgettext:c-format */
 		  fprintf (file, _("\n      End+1 symbol: %-7ld   Type:  %s"),
-			   ((long)
+			   ((long long)
 			    (AUX_GET_ISYM (bigendian,
 					   &aux_base[ecoff_ext.asym.index])
 			     + sym_base)),
 			   ecoff_type_to_string (abfd, fdr, indx + 1));
 		else
 		  fprintf (file, _("\n      Local symbol: %ld"),
-			   ((long) indx
-			    + (long) sym_base
+			   ((long long) indx
+			    + (long long) sym_base
 			    + (ecoff_data (abfd)
 			       ->debug_info.symbolic_header.iextMax)));
 		break;
 
 	      case stStruct:
 		fprintf (file, _("\n      struct; End+1 symbol: %ld"),
-			 (long) (indx + sym_base));
+			 (long long) (indx + sym_base));
 		break;
 
 	      case stUnion:
 		fprintf (file, _("\n      union; End+1 symbol: %ld"),
-			 (long) (indx + sym_base));
+			 (long long) (indx + sym_base));
 		break;
 
 	      case stEnum:
 		fprintf (file, _("\n      enum; End+1 symbol: %ld"),
-			 (long) (indx + sym_base));
+			 (long long) (indx + sym_base));
 		break;
 
 	      default:
@@ -1696,7 +1696,7 @@ ecoff_slurp_reloc_table (bfd *abfd,
 
 /* Get a canonical list of relocs.  */
 
-long
+long long
 _bfd_ecoff_canonicalize_reloc (bfd *abfd,
 			       asection *section,
 			       arelent **relptr,
@@ -1900,7 +1900,7 @@ _bfd_ecoff_bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
 bfd_boolean
 _bfd_ecoff_set_arch_mach (bfd *abfd,
 			  enum bfd_architecture arch,
-			  unsigned long machine)
+			  unsigned long long machine)
 {
   bfd_default_set_arch_mach (abfd, arch, machine);
   return arch == ecoff_backend (abfd)->arch;
@@ -2241,9 +2241,9 @@ bfd_ecoff_set_gp_value (bfd *abfd, bfd_vma gp_value)
 
 bfd_boolean
 bfd_ecoff_set_regmasks (bfd *abfd,
-			unsigned long gprmask,
-			unsigned long fprmask,
-			unsigned long *cprmask)
+			unsigned long long gprmask,
+			unsigned long long fprmask,
+			unsigned long long *cprmask)
 {
   ecoff_data_type *tdata;
 
@@ -2699,7 +2699,7 @@ _bfd_ecoff_write_object_contents (bfd *abfd)
 		  static struct
 		  {
 		    const char * name;
-		    long r_symndx;
+		    long long r_symndx;
 		  }
 		  section_symndx [] =
 		  {
@@ -3082,7 +3082,7 @@ _bfd_ecoff_write_armap (bfd *abfd,
      date.  */
   stat (abfd->filename, &statbuf);
   _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
-		    (long) (statbuf.st_mtime + 60));
+		    (long long) (statbuf.st_mtime + 60));
 
   /* The DECstation uses zeroes for the uid, gid and mode of the
      armap.  */
@@ -3271,7 +3271,7 @@ ecoff_link_add_externals (bfd *abfd,
   void (* const swap_ext_in) (bfd *, void *, EXTR *)
     = backend->debug_swap.swap_ext_in;
   bfd_size_type external_ext_size = backend->debug_swap.external_ext_size;
-  unsigned long ext_count;
+  unsigned long long ext_count;
   struct bfd_link_hash_entry **sym_hash;
   char *ext_ptr;
   char *ext_end;
@@ -4056,7 +4056,7 @@ ecoff_reloc_link_order (bfd *output_bfd,
       static struct
       {
 	const char * name;
-	long r_symndx;
+	long long r_symndx;
       }
       section_symndx [] =
       {
diff --git a/bfd/ecofflink.c b/bfd/ecofflink.c
index 6e25ed0..2de95a7 100644
--- a/bfd/ecofflink.c
+++ b/bfd/ecofflink.c
@@ -271,7 +271,7 @@ struct string_hash_entry
 {
   struct bfd_hash_entry root;
   /* FDR index or string table offset.  */
-  long val;
+  long long val;
   /* Next entry in string table.  */
   struct string_hash_entry *next;
 };
@@ -327,7 +327,7 @@ struct shuffle
   /* The next entry in this linked list.  */
   struct shuffle *next;
   /* The length of the information.  */
-  unsigned long size;
+  unsigned long long size;
   /* Whether this information comes from a file or not.  */
   bfd_boolean filep;
   union
@@ -375,7 +375,7 @@ struct accumulate
   struct shuffle *rfd;
   struct shuffle *rfd_end;
   /* The size of the largest file shuffle.  */
-  unsigned long largest_file_shuffle;
+  unsigned long long largest_file_shuffle;
   /* An objalloc for debugging information.  */
   struct objalloc *memory;
 };
@@ -388,14 +388,14 @@ add_file_shuffle (struct accumulate *ainfo,
 		  struct shuffle **tail,
 		  bfd *input_bfd,
 		  file_ptr offset,
-		  unsigned long size)
+		  unsigned long long size)
 {
   struct shuffle *n;
 
   if (*tail != (struct shuffle *) NULL
       && (*tail)->filep
       && (*tail)->u.file.input_bfd == input_bfd
-      && (*tail)->u.file.offset + (*tail)->size == (unsigned long) offset)
+      && (*tail)->u.file.offset + (*tail)->size == (unsigned long long) offset)
     {
       /* Just merge this entry onto the existing one.  */
       (*tail)->size += size;
@@ -433,7 +433,7 @@ add_memory_shuffle (struct accumulate *ainfo,
 		    struct shuffle **head,
 		    struct shuffle **tail,
 		    bfd_byte *data,
-		    unsigned long size)
+		    unsigned long long size)
 {
   struct shuffle *n;
 
@@ -581,12 +581,12 @@ bfd_ecoff_debug_accumulate (void * handle,
   bfd_size_type fdr_add;
   unsigned int copied;
   RFDT i;
-  unsigned long sz;
+  unsigned long long sz;
   bfd_byte *rfd_out;
   bfd_byte *rfd_in;
   bfd_byte *rfd_end;
-  long newrfdbase = 0;
-  long oldrfdbase = 0;
+  long long newrfdbase = 0;
+  long long oldrfdbase = 0;
   bfd_byte *fdr_out;
   bfd_size_type amt;
 
@@ -683,8 +683,8 @@ bfd_ecoff_debug_accumulate (void * handle,
 	  lookup = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 20);
 	  if (lookup == NULL)
 	    return FALSE;
-	  sprintf (lookup, "%s %lx %lx", name, (unsigned long) fdr.csym,
-		   (unsigned long) fdr.caux);
+	  sprintf (lookup, "%s %lx %lx", name, (unsigned long long) fdr.csym,
+		   (unsigned long long) fdr.caux);
 
 	  fh = string_hash_lookup (&ainfo->fdr_hash, lookup, TRUE, TRUE);
 	  free (lookup);
@@ -877,7 +877,7 @@ bfd_ecoff_debug_accumulate (void * handle,
 	{
 	  file_ptr pos = input_symhdr->cbLineOffset + fdr.cbLineOffset;
 	  if (!add_file_shuffle (ainfo, &ainfo->line, &ainfo->line_end,
-				 input_bfd, pos, (unsigned long) fdr.cbLine))
+				 input_bfd, pos, (unsigned long long) fdr.cbLine))
 	    return FALSE;
 	  fdr.ilineBase = output_symhdr->ilineMax;
 	  fdr.cbLineOffset = output_symhdr->cbLine;
@@ -909,7 +909,7 @@ bfd_ecoff_debug_accumulate (void * handle,
 	{
 	  file_ptr pos = input_symhdr->cbSsOffset + fdr.issBase;
 	  if (!add_file_shuffle (ainfo, &ainfo->ss, &ainfo->ss_end,
-				 input_bfd, pos, (unsigned long) fdr.cbSs))
+				 input_bfd, pos, (unsigned long long) fdr.cbSs))
 	    return FALSE;
 	  fdr.issBase = output_symhdr->issMax;
 	  output_symhdr->issMax += fdr.cbSs;
@@ -926,7 +926,7 @@ bfd_ecoff_debug_accumulate (void * handle,
 	    {
 	      file_ptr pos = (input_symhdr->cbPdOffset
 			      + fdr.ipdFirst * external_pdr_size);
-	      unsigned long size = fdr.cpd * external_pdr_size;
+	      unsigned long long size = fdr.cpd * external_pdr_size;
 	      if (!add_file_shuffle (ainfo, &ainfo->pdr, &ainfo->pdr_end,
 				     input_bfd, pos, size))
 		return FALSE;
@@ -936,7 +936,7 @@ bfd_ecoff_debug_accumulate (void * handle,
 	    {
 	      file_ptr pos = (input_symhdr->cbOptOffset
 			      + fdr.ioptBase * external_opt_size);
-	      unsigned long size = fdr.copt * external_opt_size;
+	      unsigned long long size = fdr.copt * external_opt_size;
 	      if (!add_file_shuffle (ainfo, &ainfo->opt, &ainfo->opt_end,
 				     input_bfd, pos, size))
 		return FALSE;
@@ -1028,7 +1028,7 @@ bfd_ecoff_debug_accumulate (void * handle,
 /* Add a string to the debugging information we are accumulating.
    Return the offset from the fdr string base.  */
 
-static long
+static long long
 ecoff_add_string (struct accumulate *ainfo,
 		  struct bfd_link_info *info,
 		  struct ecoff_debug_info *debug,
@@ -1093,8 +1093,8 @@ bfd_ecoff_debug_accumulate_other (void * handle,
   asymbol **symbols;
   asymbol **sym_ptr;
   asymbol **sym_end;
-  long symsize;
-  long symcount;
+  long long symsize;
+  long long symcount;
   void * external_fdr;
 
   memset (&fdr, 0, sizeof fdr);
@@ -1165,7 +1165,7 @@ bfd_ecoff_debug_accumulate_other (void * handle,
       (*swap_sym_out) (output_bfd, &internal_sym, external_sym);
       add_memory_shuffle (ainfo, &ainfo->sym, &ainfo->sym_end,
 			  (bfd_byte *) external_sym,
-			  (unsigned long) output_swap->external_sym_size);
+			  (unsigned long long) output_swap->external_sym_size);
       ++fdr.csym;
       ++output_symhdr->isymMax;
     }
@@ -1186,7 +1186,7 @@ bfd_ecoff_debug_accumulate_other (void * handle,
   (*output_swap->swap_fdr_out) (output_bfd, &fdr, external_fdr);
   add_memory_shuffle (ainfo, &ainfo->fdr, &ainfo->fdr_end,
 		      (bfd_byte *) external_fdr,
-		      (unsigned long) output_swap->external_fdr_size);
+		      (unsigned long long) output_swap->external_fdr_size);
 
   ++output_symhdr->ifdMax;
 
@@ -1523,7 +1523,7 @@ ecoff_write_shuffle (bfd *abfd,
 		     void * space)
 {
   struct shuffle *l;
-  unsigned long total;
+  unsigned long long total;
 
   total = 0;
   for (l = shuffle; l != (struct shuffle *) NULL; l = l->next)
@@ -1606,7 +1606,7 @@ bfd_ecoff_write_accumulated_debug (void * handle,
     }
   else
     {
-      unsigned long total;
+      unsigned long long total;
       bfd_byte null;
       struct string_hash_entry *sh;
 
@@ -1731,7 +1731,7 @@ mk_fdrtab (bfd *abfd,
   FDR *fdr_start;
   FDR *fdr_end;
   bfd_boolean stabs;
-  long len;
+  long long len;
   bfd_size_type amt;
 
   fdr_start = debug_info->fdr;
@@ -1811,11 +1811,11 @@ mk_fdrtab (bfd *abfd,
 
 /* Return index of first FDR that covers to OFFSET.  */
 
-static long
+static long long
 fdrtab_lookup (struct ecoff_find_line *line_info, bfd_vma offset)
 {
-  long low, high, len;
-  long mid = -1;
+  long long low, high, len;
+  long long mid = -1;
   struct ecoff_fdrtab_entry *tab;
 
   len = line_info->fdrtab_len;
@@ -2404,7 +2404,7 @@ _bfd_ecoff_locate_line (bfd *abfd,
 static bfd_boolean
 ecoff_collect_shuffle (struct shuffle *l, bfd_byte *buff)
 {
-  unsigned long total;
+  unsigned long long total;
 
   total = 0;
   for (; l != (struct shuffle *) NULL; l = l->next)
@@ -2453,7 +2453,7 @@ _bfd_ecoff_get_accumulated_ss (void * handle, bfd_byte *buff)
 {
   struct accumulate *ainfo = (struct accumulate *) handle;
   struct string_hash_entry *sh;
-  unsigned long total;
+  unsigned long long total;
 
   /* The string table is written out from the hash table if this is a
      final link.  */
diff --git a/bfd/ecoffswap.h b/bfd/ecoffswap.h
index 35524d1..c0d4ea9 100644
--- a/bfd/ecoffswap.h
+++ b/bfd/ecoffswap.h
@@ -188,7 +188,7 @@ ecoff_swap_fdr_in (bfd *abfd, void * ext_copy, FDR *intern)
   intern->adr		= ECOFF_GET_OFF (abfd, ext->f_adr);
   intern->rss		= H_GET_32 (abfd, ext->f_rss);
 #if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
-  if (intern->rss == (signed long) 0xffffffff)
+  if (intern->rss == (signed long long) 0xffffffff)
     intern->rss = -1;
 #endif
   intern->issBase	= H_GET_32 (abfd, ext->f_issBase);
@@ -340,9 +340,9 @@ ecoff_swap_pdr_in (bfd *abfd, void * ext_copy, PDR *intern)
   intern->cbLineOffset	= ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);
 
 #if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
-  if (intern->isym == (signed long) 0xffffffff)
+  if (intern->isym == (signed long long) 0xffffffff)
     intern->isym = -1;
-  if (intern->iline == (signed long) 0xffffffff)
+  if (intern->iline == (signed long long) 0xffffffff)
     intern->iline = -1;
 
   intern->gp_prologue = H_GET_8 (abfd, ext->p_gp_prologue);
@@ -448,7 +448,7 @@ ecoff_swap_sym_in (bfd *abfd, void * ext_copy, SYMR *intern)
   intern->value		= ECOFF_GET_OFF (abfd, ext->s_value);
 
 #if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
-  if (intern->iss == (signed long) 0xffffffff)
+  if (intern->iss == (signed long long) 0xffffffff)
     intern->iss = -1;
 #endif
 
diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
index 3ed16de..33ea5be 100644
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -126,7 +126,7 @@ struct elf_link_hash_entry
   /* Symbol index in output file.  This is initialized to -1.  It is
      set to -2 if the symbol is used by a reloc.  It is set to -3 if
      this symbol is defined in a discarded section.  */
-  long indx;
+  long long indx;
 
   /* Symbol index as a dynamic symbol.  Initialized to -1, and remains
      -1 if this is not a dynamic symbol.  */
@@ -140,7 +140,7 @@ struct elf_link_hash_entry
      End result: this field -1 does not indicate that the symbol is
      not in the dynamic symbol table, but rather that the symbol is
      not visible outside this DSO.  */
-  long dynindx;
+  long long dynindx;
 
   /* If this symbol requires an entry in the global offset table, the
      processor specific backend uses this field to track usage and
@@ -222,7 +222,7 @@ struct elf_link_hash_entry
   unsigned int is_weakalias : 1;
 
   /* String table index in .dynstr if this is a dynamic symbol.  */
-  unsigned long dynstr_index;
+  unsigned long long dynstr_index;
 
   union
   {
@@ -232,7 +232,7 @@ struct elf_link_hash_entry
     /* Hash value of the name computed using the ELF hash function.
        Used part way through size_dynamic_sections, after we've finished
        with aliases.  */
-    unsigned long elf_hash_value;
+    unsigned long long elf_hash_value;
   } u;
 
   /* Version information.  */
@@ -303,10 +303,10 @@ struct elf_link_local_dynamic_entry
   bfd *input_bfd;
 
   /* The index of the local symbol being copied.  */
-  long input_indx;
+  long long input_indx;
 
   /* The index in the outgoing dynamic symbol table.  */
-  long dynindx;
+  long long dynindx;
 
   /* A copy of the input symbol.  */
   Elf_Internal_Sym isym;
@@ -525,8 +525,8 @@ enum elf_target_id
 struct elf_sym_strtab
 {
   Elf_Internal_Sym sym;
-  unsigned long dest_index;
-  unsigned long destshndx_index;
+  unsigned long long dest_index;
+  unsigned long long destshndx_index;
 };
 
 /* ELF linker hash table.  */
@@ -681,7 +681,7 @@ struct elf_link_hash_table
 struct sym_cache
 {
   bfd *abfd;
-  unsigned long indx[LOCAL_SYM_CACHE_SIZE];
+  unsigned long long indx[LOCAL_SYM_CACHE_SIZE];
   Elf_Internal_Sym sym[LOCAL_SYM_CACHE_SIZE];
 };
 
@@ -717,7 +717,7 @@ struct elf_size_info {
     (bfd *, const Elf_Internal_Sym *, void *, void *);
   bfd_boolean (*slurp_reloc_table)
     (bfd *, asection *, asymbol **, bfd_boolean);
-  long (*slurp_symbol_table)
+  long long (*slurp_symbol_table)
     (bfd *, asymbol **, bfd_boolean);
   void (*swap_dyn_in)
     (bfd *, const void *, Elf_Internal_Dyn *);
@@ -1218,7 +1218,7 @@ struct elf_backend_data
   /* Filter what symbols of the output file to include in the import
      library if one is created.  */
   unsigned int (*elf_backend_filter_implib_symbols)
-    (bfd *, struct bfd_link_info *, asymbol **, long);
+    (bfd *, struct bfd_link_info *, asymbol **, long long);
 
   /* Copy any information related to dynamic linking from a pre-existing
      symbol to a newly created symbol.  Also called to copy flags and
@@ -1440,7 +1440,7 @@ struct elf_backend_data
      otherwise by the local symbol with index SYMNDX in IBFD.  */
   bfd_vma (*got_elt_size) (bfd *, struct bfd_link_info *,
 			   struct elf_link_hash_entry *h,
-			   bfd *ibfd, unsigned long symndx);
+			   bfd *ibfd, unsigned long long symndx);
 
   /* The vendor name to use for a processor-standard attributes section.  */
   const char *obj_attrs_vendor;
@@ -1492,7 +1492,7 @@ struct elf_backend_data
   unsigned stack_align;
 
   /* Flag bits to assign to a section of type SHT_STRTAB.  */
-  unsigned long elf_strtab_flags;
+  unsigned long long elf_strtab_flags;
 
   /* This is TRUE if the linker should act like collect and gather
      global constructors and destructors by name.  This is TRUE for
@@ -2064,9 +2064,9 @@ extern bfd_vma _bfd_elf_rel_local_sym
 extern bfd_vma _bfd_elf_section_offset
   (bfd *, struct bfd_link_info *, asection *, bfd_vma);
 
-extern unsigned long bfd_elf_hash
+extern unsigned long long bfd_elf_hash
   (const char *);
-extern unsigned long bfd_elf_gnu_hash
+extern unsigned long long bfd_elf_gnu_hash
   (const char *);
 
 extern bfd_reloc_status_type bfd_elf_generic_reloc
@@ -2114,7 +2114,7 @@ extern bfd_boolean _bfd_elf_section_already_linked
 extern void bfd_elf_set_group_contents
   (bfd *, asection *, void *);
 extern unsigned int _bfd_elf_filter_global_symbols
-  (bfd *, struct bfd_link_info *, asymbol **, long);
+  (bfd *, struct bfd_link_info *, asymbol **, long long);
 extern asection *_bfd_elf_check_kept_section
   (asection *, struct bfd_link_info *);
 #define _bfd_elf_link_just_syms _bfd_generic_link_just_syms
@@ -2140,27 +2140,27 @@ extern bfd_boolean _bfd_elf_write_corefile_contents
   (bfd *);
 extern bfd_boolean _bfd_elf_set_section_contents
   (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
-extern long _bfd_elf_get_symtab_upper_bound
+extern long long _bfd_elf_get_symtab_upper_bound
   (bfd *);
-extern long _bfd_elf_canonicalize_symtab
+extern long long _bfd_elf_canonicalize_symtab
   (bfd *, asymbol **);
-extern long _bfd_elf_get_dynamic_symtab_upper_bound
+extern long long _bfd_elf_get_dynamic_symtab_upper_bound
   (bfd *);
-extern long _bfd_elf_canonicalize_dynamic_symtab
+extern long long _bfd_elf_canonicalize_dynamic_symtab
   (bfd *, asymbol **);
-extern long _bfd_elf_get_synthetic_symtab
-  (bfd *, long, asymbol **, long, asymbol **, asymbol **);
-extern long _bfd_elf_get_reloc_upper_bound
+extern long long _bfd_elf_get_synthetic_symtab
+  (bfd *, long long, asymbol **, long long, asymbol **, asymbol **);
+extern long long _bfd_elf_get_reloc_upper_bound
   (bfd *, sec_ptr);
-extern long _bfd_elf_canonicalize_reloc
+extern long long _bfd_elf_canonicalize_reloc
   (bfd *, sec_ptr, arelent **, asymbol **);
 extern asection * _bfd_elf_get_dynamic_reloc_section
   (bfd *, asection *, bfd_boolean);
 extern asection * _bfd_elf_make_dynamic_reloc_section
   (asection *, bfd *, unsigned int, bfd *, bfd_boolean);
-extern long _bfd_elf_get_dynamic_reloc_upper_bound
+extern long long _bfd_elf_get_dynamic_reloc_upper_bound
   (bfd *);
-extern long _bfd_elf_canonicalize_dynamic_reloc
+extern long long _bfd_elf_canonicalize_dynamic_reloc
   (bfd *, arelent **, asymbol **);
 extern asymbol *_bfd_elf_make_empty_symbol
   (bfd *);
@@ -2171,7 +2171,7 @@ extern bfd_boolean _bfd_elf_is_local_label_name
 extern alent *_bfd_elf_get_lineno
   (bfd *, asymbol *);
 extern bfd_boolean _bfd_elf_set_arch_mach
-  (bfd *, enum bfd_architecture, unsigned long);
+  (bfd *, enum bfd_architecture, unsigned long long);
 extern bfd_boolean _bfd_elf_find_nearest_line
   (bfd *, asymbol **, asection *, bfd_vma,
    const char **, const char **, unsigned int *, unsigned int *);
@@ -2208,7 +2208,7 @@ extern int _bfd_elf_symbol_from_bfd_symbol
   (bfd *, asymbol **);
 
 extern Elf_Internal_Sym *bfd_sym_from_r_symndx
-  (struct sym_cache *, bfd *, unsigned long);
+  (struct sym_cache *, bfd *, unsigned long long);
 extern asection *bfd_section_from_elf_index
   (bfd *, unsigned int);
 
@@ -2273,8 +2273,8 @@ extern bfd_boolean _bfd_elf_maybe_strip_eh_frame_hdr
 
 extern bfd_boolean _bfd_elf_hash_symbol (struct elf_link_hash_entry *);
 
-extern long _bfd_elf_link_lookup_local_dynindx
-  (struct bfd_link_info *, bfd *, long);
+extern long long _bfd_elf_link_lookup_local_dynindx
+  (struct bfd_link_info *, bfd *, long long);
 extern bfd_boolean _bfd_elf_compute_section_file_positions
   (bfd *, struct bfd_link_info *);
 extern file_ptr _bfd_elf_assign_file_position_for_section
@@ -2294,7 +2294,7 @@ extern bfd_boolean _bfd_elf_create_dynamic_sections
 extern bfd_boolean _bfd_elf_create_got_section
   (bfd *, struct bfd_link_info *);
 extern asection *_bfd_elf_section_for_symbol
-  (struct elf_reloc_cookie *, unsigned long, bfd_boolean);
+  (struct elf_reloc_cookie *, unsigned long long, bfd_boolean);
 extern struct elf_link_hash_entry *_bfd_elf_define_linkage_sym
   (bfd *, struct bfd_link_info *, asection *, const char *);
 extern void _bfd_elf_init_1_index_section
@@ -2367,7 +2367,7 @@ extern void bfd_elf32_swap_dyn_in
   (bfd *, const void *, Elf_Internal_Dyn *);
 extern void bfd_elf32_swap_dyn_out
   (bfd *, const Elf_Internal_Dyn *, void *);
-extern long bfd_elf32_slurp_symbol_table
+extern long long bfd_elf32_slurp_symbol_table
   (bfd *, asymbol **, bfd_boolean);
 extern bfd_boolean bfd_elf32_write_shdrs_and_ehdr
   (bfd *);
@@ -2413,7 +2413,7 @@ extern void bfd_elf64_swap_dyn_in
   (bfd *, const void *, Elf_Internal_Dyn *);
 extern void bfd_elf64_swap_dyn_out
   (bfd *, const Elf_Internal_Dyn *, void *);
-extern long bfd_elf64_slurp_symbol_table
+extern long long bfd_elf64_slurp_symbol_table
   (bfd *, asymbol **, bfd_boolean);
 extern bfd_boolean bfd_elf64_write_shdrs_and_ehdr
   (bfd *);
@@ -2447,7 +2447,7 @@ extern bfd_boolean bfd_elf_link_record_dynamic_symbol
   (struct bfd_link_info *, struct elf_link_hash_entry *);
 
 extern int bfd_elf_link_record_local_dynamic_symbol
-  (struct bfd_link_info *, bfd *, long);
+  (struct bfd_link_info *, bfd *, long long);
 
 extern bfd_boolean _bfd_elf_close_and_cleanup
   (bfd *);
@@ -2463,7 +2463,7 @@ extern asection *_bfd_elf_common_section
 
 extern bfd_vma _bfd_elf_default_got_elt_size
 (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, bfd *,
- unsigned long);
+ unsigned long long);
 
 extern bfd_reloc_status_type _bfd_elf_rel_vtable_reloc_fn
   (bfd *, arelent *, struct bfd_symbol *, void *,
@@ -2556,9 +2556,9 @@ extern char *elfcore_write_note
 extern char *elfcore_write_prpsinfo
   (bfd *, char *, int *, const char *, const char *);
 extern char *elfcore_write_prstatus
-  (bfd *, char *, int *, long, int, const void *);
+  (bfd *, char *, int *, long long, int, const void *);
 extern char * elfcore_write_pstatus
-  (bfd *, char *, int *, long, int, const void *);
+  (bfd *, char *, int *, long long, int, const void *);
 extern char *elfcore_write_prfpreg
   (bfd *, char *, int *, const void *, int);
 extern char *elfcore_write_prxfpreg
@@ -2602,7 +2602,7 @@ extern char *elfcore_write_aarch_hw_break
 extern char *elfcore_write_aarch_hw_watch
   (bfd *, char *, int *, const void *, int);
 extern char *elfcore_write_lwpstatus
-  (bfd *, char *, int *, long, int, const void *);
+  (bfd *, char *, int *, long long, int, const void *);
 extern char *elfcore_write_register_note
   (bfd *, char *, int *, const char *, const void *, int);
 
@@ -2622,7 +2622,7 @@ struct elf_internal_linux_prpsinfo
     char pr_sname;			/* Char for pr_state.  */
     char pr_zomb;			/* Zombie.  */
     char pr_nice;			/* Nice val.  */
-    unsigned long pr_flag;		/* Flags.  */
+    unsigned long long pr_flag;		/* Flags.  */
     unsigned int pr_uid;
     unsigned int pr_gid;
     int pr_pid, pr_ppid, pr_pgrp, pr_sid;
diff --git a/bfd/elf-eh-frame.c b/bfd/elf-eh-frame.c
index 12f06ef..db3a3dd 100644
--- a/bfd/elf-eh-frame.c
+++ b/bfd/elf-eh-frame.c
@@ -527,7 +527,7 @@ _bfd_elf_parse_eh_frame_entry (struct bfd_link_info *info,
 {
   struct elf_link_hash_table *htab;
   struct eh_frame_hdr_info *hdr_info;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   asection *text_sec;
 
   htab = elf_hash_table (info);
@@ -1202,7 +1202,7 @@ find_merged_cie (bfd *abfd, struct bfd_link_info *info, asection *sec,
 		 struct elf_reloc_cookie *cookie,
 		 struct eh_cie_fde *cie_inf)
 {
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   struct cie *cie, *new_cie;
   Elf_Internal_Rela *rel;
   void **loc;
diff --git a/bfd/elf-hppa.h b/bfd/elf-hppa.h
index 5eac129..a15c485 100644
--- a/bfd/elf-hppa.h
+++ b/bfd/elf-hppa.h
@@ -1194,19 +1194,19 @@ static int
 hppa_unwind_entry_compare (const void *a, const void *b)
 {
   const bfd_byte *ap, *bp;
-  unsigned long av, bv;
+  unsigned long long av, bv;
 
   ap = a;
-  av = (unsigned long) ap[0] << 24;
-  av |= (unsigned long) ap[1] << 16;
-  av |= (unsigned long) ap[2] << 8;
-  av |= (unsigned long) ap[3];
+  av = (unsigned long long) ap[0] << 24;
+  av |= (unsigned long long) ap[1] << 16;
+  av |= (unsigned long long) ap[2] << 8;
+  av |= (unsigned long long) ap[3];
 
   bp = b;
-  bv = (unsigned long) bp[0] << 24;
-  bv |= (unsigned long) bp[1] << 16;
-  bv |= (unsigned long) bp[2] << 8;
-  bv |= (unsigned long) bp[3];
+  bv = (unsigned long long) bp[0] << 24;
+  bv |= (unsigned long long) bp[1] << 16;
+  bv |= (unsigned long long) bp[2] << 8;
+  bv |= (unsigned long long) bp[3];
 
   return av < bv ? -1 : av > bv ? 1 : 0;
 }
diff --git a/bfd/elf-m10200.c b/bfd/elf-m10200.c
index cc71c1e..e154adb 100644
--- a/bfd/elf-m10200.c
+++ b/bfd/elf-m10200.c
@@ -248,7 +248,7 @@ mn10200_elf_final_link_relocate (reloc_howto_type *howto,
 				 asection *sym_sec ATTRIBUTE_UNUSED,
 				 int is_local ATTRIBUTE_UNUSED)
 {
-  unsigned long r_type = howto->type;
+  unsigned long long r_type = howto->type;
   bfd_byte *hit_data = contents + offset;
 
   switch (r_type)
@@ -265,7 +265,7 @@ mn10200_elf_final_link_relocate (reloc_howto_type *howto,
     case R_MN10200_16:
       value += addend;
 
-      if ((long) value > 0x7fff || (long) value < -0x8000)
+      if ((long long) value > 0x7fff || (long long) value < -0x8000)
 	return bfd_reloc_overflow;
 
       bfd_put_16 (input_bfd, value, hit_data);
@@ -274,7 +274,7 @@ mn10200_elf_final_link_relocate (reloc_howto_type *howto,
     case R_MN10200_8:
       value += addend;
 
-      if ((long) value > 0x7f || (long) value < -0x80)
+      if ((long long) value > 0x7f || (long long) value < -0x80)
 	return bfd_reloc_overflow;
 
       bfd_put_8 (input_bfd, value, hit_data);
@@ -283,7 +283,7 @@ mn10200_elf_final_link_relocate (reloc_howto_type *howto,
     case R_MN10200_24:
       value += addend;
 
-      if ((long) value > 0x7fffff || (long) value < -0x800000)
+      if ((long long) value > 0x7fffff || (long long) value < -0x800000)
 	return bfd_reloc_overflow;
 
       value &= 0xffffff;
@@ -297,7 +297,7 @@ mn10200_elf_final_link_relocate (reloc_howto_type *howto,
       value -= (offset + 1);
       value += addend;
 
-      if ((long) value > 0xff || (long) value < -0x100)
+      if ((long long) value > 0xff || (long long) value < -0x100)
 	return bfd_reloc_overflow;
 
       bfd_put_8 (input_bfd, value, hit_data);
@@ -309,7 +309,7 @@ mn10200_elf_final_link_relocate (reloc_howto_type *howto,
       value -= (offset + 2);
       value += addend;
 
-      if ((long) value > 0xffff || (long) value < -0x10000)
+      if ((long long) value > 0xffff || (long long) value < -0x10000)
 	return bfd_reloc_overflow;
 
       bfd_put_16 (input_bfd, value, hit_data);
@@ -321,7 +321,7 @@ mn10200_elf_final_link_relocate (reloc_howto_type *howto,
       value -= (offset + 3);
       value += addend;
 
-      if ((long) value > 0xffffff || (long) value < -0x1000000)
+      if ((long long) value > 0xffffff || (long long) value < -0x1000000)
 	return bfd_reloc_overflow;
 
       value &= 0xffffff;
@@ -358,7 +358,7 @@ mn10200_elf_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -652,7 +652,7 @@ mn10200_elf_relax_section (bfd *abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
@@ -695,7 +695,7 @@ mn10200_elf_relax_section (bfd *abfd,
 	  /* See if the value will fit in 16 bits, note the high value is
 	     0x7fff + 2 as the target will be two bytes closer if we are
 	     able to relax.  */
-	  if ((long) value < 0x8001 && (long) value > -0x8000)
+	  if ((long long) value < 0x8001 && (long long) value > -0x8000)
 	    {
 	      unsigned char code;
 
@@ -748,7 +748,7 @@ mn10200_elf_relax_section (bfd *abfd,
 	  /* See if the value will fit in 8 bits, note the high value is
 	     0x7f + 1 as the target will be one bytes closer if we are
 	     able to relax.  */
-	  if ((long) value < 0x80 && (long) value > -0x80)
+	  if ((long long) value < 0x80 && (long long) value > -0x80)
 	    {
 	      unsigned char code;
 
@@ -942,7 +942,7 @@ mn10200_elf_relax_section (bfd *abfd,
 	  /* See if the value will fit in 16 bits.
 	     We allow any 16bit match here.  We prune those we can't
 	     handle below.  */
-	  if ((long) value < 0x7fff && (long) value > -0x8000)
+	  if ((long long) value < 0x7fff && (long long) value > -0x8000)
 	    {
 	      unsigned char code;
 
diff --git a/bfd/elf-m10300.c b/bfd/elf-m10300.c
index f86346e..aa0d0f0 100644
--- a/bfd/elf-m10300.c
+++ b/bfd/elf-m10300.c
@@ -1079,7 +1079,7 @@ mn10300_elf_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       unsigned int r_type;
       int tls_type = GOT_NORMAL;
 
@@ -1413,7 +1413,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
 				 bfd_vma value,
 				 bfd_vma addend,
 				 struct elf_link_hash_entry * h,
-				 unsigned long symndx,
+				 unsigned long long symndx,
 				 struct bfd_link_info *info,
 				 asection *sym_sec ATTRIBUTE_UNUSED,
 				 int is_local ATTRIBUTE_UNUSED)
@@ -1422,7 +1422,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
   static asection *  sym_diff_section;
   static bfd_vma     sym_diff_value;
   bfd_boolean is_sym_diff_reloc;
-  unsigned long r_type = howto->type;
+  unsigned long long r_type = howto->type;
   bfd_byte * hit_data = contents + offset;
   bfd *      dynobj;
   asection * sgot;
@@ -1594,7 +1594,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
     case R_MN10300_24:
       value += addend;
 
-      if ((long) value > 0x7fffff || (long) value < -0x800000)
+      if ((long long) value > 0x7fffff || (long long) value < -0x800000)
 	return bfd_reloc_overflow;
 
       bfd_put_8 (input_bfd, value & 0xff, hit_data);
@@ -1605,7 +1605,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
     case R_MN10300_16:
       value += addend;
 
-      if ((long) value > 0x7fff || (long) value < -0x8000)
+      if ((long long) value > 0x7fff || (long long) value < -0x8000)
 	return bfd_reloc_overflow;
 
       bfd_put_16 (input_bfd, value, hit_data);
@@ -1614,7 +1614,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
     case R_MN10300_8:
       value += addend;
 
-      if ((long) value > 0x7f || (long) value < -0x80)
+      if ((long long) value > 0x7f || (long long) value < -0x80)
 	return bfd_reloc_overflow;
 
       bfd_put_8 (input_bfd, value, hit_data);
@@ -1626,7 +1626,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
       value -= offset;
       value += addend;
 
-      if ((long) value > 0x7f || (long) value < -0x80)
+      if ((long long) value > 0x7f || (long long) value < -0x80)
 	return bfd_reloc_overflow;
 
       bfd_put_8 (input_bfd, value, hit_data);
@@ -1638,7 +1638,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
       value -= offset;
       value += addend;
 
-      if ((long) value > 0x7fff || (long) value < -0x8000)
+      if ((long long) value > 0x7fff || (long long) value < -0x8000)
 	return bfd_reloc_overflow;
 
       bfd_put_16 (input_bfd, value, hit_data);
@@ -1682,7 +1682,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
       value -= offset;
       value += addend;
 
-      if ((long) value > 0x7fff || (long) value < -0x8000)
+      if ((long long) value > 0x7fff || (long long) value < -0x8000)
 	return bfd_reloc_overflow;
 
       bfd_put_16 (input_bfd, value, hit_data);
@@ -1705,7 +1705,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
       value -= htab->root.sgot->output_section->vma;
       value += addend;
 
-      if ((long) value > 0x7fffff || (long) value < -0x800000)
+      if ((long long) value > 0x7fffff || (long long) value < -0x800000)
 	return bfd_reloc_overflow;
 
       bfd_put_8 (input_bfd, value, hit_data);
@@ -1720,7 +1720,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
       value -= htab->root.sgot->output_section->vma;
       value += addend;
 
-      if ((long) value > 0x7fff || (long) value < -0x8000)
+      if ((long long) value > 0x7fff || (long long) value < -0x8000)
 	return bfd_reloc_overflow;
 
       bfd_put_16 (input_bfd, value, hit_data);
@@ -1769,7 +1769,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
       value -= offset;
       value += addend;
 
-      if ((long) value > 0x7fff || (long) value < -0x8000)
+      if ((long long) value > 0x7fff || (long long) value < -0x8000)
 	return bfd_reloc_overflow;
 
       bfd_put_16 (input_bfd, value, hit_data);
@@ -1939,7 +1939,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
 	}
       else if (r_type == R_MN10300_GOT24)
 	{
-	  if ((long) value > 0x7fffff || (long) value < -0x800000)
+	  if ((long long) value > 0x7fffff || (long long) value < -0x800000)
 	    return bfd_reloc_overflow;
 
 	  bfd_put_8 (input_bfd, value & 0xff, hit_data);
@@ -1949,7 +1949,7 @@ mn10300_elf_final_link_relocate (reloc_howto_type *howto,
 	}
       else if (r_type == R_MN10300_GOT16)
 	{
-	  if ((long) value > 0x7fff || (long) value < -0x8000)
+	  if ((long long) value > 0x7fff || (long long) value < -0x8000)
 	    return bfd_reloc_overflow;
 
 	  bfd_put_16 (input_bfd, value, hit_data);
@@ -1988,7 +1988,7 @@ mn10300_elf_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf32_mn10300_link_hash_entry *h;
@@ -2725,8 +2725,8 @@ mn10300_elf_relax_section (bfd *abfd,
 		  irelend = irel + section->reloc_count;
 		  for (; irel < irelend; irel++)
 		    {
-		      long r_type;
-		      unsigned long r_index;
+		      long long r_type;
+		      unsigned long long r_index;
 		      unsigned char code;
 
 		      r_type = ELF32_R_TYPE (irel->r_info);
@@ -3419,7 +3419,7 @@ mn10300_elf_relax_section (bfd *abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 
 	  /* An external symbol.  */
 	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
@@ -3656,7 +3656,7 @@ mn10300_elf_relax_section (bfd *abfd,
 	  /* See if the value will fit in 8 bits, note the high value is
 	     0x7f + 1 as the target will be one bytes closer if we are
 	     able to relax.  */
-	  if ((long) value < 0x80 && (long) value > -0x80)
+	  if ((long long) value < 0x80 && (long long) value > -0x80)
 	    {
 	      unsigned char code;
 
@@ -3836,7 +3836,7 @@ mn10300_elf_relax_section (bfd *abfd,
 	  value += irel->r_addend;
 
 	  /* See if the value will fit in 8 bits.  */
-	  if ((long) value < 0x7f && (long) value > -0x80)
+	  if ((long long) value < 0x7f && (long long) value > -0x80)
 	    {
 	      unsigned char code;
 
@@ -3935,7 +3935,7 @@ mn10300_elf_relax_section (bfd *abfd,
 	  /* See if the value will fit in 24 bits.
 	     We allow any 16bit match here.  We prune those we can't
 	     handle below.  */
-	  if ((long) value < 0x7fffff && (long) value > -0x800000)
+	  if ((long long) value < 0x7fffff && (long long) value > -0x800000)
 	    {
 	      unsigned char code;
 
@@ -4006,7 +4006,7 @@ mn10300_elf_relax_section (bfd *abfd,
 	  /* See if the value will fit in 16 bits.
 	     We allow any 16bit match here.  We prune those we can't
 	     handle below.  */
-	  if ((long) value < 0x7fff && (long) value > -0x8000)
+	  if ((long long) value < 0x7fff && (long long) value > -0x8000)
 	    {
 	      unsigned char code;
 
@@ -4151,7 +4151,7 @@ mn10300_elf_relax_section (bfd *abfd,
 		  case 0x93:
 		    /* sp-based offsets are zero-extended.  */
 		    if (code >= 0x90 && code <= 0x93
-			&& (long) value < 0)
+			&& (long long) value < 0)
 		      continue;
 
 		    /* Note that we've changed the relocation contents, etc.  */
@@ -4208,7 +4208,7 @@ mn10300_elf_relax_section (bfd *abfd,
 
 		    /* "mov imm16, an" zero-extends the immediate.  */
 		    if ((code & 0xfc) == 0xdc
-			&& (long) value < 0)
+			&& (long long) value < 0)
 		      continue;
 
 		    /* Note that we've changed the relocation contents, etc.  */
@@ -4289,12 +4289,12 @@ mn10300_elf_relax_section (bfd *abfd,
 		  case 0xe3:
 		    /* cmp imm16, an zero-extends the immediate.  */
 		    if (code == 0xdc
-			&& (long) value < 0)
+			&& (long long) value < 0)
 		      continue;
 
 		    /* So do sp-based offsets.  */
 		    if (code >= 0xb0 && code <= 0xb3
-			&& (long) value < 0)
+			&& (long long) value < 0)
 		      continue;
 
 		    /* Note that we've changed the relocation contents, etc.  */
@@ -4648,7 +4648,7 @@ elf32_mn10300_link_hash_table_create (bfd *abfd)
   return & ret->root.root;
 }
 
-static unsigned long
+static unsigned long long
 elf_mn10300_mach (flagword flags)
 {
   switch (flags & EF_MN10300_MACH)
@@ -4673,7 +4673,7 @@ static void
 _bfd_mn10300_elf_final_write_processing (bfd *abfd,
 					 bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
 
   switch (bfd_get_mach (abfd))
     {
diff --git a/bfd/elf.c b/bfd/elf.c
index 0f75375..460b676 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -194,12 +194,12 @@ _bfd_elf_swap_versym_out (bfd *abfd,
 /* Standard ELF hash function.  Do not change this function; you will
    cause invalid hash tables to be generated.  */
 
-unsigned long
+unsigned long long
 bfd_elf_hash (const char *namearg)
 {
   const unsigned char *name = (const unsigned char *) namearg;
-  unsigned long h = 0;
-  unsigned long g;
+  unsigned long long h = 0;
+  unsigned long long g;
   int ch;
 
   while ((ch = *name++) != '\0')
@@ -219,11 +219,11 @@ bfd_elf_hash (const char *namearg)
 /* DT_GNU_HASH hash function.  Do not change this function; you will
    cause invalid hash tables to be generated.  */
 
-unsigned long
+unsigned long long
 bfd_elf_gnu_hash (const char *namearg)
 {
   const unsigned char *name = (const unsigned char *) namearg;
-  unsigned long h = 5381;
+  unsigned long long h = 5381;
   unsigned char ch;
 
   while ((ch = *name++) != '\0')
@@ -497,7 +497,7 @@ bfd_elf_get_elf_syms (bfd *ibfd,
 	/* xgettext:c-format */
 	_bfd_error_handler (_("%pB symbol number %lu references"
 			      " nonexistent SHT_SYMTAB_SHNDX section"),
-			    ibfd, (unsigned long) symoffset);
+			    ibfd, (unsigned long long) symoffset);
 	if (alloc_intsym != NULL)
 	  free (alloc_intsym);
 	intsym_buf = NULL;
@@ -1655,7 +1655,7 @@ _bfd_elf_print_private_bfd_data (bfd *abfd, void *farg)
   if (s != NULL)
     {
       unsigned int elfsec;
-      unsigned long shlink;
+      unsigned long long shlink;
       bfd_byte *extdyn, *extdynend;
       size_t extdynsize;
       void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
@@ -2559,7 +2559,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 Elf_Internal_Sym *
 bfd_sym_from_r_symndx (struct sym_cache *cache,
 		       bfd *abfd,
-		       unsigned long r_symndx)
+		       unsigned long long r_symndx)
 {
   unsigned int ent = r_symndx % LOCAL_SYM_CACHE_SIZE;
 
@@ -3464,7 +3464,7 @@ bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
 
   if (elf_section_data (sec)->this_hdr.sh_info == 0)
     {
-      unsigned long symindx = 0;
+      unsigned long long symindx = 0;
 
       /* elf_group_id will have been set up by objcopy and the
 	 generic linker.  */
@@ -3487,8 +3487,8 @@ bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
 	 set until all local symbols are output.  */
       asection *igroup;
       struct bfd_elf_section_data *sec_data;
-      unsigned long symndx;
-      unsigned long extsymoff;
+      unsigned long long symndx;
+      unsigned long long extsymoff;
       struct elf_link_hash_entry *h;
 
       /* The point of this little dance to the first SHF_GROUP section
@@ -4002,9 +4002,9 @@ sym_is_global (bfd *abfd, asymbol *sym)
 
 unsigned int
 _bfd_elf_filter_global_symbols (bfd *abfd, struct bfd_link_info *info,
-				asymbol **syms, long symcount)
+				asymbol **syms, long long symcount)
 {
-  long src_count, dst_count = 0;
+  long long src_count, dst_count = 0;
 
   for (src_count = 0; src_count < symcount; src_count++)
     {
@@ -4993,7 +4993,7 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
 		  <= PT_GNU_MBIND_NUM))
 	    {
 	      /* Mandated PF_R.  */
-	      unsigned long p_flags = PF_R;
+	      unsigned long long p_flags = PF_R;
 	      if ((s->flags & SEC_READONLY) == 0)
 		p_flags |= PF_W;
 	      if ((s->flags & SEC_CODE) != 0)
@@ -6534,7 +6534,7 @@ _bfd_elf_symbol_from_bfd_symbol (bfd *abfd, asymbol **asym_ptr_ptr)
   {
     fprintf (stderr,
 	     "elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8x\n",
-	     (long) asym_ptr, asym_ptr->name, idx, flags);
+	     (long long) asym_ptr, asym_ptr->name, idx, flags);
     fflush (stderr);
   }
 #endif
@@ -7761,8 +7761,8 @@ swap_out_syms (bfd *abfd,
   struct elf_sym_strtab *symstrtab;
   bfd_byte *outbound_syms;
   bfd_byte *outbound_shndx;
-  unsigned long outbound_syms_index;
-  unsigned long outbound_shndx_index;
+  unsigned long long outbound_syms_index;
+  unsigned long long outbound_shndx_index;
   int idx;
   unsigned int num_locals;
   bfd_size_type amt;
@@ -7868,16 +7868,16 @@ error_return:
 	  && (flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
 	{
 	  /* Local section symbols have no name.  */
-	  sym.st_name = (unsigned long) -1;
+	  sym.st_name = (unsigned long long) -1;
 	}
       else
 	{
 	  /* Call _bfd_elf_strtab_offset after _bfd_elf_strtab_finalize
 	     to get the final offset for st_name.  */
 	  sym.st_name
-	    = (unsigned long) _bfd_elf_strtab_add (stt, syms[idx]->name,
+	    = (unsigned long long) _bfd_elf_strtab_add (stt, syms[idx]->name,
 						   FALSE);
-	  if (sym.st_name == (unsigned long) -1)
+	  if (sym.st_name == (unsigned long long) -1)
 	    goto error_return;
 	}
 
@@ -8077,7 +8077,7 @@ error_return:
   for (idx = 0; idx <= symcount; idx++)
     {
       struct elf_sym_strtab *elfsym = &symstrtab[idx];
-      if (elfsym->sym.st_name == (unsigned long) -1)
+      if (elfsym->sym.st_name == (unsigned long long) -1)
 	elfsym->sym.st_name = 0;
       else
 	elfsym->sym.st_name = _bfd_elf_strtab_offset (stt,
@@ -8111,11 +8111,11 @@ error_return:
    the vector allocated based on this size.  However, the ELF symbol table
    always has a dummy entry as symbol #0, so it ends up even.  */
 
-long
+long long
 _bfd_elf_get_symtab_upper_bound (bfd *abfd)
 {
-  long symcount;
-  long symtab_size;
+  long long symcount;
+  long long symtab_size;
   Elf_Internal_Shdr *hdr = &elf_tdata (abfd)->symtab_hdr;
 
   symcount = hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;
@@ -8126,11 +8126,11 @@ _bfd_elf_get_symtab_upper_bound (bfd *abfd)
   return symtab_size;
 }
 
-long
+long long
 _bfd_elf_get_dynamic_symtab_upper_bound (bfd *abfd)
 {
-  long symcount;
-  long symtab_size;
+  long long symcount;
+  long long symtab_size;
   Elf_Internal_Shdr *hdr = &elf_tdata (abfd)->dynsymtab_hdr;
 
   if (elf_dynsymtab (abfd) == 0)
@@ -8147,7 +8147,7 @@ _bfd_elf_get_dynamic_symtab_upper_bound (bfd *abfd)
   return symtab_size;
 }
 
-long
+long long
 _bfd_elf_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
 				sec_ptr asect)
 {
@@ -8156,7 +8156,7 @@ _bfd_elf_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
 
 /* Canonicalize the relocs.  */
 
-long
+long long
 _bfd_elf_canonicalize_reloc (bfd *abfd,
 			     sec_ptr section,
 			     arelent **relptr,
@@ -8178,23 +8178,23 @@ _bfd_elf_canonicalize_reloc (bfd *abfd,
   return section->reloc_count;
 }
 
-long
+long long
 _bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
 {
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
-  long symcount = bed->s->slurp_symbol_table (abfd, allocation, FALSE);
+  long long symcount = bed->s->slurp_symbol_table (abfd, allocation, FALSE);
 
   if (symcount >= 0)
     bfd_get_symcount (abfd) = symcount;
   return symcount;
 }
 
-long
+long long
 _bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
 				      asymbol **allocation)
 {
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
-  long symcount = bed->s->slurp_symbol_table (abfd, allocation, TRUE);
+  long long symcount = bed->s->slurp_symbol_table (abfd, allocation, TRUE);
 
   if (symcount >= 0)
     bfd_get_dynamic_symcount (abfd) = symcount;
@@ -8206,10 +8206,10 @@ _bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
    or SHT_RELA, and uses the dynamic symbol table, is considered to be a
    dynamic reloc section.  */
 
-long
+long long
 _bfd_elf_get_dynamic_reloc_upper_bound (bfd *abfd)
 {
-  long ret;
+  long long ret;
   asection *s;
 
   if (elf_dynsymtab (abfd) == 0)
@@ -8237,14 +8237,14 @@ _bfd_elf_get_dynamic_reloc_upper_bound (bfd *abfd)
    installed in the BFD, and has type SHT_REL or SHT_RELA, and uses the
    dynamic symbol table, is considered to be a dynamic reloc section.  */
 
-long
+long long
 _bfd_elf_canonicalize_dynamic_reloc (bfd *abfd,
 				     arelent **storage,
 				     asymbol **syms)
 {
   bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
   asection *s;
-  long ret;
+  long long ret;
 
   if (elf_dynsymtab (abfd) == 0)
     {
@@ -8261,7 +8261,7 @@ _bfd_elf_canonicalize_dynamic_reloc (bfd *abfd,
 	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
 	{
 	  arelent *p;
-	  long count, i;
+	  long long count, i;
 
 	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
 	    return -1;
@@ -8722,7 +8722,7 @@ _bfd_elf_get_lineno (bfd *abfd ATTRIBUTE_UNUSED,
 bfd_boolean
 _bfd_elf_set_arch_mach (bfd *abfd,
 			enum bfd_architecture arch,
-			unsigned long machine)
+			unsigned long long machine)
 {
   /* If this isn't the right architecture for this backend, and this
      isn't the generic backend, fail.  */
@@ -9596,7 +9596,7 @@ elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
     case 2 /* NOTE_INFO_THREAD */:
       /* Make a ".reg/999" section.  */
       /* thread_info.tid */
-      sprintf (buf, ".reg/%ld", (long) bfd_get_32 (abfd, note->descdata + 8));
+      sprintf (buf, ".reg/%ld", (long long) bfd_get_32 (abfd, note->descdata + 8));
 
       len = strlen (buf) + 1;
       name = (char *) bfd_alloc (abfd, len);
@@ -9627,7 +9627,7 @@ elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
       /* Make a ".module/xxxxxxxx" section.  */
       /* module_info.base_address */
       base_addr = bfd_get_32 (abfd, note->descdata + 4);
-      sprintf (buf, ".module/%08lx", (unsigned long) base_addr);
+      sprintf (buf, ".module/%08lx", (unsigned long long) base_addr);
 
       len = strlen (buf) + 1;
       name = (char *) bfd_alloc (abfd, len);
@@ -10305,7 +10305,7 @@ elfcore_grok_openbsd_note (bfd *abfd, Elf_Internal_Note *note)
 }
 
 static bfd_boolean
-elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, long *tid)
+elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, long long *tid)
 {
   void *ddata = note->descdata;
   char buf[100];
@@ -10361,7 +10361,7 @@ elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, long *tid)
 static bfd_boolean
 elfcore_grok_nto_regs (bfd *abfd,
 		       Elf_Internal_Note *note,
-		       long tid,
+		       long long tid,
 		       char *base)
 {
   char buf[100];
@@ -10402,7 +10402,7 @@ elfcore_grok_nto_note (bfd *abfd, Elf_Internal_Note *note)
   /* Every GREG section has a STATUS section before it.  Store the
      tid from the previous call to pass down to the next gregs
      function.  */
-  static long tid = 1;
+  static long long tid = 1;
 
   switch (note->type)
     {
@@ -10641,7 +10641,7 @@ char *
 elfcore_write_prstatus (bfd *abfd,
 			char *buf,
 			int *bufsiz,
-			long pid,
+			long long pid,
 			int cursig,
 			const void *gregs)
 {
@@ -10693,7 +10693,7 @@ char *
 elfcore_write_lwpstatus (bfd *abfd,
 			 char *buf,
 			 int *bufsiz,
-			 long pid,
+			 long long pid,
 			 int cursig,
 			 const void *gregs)
 {
@@ -10724,7 +10724,7 @@ char *
 elfcore_write_pstatus (bfd *abfd,
 		       char *buf,
 		       int *bufsiz,
-		       long pid,
+		       long long pid,
 		       int cursig ATTRIBUTE_UNUSED,
 		       const void *gregs ATTRIBUTE_UNUSED)
 {
@@ -11219,7 +11219,7 @@ elf_read_notes (bfd *abfd, file_ptr offset, bfd_size_type size,
    copy of ABFD's program header table entries.  Return -1 if an error
    occurs; bfd_get_error will return an appropriate code.  */
 
-long
+long long
 bfd_get_elf_phdr_upper_bound (bfd *abfd)
 {
   if (abfd->xvec->flavour != bfd_target_elf_flavour)
@@ -11381,11 +11381,11 @@ bfd_elf_bfd_from_remote_memory
     (templ, ehdr_vma, size, loadbasep, target_read_memory);
 }
 
-long
+long long
 _bfd_elf_get_synthetic_symtab (bfd *abfd,
-			       long symcount ATTRIBUTE_UNUSED,
+			       long long symcount ATTRIBUTE_UNUSED,
 			       asymbol **syms ATTRIBUTE_UNUSED,
-			       long dynsymcount,
+			       long long dynsymcount,
 			       asymbol **dynsyms,
 			       asymbol **ret)
 {
@@ -11395,7 +11395,7 @@ _bfd_elf_get_synthetic_symtab (bfd *abfd,
   const char *relplt_name;
   bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
   arelent *p;
-  long count, i, n;
+  long long count, i, n;
   size_t size;
   Elf_Internal_Shdr *hdr;
   char *names;
diff --git a/bfd/elf32-arc.c b/bfd/elf32-arc.c
index a48ef0c..e7c1e17 100644
--- a/bfd/elf32-arc.c
+++ b/bfd/elf32-arc.c
@@ -65,7 +65,7 @@ name_for_global_symbol (struct elf_link_hash_entry *h)
 	_rel.r_addend = ADDEND;						\
 	_rel.r_offset = (_htab->s##SECTION)->output_section->vma	\
 	  + (_htab->s##SECTION)->output_offset + OFFSET;		\
-	BFD_ASSERT ((long) SYM_IDX != -1);				\
+	BFD_ASSERT ((long long) SYM_IDX != -1);				\
 	_rel.r_info = ELF32_R_INFO (SYM_IDX, TYPE);			\
 	bfd_elf32_swap_reloca_out (BFD, &_rel, _loc);			\
       }									\
@@ -439,7 +439,7 @@ arc_elf_print_private_bfd_data (bfd *abfd, void * ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx:"), (unsigned long) flags);
+  fprintf (file, _("private flags = 0x%lx:"), (unsigned long long) flags);
 
   switch (flags & EF_ARC_MACH_MSK)
     {
@@ -965,7 +965,7 @@ arc_elf_object_p (bfd * abfd)
      garbage---or misleading values---into the call to
      bfd_default_set_arch_mach ().  */
   unsigned int	  mach = bfd_mach_arc_arc700;
-  unsigned long   arch = elf_elfheader (abfd)->e_flags & EF_ARC_MACH_MSK;
+  unsigned long long   arch = elf_elfheader (abfd)->e_flags & EF_ARC_MACH_MSK;
   unsigned	  e_machine = elf_elfheader (abfd)->e_machine;
 
   if (e_machine == EM_ARC_COMPACT || e_machine == EM_ARC_COMPACT2)
@@ -1016,7 +1016,7 @@ static void
 arc_elf_final_write_processing (bfd * abfd,
 				bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long emf;
+  unsigned long long emf;
   int osver = bfd_elf_get_obj_attr_int (abfd, OBJ_ATTR_PROC,
 					Tag_ARC_ABI_osver);
   flagword e_flags = elf_elfheader (abfd)->e_flags & ~EF_ARC_OSABI_MSK;
@@ -1424,7 +1424,7 @@ elf_arc_relocate_section (bfd *			  output_bfd,
     {
       enum elf_arc_reloc_type	    r_type;
       reloc_howto_type *	    howto;
-      unsigned long		    r_symndx;
+      unsigned long long		    r_symndx;
       struct elf_link_hash_entry *  h;
       Elf_Internal_Sym *	    sym;
       asection *		    sec;
@@ -1939,7 +1939,7 @@ elf_arc_check_relocs (bfd *			 abfd,
     {
       enum elf_arc_reloc_type r_type;
       reloc_howto_type *howto;
-      unsigned long   r_symndx;
+      unsigned long long   r_symndx;
       struct elf_link_hash_entry *h;
 
       r_type = ELF32_R_TYPE (rel->r_info);
@@ -2177,12 +2177,12 @@ relocate_plt_for_symbol (bfd *output_bfd,
 
   ARC_DEBUG ("arc_info: PLT_OFFSET = %#lx, PLT_ENTRY_VMA = %#lx, \
 GOT_ENTRY_OFFSET = %#lx, GOT_ENTRY_VMA = %#lx, for symbol %s\n",
-	     (long) h->plt.offset,
-	     (long) (htab->splt->output_section->vma
+	     (long long) h->plt.offset,
+	     (long long) (htab->splt->output_section->vma
 		     + htab->splt->output_offset
 		     + h->plt.offset),
-	     (long) got_offset,
-	     (long) (htab->sgotplt->output_section->vma
+	     (long long) got_offset,
+	     (long long) (htab->sgotplt->output_section->vma
 		     + htab->sgotplt->output_offset
 		     + got_offset),
 	     h->root.root.string);
diff --git a/bfd/elf32-arm.c b/bfd/elf32-arm.c
index b21901c..02b5b10 100644
--- a/bfd/elf32-arm.c
+++ b/bfd/elf32-arm.c
@@ -2194,13 +2194,13 @@ elf32_arm_nabi_write_core_note (bfd *abfd, char *buf, int *bufsiz,
       {
 	char data[148];
 	va_list ap;
-	long pid;
+	long long pid;
 	int cursig;
 	const void *greg;
 
 	va_start (ap, note_type);
 	memset (data, 0, sizeof (data));
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	bfd_put_32 (abfd, pid, data + 24);
 	cursig = va_arg (ap, int);
 	bfd_put_16 (abfd, cursig, data + 12);
@@ -2223,7 +2223,7 @@ elf32_arm_nabi_write_core_note (bfd *abfd, char *buf, int *bufsiz,
 #define elf_backend_grok_psinfo		elf32_arm_nabi_grok_psinfo
 #define elf_backend_write_core_note	elf32_arm_nabi_write_core_note
 
-typedef unsigned long int insn32;
+typedef unsigned long long int insn32;
 typedef unsigned short int insn16;
 
 /* In lieu of proper flags, assume all EABIv4 or later objects are
@@ -2263,14 +2263,14 @@ typedef unsigned short int insn16;
 /* FDPIC default stack size.  */
 #define DEFAULT_STACK_SIZE 0x8000
 
-static const unsigned long tls_trampoline [] =
+static const unsigned long long tls_trampoline [] =
 {
   0xe08e0000,		/* add r0, lr, r0 */
   0xe5901004,		/* ldr r1, [r0,#4] */
   0xe12fff11,		/* bx  r1 */
 };
 
-static const unsigned long dl_tlsdesc_lazy_trampoline [] =
+static const unsigned long long dl_tlsdesc_lazy_trampoline [] =
 {
   0xe52d2004, /*	push    {r2}			*/
   0xe59f200c, /*      ldr     r2, [pc, #3f - . - 8]	*/
@@ -2858,7 +2858,7 @@ struct elf32_arm_stub_hash_entry
 
   /* The instruction which caused this stub to be generated (only valid for
      Cortex-A8 erratum workaround stubs at present).  */
-  unsigned long orig_insn;
+  unsigned long long orig_insn;
 
   /* The stub type.  */
   enum elf32_arm_stub_type stub_type;
@@ -3024,7 +3024,7 @@ struct a8_erratum_fix
   asection *section;
   bfd_vma offset;
   bfd_vma target_offset;
-  unsigned long orig_insn;
+  unsigned long long orig_insn;
   char *stub_name;
   enum elf32_arm_stub_type stub_type;
   enum arm_st_branch_type branch_type;
@@ -3593,7 +3593,7 @@ elf32_arm_allocate_local_sym_info (bfd *abfd)
    Return null if an allocation fails.  */
 
 static struct arm_local_iplt_info *
-elf32_arm_create_local_iplt (bfd *abfd, unsigned long r_symndx)
+elf32_arm_create_local_iplt (bfd *abfd, unsigned long long r_symndx)
 {
   struct arm_local_iplt_info **ptr;
 
@@ -3618,7 +3618,7 @@ elf32_arm_create_local_iplt (bfd *abfd, unsigned long r_symndx)
 static bfd_boolean
 elf32_arm_get_plt_info (bfd *abfd, struct elf32_arm_link_hash_table *globals,
 			struct elf32_arm_link_hash_entry *h,
-			unsigned long r_symndx, union gotplt_union **root_plt,
+			unsigned long long r_symndx, union gotplt_union **root_plt,
 			struct arm_plt_info **arm_plt)
 {
   struct arm_local_iplt_info *local_iplt;
@@ -3667,7 +3667,7 @@ elf32_arm_plt_needs_thumb_stub_p (struct bfd_link_info *info,
    ABFD's symbol table.  Return null if an error occurs.  */
 
 static struct elf_dyn_relocs **
-elf32_arm_get_local_dynreloc_list (bfd *abfd, unsigned long r_symndx,
+elf32_arm_get_local_dynreloc_list (bfd *abfd, unsigned long long r_symndx,
 				   Elf_Internal_Sym *isym)
 {
   if (ELF32_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
@@ -6142,10 +6142,10 @@ set_cmse_veneer_addr_from_implib (struct bfd_link_info *info,
 				  struct elf32_arm_link_hash_table *htab,
 				  int *cmse_stub_created)
 {
-  long symsize;
+  long long symsize;
   char *sym_name;
   flagword flags;
-  long i, symcount;
+  long long i, symcount;
   bfd *in_implib_bfd;
   asection *stub_out_sec;
   bfd_boolean ret = TRUE;
@@ -7825,8 +7825,8 @@ bfd_elf32_arm_process_before_allocation (bfd *abfd,
       irelend = internal_relocs + sec->reloc_count;
       for (irel = internal_relocs; irel < irelend; irel++)
 	{
-	  long r_type;
-	  unsigned long r_index;
+	  long long r_type;
+	  unsigned long long r_index;
 
 	  struct elf_link_hash_entry *h;
 
@@ -9021,7 +9021,7 @@ bfd_elf32_arm_set_target_params (struct bfd *output_bfd,
 /* Replace the target offset of a Thumb bl or b.w instruction.  */
 
 static void
-insert_thumb_branch (bfd *abfd, long int offset, bfd_byte *insn)
+insert_thumb_branch (bfd *abfd, long long int offset, bfd_byte *insn)
 {
   bfd_vma upper;
   bfd_vma lower;
@@ -9060,7 +9060,7 @@ elf32_thumb_to_arm_stub (struct bfd_link_info * info,
 {
   asection * s = 0;
   bfd_vma my_offset;
-  long int ret_offset;
+  long long int ret_offset;
   struct elf_link_hash_entry * myh;
   struct elf32_arm_link_hash_table * globals;
 
@@ -9157,7 +9157,7 @@ elf32_arm_create_thumb_stub (struct bfd_link_info * info,
 			     char **		    error_message)
 {
   bfd_vma my_offset;
-  long int ret_offset;
+  long long int ret_offset;
   struct elf_link_hash_entry * myh;
   struct elf32_arm_link_hash_table * globals;
 
@@ -9254,10 +9254,10 @@ elf32_arm_to_thumb_stub (struct bfd_link_info * info,
 			 bfd_vma		val,
 			 char **error_message)
 {
-  unsigned long int tmp;
+  unsigned long long int tmp;
   bfd_vma my_offset;
   asection * s;
-  long int ret_offset;
+  long long int ret_offset;
   struct elf_link_hash_entry * myh;
   struct elf32_arm_link_hash_table * globals;
 
@@ -10041,9 +10041,9 @@ elf32_arm_abs12_reloc (bfd *abfd, void *data, bfd_vma value)
 static bfd_reloc_status_type
 elf32_arm_tls_relax (struct elf32_arm_link_hash_table *globals,
 		     bfd *input_bfd, asection *input_sec, bfd_byte *contents,
-		     Elf_Internal_Rela *rel, unsigned long is_local)
+		     Elf_Internal_Rela *rel, unsigned long long is_local)
 {
-  unsigned long insn;
+  unsigned long long insn;
 
   switch (ELF32_R_TYPE (rel->r_info))
     {
@@ -10265,8 +10265,8 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 			       bfd_boolean *		    unresolved_reloc_p,
 			       char **			    error_message)
 {
-  unsigned long			r_type = howto->type;
-  unsigned long			r_symndx;
+  unsigned long long			r_type = howto->type;
+  unsigned long long			r_symndx;
   bfd_byte *			hit_data = contents + rel->r_offset;
   bfd_vma *			local_got_offsets;
   bfd_vma *			local_tlsdesc_gotents;
@@ -10839,7 +10839,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
       /* There is no way to tell whether the user intended to use a signed or
 	 unsigned addend.  When checking for overflow we accept either,
 	 as specified by the AAELF.  */
-      if ((long) value > 0xff || (long) value < -0x80)
+      if ((long long) value > 0xff || (long long) value < -0x80)
 	return bfd_reloc_overflow;
 
       bfd_put_8 (input_bfd, value, hit_data);
@@ -10852,7 +10852,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
       value += addend;
 
       /* See comment for R_ARM_ABS8.  */
-      if ((long) value > 0xffff || (long) value < -0x8000)
+      if ((long long) value > 0xffff || (long long) value < -0x8000)
 	return bfd_reloc_overflow;
 
       bfd_put_16 (input_bfd, value, hit_data);
@@ -10870,7 +10870,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
       value += addend;
 
       /* ??? Isn't value unsigned?  */
-      if ((long) value > 0x1f || (long) value < -0x10)
+      if ((long long) value > 0x1f || (long long) value < -0x10)
 	return bfd_reloc_overflow;
 
       /* ??? Value needs to be properly shifted into place first.  */
@@ -11885,7 +11885,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 
 	    if (ELF32_R_TYPE(rel->r_info) == R_ARM_TLS_CALL)
 	      {
-		unsigned long inst;
+		unsigned long long inst;
 
 		offset -= (input_section->output_section->vma
 			   + input_section->output_offset
@@ -11936,7 +11936,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *	    howto,
 	   we refer to.  */
 	else if ((r_type == R_ARM_TLS_GOTDESC) && (tls_type & GOT_TLS_GDESC))
 	  {
-	    unsigned long data, insn;
+	    unsigned long long data, insn;
 	    unsigned thumb;
 
 	    data = bfd_get_32 (input_bfd, hit_data);
@@ -12974,7 +12974,7 @@ elf32_arm_relocate_section (bfd *		   output_bfd,
     {
       int			   r_type;
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
@@ -14853,7 +14853,7 @@ static bfd_boolean
 elf32_arm_print_private_bfd_data (bfd *abfd, void * ptr)
 {
   FILE * file = (FILE *) ptr;
-  unsigned long flags;
+  unsigned long long flags;
 
   BFD_ASSERT (abfd != NULL && ptr != NULL);
 
@@ -15050,7 +15050,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
   bfd_boolean call_reloc_p;
   bfd_boolean may_become_dynamic_p;
   bfd_boolean may_need_local_target_p;
-  unsigned long nsyms;
+  unsigned long long nsyms;
 
   if (bfd_link_relocatable (info))
     return TRUE;
@@ -17157,13 +17157,13 @@ elf32_arm_finish_dynamic_symbol (bfd * output_bfd,
 static void
 arm_put_trampoline (struct elf32_arm_link_hash_table *htab, bfd *output_bfd,
 		    void *contents,
-		    const unsigned long *template, unsigned count)
+		    const unsigned long long *template, unsigned count)
 {
   unsigned ix;
 
   for (ix = 0; ix != count; ix++)
     {
-      unsigned long insn = template[ix];
+      unsigned long long insn = template[ix];
 
       /* Emit mov pc,rx if bx is not permitted.  */
       if (htab->fix_v4bx == 1 && (insn & 0x0ffffff0) == 0x012fff10)
@@ -18284,11 +18284,11 @@ elf32_arm_output_arch_local_syms (bfd *output_bfd,
 static unsigned int
 elf32_arm_filter_cmse_symbols (bfd *abfd ATTRIBUTE_UNUSED,
 			       struct bfd_link_info *info,
-			       asymbol **syms, long symcount)
+			       asymbol **syms, long long symcount)
 {
   size_t maxnamelen;
   char *cmse_name;
-  long src_count, dst_count = 0;
+  long long src_count, dst_count = 0;
   struct elf32_arm_link_hash_table *htab;
 
   htab = elf32_arm_hash_table (info);
@@ -18353,7 +18353,7 @@ elf32_arm_filter_cmse_symbols (bfd *abfd ATTRIBUTE_UNUSED,
 static unsigned int
 elf32_arm_filter_implib_symbols (bfd *abfd ATTRIBUTE_UNUSED,
 				 struct bfd_link_info *info,
-				 asymbol **syms, long symcount)
+				 asymbol **syms, long long symcount)
 {
   struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (info);
 
@@ -18412,8 +18412,8 @@ elf32_arm_compare_mapping (const void * a, const void * b)
 
 /* Add OFFSET to lower 31 bits of ADDR, leaving other bits unmodified.  */
 
-static unsigned long
-offset_prel31 (unsigned long addr, bfd_vma offset)
+static unsigned long long
+offset_prel31 (unsigned long long addr, bfd_vma offset)
 {
   return (addr & ~0x7ffffffful) | ((addr + offset) & 0x7ffffffful);
 }
@@ -18424,8 +18424,8 @@ offset_prel31 (unsigned long addr, bfd_vma offset)
 static void
 copy_exidx_entry (bfd *output_bfd, bfd_byte *to, bfd_byte *from, bfd_vma offset)
 {
-  unsigned long first_word = bfd_get_32 (output_bfd, from);
-  unsigned long second_word = bfd_get_32 (output_bfd, from + 4);
+  unsigned long long first_word = bfd_get_32 (output_bfd, from);
+  unsigned long long second_word = bfd_get_32 (output_bfd, from + 4);
 
   /* High bit of first word is supposed to be zero.  */
   if ((first_word & 0x80000000ul) == 0)
@@ -18459,7 +18459,7 @@ make_branch_to_a8_stub (struct bfd_hash_entry *gen_entry,
   struct elf32_arm_stub_hash_entry *stub_entry;
   struct a8_branch_to_stub_data *data;
   bfd_byte *contents;
-  unsigned long branch_insn;
+  unsigned long long branch_insn;
   bfd_vma veneered_insn_loc, veneer_entry_loc;
   bfd_signed_vma branch_offset;
   bfd *abfd;
@@ -18584,10 +18584,10 @@ create_instruction_branch_absolute (int branch_offset)
 
   bfd_vma patched_inst = 0xf0009000
     | s << 26 /* S.  */
-    | (((unsigned long) (branch_offset) >> 12) & 0x3ff) << 16 /* imm10.  */
+    | (((unsigned long long) (branch_offset) >> 12) & 0x3ff) << 16 /* imm10.  */
     | j1 << 13 /* J1.  */
     | j2 << 11 /* J2.  */
-    | (((unsigned long) (branch_offset) >> 1) & 0x7ff); /* imm11.  */
+    | (((unsigned long long) (branch_offset) >> 1) & 0x7ff); /* imm11.  */
 
   return patched_inst;
 }
@@ -19526,7 +19526,7 @@ elf32_arm_write_section (bfd *output_bfd,
 					      + text_sec->output_offset
 					      + text_sec->size;
 			bfd_vma exidx_offset = offset + out_index * 8;
-			unsigned long prel31_offset;
+			unsigned long long prel31_offset;
 
 			/* Note: this is meant to be equivalent to an
 			   R_ARM_PREL31 relocation.  These synthetic
@@ -19920,18 +19920,18 @@ elf32_arm_plt_size (const bfd *abfd, const bfd_byte *start, bfd_vma offset)
 
 /* Implementation is shamelessly borrowed from _bfd_elf_get_synthetic_symtab.  */
 
-static long
+static long long
 elf32_arm_get_synthetic_symtab (bfd *abfd,
-			       long symcount ATTRIBUTE_UNUSED,
+			       long long symcount ATTRIBUTE_UNUSED,
 			       asymbol **syms ATTRIBUTE_UNUSED,
-			       long dynsymcount,
+			       long long dynsymcount,
 			       asymbol **dynsyms,
 			       asymbol **ret)
 {
   asection *relplt;
   asymbol *s;
   arelent *p;
-  long count, i, n;
+  long long count, i, n;
   size_t size;
   Elf_Internal_Shdr *hdr;
   char *names;
diff --git a/bfd/elf32-avr.c b/bfd/elf32-avr.c
index 7087606..b25e3ca 100644
--- a/bfd/elf32-avr.c
+++ b/bfd/elf32-avr.c
@@ -1436,7 +1436,7 @@ elf32_avr_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
@@ -1535,7 +1535,7 @@ static void
 bfd_elf_avr_final_write_processing (bfd *abfd,
 				    bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
 
   switch (bfd_get_mach (abfd))
     {
@@ -2217,7 +2217,7 @@ retrieve_local_syms (bfd *input_bfd)
    . an absolute value, return the absolute section.  */
 
 static asection *
-get_elf_r_symndx_section (bfd *abfd, unsigned long r_symndx)
+get_elf_r_symndx_section (bfd *abfd, unsigned long long r_symndx)
 {
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   asection *target_sec = NULL;
@@ -2240,7 +2240,7 @@ get_elf_r_symndx_section (bfd *abfd, unsigned long r_symndx)
     }
   else
     {
-      unsigned long indx = r_symndx - symtab_hdr->sh_info;
+      unsigned long long indx = r_symndx - symtab_hdr->sh_info;
       struct elf_link_hash_entry *h = elf_sym_hashes (abfd)[indx];
 
       while (h->root.type == bfd_link_hash_indirect
@@ -2271,7 +2271,7 @@ get_elf_r_symndx_section (bfd *abfd, unsigned long r_symndx)
 /* Get the section-relative offset for a symbol number.  */
 
 static bfd_vma
-get_elf_r_symndx_offset (bfd *abfd, unsigned long r_symndx)
+get_elf_r_symndx_offset (bfd *abfd, unsigned long long r_symndx)
 {
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   bfd_vma offset = 0;
@@ -2284,7 +2284,7 @@ get_elf_r_symndx_offset (bfd *abfd, unsigned long r_symndx)
     }
   else
     {
-      unsigned long indx = r_symndx - symtab_hdr->sh_info;
+      unsigned long long indx = r_symndx - symtab_hdr->sh_info;
       struct elf_link_hash_entry *h =
 	elf_sym_hashes (abfd)[indx];
 
@@ -2595,7 +2595,7 @@ elf32_avr_relax_section (bfd *abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
@@ -3099,7 +3099,7 @@ elf32_avr_relax_section (bfd *abfd,
 		case RECORD_ALIGN_AND_FILL:
 		  {
 		    struct avr_property_record *record;
-		    unsigned long bytes_to_align;
+		    unsigned long long bytes_to_align;
 		    int count = 0;
 
 		    /* Look for alignment directives that have had enough
@@ -3108,7 +3108,7 @@ elf32_avr_relax_section (bfd *abfd,
 		       required alignment.  */
 		    record = &relax_info->records.items [i];
 		    bytes_to_align
-		      = (unsigned long) (1 << record->data.align.bytes);
+		      = (unsigned long long) (1 << record->data.align.bytes);
 		    while (record->data.align.preceding_deleted >=
 			   bytes_to_align)
 		      {
@@ -4086,7 +4086,7 @@ avr_elf32_load_records_from_section (bfd *abfd, asection *sec)
 	  else if (rel->r_offset == offset)
 	    {
 	      /* Find section and section offset.  */
-	      unsigned long r_symndx;
+	      unsigned long long r_symndx;
 
 	      asection * rel_sec;
 	      bfd_vma sec_offset;
diff --git a/bfd/elf32-avr.h b/bfd/elf32-avr.h
index b6c664c..8d4d85a 100644
--- a/bfd/elf32-avr.h
+++ b/bfd/elf32-avr.h
@@ -70,21 +70,21 @@ struct avr_property_record
     /* RECORD_ORG and RECORD_ORG_AND_FILL.  */
     struct
     {
-      unsigned long fill;
+      unsigned long long fill;
     } org;
 
     /* RECORD_ALIGN and RECORD_ALIGN_AND_FILL.  */
     struct
     {
-      unsigned long bytes;
-      unsigned long fill;
+      unsigned long long bytes;
+      unsigned long long fill;
 
       /* This field is used during linker relaxation to track the number of
 	 bytes that have been opened up before this alignment directive.
 	 When we have enough bytes available it is possible to move the
 	 re-align this directive backwards while still maintaining the
 	 alignment requirement.  */
-      unsigned long preceding_deleted;
+      unsigned long long preceding_deleted;
     } align;
   } data;
 };
@@ -100,7 +100,7 @@ struct avr_property_record_list
 
   /* The number of property records.  This is stored as a 2-byte value in
      the section contents.  */
-  unsigned long record_count;
+  unsigned long long record_count;
 
   /* The section from which the property records were loaded.  This is the
      actual section containing the records, not the section(s) to which the
diff --git a/bfd/elf32-bfin.c b/bfd/elf32-bfin.c
index ae83771..d6df309 100644
--- a/bfd/elf32-bfin.c
+++ b/bfd/elf32-bfin.c
@@ -1187,7 +1187,7 @@ bfin_check_relocs (bfd * abfd,
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
@@ -1387,7 +1387,7 @@ bfin_relocate_section (bfd * output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       asection *sec;
@@ -1718,9 +1718,9 @@ struct _bfinfdpic_dynamic_got_info
   /* Total size needed by lazy PLT entries.  */
   bfd_vma lzplt;
   /* Number of relocations carried over from input object files.  */
-  unsigned long relocs;
+  unsigned long long relocs;
   /* Number of fixups introduced by relocations in input object files.  */
-  unsigned long fixups;
+  unsigned long long fixups;
 };
 
 /* Create a Blackfin ELF linker hash table.  */
@@ -1763,7 +1763,7 @@ struct bfinfdpic_relocs_info
 {
   /* The index of the symbol, as stored in the relocation r_info, if
      we have a local symbol; -1 otherwise.  */
-  long symndx;
+  long long symndx;
   union
   {
     /* The input bfd in which the symbol is defined, if it's a local
@@ -1849,8 +1849,8 @@ bfinfdpic_relocs_info_hash (const void *entry_)
   const struct bfinfdpic_relocs_info *entry = entry_;
 
   return (entry->symndx == -1
-	  ? (long) entry->d.h->root.root.hash
-	  : entry->symndx + (long) entry->d.abfd->id * 257) + entry->addend;
+	  ? (long long) entry->d.h->root.root.hash
+	  : entry->symndx + (long long) entry->d.abfd->id * 257) + entry->addend;
 }
 
 /* Test whether the key fields of two bfinfdpic_relocs_info entries are
@@ -1926,7 +1926,7 @@ bfinfdpic_relocs_info_for_global (struct htab *ht,
 inline static struct bfinfdpic_relocs_info *
 bfinfdpic_relocs_info_for_local (struct htab *ht,
 				bfd *abfd,
-				long symndx,
+				long long symndx,
 				bfd_vma addend,
 				enum insert_option insert)
 {
@@ -1974,7 +1974,7 @@ bfinfdpic_pic_merge_early_relocs_info (struct bfinfdpic_relocs_info *e2,
 
 inline static bfd_vma
 _bfinfdpic_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
-			 int reloc_type, long dynindx, bfd_vma addend,
+			 int reloc_type, long long dynindx, bfd_vma addend,
 			 struct bfinfdpic_relocs_info *entry)
 {
   Elf_Internal_Rela outrel;
@@ -2249,7 +2249,7 @@ _bfinfdpic_emit_got_relocs_plt_entries (struct bfinfdpic_relocs_info *entry,
       int idx = dynindx;
       bfd_vma ad = addend;
       bfd_vma ofst;
-      long lowword, highword;
+      long long lowword, highword;
 
       /* If the symbol is dynamic but binds locally, use
 	 section+offset.  */
@@ -2524,7 +2524,7 @@ bfinfdpic_relocate_section (bfd * output_bfd,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -4138,7 +4138,7 @@ _bfinfdpic_check_discarded_relocs (bfd *abfd, asection *sec,
   for (erel = rel + sec->reloc_count; rel < erel; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct bfinfdpic_relocs_info *picrel;
       struct _bfinfdpic_dynamic_got_info *dinfo;
 
@@ -4537,7 +4537,7 @@ bfinfdpic_check_relocs (bfd *abfd, struct bfd_link_info *info,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -5376,7 +5376,7 @@ bfd_bfin_elf32_create_embedded_relocs (bfd *abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
diff --git a/bfd/elf32-cr16.c b/bfd/elf32-cr16.c
index 7756ef5..2ca1c68 100644
--- a/bfd/elf32-cr16.c
+++ b/bfd/elf32-cr16.c
@@ -726,7 +726,7 @@ cr16_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -843,7 +843,7 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 			      bfd_vma Rvalue,
 			      bfd_vma addend,
 			      struct elf_link_hash_entry * h,
-			      unsigned long symndx  ATTRIBUTE_UNUSED,
+			      unsigned long long symndx  ATTRIBUTE_UNUSED,
 			      struct bfd_link_info *info ATTRIBUTE_UNUSED,
 			      asection *sec ATTRIBUTE_UNUSED,
 			      int is_local ATTRIBUTE_UNUSED)
@@ -1005,7 +1005,7 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	      Rvalue += Rvalue1;
 
 	     /* Check for range.  */
-	     if ((long) Rvalue > 0xffff || (long) Rvalue < 0x0)
+	     if ((long long) Rvalue > 0xffff || (long long) Rvalue < 0x0)
 	      return bfd_reloc_overflow;
 	  }
 
@@ -1025,7 +1025,7 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 		Rvalue += Rvalue1;
 
 	      /* Check for range.  */
-	      if ((long) Rvalue > 0xfffff || (long) Rvalue < 0x0)
+	      if ((long long) Rvalue > 0xfffff || (long long) Rvalue < 0x0)
 	       return bfd_reloc_overflow;
 
 	    bfd_put_16 (input_bfd, ((bfd_get_16 (input_bfd, hit_data) & 0xfff0)
@@ -1071,7 +1071,7 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 
 	     /* REVISIT: if ((long) Rvalue > 0xffffff ||
 				    (long) Rvalue < -0x800000).  */
-	     if ((long) Rvalue > 0xffffff || (long) Rvalue < 0)
+	     if ((long long) Rvalue > 0xffffff || (long long) Rvalue < 0)
 	       return bfd_reloc_overflow;
 
 
@@ -1132,7 +1132,7 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	      /* Check for range.  */
 	     /* REVISIT: if ((long) Rvalue > 0xffffff
 			     || (long) Rvalue < -0x800000).  */
-	     if ((long) Rvalue > 0xffffff || (long) Rvalue < 0)
+	     if ((long long) Rvalue > 0xffffff || (long long) Rvalue < 0)
 	       return bfd_reloc_overflow;
 
 	     bfd_put_16 (input_bfd, (bfd_get_16 (input_bfd, hit_data))
@@ -1154,7 +1154,7 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 		    Rvalue += Rvalue1;
 
 		 /* Check for Range.  */
-		 if ((long) Rvalue > 0xffffff || (long) Rvalue < 0x0)
+		 if ((long long) Rvalue > 0xffffff || (long long) Rvalue < 0x0)
 		   return bfd_reloc_overflow;
 
 		 Rvalue = ((((Rvalue >> 20) & 0xf) | (((Rvalue >> 16) & 0xf)<<8)
@@ -1179,7 +1179,7 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 		   Rvalue += Rvalue1;
 
 		 /* Check for range.  */
-		 if (Rvalue > 0xffffffff || (long) Rvalue < 0x0)
+		 if (Rvalue > 0xffffffff || (long long) Rvalue < 0x0)
 		   return bfd_reloc_overflow;
 
 		 Rvalue = (((Rvalue >> 16)& 0xffff) | (Rvalue & 0xffff) << 16);
@@ -1202,7 +1202,7 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 		     Rvalue += Rvalue1;
 
 		  /* Check for range.  */
-		  if ((long) Rvalue > 0xfffff || (long) Rvalue < 0x0)
+		  if ((long long) Rvalue > 0xfffff || (long long) Rvalue < 0x0)
 		    return bfd_reloc_overflow;
 
 		  Rvalue = (((((Rvalue >> 20)& 0xf) | (((Rvalue >>16) & 0xf)<<8)
@@ -1288,7 +1288,7 @@ elf32_cr16_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,
 #if 0
 	  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
 	    {
-	      unsigned long r_symndx;
+	      unsigned long long r_symndx;
 	      Elf_Internal_Sym *rsym;
 	      bfd_vma addsym, subsym;
 
@@ -1387,7 +1387,7 @@ elf32_cr16_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -1658,7 +1658,7 @@ elf32_cr16_link_hash_table_create (bfd *abfd)
   return &ret->root;
 }
 
-static unsigned long
+static unsigned long long
 elf_cr16_mach (flagword flags)
 {
   switch (flags)
@@ -1677,7 +1677,7 @@ static void
 _bfd_cr16_elf_final_write_processing (bfd *abfd,
 				      bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
   switch (bfd_get_mach (abfd))
     {
      default:
@@ -1824,7 +1824,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
@@ -1866,7 +1866,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,
 	  /* See if the value will fit in 16 bits, note the high value is
 	     0xfffe + 2 as the target will be two bytes closer if we are
 	     able to relax.  */
-	  if ((long) value < 0x10000 && (long) value > -0x10002)
+	  if ((long long) value < 0x10000 && (long long) value > -0x10002)
 	    {
 	      unsigned int code;
 
@@ -1914,7 +1914,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,
 	     0xfc + 2 as the target will be two bytes closer if we are
 	     able to relax.  */
 	  /*if ((long) value < 0x1fa && (long) value > -0x100) REVISIT:range */
-	  if ((long) value < 0xfa && (long) value > -0x100)
+	  if ((long long) value < 0xfa && (long long) value > -0x100)
 	    {
 	      unsigned short code;
 
@@ -1959,7 +1959,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,
 		   |(((bfd_get_32 (abfd, contents + irel->r_offset + 2) & 0xffff) << 16)));
 
 	  /* See if the value will fit in 20 bits.  */
-	  if ((long) (value + value1) < 0xfffff && (long) (value + value1) > 0)
+	  if ((long long) (value + value1) < 0xfffff && (long long) (value + value1) > 0)
 	    {
 	      unsigned short code;
 
@@ -2013,7 +2013,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,
 
 	  /* See if the value will fit in 16 bits.  */
 	  if ((!is_add_mov)
-	      && ((long)(value + value1) < 0x7fff && (long)(value + value1) > 0))
+	      && ((long long)(value + value1) < 0x7fff && (long long)(value + value1) > 0))
 	    {
 	      unsigned short code;
 
@@ -2079,8 +2079,8 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,
 	    }
 
 	  /* See if the value will fit in 4 bits.  */
-	  if ((((long) (value + value1)) < 0xf)
-	      && (((long) (value + value1)) > 0))
+	  if ((((long long) (value + value1)) < 0xf)
+	      && (((long long) (value + value1)) > 0))
 	    {
 	      unsigned short code;
 
@@ -2828,7 +2828,7 @@ bfd_cr16_elf32_create_embedded_relocs (bfd *abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
diff --git a/bfd/elf32-cr16c.c b/bfd/elf32-cr16c.c
index 40ec759..821bc5d 100644
--- a/bfd/elf32-cr16c.c
+++ b/bfd/elf32-cr16c.c
@@ -207,18 +207,18 @@ cr16c_elf_final_link_relocate (reloc_howto_type *howto,
 			       asection *sym_sec ATTRIBUTE_UNUSED,
 			       int is_local ATTRIBUTE_UNUSED)
 {
-  long value;
+  long long value;
   short sword;			/* Extracted from the hole and put back.  */
-  unsigned long format, addr_type, code_factor;
+  unsigned long long format, addr_type, code_factor;
   unsigned short size;
   unsigned short r_type;
 
-  unsigned long disp20_opcod;
+  unsigned long long disp20_opcod;
   char neg = 0;
   char neg2pos = 0;
 
-  long left_val = 0;
-  long plus_factor = 0;		/* To be added to the hole.  */
+  long long left_val = 0;
+  long long plus_factor = 0;		/* To be added to the hole.  */
 
 #define MIN_BYTE	((int) 0xFFFFFF80)
 #define MIN_WORD	((int) 0xFFFF8000)
@@ -700,7 +700,7 @@ elf32_cr16c_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
diff --git a/bfd/elf32-cris.c b/bfd/elf32-cris.c
index 1c367c4..d9405cf 100644
--- a/bfd/elf32-cris.c
+++ b/bfd/elf32-cris.c
@@ -32,7 +32,7 @@ bfd_reloc_status_type
 cris_elf_pcrel_reloc (bfd *, arelent *, asymbol *, void *,
 		      asection *, bfd *, char **);
 static bfd_boolean
-cris_elf_set_mach_from_flags (bfd *, unsigned long);
+cris_elf_set_mach_from_flags (bfd *, unsigned long long);
 
 /* Forward declarations.  */
 static reloc_howto_type cris_elf_howto_table [] =
@@ -1013,7 +1013,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -1515,7 +1515,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		    }
 		  else
 		    {
-		      long indx;
+		      long long indx;
 
 		      if (bfd_is_abs_section (sec))
 			indx = 0;
@@ -2979,10 +2979,10 @@ cris_elf_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       enum elf_cris_reloc_type r_type;
       bfd_signed_vma got_element_size = 4;
-      unsigned long r_symndx_lgot = INT_MAX;
+      unsigned long long r_symndx_lgot = INT_MAX;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -3835,7 +3835,7 @@ static void
 cris_elf_final_write_processing (bfd *abfd,
 				 bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long e_flags = elf_elfheader (abfd)->e_flags;
+  unsigned long long e_flags = elf_elfheader (abfd)->e_flags;
 
   e_flags &= ~EF_CRIS_UNDERSCORE;
   if (bfd_get_symbol_leading_char (abfd) == '_')
@@ -3867,7 +3867,7 @@ cris_elf_final_write_processing (bfd *abfd,
 
 static bfd_boolean
 cris_elf_set_mach_from_flags (bfd *abfd,
-			      unsigned long flags)
+			      unsigned long long flags)
 {
   switch (flags & EF_CRIS_VARIANT_MASK)
     {
@@ -4044,7 +4044,7 @@ elf_cris_got_elt_size (bfd *abfd ATTRIBUTE_UNUSED,
 		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
 		       struct elf_link_hash_entry *hr,
 		       bfd *ibfd,
-		       unsigned long symndx)
+		       unsigned long long symndx)
 {
   struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) hr;
   bfd_vma eltsiz = 0;
diff --git a/bfd/elf32-crx.c b/bfd/elf32-crx.c
index fde3a58..33a85c2 100644
--- a/bfd/elf32-crx.c
+++ b/bfd/elf32-crx.c
@@ -643,7 +643,7 @@ elf32_crx_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,
 	     which reference this local symbol.  */
 	  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
 	    {
-	      unsigned long r_symndx;
+	      unsigned long long r_symndx;
 	      Elf_Internal_Sym *rsym;
 	      bfd_vma addsym, subsym;
 
@@ -850,7 +850,7 @@ elf32_crx_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -1049,7 +1049,7 @@ elf32_crx_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
@@ -1091,7 +1091,7 @@ elf32_crx_relax_section (bfd *abfd, asection *sec,
 	  /* See if the value will fit in 16 bits, note the high value is
 	     0xfffe + 2 as the target will be two bytes closer if we are
 	     able to relax.  */
-	  if ((long) value < 0x10000 && (long) value > -0x10002)
+	  if ((long long) value < 0x10000 && (long long) value > -0x10002)
 	    {
 	      unsigned short code;
 
@@ -1140,7 +1140,7 @@ elf32_crx_relax_section (bfd *abfd, asection *sec,
 	  /* See if the value will fit in 8 bits, note the high value is
 	     0xfc + 2 as the target will be two bytes closer if we are
 	     able to relax.  */
-	  if ((long) value < 0xfe && (long) value > -0x100)
+	  if ((long long) value < 0xfe && (long long) value > -0x100)
 	    {
 	      unsigned short code;
 
@@ -1185,7 +1185,7 @@ elf32_crx_relax_section (bfd *abfd, asection *sec,
 	  /* See if the value will fit in 8 bits, note the high value is
 	     0x7e + 2 as the target will be two bytes closer if we are
 	     able to relax.  */
-	  if ((long) value < 0x100 && (long) value > -0x100)
+	  if ((long long) value < 0x100 && (long long) value > -0x100)
 	    {
 	      unsigned short code;
 
@@ -1230,7 +1230,7 @@ elf32_crx_relax_section (bfd *abfd, asection *sec,
 	  bfd_vma value = symval;
 
 	  /* See if the value will fit in 16 bits.  */
-	  if ((long) value < 0x7fff && (long) value > -0x8000)
+	  if ((long long) value < 0x7fff && (long long) value > -0x8000)
 	    {
 	      unsigned short code;
 
diff --git a/bfd/elf32-d10v.c b/bfd/elf32-d10v.c
index c901595..e18065e 100644
--- a/bfd/elf32-d10v.c
+++ b/bfd/elf32-d10v.c
@@ -283,7 +283,7 @@ elf32_d10v_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -412,7 +412,7 @@ elf32_d10v_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
diff --git a/bfd/elf32-dlx.c b/bfd/elf32-dlx.c
index d82d3ea..1976ce3 100644
--- a/bfd/elf32-dlx.c
+++ b/bfd/elf32-dlx.c
@@ -117,7 +117,7 @@ elf32_dlx_relocate16 (bfd *abfd,
 		      bfd *output_bfd,
 		      char **error_message ATTRIBUTE_UNUSED)
 {
-  unsigned long insn, vallo, allignment;
+  unsigned long long insn, vallo, allignment;
   int		val;
 
   /* HACK: I think this first condition is necessary when producing
@@ -151,7 +151,7 @@ elf32_dlx_relocate16 (bfd *abfd,
     vallo = ~(vallo | 0xFFFF0000) + 1;
 
   /* vallo points to the vma of next instruction.  */
-  vallo += (((unsigned long)(input_section->output_section->vma +
+  vallo += (((unsigned long long)(input_section->output_section->vma +
 			   input_section->output_offset) +
 	    allignment) & ~allignment);
 
@@ -180,7 +180,7 @@ elf32_dlx_relocate26 (bfd *abfd,
 		      bfd *output_bfd,
 		      char **error_message ATTRIBUTE_UNUSED)
 {
-  unsigned long insn, vallo, allignment;
+  unsigned long long insn, vallo, allignment;
   int		val;
 
   /* HACK: I think this first condition is necessary when producing
@@ -214,7 +214,7 @@ elf32_dlx_relocate26 (bfd *abfd,
     vallo = ~(vallo | 0xFC000000) + 1;
 
   /* vallo is the vma for the next instruction.  */
-  vallo += (((unsigned long) (input_section->output_section->vma +
+  vallo += (((unsigned long long) (input_section->output_section->vma +
 			      input_section->output_offset) +
 	     allignment) & ~allignment);
 
@@ -440,7 +440,7 @@ elf32_dlx_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
diff --git a/bfd/elf32-epiphany.c b/bfd/elf32-epiphany.c
index efbd67b..7a79e5c 100644
--- a/bfd/elf32-epiphany.c
+++ b/bfd/elf32-epiphany.c
@@ -185,9 +185,9 @@ epiphany_elf_relax_section (bfd *abfd, asection *sec,
   bfd_byte *contents = NULL;
   Elf_Internal_Sym *isymbuf = NULL;
   static asection * first_section = NULL;
-  static unsigned long search_addr;
-  static unsigned long page_start = 0;
-  static unsigned long page_end = 0;
+  static unsigned long long search_addr;
+  static unsigned long long page_start = 0;
+  static unsigned long long page_end = 0;
   static unsigned int pass = 0;
   static bfd_boolean new_pass = FALSE;
   static bfd_boolean changed = FALSE;
@@ -494,7 +494,7 @@ epiphany_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
diff --git a/bfd/elf32-fr30.c b/bfd/elf32-fr30.c
index 7b0fc88..2c68a5d 100644
--- a/bfd/elf32-fr30.c
+++ b/bfd/elf32-fr30.c
@@ -241,7 +241,7 @@ fr30_elf_i20_reloc (bfd *abfd,
 		    char **error_message ATTRIBUTE_UNUSED)
 {
   bfd_vma relocation;
-  unsigned long x;
+  unsigned long long x;
 
   /* This part is from bfd_elf_generic_reloc.  */
   if (output_bfd != (bfd *) NULL
@@ -519,7 +519,7 @@ fr30_elf_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -662,7 +662,7 @@ fr30_elf_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
diff --git a/bfd/elf32-frv.c b/bfd/elf32-frv.c
index fc0bdcd..b8bd109 100644
--- a/bfd/elf32-frv.c
+++ b/bfd/elf32-frv.c
@@ -892,12 +892,12 @@ struct _frvfdpic_dynamic_got_info
   /* Total PLT size needed by TLS lazy PLT entries.  */
   bfd_vma tlslzplt;
   /* Number of relocations carried over from input object files.  */
-  unsigned long relocs;
+  unsigned long long relocs;
   /* Number of fixups introduced by relocations in input object files.  */
-  unsigned long fixups;
+  unsigned long long fixups;
   /* The number of fixups that reference the ret instruction added to
      the PLT for locally-resolved TLS descriptors.  */
-  unsigned long tls_ret_refs;
+  unsigned long long tls_ret_refs;
 };
 
 /* This structure is used to assign offsets to got entries, function
@@ -976,7 +976,7 @@ struct frvfdpic_relocs_info
 {
   /* The index of the symbol, as stored in the relocation r_info, if
      we have a local symbol; -1 otherwise.  */
-  long symndx;
+  long long symndx;
   union
   {
     /* The input bfd in which the symbol is defined, if it's a local
@@ -1090,8 +1090,8 @@ frvfdpic_relocs_info_hash (const void *entry_)
   const struct frvfdpic_relocs_info *entry = entry_;
 
   return (entry->symndx == -1
-	  ? (long) entry->d.h->root.root.hash
-	  : entry->symndx + (long) entry->d.abfd->id * 257) + entry->addend;
+	  ? (long long) entry->d.h->root.root.hash
+	  : entry->symndx + (long long) entry->d.abfd->id * 257) + entry->addend;
 }
 
 /* Test whether the key fields of two frvfdpic_relocs_info entries are
@@ -1164,7 +1164,7 @@ frvfdpic_relocs_info_for_global (struct htab *ht,
 inline static struct frvfdpic_relocs_info *
 frvfdpic_relocs_info_for_local (struct htab *ht,
 				bfd *abfd,
-				long symndx,
+				long long symndx,
 				bfd_vma addend,
 				enum insert_option insert)
 {
@@ -1218,7 +1218,7 @@ frvfdpic_pic_merge_early_relocs_info (struct frvfdpic_relocs_info *e2,
 
 inline static bfd_vma
 _frvfdpic_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
-			 int reloc_type, long dynindx, bfd_vma addend,
+			 int reloc_type, long long dynindx, bfd_vma addend,
 			 struct frvfdpic_relocs_info *entry)
 {
   Elf_Internal_Rela outrel;
@@ -1517,7 +1517,7 @@ _frvfdpic_emit_got_relocs_plt_entries (struct frvfdpic_relocs_info *entry,
       int idx = dynindx;
       bfd_vma ad = addend;
       bfd_vma ofst;
-      long lowword, highword;
+      long long lowword, highword;
 
       /* If the symbol is dynamic but binds locally, use
 	 section+offset.  */
@@ -2145,7 +2145,7 @@ elf32_frv_relocate_gprel12 (struct bfd_link_info *info,
 
   value += relocation->r_addend;
 
-  if ((long) value > 0x7ff || (long) value < -0x800)
+  if ((long long) value > 0x7ff || (long long) value < -0x800)
     return bfd_reloc_overflow;
 
   bfd_put_32 (input_bfd,
@@ -2183,7 +2183,7 @@ elf32_frv_relocate_gprelu12 (struct bfd_link_info *info,
 
   value += relocation->r_addend;
 
-  if ((long) value > 0x7ff || (long) value < -0x800)
+  if ((long long) value > 0x7ff || (long long) value < -0x800)
     return bfd_reloc_overflow;
 
   /* The high 6 bits go into bits 17-12. The low 6 bits go into bits 5-0.  */
@@ -2212,7 +2212,7 @@ elf32_frv_relocate_hi16 (bfd *input_bfd,
 
   insn = (insn & 0xffff0000) | value;
 
-  if ((long) value > 0xffff || (long) value < -0x10000)
+  if ((long long) value > 0xffff || (long long) value < -0x10000)
     return bfd_reloc_overflow;
 
   bfd_put_32 (input_bfd, insn, contents + relhi->r_offset);
@@ -2234,7 +2234,7 @@ elf32_frv_relocate_lo16 (bfd *input_bfd,
 
   insn = (insn & 0xffff0000) | value;
 
-  if ((long) value > 0xffff || (long) value < -0x10000)
+  if ((long long) value > 0xffff || (long long) value < -0x10000)
     return bfd_reloc_overflow;
 
   bfd_put_32 (input_bfd, insn, contents + rello->r_offset);
@@ -2308,7 +2308,7 @@ elf32_frv_relocate_gprelhi (struct bfd_link_info *info,
   value += relocation->r_addend;
   value = ((value >> 16) & 0xffff);
 
-  if ((long) value > 0xffff || (long) value < -0x10000)
+  if ((long long) value > 0xffff || (long long) value < -0x10000)
     return bfd_reloc_overflow;
 
   insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);
@@ -2341,7 +2341,7 @@ elf32_frv_relocate_gprello (struct bfd_link_info *info,
   value += relocation->r_addend;
   value = value & 0xffff;
 
-  if ((long) value > 0xffff || (long) value < -0x10000)
+  if ((long long) value > 0xffff || (long long) value < -0x10000)
     return bfd_reloc_overflow;
 
   insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);
@@ -2668,7 +2668,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   unsigned isec_segment, got_segment, plt_segment, gprel_segment, tls_segment,
     check_segment[2];
   int silence_segment_error = !bfd_link_pic (info);
-  unsigned long insn;
+  unsigned long long insn;
 
   symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
   sym_hashes = elf_sym_hashes (input_bfd);
@@ -2703,7 +2703,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -2916,7 +2916,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this a call instruction?  */
-	    if ((insn & (unsigned long)0x01fc0000) != 0x003c0000)
+	    if ((insn & (unsigned long long)0x01fc0000) != 0x003c0000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_GETTLSOFF not applied to a call instruction\n"),
@@ -2929,8 +2929,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	      {
 		/* Replace the call instruction (except the packing bit)
 		   with setlos #tlsmofflo(symbol+offset), gr9.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x12fc0000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x12fc0000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_TLSMOFFLO;
@@ -2942,8 +2942,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	      {
 		/* Replace the call instruction (except the packing bit)
 		   with ldi @(gr15, #gottlsoff12(symbol+addend)), gr9.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x12c8f000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x12c8f000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_GOTTLSOFF12;
@@ -2957,7 +2957,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this an lddi instruction?  */
-	    if ((insn & (unsigned long)0x01fc0000) != 0x00cc0000)
+	    if ((insn & (unsigned long long)0x01fc0000) != 0x00cc0000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_GOTTLSDESC12"
@@ -2974,10 +2974,10 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace lddi @(grB, #gottlsdesc12(symbol+offset), grC
 		   with setlos #tlsmofflo(symbol+offset), gr<C+1>.
 		   Preserve the packing bit.  */
-		insn = (insn & (unsigned long)0x80000000)
-		  | ((insn + (unsigned long)0x02000000)
-		     & (unsigned long)0x7e000000);
-		insn |= (unsigned long)0x00fc0000;
+		insn = (insn & (unsigned long long)0x80000000)
+		  | ((insn + (unsigned long long)0x02000000)
+		     & (unsigned long long)0x7e000000);
+		insn |= (unsigned long long)0x00fc0000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_TLSMOFFLO;
@@ -2991,10 +2991,10 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace lddi @(grB, #gottlsdesc12(symbol+offset), grC
 		   with sethi #tlsmoffhi(symbol+offset), gr<C+1>.
 		   Preserve the packing bit.  */
-		insn = (insn & (unsigned long)0x80000000)
-		  | ((insn + (unsigned long)0x02000000)
-		     & (unsigned long)0x7e000000);
-		insn |= (unsigned long)0x00f80000;
+		insn = (insn & (unsigned long long)0x80000000)
+		  | ((insn + (unsigned long long)0x02000000)
+		     & (unsigned long long)0x7e000000);
+		insn |= (unsigned long long)0x00f80000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_TLSMOFFHI;
@@ -3012,9 +3012,9 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		   more demanding.  Compiling with -fPIE instead of
 		   -fpie would fix it; linking with --relax should fix
 		   it as well.  */
-		insn = (insn & (unsigned long)0x80cbf000)
-		  | ((insn + (unsigned long)0x02000000)
-		     & (unsigned long)0x7e000000);
+		insn = (insn & (unsigned long long)0x80cbf000)
+		  | ((insn + (unsigned long long)0x02000000)
+		     & (unsigned long long)0x7e000000);
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_GOTTLSOFF12;
@@ -3028,7 +3028,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this a sethi instruction?  */
-	    if ((insn & (unsigned long)0x01ff0000) != 0x00f80000)
+	    if ((insn & (unsigned long long)0x01ff0000) != 0x00f80000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_GOTTLSDESCHI"
@@ -3043,8 +3043,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		    && IN_RANGE_FOR_SETLOS_P (picrel->tlsoff_entry)))
 	      {
 		/* Replace sethi with a nop.  Preserve the packing bit.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x00880000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x00880000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		/* Nothing to relocate.  */
@@ -3065,7 +3065,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this a setlo or setlos instruction?  */
-	    if ((insn & (unsigned long)0x01f70000) != 0x00f40000)
+	    if ((insn & (unsigned long long)0x01f70000) != 0x00f40000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_GOTTLSDESCLO"
@@ -3081,8 +3081,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	      {
 		/* Replace setlo/setlos with a nop.  Preserve the
 		   packing bit.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x00880000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x00880000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		/* Nothing to relocate.  */
@@ -3096,7 +3096,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		   setlos, not setlo.  */
 		if (IN_RANGE_FOR_SETLOS_P (picrel->tlsoff_entry))
 		  {
-		    insn |= (unsigned long)0x00080000;
+		    insn |= (unsigned long long)0x00080000;
 		    bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 		  }
 
@@ -3112,7 +3112,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this an ldd instruction?  */
-	    if ((insn & (unsigned long)0x01fc0fc0) != 0x00080140)
+	    if ((insn & (unsigned long long)0x01fc0fc0) != 0x00080140)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_TLSDESC_RELAX"
@@ -3129,10 +3129,10 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace ldd #tlsdesc(symbol+offset)@(grB, grA), grC
 		   with setlos #tlsmofflo(symbol+offset), gr<C+1>.
 		   Preserve the packing bit.  */
-		insn = (insn & (unsigned long)0x80000000)
-		  | ((insn + (unsigned long)0x02000000)
-		     & (unsigned long)0x7e000000);
-		insn |= (unsigned long)0x00fc0000;
+		insn = (insn & (unsigned long long)0x80000000)
+		  | ((insn + (unsigned long long)0x02000000)
+		     & (unsigned long long)0x7e000000);
+		insn |= (unsigned long long)0x00fc0000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_TLSMOFFLO;
@@ -3146,10 +3146,10 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace ldd #tlsdesc(symbol+offset)@(grB, grA), grC
 		   with sethi #tlsmoffhi(symbol+offset), gr<C+1>.
 		   Preserve the packing bit.  */
-		insn = (insn & (unsigned long)0x80000000)
-		  | ((insn + (unsigned long)0x02000000)
-		     & (unsigned long)0x7e000000);
-		insn |= (unsigned long)0x00f80000;
+		insn = (insn & (unsigned long long)0x80000000)
+		  | ((insn + (unsigned long long)0x02000000)
+		     & (unsigned long long)0x7e000000);
+		insn |= (unsigned long long)0x00f80000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_TLSMOFFHI;
@@ -3163,10 +3163,10 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace ldd #tlsdesc(symbol+offset)@(grB, grA), grC
 		   with ldi @(grB, #gottlsoff12(symbol+offset), gr<C+1>.
 		   Preserve the packing bit.  */
-		insn = (insn & (unsigned long)0x8003f000)
-		  | (unsigned long)0x00c80000
-		  | ((insn + (unsigned long)0x02000000)
-		     & (unsigned long)0x7e000000);
+		insn = (insn & (unsigned long long)0x8003f000)
+		  | (unsigned long long)0x00c80000
+		  | ((insn + (unsigned long long)0x02000000)
+		     & (unsigned long long)0x7e000000);
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_GOTTLSOFF12;
@@ -3179,9 +3179,9 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace ldd #tlsdesc(symbol+offset)@(grB, grA), grC
 		   with ld #tlsoff(symbol+offset)@(grB, grA), gr<C+1>.
 		   Preserve the packing bit.  */
-		insn = (insn & (unsigned long)0x81ffffbf)
-		  | ((insn + (unsigned long)0x02000000)
-		     & (unsigned long)0x7e000000);
+		insn = (insn & (unsigned long long)0x81ffffbf)
+		  | ((insn + (unsigned long long)0x02000000)
+		     & (unsigned long long)0x7e000000);
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		/* #tlsoff(symbol+offset) is just a relaxation
@@ -3196,7 +3196,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this a calll or callil instruction?  */
-	    if ((insn & (unsigned long)0x7ff80fc0) != 0x02300000)
+	    if ((insn & (unsigned long long)0x7ff80fc0) != 0x02300000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_GETTLSOFF_RELAX"
@@ -3211,8 +3211,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 						  info))
 	      {
 		/* Replace calll with a nop.  Preserve the packing bit.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x00880000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x00880000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		/* Nothing to relocate.  */
@@ -3224,8 +3224,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	      {
 		/* Replace calll with setlo #tlsmofflo(symbol+offset), gr9.
 		   Preserve the packing bit.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x12f40000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x12f40000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_TLSMOFFLO;
@@ -3236,8 +3236,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    else if (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel))
 	      {
 		/* Replace calll with a nop.  Preserve the packing bit.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x00880000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x00880000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		/* Nothing to relocate.  */
@@ -3250,7 +3250,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this an ldi instruction?  */
-	    if ((insn & (unsigned long)0x01fc0000) != 0x00c80000)
+	    if ((insn & (unsigned long long)0x01fc0000) != 0x00c80000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_GOTTLSOFF12"
@@ -3265,8 +3265,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace ldi @(grB, #gottlsoff12(symbol+offset), grC
 		   with setlos #tlsmofflo(symbol+offset), grC.
 		   Preserve the packing bit.  */
-		insn &= (unsigned long)0xfe000000;
-		insn |= (unsigned long)0x00fc0000;
+		insn &= (unsigned long long)0xfe000000;
+		insn |= (unsigned long long)0x00fc0000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_TLSMOFFLO;
@@ -3280,7 +3280,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this a sethi instruction?  */
-	    if ((insn & (unsigned long)0x01ff0000) != 0x00f80000)
+	    if ((insn & (unsigned long long)0x01ff0000) != 0x00f80000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_GOTTLSOFFHI"
@@ -3295,8 +3295,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		    && IN_RANGE_FOR_OFST12_P (picrel->tlsoff_entry)))
 	      {
 		/* Replace sethi with a nop.  Preserve the packing bit.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x00880000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x00880000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		/* Nothing to relocate.  */
@@ -3309,7 +3309,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this a setlo or setlos instruction?  */
-	    if ((insn & (unsigned long)0x01f70000) != 0x00f40000)
+	    if ((insn & (unsigned long long)0x01f70000) != 0x00f40000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_GOTTLSOFFLO"
@@ -3325,8 +3325,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	      {
 		/* Replace setlo/setlos with a nop.  Preserve the
 		   packing bit.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x00880000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x00880000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		/* Nothing to relocate.  */
@@ -3339,7 +3339,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this an ld instruction?  */
-	    if ((insn & (unsigned long)0x01fc0fc0) != 0x00080100)
+	    if ((insn & (unsigned long long)0x01fc0fc0) != 0x00080100)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_TLSOFF_RELAX"
@@ -3354,8 +3354,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace ld #gottlsoff(symbol+offset)@(grB, grA), grC
 		   with setlos #tlsmofflo(symbol+offset), grC.
 		   Preserve the packing bit.  */
-		insn &= (unsigned long)0xfe000000;
-		insn |= (unsigned long)0x00fc0000;
+		insn &= (unsigned long long)0xfe000000;
+		insn |= (unsigned long long)0x00fc0000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_TLSMOFFLO;
@@ -3369,8 +3369,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		/* Replace ld #tlsoff(symbol+offset)@(grB, grA), grC
 		   with ldi @(grB, #gottlsoff12(symbol+offset), grC.
 		   Preserve the packing bit.  */
-		insn = (insn & (unsigned long)0xfe03f000)
-		  | (unsigned long)0x00c80000;
+		insn = (insn & (unsigned long long)0xfe03f000)
+		  | (unsigned long long)0x00c80000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		r_type = R_FRV_GOTTLSOFF12;
@@ -3384,7 +3384,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this a sethi instruction?  */
-	    if ((insn & (unsigned long)0x01ff0000) != 0x00f80000)
+	    if ((insn & (unsigned long long)0x01ff0000) != 0x00f80000)
 	      {
 		info->callbacks->einfo
 		  (_("%H: R_FRV_TLSMOFFHI"
@@ -3397,8 +3397,8 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 					       info))
 	      {
 		/* Replace sethi with a nop.  Preserve the packing bit.  */
-		insn &= (unsigned long)0x80000000;
-		insn |= (unsigned long)0x00880000;
+		insn &= (unsigned long long)0x80000000;
+		insn |= (unsigned long long)0x00880000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 
 		/* Nothing to relocate.  */
@@ -3411,7 +3411,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	    /* Is this a setlo or setlos instruction?  */
-	    if ((insn & (unsigned long)0x01f70000) != 0x00f40000)
+	    if ((insn & (unsigned long long)0x01f70000) != 0x00f40000)
 	      {
 		info->callbacks->einfo
 		  (_("R_FRV_TLSMOFFLO"
@@ -3426,7 +3426,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		 to a nop, make sure this becomes (or already is) a
 		 setlos, not setlo.  */
 	      {
-		insn |= (unsigned long)0x00080000;
+		insn |= (unsigned long long)0x00080000;
 		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
 	      }
 
@@ -5527,7 +5527,7 @@ _frvfdpic_check_discarded_relocs (bfd *abfd, asection *sec,
   for (erel = rel + sec->reloc_count; rel < erel; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct frvfdpic_relocs_info *picrel;
       struct _frvfdpic_dynamic_got_info *dinfo;
 
@@ -6036,7 +6036,7 @@ elf32_frv_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -6627,7 +6627,7 @@ frv_elf_print_private_bfd_data (bfd *abfd, void * ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx:"), (unsigned long) flags);
+  fprintf (file, _("private flags = 0x%lx:"), (unsigned long long) flags);
 
   switch (flags & EF_FRV_CPU_MASK)
     {
diff --git a/bfd/elf32-ft32.c b/bfd/elf32-ft32.c
index 7c4e1ae..3053f0d 100644
--- a/bfd/elf32-ft32.c
+++ b/bfd/elf32-ft32.c
@@ -365,7 +365,7 @@ ft32_elf_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -560,7 +560,7 @@ ft32_reloc_shortable
     }
   else
     {
-      unsigned long indx;
+      unsigned long long indx;
       struct elf_link_hash_entry *h;
 
       /* An external symbol.  */
diff --git a/bfd/elf32-h8300.c b/bfd/elf32-h8300.c
index a41ae63..6d2c227 100644
--- a/bfd/elf32-h8300.c
+++ b/bfd/elf32-h8300.c
@@ -30,7 +30,7 @@ static bfd_boolean elf32_h8_info_to_howto
   (bfd *, arelent *, Elf_Internal_Rela *);
 static bfd_boolean elf32_h8_info_to_howto_rel
   (bfd *, arelent *, Elf_Internal_Rela *);
-static unsigned long elf32_h8_mach (flagword);
+static unsigned long long elf32_h8_mach (flagword);
 static void elf32_h8_final_write_processing (bfd *, bfd_boolean);
 static bfd_boolean elf32_h8_object_p (bfd *);
 static bfd_boolean elf32_h8_merge_private_bfd_data
@@ -44,7 +44,7 @@ static bfd_byte *elf32_h8_get_relocated_section_contents
   (bfd *, struct bfd_link_info *, struct bfd_link_order *,
    bfd_byte *, bfd_boolean, asymbol **);
 static bfd_reloc_status_type elf32_h8_final_link_relocate
-  (unsigned long, bfd *, bfd *, asection *,
+  (unsigned long long, bfd *, bfd *, asection *,
    bfd_byte *, bfd_vma, bfd_vma, bfd_vma,
    struct bfd_link_info *, asection *, int);
 static bfd_boolean elf32_h8_relocate_section
@@ -335,7 +335,7 @@ special (bfd *abfd ATTRIBUTE_UNUSED,
 
 /* Perform a relocation as part of a final link.  */
 static bfd_reloc_status_type
-elf32_h8_final_link_relocate (unsigned long r_type, bfd *input_bfd,
+elf32_h8_final_link_relocate (unsigned long long r_type, bfd *input_bfd,
 			      bfd *output_bfd ATTRIBUTE_UNUSED,
 			      asection *input_section ATTRIBUTE_UNUSED,
 			      bfd_byte *contents, bfd_vma offset,
@@ -444,7 +444,7 @@ elf32_h8_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
   for (; rel < relend; rel++)
     {
       unsigned int r_type;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -551,7 +551,7 @@ elf32_h8_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 
    Examine that field and return the proper BFD machine type for
    the object file.  */
-static unsigned long
+static unsigned long long
 elf32_h8_mach (flagword flags)
 {
   switch (flags & EF_H8_MACH)
@@ -588,7 +588,7 @@ static void
 elf32_h8_final_write_processing (bfd *abfd,
 				 bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
 
   switch (bfd_get_mach (abfd))
     {
@@ -799,7 +799,7 @@ elf32_h8_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index 49797dc..5347bf3 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -864,7 +864,7 @@ elf_i386_check_tls_transition (asection *sec,
 			       const Elf_Internal_Rela *relend)
 {
   unsigned int val, type, reg;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   struct elf_link_hash_entry *h;
   bfd_vma offset;
   bfd_byte *call;
@@ -1071,7 +1071,7 @@ elf_i386_tls_transition (struct bfd_link_info *info, bfd *abfd,
 			 const Elf_Internal_Rela *rel,
 			 const Elf_Internal_Rela *relend,
 			 struct elf_link_hash_entry *h,
-			 unsigned long r_symndx,
+			 unsigned long long r_symndx,
 			 bfd_boolean from_relocate_section)
 {
   unsigned int from_type = *r_type;
@@ -2051,7 +2051,7 @@ elf_i386_relocate_section (bfd *output_bfd,
     {
       unsigned int r_type, r_type_tls;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       struct elf_x86_link_hash_entry *eh;
       Elf_Internal_Sym *sym;
@@ -3937,7 +3937,7 @@ elf_i386_reloc_type_class (const struct bfd_link_info *info,
     {
       /* Check relocation against STT_GNU_IFUNC symbol if there are
 	 dynamic symbols.  */
-      unsigned long r_symndx = ELF32_R_SYM (rela->r_info);
+      unsigned long long r_symndx = ELF32_R_SYM (rela->r_info);
       if (r_symndx != STN_UNDEF)
 	{
 	  Elf_Internal_Sym sym;
@@ -4110,18 +4110,18 @@ static const struct elf_x86_lazy_plt_layout elf_i386_nacl_plt;
 /* Similar to _bfd_elf_get_synthetic_symtab.  Support PLTs with all
    dynamic relocations.   */
 
-static long
+static long long
 elf_i386_get_synthetic_symtab (bfd *abfd,
-			       long symcount ATTRIBUTE_UNUSED,
+			       long long symcount ATTRIBUTE_UNUSED,
 			       asymbol **syms ATTRIBUTE_UNUSED,
-			       long dynsymcount,
+			       long long dynsymcount,
 			       asymbol **dynsyms,
 			       asymbol **ret)
 {
-  long count, i, n;
+  long long count, i, n;
   int j;
   bfd_byte *plt_contents;
-  long relsize;
+  long long relsize;
   const struct elf_x86_lazy_plt_layout *lazy_plt;
   const struct elf_x86_non_lazy_plt_layout *non_lazy_plt;
   const struct elf_x86_lazy_plt_layout *lazy_ibt_plt;
diff --git a/bfd/elf32-ip2k.c b/bfd/elf32-ip2k.c
index 1432f18..7986177 100644
--- a/bfd/elf32-ip2k.c
+++ b/bfd/elf32-ip2k.c
@@ -295,7 +295,7 @@ symbol_value (bfd *abfd,
     }
   else
     {
-      unsigned long indx;
+      unsigned long long indx;
       struct elf_link_hash_entry *h;
 
       indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
@@ -987,8 +987,8 @@ ip2k_elf_relax_section_page (bfd *abfd,
 			     asection *sec,
 			     bfd_boolean *again,
 			     struct misc *misc,
-			     unsigned long page_start,
-			     unsigned long page_end)
+			     unsigned long long page_start,
+			     unsigned long long page_end)
 {
   Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
   Elf_Internal_Rela *irel;
@@ -1070,9 +1070,9 @@ ip2k_elf_relax_section (bfd *abfd,
   bfd_byte *contents = NULL;
   Elf_Internal_Sym *isymbuf = NULL;
   static asection * first_section = NULL;
-  static unsigned long search_addr;
-  static unsigned long page_start = 0;
-  static unsigned long page_end = 0;
+  static unsigned long long search_addr;
+  static unsigned long long page_start = 0;
+  static unsigned long long page_end = 0;
   static unsigned int pass = 0;
   static bfd_boolean new_pass = FALSE;
   static bfd_boolean changed = FALSE;
@@ -1411,7 +1411,7 @@ ip2k_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
diff --git a/bfd/elf32-iq2000.c b/bfd/elf32-iq2000.c
index e616766..b4218cb 100644
--- a/bfd/elf32-iq2000.c
+++ b/bfd/elf32-iq2000.c
@@ -476,7 +476,7 @@ iq2000_elf_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -585,7 +585,7 @@ iq2000_elf_relocate_section (bfd *		     output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
@@ -867,7 +867,7 @@ iq2000_elf_print_private_bfd_data (bfd *abfd, void * ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx:"), (unsigned long) flags);
+  fprintf (file, _("private flags = 0x%lx:"), (unsigned long long) flags);
 
   switch (flags & EF_IQ2000_CPU_MASK)
     {
diff --git a/bfd/elf32-lm32.c b/bfd/elf32-lm32.c
index 027830b..e634d47 100644
--- a/bfd/elf32-lm32.c
+++ b/bfd/elf32-lm32.c
@@ -790,7 +790,7 @@ lm32_elf_relocate_section (bfd *output_bfd,
     {
       reloc_howto_type *howto;
       unsigned int r_type;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -1197,7 +1197,7 @@ lm32_elf_check_relocs (bfd *abfd,
     {
       int r_type;
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       r_type = ELF32_R_TYPE (rel->r_info);
@@ -1381,7 +1381,7 @@ lm32_elf_finish_dynamic_sections (bfd *output_bfd,
 	    }
 	  else
 	    {
-	      unsigned long addr;
+	      unsigned long long addr;
 	      /* addr = .got + 4 */
 	      addr = sgot->output_section->vma + sgot->output_offset + 4;
 	      bfd_put_32 (output_bfd,
@@ -2232,7 +2232,7 @@ lm32_elf_size_dynamic_sections (bfd *output_bfd,
 			{
 			  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
 			  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (ibfd);
-			  unsigned long r_symndx;
+			  unsigned long long r_symndx;
 			  struct elf_link_hash_entry *h;
 
 			  symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
diff --git a/bfd/elf32-m32c.c b/bfd/elf32-m32c.c
index 613844a..0b40315 100644
--- a/bfd/elf32-m32c.c
+++ b/bfd/elf32-m32c.c
@@ -36,7 +36,7 @@ static bfd_boolean m32c_elf_check_relocs
   (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
 static bfd_boolean m32c_elf_relax_delete_bytes (bfd *, asection *, bfd_vma, int);
 #ifdef DEBUG
-char * m32c_get_reloc (long reloc);
+char * m32c_get_reloc (long long reloc);
 void dump_symtab (bfd *, void *, void *);
 #endif
 static bfd_boolean m32c_elf_relax_section
@@ -414,7 +414,7 @@ m32c_elf_relocate_section
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
@@ -677,7 +677,7 @@ m32c_elf_check_relocs
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       bfd_vma *offset;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
@@ -911,7 +911,7 @@ m32c_elf_print_private_bfd_data (bfd *abfd, void *ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx:"), (unsigned long) flags);
+  fprintf (file, _("private flags = 0x%lx:"), (unsigned long long) flags);
 
   switch (flags & EF_M32C_CPU_MASK)
     {
@@ -1064,8 +1064,8 @@ dump_symtab (bfd * abfd, void *internal_syms, void *external_syms)
       printf ("isym = %p st_value = %lx st_size = %lx st_name = (%lu) %s "
 	      "st_info = (%d) %s %s st_other = (%d) %s st_shndx = (%d) %s\n",
 	      isym,
-	      (unsigned long) isym->st_value,
-	      (unsigned long) isym->st_size,
+	      (unsigned long long) isym->st_value,
+	      (unsigned long long) isym->st_size,
 	      isym->st_name,
 	      bfd_elf_string_from_elf_section (abfd, symtab_hdr->sh_link,
 					       isym->st_name),
@@ -1080,7 +1080,7 @@ dump_symtab (bfd * abfd, void *internal_syms, void *external_syms)
 }
 
 char *
-m32c_get_reloc (long reloc)
+m32c_get_reloc (long long reloc)
 {
   if (0 <= reloc && reloc < R_M32C_max)
     return m32c_elf_howto_table[reloc].name;
@@ -1305,7 +1305,7 @@ m32c_offset_for_reloc (bfd *abfd,
     }
   else
     {
-      unsigned long indx;
+      unsigned long long indx;
       struct elf_link_hash_entry *h;
 
       /* An external symbol.  */
diff --git a/bfd/elf32-m32r.c b/bfd/elf32-m32r.c
index 94a4bc9..d01ca2a 100644
--- a/bfd/elf32-m32r.c
+++ b/bfd/elf32-m32r.c
@@ -94,7 +94,7 @@ m32r_elf_do_10_pcrel_reloc (bfd *abfd,
 			    bfd_vma addend)
 {
   bfd_signed_vma relocation;
-  unsigned long x;
+  unsigned long long x;
   bfd_reloc_status_type status;
 
   /* Sanity check the address (offset in section).  */
@@ -232,7 +232,7 @@ m32r_elf_generic_reloc (bfd *input_bfd,
       break;
     case 2:
       {
-	unsigned long x = bfd_get_32 (input_bfd, inplace_address);
+	unsigned long long x = bfd_get_32 (input_bfd, inplace_address);
 	DOIT (x);
 	bfd_put_32 (input_bfd, (bfd_vma)x , inplace_address);
       }
@@ -376,7 +376,7 @@ m32r_elf_relocate_hi16 (bfd *input_bfd,
 			bfd_byte *contents,
 			bfd_vma addend)
 {
-  unsigned long insn;
+  unsigned long long insn;
   bfd_vma addlo;
 
   insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);
@@ -430,9 +430,9 @@ m32r_elf_lo16_reloc (bfd *input_bfd,
       l = m32r_hi16_list;
       while (l != NULL)
 	{
-	  unsigned long insn;
-	  unsigned long val;
-	  unsigned long vallo;
+	  unsigned long long insn;
+	  unsigned long long val;
+	  unsigned long long vallo;
 	  struct m32r_hi16 *next;
 
 	  /* Do the HI16 relocation.  Note that we actually don't need
@@ -2393,7 +2393,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       /* We can't modify r_addend here as elf_link_input_bfd has an assert to
 	 ensure it's zero (we use REL relocs, not RELA).  Therefore this
@@ -3348,7 +3348,7 @@ m32r_elf_finish_dynamic_sections (bfd *output_bfd,
 	    }
 	  else
 	    {
-	      unsigned long addr;
+	      unsigned long long addr;
 	      /* addr = .got + 4 */
 	      addr = sgot->output_section->vma + sgot->output_offset + 4;
 	      bfd_put_32 (output_bfd,
@@ -3407,7 +3407,7 @@ static void
 m32r_elf_final_write_processing (bfd *abfd,
 				 bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
 
   switch (bfd_get_mach (abfd))
     {
@@ -3585,7 +3585,7 @@ m32r_elf_check_relocs (bfd *abfd,
     {
       int r_type;
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       r_type = ELF32_R_TYPE (rel->r_info);
diff --git a/bfd/elf32-m68hc11.c b/bfd/elf32-m68hc11.c
index 95d271f..48ed346 100644
--- a/bfd/elf32-m68hc11.c
+++ b/bfd/elf32-m68hc11.c
@@ -49,7 +49,7 @@ static bfd_boolean m68hc11_elf_relax_section
 static void m68hc11_elf_relax_delete_bytes
   (bfd *, asection *, bfd_vma, int);
 static void m68hc11_relax_group
-  (bfd *, asection *, bfd_byte *, unsigned, unsigned long, unsigned long);
+  (bfd *, asection *, bfd_byte *, unsigned, unsigned long long, unsigned long long);
 static int compare_reloc (const void *, const void *);
 
 /* Use REL instead of RELA to save space */
@@ -568,13 +568,13 @@ compare_reloc (const void *e1, const void *e2)
 
 static void
 m68hc11_relax_group (bfd *abfd, asection *sec, bfd_byte *contents,
-		     unsigned value, unsigned long offset,
-		     unsigned long end_group)
+		     unsigned value, unsigned long long offset,
+		     unsigned long long end_group)
 {
   unsigned char code;
-  unsigned long start_offset;
-  unsigned long ldx_offset = offset;
-  unsigned long ldx_size;
+  unsigned long long start_offset;
+  unsigned long long ldx_offset = offset;
+  unsigned long long ldx_size;
   int can_delete_ldx;
   int relax_ldy = 0;
 
@@ -832,7 +832,7 @@ m68hc11_elf_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
@@ -967,7 +967,7 @@ m68hc11_elf_relax_section (bfd *abfd, asection *sec,
 
 	  if (prev_insn_group)
 	    {
-	      unsigned long old_sec_size = sec->size;
+	      unsigned long long old_sec_size = sec->size;
 
 	      /* Note that we've changed the relocation contents, etc.  */
 	      elf_section_data (sec)->relocs = internal_relocs;
@@ -1156,7 +1156,7 @@ m68hc11_elf_relax_delete_bytes (bfd *abfd, asection *sec,
       unsigned char code;
       unsigned char offset;
       unsigned short raddr;
-      unsigned long old_offset;
+      unsigned long long old_offset;
       int branch_pos;
 
       old_offset = irel->r_offset;
diff --git a/bfd/elf32-m68hc1x.c b/bfd/elf32-m68hc1x.c
index 35152ee..7195090 100644
--- a/bfd/elf32-m68hc1x.c
+++ b/bfd/elf32-m68hc1x.c
@@ -864,7 +864,7 @@ elf32_m68hc11_check_relocs (bfd *abfd, struct bfd_link_info *info,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry * h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
 
@@ -917,7 +917,7 @@ elf32_m68hc11_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   struct m68hc11_page_info *pinfo;
   const struct elf_backend_data * const ebd = get_elf_backend_data (input_bfd);
   struct m68hc11_elf_link_hash_table *htab;
-  unsigned long e_flags;
+  unsigned long long e_flags;
 
   symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
   sym_hashes = elf_sym_hashes (input_bfd);
@@ -939,7 +939,7 @@ elf32_m68hc11_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
       int r_type;
       arelent arel;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       bfd_vma relocation = 0;
@@ -1169,9 +1169,9 @@ elf32_m68hc11_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 		      "as current banked address [%lx:%04lx] (%lx)");
 	      buf = xmalloc (strlen (msg) + 128);
 	      sprintf (buf, msg, phys_page, phys_addr,
-		       (long) (relocation + rel->r_addend),
+		       (long long) (relocation + rel->r_addend),
 		       insn_page, m68hc11_phys_addr (pinfo, insn_addr),
-		       (long) (insn_addr));
+		       (long long) (insn_addr));
 	      (*info->callbacks->warning) (info, buf, name, input_bfd,
 					   input_section, rel->r_offset);
 	      free (buf);
diff --git a/bfd/elf32-m68k.c b/bfd/elf32-m68k.c
index 70532c2..5df7fe4 100644
--- a/bfd/elf32-m68k.c
+++ b/bfd/elf32-m68k.c
@@ -651,7 +651,7 @@ struct elf_m68k_link_hash_entry
   struct elf_m68k_pcrel_relocs_copied *pcrel_relocs_copied;
 
   /* Key to got_entries.  */
-  unsigned long got_entry_key;
+  unsigned long long got_entry_key;
 
   /* List of GOT entries for this symbol.  This list is build during
      offset finalization and is used within elf_m68k_finish_dynamic_symbol
@@ -671,7 +671,7 @@ struct elf_m68k_got_entry_key
   const bfd *bfd;
 
   /* Symbol index.  Either local symbol index or h->got_entry_key.  */
-  unsigned long symndx;
+  unsigned long long symndx;
 
   /* Type is one of R_68K_GOT{8, 16, 32}O, R_68K_TLS_GD{8, 16, 32},
      R_68K_TLS_LDM{8, 16, 32} or R_68K_TLS_IE{8, 16, 32}.
@@ -878,7 +878,7 @@ struct elf_m68k_multi_got
 
   /* Next symndx to assign a global symbol.
      h->got_entry_key is initialized from this counter.  */
-  unsigned long global_symndx;
+  unsigned long long global_symndx;
 };
 
 /* m68k ELF linker hash table.  */
@@ -1058,7 +1058,7 @@ elf_m68k_final_write_processing (bfd *abfd,
 				 bfd_boolean linker ATTRIBUTE_UNUSED)
 {
   int mach = bfd_get_mach (abfd);
-  unsigned long e_flags = elf_elfheader (abfd)->e_flags;
+  unsigned long long e_flags = elf_elfheader (abfd)->e_flags;
 
   if (!e_flags)
     {
@@ -1395,7 +1395,7 @@ elf_m68k_create_empty_got (struct bfd_link_info *info)
 static void
 elf_m68k_init_got_entry_key (struct elf_m68k_got_entry_key *key,
 			     struct elf_link_hash_entry *h,
-			     const bfd *abfd, unsigned long symndx,
+			     const bfd *abfd, unsigned long long symndx,
 			     enum elf_m68k_reloc_type reloc_type)
 {
   if (elf_m68k_reloc_got_type (reloc_type) == R_68K_TLS_LDM32)
@@ -1616,7 +1616,7 @@ elf_m68k_add_entry_to_got (struct elf_m68k_got *got,
 			   struct elf_link_hash_entry *h,
 			   const bfd *abfd,
 			   enum elf_m68k_reloc_type reloc_type,
-			   unsigned long symndx,
+			   unsigned long long symndx,
 			   struct bfd_link_info *info)
 {
   struct elf_m68k_got_entry_key key_;
@@ -2508,7 +2508,7 @@ elf_m68k_check_relocs (bfd *abfd,
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
@@ -3423,7 +3423,7 @@ elf_m68k_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       asection *sec;
@@ -3824,7 +3824,7 @@ elf_m68k_relocate_section (bfd *output_bfd,
 		    }
 		  else
 		    {
-		      long indx;
+		      long long indx;
 
 		      if (bfd_is_abs_section (sec))
 			indx = 0;
@@ -4415,7 +4415,7 @@ bfd_m68k_elf32_create_embedded_relocs (bfd *abfd, struct bfd_link_info *info,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
diff --git a/bfd/elf32-mcore.c b/bfd/elf32-mcore.c
index a88acae..d64584a 100644
--- a/bfd/elf32-mcore.c
+++ b/bfd/elf32-mcore.c
@@ -428,7 +428,7 @@ mcore_elf_relocate_section (bfd * output_bfd,
       reloc_howto_type *	   howto;
       bfd_vma			   relocation;
       Elf_Internal_Sym *	   sym = NULL;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       struct elf_link_hash_entry * h = NULL;
       unsigned short		   oldinst = 0;
 
@@ -499,7 +499,7 @@ mcore_elf_relocate_section (bfd * output_bfd,
 
 #ifdef DEBUG
       fprintf (stderr, "\ttype = %s (%d), symbol index = %ld, offset = %ld, addend = %ld\n",
-	       howto->name, r_type, r_symndx, (long) offset, (long) addend);
+	       howto->name, r_type, r_symndx, (long long) offset, (long long) addend);
 #endif
 
       r = _bfd_final_link_relocate
@@ -602,7 +602,7 @@ mcore_elf_check_relocs (bfd * abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry * h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
 
diff --git a/bfd/elf32-mep.c b/bfd/elf32-mep.c
index 5224d9a..c7922e2 100644
--- a/bfd/elf32-mep.c
+++ b/bfd/elf32-mep.c
@@ -220,8 +220,8 @@ mep_final_link_relocate
      Elf_Internal_Rela * rel,
      bfd_vma		 relocation)
 {
-  unsigned long u;
-  long s;
+  unsigned long long u;
+  long long s;
   unsigned char *byte;
   bfd_vma pc;
   bfd_reloc_status_type r = bfd_reloc_ok;
@@ -259,7 +259,7 @@ mep_final_link_relocate
   if (howto->pc_relative)
     s -= pc;
 
-  u = (unsigned long) s;
+  u = (unsigned long long) s;
 
   switch (howto->type)
     {
@@ -453,7 +453,7 @@ mep_elf_relocate_section
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
@@ -676,15 +676,15 @@ mep_elf_print_private_bfd_data (bfd * abfd, void * ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx"), (unsigned long) flags);
+  fprintf (file, _("private flags = 0x%lx"), (unsigned long long) flags);
 
   partial_flags = (flags & EF_MEP_CPU_MASK) >> 24;
   if (partial_flags < ARRAY_SIZE (core_names))
-    fprintf (file, "  core: %s", core_names[(long)partial_flags]);
+    fprintf (file, "  core: %s", core_names[(long long)partial_flags]);
 
   partial_flags = flags & EF_MEP_INDEX_MASK;
   if (partial_flags < ARRAY_SIZE (config_names))
-    fprintf (file, "  me_module: %s", config_names[(long)partial_flags]);
+    fprintf (file, "  me_module: %s", config_names[(long long)partial_flags]);
 
   fputc ('\n', file);
 
diff --git a/bfd/elf32-metag.c b/bfd/elf32-metag.c
index efe95bd..abc80a1 100644
--- a/bfd/elf32-metag.c
+++ b/bfd/elf32-metag.c
@@ -1488,7 +1488,7 @@ elf_metag_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_metag_link_hash_entry *hh;
@@ -2095,7 +2095,7 @@ elf_metag_check_relocs (bfd *abfd,
       int r_type;
       struct elf_metag_link_hash_entry *hh;
       Elf_Internal_Sym *isym;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       r_type = ELF32_R_TYPE (rel->r_info);
@@ -3332,7 +3332,7 @@ elf_metag_finish_dynamic_sections (bfd *output_bfd,
       splt = htab->etab.splt;
       if (splt && splt->size > 0)
 	{
-	  unsigned long addr;
+	  unsigned long long addr;
 	  /* addr = .got + 4 */
 	  addr = (htab->etab.sgot->output_section->vma
 		  + htab->etab.sgot->output_offset + 4);
diff --git a/bfd/elf32-microblaze.c b/bfd/elf32-microblaze.c
index 3d131bc..49c73b7 100644
--- a/bfd/elf32-microblaze.c
+++ b/bfd/elf32-microblaze.c
@@ -859,8 +859,8 @@ dtprel_base (struct bfd_link_info *info)
 static void
 microblaze_elf_output_dynamic_relocation (bfd *output_bfd,
 					  asection *sreloc,
-					  unsigned long reloc_index,
-					  unsigned long indx,
+					  unsigned long long reloc_index,
+					  unsigned long long indx,
 					  int r_type,
 					  bfd_vma offset,
 					  bfd_vma addend)
@@ -948,7 +948,7 @@ microblaze_elf_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       bfd_vma addend = rel->r_addend;
       bfd_vma offset = rel->r_offset;
       struct elf_link_hash_entry *h;
@@ -1231,7 +1231,7 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 	      {
 		bfd_vma *offp;
 		bfd_vma off, off2;
-		unsigned long indx;
+		unsigned long long indx;
 		bfd_vma static_value;
 
 		bfd_boolean need_relocs = FALSE;
@@ -1681,7 +1681,7 @@ calc_fixup (bfd_vma start, bfd_vma size, asection *sec)
 static void
 microblaze_bfd_write_imm_value_32 (bfd *abfd, bfd_byte *bfd_addr, bfd_vma val)
 {
-    unsigned long instr = bfd_get_32 (abfd, bfd_addr);
+    unsigned long long instr = bfd_get_32 (abfd, bfd_addr);
     instr &= ~0x0000ffff;
     instr |= (val & 0x0000ffff);
     bfd_put_32 (abfd, instr, bfd_addr);
@@ -1692,8 +1692,8 @@ microblaze_bfd_write_imm_value_32 (bfd *abfd, bfd_byte *bfd_addr, bfd_vma val)
 static void
 microblaze_bfd_write_imm_value_64 (bfd *abfd, bfd_byte *bfd_addr, bfd_vma val)
 {
-    unsigned long instr_hi;
-    unsigned long instr_lo;
+    unsigned long long instr_hi;
+    unsigned long long instr_lo;
 
     instr_hi = bfd_get_32 (abfd, bfd_addr);
     instr_hi &= ~0x0000ffff;
@@ -1817,7 +1817,7 @@ microblaze_elf_relax_section (bfd *abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
@@ -2075,7 +2075,7 @@ microblaze_elf_relax_section (bfd *abfd,
 			    }
 			}
 
-		      unsigned long instr = bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+		      unsigned long long instr = bfd_get_32 (abfd, ocontents + irelscan->r_offset);
 		      immediate = instr & 0x0000ffff;
 		      target_address = immediate;
 		      offset = calc_fixup (target_address, 0, sec);
@@ -2120,9 +2120,9 @@ microblaze_elf_relax_section (bfd *abfd,
 			      elf_section_data (o)->this_hdr.contents = ocontents;
 			    }
 			}
-	  unsigned long instr_hi =  bfd_get_32 (abfd, ocontents
+	  unsigned long long instr_hi =  bfd_get_32 (abfd, ocontents
 						+ irelscan->r_offset);
-	  unsigned long instr_lo =  bfd_get_32 (abfd, ocontents
+	  unsigned long long instr_lo =  bfd_get_32 (abfd, ocontents
 						+ irelscan->r_offset
 						+ INST_WORD_SIZE);
 	  immediate = (instr_hi & 0x0000ffff) << 16;
@@ -2164,9 +2164,9 @@ microblaze_elf_relax_section (bfd *abfd,
 			      elf_section_data (o)->this_hdr.contents = ocontents;
 			    }
 			}
-	  unsigned long instr_hi =  bfd_get_32 (abfd, ocontents
+	  unsigned long long instr_hi =  bfd_get_32 (abfd, ocontents
 						+ irelscan->r_offset);
-	  unsigned long instr_lo =  bfd_get_32 (abfd, ocontents
+	  unsigned long long instr_lo =  bfd_get_32 (abfd, ocontents
 						+ irelscan->r_offset
 						+ INST_WORD_SIZE);
 	  immediate = (instr_hi & 0x0000ffff) << 16;
@@ -2308,7 +2308,7 @@ microblaze_elf_gc_mark_hook (asection *sec,
 static bfd_boolean
 update_local_sym_info (bfd *abfd,
 		       Elf_Internal_Shdr *symtab_hdr,
-		       unsigned long r_symndx,
+		       unsigned long long r_symndx,
 		       unsigned int tls_type)
 {
   bfd_signed_vma *local_got_refcounts = elf_local_got_refcounts (abfd);
@@ -2367,7 +2367,7 @@ microblaze_elf_check_relocs (bfd * abfd,
     {
       unsigned int r_type;
       struct elf_link_hash_entry * h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       unsigned char tls_type = 0;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
diff --git a/bfd/elf32-mips.c b/bfd/elf32-mips.c
index 23a5712..2560016 100644
--- a/bfd/elf32-mips.c
+++ b/bfd/elf32-mips.c
@@ -1895,7 +1895,7 @@ mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry,
 {
   bfd_reloc_status_type r;
   arelent reloc32;
-  unsigned long val;
+  unsigned long long val;
   bfd_size_type addr;
 
   /* Do a normal 32 bit relocation on the lower 32 bits.  */
@@ -2290,7 +2290,7 @@ mips_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
 static bfd_boolean
 mips_elf32_object_p (bfd *abfd)
 {
-  unsigned long mach;
+  unsigned long long mach;
 
   if (ABI_N32_P (abfd))
     return FALSE;
@@ -2401,13 +2401,13 @@ elf32_mips_write_core_note (bfd *abfd, char *buf, int *bufsiz, int note_type,
       {
 	char data[256];
 	va_list ap;
-	long pid;
+	long long pid;
 	int cursig;
 	const void *greg;
 
 	va_start (ap, note_type);
 	memset (data, 0, 72);
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	bfd_put_32 (abfd, pid, data + 24);
 	cursig = va_arg (ap, int);
 	bfd_put_16 (abfd, cursig, data + 12);
diff --git a/bfd/elf32-moxie.c b/bfd/elf32-moxie.c
index d8b549d..dba7b6a 100644
--- a/bfd/elf32-moxie.c
+++ b/bfd/elf32-moxie.c
@@ -219,7 +219,7 @@ moxie_elf_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -348,7 +348,7 @@ moxie_elf_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
diff --git a/bfd/elf32-msp430.c b/bfd/elf32-msp430.c
index 2d351d3..c5dcf6b 100644
--- a/bfd/elf32-msp430.c
+++ b/bfd/elf32-msp430.c
@@ -689,7 +689,7 @@ elf32_msp430_check_relocs (bfd * abfd, struct bfd_link_info * info,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -1285,7 +1285,7 @@ elf32_msp430_relocate_section (bfd * output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -1389,7 +1389,7 @@ static void
 bfd_elf_msp430_final_write_processing (bfd * abfd,
 				       bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
 
   switch (bfd_get_mach (abfd))
     {
@@ -1920,7 +1920,7 @@ msp430_elf_relax_section (bfd * abfd, asection * sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
@@ -2083,7 +2083,7 @@ msp430_elf_relax_section (bfd * abfd, asection * sec,
 	  }
 	else
 	  {
-	    unsigned long indx;
+	    unsigned long long indx;
 	    struct elf_link_hash_entry *h;
 
 	    /* An external symbol.  */
@@ -2127,7 +2127,7 @@ msp430_elf_relax_section (bfd * abfd, asection * sec,
 	    /* See if the value will fit in 10 bits, note the high value is
 	       1016 as the target will be two bytes closer if we are
 	       able to relax.  */
-	    if ((long) value < 1016 && (long) value > -1016)
+	    if ((long long) value < 1016 && (long long) value > -1016)
 	      {
 		int code0 = 0, code1 = 0, code2 = 0;
 		int i;
@@ -2242,7 +2242,7 @@ msp430_elf_relax_section (bfd * abfd, asection * sec,
 	    /* See if the value will fit in 10 bits, note the high value is
 	       1016 as the target will be two bytes closer if we are
 	       able to relax.  */
-	    if ((long) value < 1016 && (long) value > -1016)
+	    if ((long long) value < 1016 && (long long) value > -1016)
 	      {
 		int code2;
 
diff --git a/bfd/elf32-mt.c b/bfd/elf32-mt.c
index 94c2fac..a9a1b07 100644
--- a/bfd/elf32-mt.c
+++ b/bfd/elf32-mt.c
@@ -320,7 +320,7 @@ mt_elf_relocate_section
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
@@ -446,7 +446,7 @@ mt_elf_check_relocs
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -559,7 +559,7 @@ mt_elf_print_private_bfd_data (bfd * abfd, void * ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx:"), (unsigned long) flags);
+  fprintf (file, _("private flags = 0x%lx:"), (unsigned long long) flags);
 
   switch (flags & EF_MT_CPU_MASK)
     {
diff --git a/bfd/elf32-nds32.c b/bfd/elf32-nds32.c
index 1b30d12..5ab0997 100644
--- a/bfd/elf32-nds32.c
+++ b/bfd/elf32-nds32.c
@@ -146,7 +146,7 @@ enum
 #define CONSERVATIVE_20BIT	(0x80000 - 0x1000)
 
 /* Size of small data/bss sections, used to calculate SDA_BASE.  */
-static long got_size = 0;
+static long long got_size = 0;
 static int is_SDA_BASE_set = 0;
 
 /* Convert ELF-VER in eflags to string for debugging purpose.  */
@@ -2429,7 +2429,7 @@ nds32_elf_relocate_hi20 (bfd *input_bfd ATTRIBUTE_UNUSED,
 			 Elf_Internal_Rela *rello, bfd_byte *contents,
 			 bfd_vma addend)
 {
-  unsigned long insn;
+  unsigned long long insn;
   bfd_vma addlo;
 
   insn = bfd_getb32 (contents + relhi->r_offset);
@@ -2469,9 +2469,9 @@ nds32_elf_lo12_reloc (bfd *input_bfd, arelent *reloc_entry, asymbol *symbol,
       l = nds32_hi20_list;
       while (l != NULL)
 	{
-	  unsigned long insn;
-	  unsigned long val;
-	  unsigned long vallo;
+	  unsigned long long insn;
+	  unsigned long long val;
+	  unsigned long long vallo;
 	  struct nds32_hi20 *next;
 
 	  /* Do the HI20 relocation.  Note that we actually don't need
@@ -2610,7 +2610,7 @@ nds32_elf_generic_reloc (bfd *input_bfd, arelent *reloc_entry,
       break;
     case 2:
       {
-	unsigned long x = bfd_getb32 (inplace_address);
+	unsigned long long x = bfd_getb32 (inplace_address);
 
 	DOIT (x);
 	bfd_putb32 ((bfd_vma) x, inplace_address);
@@ -3092,7 +3092,7 @@ nds32_elf_final_sda_base (bfd *output_bfd, struct bfd_link_info *info,
   int relax_fp_as_gp;
   struct elf_nds32_link_hash_table *table;
   struct bfd_link_hash_entry *h, *h2;
-  long unsigned int total = 0;
+  long long unsigned int total = 0;
 
   h = bfd_link_hash_lookup (info->hash, "_SDA_BASE_", FALSE, FALSE, TRUE);
   if (!h || (h->type != bfd_link_hash_defined && h->type != bfd_link_hash_defweak))
@@ -4290,7 +4290,7 @@ nds32_elf_output_symbol_hook (struct bfd_link_info *info,
 
       fprintf (sym_ld_script, "\t%s = 0x%08lx;\t /* %s */\n",
 	       h->root.root.string,
-	       (long) (h->root.u.def.value
+	       (long long) (h->root.u.def.value
 		+ h->root.u.def.section->output_section->vma
 		+ h->root.u.def.section->output_offset), source);
     }
@@ -4402,7 +4402,7 @@ nds32_elf_relocate_section (bfd *		   output_bfd ATTRIBUTE_UNUSED,
     {
       enum elf_nds32_reloc_type r_type;
       reloc_howto_type *howto = NULL;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h = NULL;
       Elf_Internal_Sym *sym = NULL;
       asection *sec;
@@ -5370,7 +5370,7 @@ nds32_elf_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,
       /* Fill in the entry in the procedure linkage table.  */
       if (!bfd_link_pic (info))
 	{
-	  unsigned long insn;
+	  unsigned long long insn;
 
 	  insn = PLT_ENTRY_WORD0 + (((sgot->output_section->vma
 				      + sgot->output_offset + got_offset) >> 12)
@@ -5396,8 +5396,8 @@ nds32_elf_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,
       else
 	{
 	  /* sda_base must be set at this time.  */
-	  unsigned long insn;
-	  long offset;
+	  unsigned long long insn;
+	  long long offset;
 
 	  /* FIXME, sda_base is 65536, it will damage opcode.  */
 	  /* insn = PLT_PIC_ENTRY_WORD0 + (((got_offset - sda_base) >> 2) & 0x7fff); */
@@ -5592,8 +5592,8 @@ nds32_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
 	{
 	  if (bfd_link_pic (info))
 	    {
-	      unsigned long insn;
-	      long offset;
+	      unsigned long long insn;
+	      long long offset;
 
 	      /* FIXME, sda_base is 65536, it will damage opcode.  */
 	      /* insn = PLT_PIC_ENTRY_WORD0 + (((got_offset - sda_base) >> 2) & 0x7fff); */
@@ -5621,8 +5621,8 @@ nds32_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
 	    }
 	  else
 	    {
-	      unsigned long insn;
-	      unsigned long addr;
+	      unsigned long long insn;
+	      unsigned long long addr;
 
 	      /* addr = .got + 4 */
 	      addr = sgot->output_section->vma + sgot->output_offset + 4;
@@ -5708,7 +5708,7 @@ static void
 nds32_elf_final_write_processing (bfd *abfd,
 				  bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
   static unsigned int cur_mach = 0;
 
   if (bfd_mach_n1 != bfd_get_mach (abfd))
@@ -6097,7 +6097,7 @@ nds32_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
     {
       enum elf_nds32_reloc_type r_type;
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       int tls_type, old_tls_type;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
@@ -6465,7 +6465,7 @@ calculate_offset (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
     }
   else
     {
-      unsigned long indx;
+      unsigned long long indx;
       struct elf_link_hash_entry *h;
       bfd *owner;
 
@@ -6534,7 +6534,7 @@ calculate_plt_memory_address (bfd *abfd, struct bfd_link_info *link_info,
     }
   else
     {
-      unsigned long indx;
+      unsigned long long indx;
       struct elf_link_hash_entry *h;
       struct elf_nds32_link_hash_table *htab;
       asection *splt;
@@ -6594,7 +6594,7 @@ nds32_convert_32_to_16_alu1 (bfd *abfd, uint32_t insn, uint16_t *pinsn16,
 {
   uint16_t insn16 = 0;
   int insn_type = 0;
-  unsigned long mach = bfd_get_mach (abfd);
+  unsigned long long mach = bfd_get_mach (abfd);
 
   if (N32_SH5 (insn) != 0)
     return 0;
@@ -6771,7 +6771,7 @@ nds32_convert_32_to_16_alu2 (bfd *abfd, uint32_t insn, uint16_t *pinsn16,
 {
   uint16_t insn16 = 0;
   int insn_type;
-  unsigned long mach = bfd_get_mach (abfd);
+  unsigned long long mach = bfd_get_mach (abfd);
 
   /* TODO: bset, bclr, btgl, btst.  */
   if (__GF (insn, 6, 4) != 0)
@@ -6809,7 +6809,7 @@ nds32_convert_32_to_16 (bfd *abfd, uint32_t insn, uint16_t *pinsn16,
   int op6;
   uint16_t insn16 = 0;
   int insn_type = 0;
-  unsigned long mach = bfd_get_mach (abfd);
+  unsigned long long mach = bfd_get_mach (abfd);
 
   /* Decode 32-bit instruction.  */
   if (insn & 0x80000000)
@@ -7266,7 +7266,7 @@ done:
 }
 
 static int
-special_convert_32_to_16 (unsigned long insn, uint16_t *pinsn16,
+special_convert_32_to_16 (unsigned long long insn, uint16_t *pinsn16,
 			  Elf_Internal_Rela *reloc)
 {
   uint16_t insn16 = 0;
@@ -7314,7 +7314,7 @@ int
 nds32_convert_16_to_32 (bfd *abfd, uint16_t insn16, uint32_t *pinsn)
 {
   uint32_t insn = 0xffffffff;
-  unsigned long mach = bfd_get_mach (abfd);
+  unsigned long long mach = bfd_get_mach (abfd);
 
   /* NOTE: push25, pop25 and movd44 do not have 32-bit variants.  */
 
@@ -7585,7 +7585,7 @@ done:
 }
 
 static bfd_boolean
-is_sda_access_insn (unsigned long insn)
+is_sda_access_insn (unsigned long long insn)
 {
   switch (N32_OP6 (insn))
     {
@@ -7608,7 +7608,7 @@ is_sda_access_insn (unsigned long insn)
   return FALSE;
 }
 
-static unsigned long
+static unsigned long long
 turn_insn_to_sda_access (uint32_t insn, bfd_signed_vma type, uint32_t *pinsn)
 {
   uint32_t oinsn = 0;
@@ -7760,7 +7760,7 @@ calculate_memory_address (bfd *abfd, Elf_Internal_Rela *irel,
     }
   else
     {
-      unsigned long indx;
+      unsigned long long indx;
       struct elf_link_hash_entry *h;
 
       /* An external symbol.  */
@@ -8406,10 +8406,10 @@ nds32_elf_relax_delete_blanks (bfd *abfd, asection *sec,
 	      && ELF32_R_TYPE (irel->r_info) <= R_NDS32_DIFF32
 	      && isym[ELF32_R_SYM (irel->r_info)].st_shndx == sec_shndx)
 	    {
-	      unsigned long val = 0;
-	      unsigned long mask;
-	      long before, between;
-	      long offset = 0;
+	      unsigned long long val = 0;
+	      unsigned long long mask;
+	      long long before, between;
+	      long long offset = 0;
 
 	      switch (ELF32_R_TYPE (irel->r_info))
 		{
@@ -8471,7 +8471,7 @@ nds32_elf_relax_delete_blanks (bfd *abfd, asection *sec,
 	    {
 	      bfd_vma val = 0;
 	      unsigned int len = 0;
-	      unsigned long before, between;
+	      unsigned long long before, between;
 	      bfd_byte *endp, *p;
 
 	      val = _bfd_read_unsigned_leb128 (abfd, contents + irel->r_offset,
@@ -8697,7 +8697,7 @@ static int
 nds32_elf_insn_size (bfd *abfd ATTRIBUTE_UNUSED,
 		     bfd_byte *contents, bfd_vma addr)
 {
-  unsigned long insn = bfd_getb32 (contents + addr);
+  unsigned long long insn = bfd_getb32 (contents + addr);
 
   if (insn & 0x80000000)
     return 2;
@@ -9122,7 +9122,7 @@ nds32_elf_relax_longjump1 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
   int pic_ext_target = 0;
   bfd_signed_vma foff;
   uint16_t insn16;
-  unsigned long reloc;
+  unsigned long long reloc;
 
   irelend = internal_relocs + sec->reloc_count;
   seq_len = GET_SEQ_LEN (irel->r_addend);
@@ -9317,7 +9317,7 @@ nds32_elf_relax_longjump2 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
   bfd_signed_vma foff;
   uint32_t insn, re_insn = 0;
   uint16_t insn16, re_insn16 = 0;
-  unsigned long reloc, cond_reloc;
+  unsigned long long reloc, cond_reloc;
 
   enum elf_nds32_reloc_type checked_types[] =
     { R_NDS32_15_PCREL_RELA, R_NDS32_9_PCREL_RELA };
@@ -9502,7 +9502,7 @@ nds32_elf_relax_longjump3 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
   bfd_signed_vma foff;
   uint32_t insn, re_insn = 0;
   uint16_t insn16, re_insn16 = 0;
-  unsigned long reloc, cond_reloc;
+  unsigned long long reloc, cond_reloc;
 
   irelend = internal_relocs + sec->reloc_count;
   seq_len = GET_SEQ_LEN (irel->r_addend);
@@ -10109,7 +10109,7 @@ nds32_elf_relax_longjump5 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
   bfd_signed_vma foff;
   uint32_t insn, re_insn = 0;
   uint16_t insn16, re_insn16 = 0;
-  unsigned long reloc;
+  unsigned long long reloc;
 
   enum elf_nds32_reloc_type checked_types[] =
     { R_NDS32_17_PCREL_RELA, R_NDS32_15_PCREL_RELA,
@@ -10243,7 +10243,7 @@ nds32_elf_relax_longjump6 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
   bfd_signed_vma foff;
   uint32_t insn, re_insn = 0;
   uint16_t insn16, re_insn16 = 0;
-  unsigned long reloc;
+  unsigned long long reloc;
 
   irelend = internal_relocs + sec->reloc_count;
   laddr = irel->r_offset;
@@ -10670,7 +10670,7 @@ nds32_elf_relax_lo12 (struct bfd_link_info *link_info, bfd *abfd,
 {
   uint32_t insn;
   bfd_vma local_sda, laddr;
-  unsigned long reloc;
+  unsigned long long reloc;
   bfd_vma access_addr;
   bfd_vma range_l = 0, range_h = 0;	/* Upper/lower bound.  */
   Elf_Internal_Rela *irelfn = NULL, *irelend;
@@ -10780,7 +10780,7 @@ nds32_elf_relax_piclo12 (struct bfd_link_info *link_info, bfd *abfd,
   uint32_t insn;
   bfd_vma local_sda, laddr;
   bfd_signed_vma foff;
-  unsigned long reloc;
+  unsigned long long reloc;
 
   nds32_elf_final_sda_base (sec->output_section->owner, link_info,
 			    &local_sda, FALSE);
@@ -10837,7 +10837,7 @@ nds32_elf_relax_letlslo12 (struct bfd_link_info *link_info, bfd *abfd,
   uint32_t insn;
   bfd_vma laddr;
   bfd_signed_vma foff;
-  unsigned long reloc;
+  unsigned long long reloc;
 
   laddr = irel->r_offset;
   foff = calculate_memory_address (abfd, irel, isymbuf, symtab_hdr);
@@ -12546,9 +12546,9 @@ nds32_elf_get_relocated_section_contents (bfd *abfd,
 {
   bfd *input_bfd = link_order->u.indirect.section->owner;
   asection *input_section = link_order->u.indirect.section;
-  long reloc_size;
+  long long reloc_size;
   arelent **reloc_vector;
-  long reloc_count;
+  long long reloc_count;
 
   reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
   if (reloc_size < 0)
diff --git a/bfd/elf32-nios2.c b/bfd/elf32-nios2.c
index e160054..abf5eb7 100644
--- a/bfd/elf32-nios2.c
+++ b/bfd/elf32-nios2.c
@@ -3709,7 +3709,7 @@ nios2_elf32_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -4665,7 +4665,7 @@ nios2_elf32_copy_indirect_symbol (struct bfd_link_info *info,
 static bfd_boolean
 nios2_elf32_object_p (bfd *abfd)
 {
-  unsigned long mach;
+  unsigned long long mach;
 
   mach = elf_elfheader (abfd)->e_flags;
 
@@ -4715,7 +4715,7 @@ nios2_elf32_check_relocs (bfd *abfd, struct bfd_link_info *info,
     {
       unsigned int r_type;
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
diff --git a/bfd/elf32-or1k.c b/bfd/elf32-or1k.c
index 91b780f..d0edc17 100644
--- a/bfd/elf32-or1k.c
+++ b/bfd/elf32-or1k.c
@@ -803,7 +803,7 @@ or1k_elf_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -1327,7 +1327,7 @@ or1k_elf_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       unsigned char tls_type;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
@@ -1683,7 +1683,7 @@ or1k_elf_finish_dynamic_sections (bfd *output_bfd,
 	    }
 	  else
 	    {
-	      unsigned long addr;
+	      unsigned long long addr;
 	      /* addr = .got + 4 */
 	      addr = sgot->output_section->vma + sgot->output_offset + 4;
 	      bfd_put_32 (output_bfd,
@@ -2575,7 +2575,7 @@ or1k_elf_copy_indirect_symbol (struct bfd_link_info *info,
 static bfd_boolean
 or1k_elf_object_p (bfd *abfd)
 {
-  unsigned long mach = bfd_mach_or1k;
+  unsigned long long mach = bfd_mach_or1k;
 
   if (elf_elfheader (abfd)->e_flags & EF_OR1K_NODELAY)
     mach = bfd_mach_or1knd;
diff --git a/bfd/elf32-pj.c b/bfd/elf32-pj.c
index 470d20a..317008c 100644
--- a/bfd/elf32-pj.c
+++ b/bfd/elf32-pj.c
@@ -38,7 +38,7 @@ pj_elf_reloc (bfd *abfd,
 	      bfd *output_bfd,
 	      char **error_message ATTRIBUTE_UNUSED)
 {
-  unsigned long insn;
+  unsigned long long insn;
   bfd_vma sym_value;
   enum elf_pj_reloc_type r_type;
   bfd_vma addr = reloc_entry->address;
diff --git a/bfd/elf32-ppc.c b/bfd/elf32-ppc.c
index a97e127..23fbecf 100644
--- a/bfd/elf32-ppc.c
+++ b/bfd/elf32-ppc.c
@@ -2093,7 +2093,7 @@ ppc_elf_addr16_ha_reloc (bfd *abfd,
 			 char **error_message ATTRIBUTE_UNUSED)
 {
   enum elf_ppc_reloc_type r_type;
-  long insn;
+  long long insn;
   bfd_size_type octets;
   bfd_vma value;
 
@@ -2222,7 +2222,7 @@ ppc_elf_mkobject (bfd *abfd)
 bfd_boolean
 _bfd_elf_ppc_set_arch (bfd *abfd)
 {
-  unsigned long mach = 0;
+  unsigned long long mach = 0;
   asection *s;
   unsigned char *contents;
 
@@ -2430,13 +2430,13 @@ ppc_elf_write_core_note (bfd *abfd, char *buf, int *bufsiz, int note_type, ...)
       {
 	char data[268];
 	va_list ap;
-	long pid;
+	long long pid;
 	int cursig;
 	const void *greg;
 
 	va_start (ap, note_type);
 	memset (data, 0, 72);
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	bfd_put_32 (abfd, pid, data + 24);
 	cursig = va_arg (ap, int);
 	bfd_put_16 (abfd, cursig, data + 12);
@@ -2669,7 +2669,7 @@ ppc_elf_get_sec_type_attr (bfd *abfd, asection *sec)
 typedef struct apuinfo_list
 {
   struct apuinfo_list *next;
-  unsigned long value;
+  unsigned long long value;
 }
 apuinfo_list;
 
@@ -2684,7 +2684,7 @@ apuinfo_list_init (void)
 }
 
 static void
-apuinfo_list_add (unsigned long value)
+apuinfo_list_add (unsigned long long value)
 {
   apuinfo_list *entry = head;
 
@@ -2708,7 +2708,7 @@ static unsigned
 apuinfo_list_length (void)
 {
   apuinfo_list *entry;
-  unsigned long count;
+  unsigned long long count;
 
   for (entry = head, count = 0;
        entry;
@@ -2718,8 +2718,8 @@ apuinfo_list_length (void)
   return count;
 }
 
-static inline unsigned long
-apuinfo_list_element (unsigned long number)
+static inline unsigned long long
+apuinfo_list_element (unsigned long long number)
 {
   apuinfo_list * entry;
 
@@ -2757,7 +2757,7 @@ ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
   char *buffer = NULL;
   bfd_size_type largest_input_size = 0;
   unsigned i;
-  unsigned long length;
+  unsigned long long length;
   const char *error_message = NULL;
 
   if (link_info == NULL)
@@ -2768,7 +2768,7 @@ ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
   /* Read in the input sections contents.  */
   for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link.next)
     {
-      unsigned long datum;
+      unsigned long long datum;
 
       asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
       if (asec == NULL)
@@ -2939,9 +2939,9 @@ section_covers_vma (bfd *abfd ATTRIBUTE_UNUSED, asection *section, void *ptr)
 	  && vma < section->vma + section->size);
 }
 
-static long
-ppc_elf_get_synthetic_symtab (bfd *abfd, long symcount, asymbol **syms,
-			      long dynsymcount, asymbol **dynsyms,
+static long long
+ppc_elf_get_synthetic_symtab (bfd *abfd, long long symcount, asymbol **syms,
+			      long long dynsymcount, asymbol **dynsyms,
 			      asymbol **ret)
 {
   bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
@@ -2951,7 +2951,7 @@ ppc_elf_get_synthetic_symtab (bfd *abfd, long symcount, asymbol **syms,
   bfd_vma stub_off;
   asymbol *s;
   arelent *p;
-  long count, i, stub_delta;
+  long long count, i, stub_delta;
   size_t size;
   char *names;
   bfd_byte buf[4];
@@ -3829,7 +3829,7 @@ elf_allocate_pointer_linker_section (bfd *abfd,
 {
   elf_linker_section_pointers_t **ptr_linker_section_ptr = NULL;
   elf_linker_section_pointers_t *linker_section_ptr;
-  unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
+  unsigned long long r_symndx = ELF32_R_SYM (rel->r_info);
   bfd_size_type amt;
 
   BFD_ASSERT (lsect != NULL);
@@ -3901,8 +3901,8 @@ elf_allocate_pointer_linker_section (bfd *abfd,
 #ifdef DEBUG
   fprintf (stderr,
 	   "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
-	   lsect->name, (long) linker_section_ptr->offset,
-	   (long) lsect->section->size);
+	   lsect->name, (long long) linker_section_ptr->offset,
+	   (long long) lsect->section->size);
 #endif
 
   return TRUE;
@@ -3911,7 +3911,7 @@ elf_allocate_pointer_linker_section (bfd *abfd,
 static struct plt_entry **
 update_local_sym_info (bfd *abfd,
 		       Elf_Internal_Shdr *symtab_hdr,
-		       unsigned long r_symndx,
+		       unsigned long long r_symndx,
 		       int tls_type)
 {
   bfd_signed_vma *local_got_refcounts = elf_local_got_refcounts (abfd);
@@ -4076,7 +4076,7 @@ ppc_elf_check_relocs (bfd *abfd,
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       enum elf_ppc_reloc_type r_type;
       struct elf_link_hash_entry *h;
       int tls_type;
@@ -5013,7 +5013,7 @@ ppc_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 static void
 ppc_elf_vle_split16 (bfd *input_bfd,
 		     asection *input_section,
-		     unsigned long offset,
+		     unsigned long long offset,
 		     bfd_byte *loc,
 		     bfd_vma value,
 		     split16_format_type split16_format,
@@ -5205,7 +5205,7 @@ get_sym_h (struct elf_link_hash_entry **hp,
 	   asection **symsecp,
 	   unsigned char **tls_maskp,
 	   Elf_Internal_Sym **locsymsp,
-	   unsigned long r_symndx,
+	   unsigned long long r_symndx,
 	   bfd *ibfd)
 {
   Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);
@@ -5365,7 +5365,7 @@ ppc_elf_inline_plt (struct bfd_link_info *info)
 	    for (rel = relstart; rel < relend; )
 	      {
 		enum elf_ppc_reloc_type r_type;
-		unsigned long r_symndx;
+		unsigned long long r_symndx;
 		asection *sym_sec;
 		struct elf_link_hash_entry *h;
 		Elf_Internal_Sym *sym;
@@ -5567,7 +5567,7 @@ ppc_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED,
 	      for (rel = relstart; rel < relend; rel++)
 		{
 		  enum elf_ppc_reloc_type r_type;
-		  unsigned long r_symndx;
+		  unsigned long long r_symndx;
 		  struct elf_link_hash_entry *h = NULL;
 		  unsigned char *tls_mask;
 		  unsigned char tls_set, tls_clear;
@@ -7310,14 +7310,14 @@ ppc_elf_relax_section (bfd *abfd,
       irelend = internal_relocs + isec->reloc_count;
       for (irel = internal_relocs; irel < irelend; irel++)
 	{
-	  unsigned long r_type = ELF32_R_TYPE (irel->r_info);
+	  unsigned long long r_type = ELF32_R_TYPE (irel->r_info);
 	  bfd_vma toff, roff;
 	  asection *tsec;
 	  struct one_branch_fixup *f;
 	  size_t insn_offset = 0;
 	  bfd_vma max_branch_offset = 0, val;
 	  bfd_byte *hit_addr;
-	  unsigned long t0;
+	  unsigned long long t0;
 	  struct elf_link_hash_entry *h;
 	  Elf_Internal_Sym *isym;
 	  struct plt_entry **plist;
@@ -7373,7 +7373,7 @@ ppc_elf_relax_section (bfd *abfd,
 	      else if (h->root.type == bfd_link_hash_undefined
 		       || h->root.type == bfd_link_hash_undefweak)
 		{
-		  unsigned long indx;
+		  unsigned long long indx;
 
 		  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
 		  tsec = bfd_und_section_ptr;
@@ -7389,8 +7389,8 @@ ppc_elf_relax_section (bfd *abfd,
 		  && h == htab->tls_get_addr
 		  && irel != internal_relocs)
 		{
-		  unsigned long t_symndx = ELF32_R_SYM (irel[-1].r_info);
-		  unsigned long t_rtype = ELF32_R_TYPE (irel[-1].r_info);
+		  unsigned long long t_symndx = ELF32_R_SYM (irel[-1].r_info);
+		  unsigned long long t_rtype = ELF32_R_TYPE (irel[-1].r_info);
 		  unsigned int tls_mask = 0;
 
 		  /* The previous reloc should be one of R_PPC_TLSGD or
@@ -7575,7 +7575,7 @@ ppc_elf_relax_section (bfd *abfd,
 	  if (f == NULL)
 	    {
 	      size_t size;
-	      unsigned long stub_rtype;
+	      unsigned long long stub_rtype;
 
 	      val = trampoff - roff;
 	      if (val >= max_branch_offset)
@@ -7834,7 +7834,7 @@ elf_finish_pointer_linker_section (bfd *input_bfd,
   else
     {
       /* Handle local symbol.  */
-      unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
+      unsigned long long r_symndx = ELF32_R_SYM (rel->r_info);
 
       BFD_ASSERT (is_ppc_elf (input_bfd));
       BFD_ASSERT (elf_local_ptr_offsets (input_bfd) != NULL);
@@ -7864,7 +7864,7 @@ elf_finish_pointer_linker_section (bfd *input_bfd,
 #ifdef DEBUG
   fprintf (stderr,
 	   "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
-	   lsect->name, (long) relocation, (long) relocation);
+	   lsect->name, (long long) relocation, (long long) relocation);
 #endif
 
   return relocation;
@@ -8121,7 +8121,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
   _bfd_error_handler ("ppc_elf_relocate_section called for %pB section %pA, "
 		      "%ld relocations%s",
 		      input_bfd, input_section,
-		      (long) input_section->reloc_count,
+		      (long long) input_section->reloc_count,
 		      (bfd_link_relocatable (info)) ? " (relocatable)" : "");
 #endif
 
@@ -8154,7 +8154,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
       struct elf_link_hash_entry *h;
       const char *sym_name;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       bfd_vma relocation;
       bfd_vma branch_bit, from;
       bfd_boolean unresolved_reloc, save_unresolved_reloc;
@@ -8847,7 +8847,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	       offset table.  */
 	    bfd_vma off;
 	    bfd_vma *offp;
-	    unsigned long indx;
+	    unsigned long long indx;
 
 	    if (htab->elf.sgot == NULL)
 	      abort ();
@@ -9224,7 +9224,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	      int skip;
 	      bfd_byte *loc;
 	      asection *sreloc;
-	      long indx = 0;
+	      long long indx = 0;
 
 #ifdef DEBUG
 	      fprintf (stderr, "ppc_elf_relocate_section needs to "
@@ -10062,8 +10062,8 @@ ppc_elf_relocate_section (bfd *output_bfd,
 	       (int) r_type,
 	       sym_name,
 	       r_symndx,
-	       (long) rel->r_offset,
-	       (long) addend);
+	       (long long) rel->r_offset,
+	       (long long) addend);
 #endif
 
       if (unresolved_reloc
diff --git a/bfd/elf32-pru.c b/bfd/elf32-pru.c
index 0b9e7dc..a64cbf6 100644
--- a/bfd/elf32-pru.c
+++ b/bfd/elf32-pru.c
@@ -539,7 +539,7 @@ pru_elf32_do_ldi32_relocate (bfd *abfd, reloc_howto_type *howto,
   bfd_signed_vma relocation;
   bfd_size_type octets = offset * bfd_octets_per_byte (abfd);
   bfd_byte *location;
-  unsigned long in1, in2;
+  unsigned long long in1, in2;
 
   /* A hacked-up version of _bfd_final_link_relocate() follows.  */
 
@@ -708,7 +708,7 @@ pru_elf32_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -766,7 +766,7 @@ pru_elf32_relocate_section (bfd *output_bfd,
 	    case R_PRU_U16:
 	      if (is_rel_reloc)
 		{
-		  unsigned long insn;
+		  unsigned long long insn;
 		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 		  addend = GET_INSN_FIELD (IMM16, insn);
 		}
@@ -783,7 +783,7 @@ pru_elf32_relocate_section (bfd *output_bfd,
 	    case R_PRU_16_PMEM:
 	      if (is_rel_reloc && howto->type == R_PRU_U16_PMEMIMM)
 		{
-		  unsigned long insn;
+		  unsigned long long insn;
 		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
 		  addend = GET_INSN_FIELD (IMM16, insn) << 2;
 		}
@@ -828,7 +828,7 @@ pru_elf32_relocate_section (bfd *output_bfd,
 	    case R_PRU_LDI32:
 	      if (is_rel_reloc)
 		{
-		  unsigned long in1, in2;
+		  unsigned long long in1, in2;
 		  in1 = bfd_get_32 (input_bfd, contents + rel->r_offset);
 		  in2 = bfd_get_32 (input_bfd, contents + rel->r_offset + 4);
 		  addend = (GET_INSN_FIELD (IMM16, in1) << 16)
@@ -1413,7 +1413,7 @@ pru_elf32_relax_section (bfd * abfd, asection * sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
@@ -1448,11 +1448,11 @@ pru_elf32_relax_section (bfd * abfd, asection * sec,
 	  bfd_vma value = symval + irel->r_addend;
 
 	  if (debug_relax)
-	    printf ("R_PRU_LDI32 with value=0x%lx\n", (long) value);
+	    printf ("R_PRU_LDI32 with value=0x%lx\n", (long long) value);
 
-	  if ((long) value >> 16 == 0)
+	  if ((long long) value >> 16 == 0)
 	    {
-	      unsigned long insn;
+	      unsigned long long insn;
 
 	      /* Note that we've changed the relocs, section contents.  */
 	      elf_section_data (sec)->relocs = internal_relocs;
diff --git a/bfd/elf32-rl78.c b/bfd/elf32-rl78.c
index e072b1a..6e3eae1 100644
--- a/bfd/elf32-rl78.c
+++ b/bfd/elf32-rl78.c
@@ -393,7 +393,7 @@ static unsigned int rl78_stack_top;
    which use a symbolic argument.  */
 
 static bfd_vma
-rl78_compute_complex_reloc (unsigned long  r_type,
+rl78_compute_complex_reloc (unsigned long long  r_type,
 			    bfd_vma	   symval,
 			    asection *	   input_section)
 {
@@ -551,7 +551,7 @@ rl78_special_reloc (bfd *      input_bfd,
 {
   bfd_reloc_status_type	 r = bfd_reloc_ok;
   bfd_vma		 relocation = 0;
-  unsigned long		 r_type = reloc->howto->type;
+  unsigned long long		 r_type = reloc->howto->type;
   bfd_byte *		 contents = data;
 
   /* If necessary, compute the symbolic value of the relocation.  */
@@ -700,7 +700,7 @@ rl78_elf_relocate_section
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
@@ -825,7 +825,7 @@ rl78_elf_relocate_section
 
       r = bfd_reloc_ok;
 
-#define RANGE(a,b) if (a > (long) relocation || (long) relocation > b) r = bfd_reloc_overflow
+#define RANGE(a,b) if (a > (long long) relocation || (long long) relocation > b) r = bfd_reloc_overflow
 
       /* Opcode relocs are always big endian.  Data relocs are bi-endian.  */
       switch (r_type)
@@ -1258,7 +1258,7 @@ rl78_elf_print_private_bfd_data (bfd * abfd, void * ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx:"), (long) flags);
+  fprintf (file, _("private flags = 0x%lx:"), (long long) flags);
 
   if (flags & E_FLAG_RL78_CPU_MASK)
     fprintf (file, " [%s]", rl78_cpu_name (flags));
@@ -1318,7 +1318,7 @@ rl78_elf_check_relocs
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       bfd_vma *offset;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
@@ -1840,7 +1840,7 @@ rl78_offset_for_reloc (bfd *			abfd,
      gets a pointer to the last relocation used.  */
   while (1)
     {
-      unsigned long r_type;
+      unsigned long long r_type;
 
       /* Get the value of the symbol referred to by the reloc.  */
       if (ELF32_R_SYM (rel->r_info) < symtab_hdr->sh_info)
@@ -1888,7 +1888,7 @@ rl78_offset_for_reloc (bfd *			abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry * h;
 
 	  /* An external symbol.  */
diff --git a/bfd/elf32-rx.c b/bfd/elf32-rx.c
index 1f70b97..850f68e 100644
--- a/bfd/elf32-rx.c
+++ b/bfd/elf32-rx.c
@@ -36,7 +36,7 @@ const bfd_target rx_elf32_be_ns_vec;
 const bfd_target rx_elf32_be_vec;
 
 #ifdef DEBUG
-char * rx_get_reloc (long);
+char * rx_get_reloc (long long);
 void rx_dump_symtab (bfd *, void *, void *);
 #endif
 
@@ -514,7 +514,7 @@ rx_elf_relocate_section
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
@@ -672,7 +672,7 @@ rx_elf_relocate_section
       r = bfd_reloc_ok;
 
 #define RANGE(a,b) \
-  if (a > (long) relocation || (long) relocation > b)		\
+  if (a > (long long) relocation || (long long) relocation > b)		\
     r = bfd_reloc_overflow
 #define ALIGN(m) \
   if (relocation & m)						\
@@ -1805,7 +1805,7 @@ rx_offset_for_reloc (bfd *		      abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry * h;
 
 	  /* An external symbol.  */
@@ -2436,12 +2436,12 @@ elf32_rx_relax_section (bfd *		       abfd,
       /* These always occur alone.  */
       if (irel->r_addend & RX_RELAXA_IMM6)
 	{
-	  long ssymval;
+	  long long ssymval;
 
 	  GET_RELOC;
 
 	  /* These relocations sign-extend, so we must do signed compares.  */
-	  ssymval = (long) symval;
+	  ssymval = (long long) symval;
 
 	  code = insn[0] & 0x03;
 
@@ -2572,7 +2572,7 @@ elf32_rx_relax_section (bfd *		       abfd,
       if (irel->r_addend & RX_RELAXA_IMM12)
 	{
 	  int dspcode, offset = 0;
-	  long ssymval;
+	  long long ssymval;
 
 	  GET_RELOC;
 
@@ -2589,7 +2589,7 @@ elf32_rx_relax_section (bfd *		       abfd,
 	    }
 
 	  /* These relocations sign-extend, so we must do signed compares.  */
-	  ssymval = (long) symval;
+	  ssymval = (long long) symval;
 
 	  code = (insn[1] >> 2) & 3;
 	  if (code == 0 && ssymval <= 8388607 && ssymval >= -8388608)
@@ -2846,7 +2846,7 @@ elf32_rx_relax_section (bfd *		       abfd,
 	{
 	  int dcode, icode, reg, ioff, dscale, ilen;
 	  bfd_vma disp_val = 0;
-	  long imm_val = 0;
+	  long long imm_val = 0;
 	  Elf_Internal_Rela * disp_rel = 0;
 	  Elf_Internal_Rela * imm_rel = 0;
 
@@ -2901,7 +2901,7 @@ elf32_rx_relax_section (bfd *		       abfd,
 	  if (srel[1].r_offset == irel->r_offset + ioff)
 	    {
 	      GET_RELOC;
-	      imm_val = (long) symval;
+	      imm_val = (long long) symval;
 	      imm_rel = srel;
 	    }
 	  else
@@ -3197,7 +3197,7 @@ rx_elf_print_private_bfd_data (bfd * abfd, void * ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx:"), (long) flags);
+  fprintf (file, _("private flags = 0x%lx:"), (long long) flags);
 
   fprintf (file, "%s", describe_flags (flags));
   return TRUE;
@@ -3383,8 +3383,8 @@ rx_dump_symtab (bfd * abfd, void * internal_syms, void * external_syms)
       printf ("isym = %p st_value = %lx st_size = %lx st_name = (%lu) %s "
 	      "st_info = (%d) %s %s st_other = (%d) %s st_shndx = (%d) %s\n",
 	      isym,
-	      (unsigned long) isym->st_value,
-	      (unsigned long) isym->st_size,
+	      (unsigned long long) isym->st_value,
+	      (unsigned long long) isym->st_size,
 	      isym->st_name,
 	      bfd_elf_string_from_elf_section (abfd, symtab_hdr->sh_link,
 					       isym->st_name),
@@ -3399,7 +3399,7 @@ rx_dump_symtab (bfd * abfd, void * internal_syms, void * external_syms)
 }
 
 char *
-rx_get_reloc (long reloc)
+rx_get_reloc (long long reloc)
 {
   if (0 <= reloc && reloc < R_RX_max)
     return rx_elf_howto_table[reloc].name;
@@ -3429,10 +3429,10 @@ rx_get_section_contents (bfd *	       abfd,
 
 #ifdef DJDEBUG
   fprintf (stderr, "dj: get %ld %ld from %s  %s e%d sc%d  %08lx:%08lx\n",
-	   (long) offset, (long) count, section->name,
+	   (long long) offset, (long long) count, section->name,
 	   bfd_big_endian(abfd) ? "be" : "le",
-	   exec, s_code, (long unsigned) section->filepos,
-	   (long unsigned) offset);
+	   exec, s_code, (long long unsigned) section->filepos,
+	   (long long unsigned) offset);
 #endif
 
   if (exec && s_code && bfd_big_endian (abfd))
@@ -3552,7 +3552,7 @@ rx_set_section_contents (bfd *	       abfd,
   bfd_size_type i;
 
   fprintf (stderr, "\ndj: set %ld %ld to %s  %s e%d sc%d\n",
-	   (long) offset, (long) count, section->name,
+	   (long long) offset, (long long) count, section->name,
 	   bfd_big_endian (abfd) ? "be" : "le",
 	   exec, s_code);
 
diff --git a/bfd/elf32-s390.c b/bfd/elf32-s390.c
index ebda1da..e631e28 100644
--- a/bfd/elf32-s390.c
+++ b/bfd/elf32-s390.c
@@ -2178,7 +2178,7 @@ elf_s390_relocate_section (bfd *output_bfd,
     {
       unsigned int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       asection *sec;
@@ -2741,7 +2741,7 @@ elf_s390_relocate_section (bfd *output_bfd,
 		    }
 		  else
 		    {
-		      long sindx;
+		      long long sindx;
 
 		      if (bfd_is_abs_section (sec))
 			sindx = 0;
@@ -3703,7 +3703,7 @@ elf_s390_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
   bfd *abfd = info->output_bfd;
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
   struct elf_s390_link_hash_table *htab = elf_s390_hash_table (info);
-  unsigned long r_symndx = ELF32_R_SYM (rela->r_info);
+  unsigned long long r_symndx = ELF32_R_SYM (rela->r_info);
   Elf_Internal_Sym sym;
 
   if (htab->elf.dynsym == NULL
@@ -3968,12 +3968,12 @@ elf_s390_write_core_note (bfd *abfd, char *buf, int *bufsiz,
     case NT_PRSTATUS:
       {
 	char data[224] = { 0 };
-	long pid;
+	long long pid;
 	int cursig;
 	const void *gregs;
 
 	va_start (ap, note_type);
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	cursig = va_arg (ap, int);
 	gregs = va_arg (ap, const void *);
 	va_end (ap);
diff --git a/bfd/elf32-score.c b/bfd/elf32-score.c
index 42ef221..0445650 100644
--- a/bfd/elf32-score.c
+++ b/bfd/elf32-score.c
@@ -72,7 +72,7 @@ struct score_got_entry
   bfd *abfd;
   /* The index of the symbol, as stored in the relocation r_info, if
      we have a local symbol; -1 otherwise.  */
-  long symndx;
+  long long symndx;
   union
   {
     /* If abfd == NULL, an address that must be stored in the got.  */
@@ -89,7 +89,7 @@ struct score_got_entry
   /* The offset from the beginning of the .got section to the entry
      corresponding to this symbol+addend.  If it's a global symbol
      whose offset is yet to be decided, it's going to be -1.  */
-  long gotidx;
+  long long gotidx;
 };
 
 /* This structure is passed to score_elf_sort_hash_table_f when sorting
@@ -100,14 +100,14 @@ struct score_elf_hash_sort_data
   /* The symbol in the global GOT with the lowest dynamic symbol table index.  */
   struct elf_link_hash_entry *low;
   /* The least dynamic symbol table index corresponding to a symbol with a GOT entry.  */
-  long min_got_dynindx;
+  long long min_got_dynindx;
   /* The greatest dynamic symbol table index corresponding to a symbol
      with a GOT entry that is not referenced (e.g., a dynamic symbol
      with dynamic relocations pointing to it from non-primary GOTs).  */
-  long max_unref_got_dynindx;
+  long long max_unref_got_dynindx;
   /* The greatest dynamic symbol table index not corresponding to a
      symbol without a GOT entry.  */
-  long max_non_got_dynindx;
+  long long max_non_got_dynindx;
 };
 
 struct score_got_info
@@ -214,12 +214,12 @@ static bfd_vma
 score3_bfd_getl32 (const void *p)
 {
   const bfd_byte *addr = p;
-  unsigned long v;
+  unsigned long long v;
 
-  v = (unsigned long) addr[2];
-  v |= (unsigned long) addr[3] << 8;
-  v |= (unsigned long) addr[0] << 16;
-  v |= (unsigned long) addr[1] << 24;
+  v = (unsigned long long) addr[2];
+  v |= (unsigned long long) addr[3] << 8;
+  v |= (unsigned long long) addr[0] << 16;
+  v |= (unsigned long long) addr[1] << 24;
   return v;
 }
 
@@ -325,8 +325,8 @@ score_elf_lo16_reloc (bfd *abfd,
 		      char **error_message ATTRIBUTE_UNUSED)
 {
   bfd_vma addend = 0, offset = 0;
-  unsigned long val;
-  unsigned long hi16_offset, hi16_value, uvalue;
+  unsigned long long val;
+  unsigned long long hi16_offset, hi16_value, uvalue;
 
   hi16_value = score_bfd_get_32 (abfd, hi16_rel_addr);
   hi16_offset = ((((hi16_value >> 16) & 0x3) << 15) | (hi16_value & 0x7fff)) >> 1;
@@ -445,7 +445,7 @@ score_elf_gprel15_with_gp (bfd *abfd,
 			   bfd_vma gp ATTRIBUTE_UNUSED)
 {
   bfd_vma relocation;
-  unsigned long insn;
+  unsigned long long insn;
 
   if (bfd_is_com_section (symbol->section))
     relocation = 0;
@@ -617,8 +617,8 @@ score_elf_got_lo16_reloc (bfd *abfd,
 			  char **error_message ATTRIBUTE_UNUSED)
 {
   bfd_vma addend = 0, offset = 0;
-  signed long val;
-  signed long hi16_offset, hi16_value, uvalue;
+  signed long long val;
+  signed long long hi16_offset, hi16_value, uvalue;
 
   hi16_value = score_bfd_get_32 (abfd, hi16_rel_addr);
   hi16_offset = ((((hi16_value >> 16) & 0x3) << 15) | (hi16_value & 0x7fff)) >> 1;
@@ -1099,7 +1099,7 @@ score_elf_got_info (bfd *abfd, asection **sgotp)
    section symbols are added and the count is higher.  */
 static bfd_boolean
 score_elf_sort_hash_table (struct bfd_link_info *info,
-			   unsigned long max_local)
+			   unsigned long long max_local)
 {
   struct score_elf_hash_sort_data hsd;
   struct score_got_info *g;
@@ -1128,7 +1128,7 @@ score_elf_sort_hash_table (struct bfd_link_info *info,
   /* There should have been enough room in the symbol table to
      accommodate both the GOT and non-GOT symbols.  */
   BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);
-  BFD_ASSERT ((unsigned long)hsd.max_unref_got_dynindx
+  BFD_ASSERT ((unsigned long long)hsd.max_unref_got_dynindx
 	      <= elf_hash_table (info)->dynsymcount);
 
   /* Now we know which dynamic symbol has the lowest dynamic symbol
@@ -1209,7 +1209,7 @@ score_elf_local_relocation_p (bfd *input_bfd,
 			      asection **local_sections,
 			      bfd_boolean check_forced)
 {
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   Elf_Internal_Shdr *symtab_hdr;
   struct score_elf_link_hash_entry *h;
   size_t extsymoff;
@@ -1297,7 +1297,7 @@ score_elf_create_dynamic_relocation (bfd *output_bfd,
   asection *sreloc;
   bfd *dynobj;
   int r_type;
-  long indx;
+  long long indx;
   bfd_boolean defined_p;
 
   r_type = ELF32_R_TYPE (rel->r_info);
@@ -1357,7 +1357,7 @@ score_elf_create_dynamic_relocation (bfd *output_bfd,
 
   /* The relocation is always an REL32 relocation because we don't
      know where the shared library will wind up at load-time.  */
-  outrel[0].r_info = ELF32_R_INFO ((unsigned long) indx, R_SCORE_REL32);
+  outrel[0].r_info = ELF32_R_INFO ((unsigned long long) indx, R_SCORE_REL32);
 
   /* For strict adherence to the ABI specification, we should
      generate a R_SCORE_64 relocation record by itself before the
@@ -1488,7 +1488,7 @@ score_elf_create_local_got_entry (bfd *abfd,
 				  bfd *ibfd ATTRIBUTE_UNUSED,
 				  struct score_got_info *gg,
 				  asection *sgot, bfd_vma value,
-				  unsigned long r_symndx ATTRIBUTE_UNUSED,
+				  unsigned long long r_symndx ATTRIBUTE_UNUSED,
 				  struct score_elf_link_hash_entry *h ATTRIBUTE_UNUSED,
 				  int r_type ATTRIBUTE_UNUSED)
 {
@@ -1690,7 +1690,7 @@ score_elf_record_global_got_symbol (struct elf_link_hash_entry *h,
    SYMNDX in input bfd ABDF, plus ADDEND.  */
 static bfd_boolean
 score_elf_record_local_got_symbol (bfd *abfd,
-				   long symndx,
+				   long long symndx,
 				   bfd_vma addend,
 				   struct score_got_info *g)
 {
@@ -1720,7 +1720,7 @@ score_elf_record_local_got_symbol (bfd *abfd,
    Returns -1 if no satisfactory GOT offset can be found.  */
 static bfd_vma
 score_elf_local_got_index (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
-			   bfd_vma value, unsigned long r_symndx,
+			   bfd_vma value, unsigned long long r_symndx,
 			   struct score_elf_link_hash_entry *h, int r_type)
 {
   asection *sgot;
@@ -1746,7 +1746,7 @@ score_elf_global_got_index (bfd *abfd, struct elf_link_hash_entry *h)
   bfd_vma got_index;
   asection *sgot;
   struct score_got_info *g;
-  long global_got_dynindx = 0;
+  long long global_got_dynindx = 0;
 
   g = score_elf_got_info (abfd, &sgot);
   if (g->global_gotsym != NULL)
@@ -1852,9 +1852,9 @@ score_elf_add_to_rel (bfd *abfd,
 {
   bfd_signed_vma addend;
   bfd_vma contents;
-  unsigned long offset;
-  unsigned long r_type = howto->type;
-  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue;
+  unsigned long long offset;
+  unsigned long long r_type = howto->type;
+  unsigned long long hi16_addend, hi16_offset, hi16_value, uvalue;
 
   contents = score_bfd_get_32 (abfd, address);
   /* Get the (signed) value from the instruction.  */
@@ -1976,8 +1976,8 @@ score_elf_final_link_relocate (reloc_howto_type *howto,
 			       asection **local_sections,
 			       bfd_boolean gp_disp_p)
 {
-  unsigned long r_type;
-  unsigned long r_symndx;
+  unsigned long long r_type;
+  unsigned long long r_symndx;
   bfd_byte *hit_data = contents + rel->r_offset;
   bfd_vma addend;
   /* The final GP value to be used for the relocatable, executable, or
@@ -1992,7 +1992,7 @@ score_elf_final_link_relocate (reloc_howto_type *howto,
   bfd_boolean local_p;
   /* The eventual value we will relocate.  */
   bfd_vma value = symbol;
-  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue, offset, abs_value = 0;
+  unsigned long long hi16_addend, hi16_offset, hi16_value, uvalue, offset, abs_value = 0;
 
 
   if (elf_gp (output_bfd) == 0)
@@ -2154,7 +2154,7 @@ score_elf_final_link_relocate (reloc_howto_type *howto,
 
     case R_SCORE_ABS16:
       value += addend;
-      if ((long)value > 0x7fff || (long)value < -0x8000)
+      if ((long long)value > 0x7fff || (long long)value < -0x8000)
 	return bfd_reloc_overflow;
       score_bfd_put_16 (input_bfd, value, hit_data);
       return bfd_reloc_ok;
@@ -2337,7 +2337,7 @@ score_elf_final_link_relocate (reloc_howto_type *howto,
 	  value = g;
 	}
 
-      if ((long) value > 0x3fff || (long) value < -0x4000)
+      if ((long long) value > 0x3fff || (long long) value < -0x4000)
 	return bfd_reloc_overflow;
 
       addend = score_bfd_get_32 (input_bfd, hit_data);
@@ -2405,8 +2405,8 @@ s3_bfd_score_elf_relocate_section (bfd *output_bfd,
   Elf_Internal_Rela *rel;
   Elf_Internal_Rela *relend;
   const char *name;
-  unsigned long offset;
-  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue;
+  unsigned long long offset;
+  unsigned long long hi16_addend, hi16_offset, hi16_value, uvalue;
   size_t extsymoff;
   bfd_boolean gp_disp_p = FALSE;
 
@@ -2438,7 +2438,7 @@ s3_bfd_score_elf_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct score_elf_link_hash_entry *h;
@@ -2809,7 +2809,7 @@ s3_bfd_score_elf_check_relocs (bfd *abfd,
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; ++rel)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       unsigned int r_type;
       struct elf_link_hash_entry *h;
 
diff --git a/bfd/elf32-score7.c b/bfd/elf32-score7.c
index 3c022e6..69229a3 100644
--- a/bfd/elf32-score7.c
+++ b/bfd/elf32-score7.c
@@ -69,7 +69,7 @@ struct score_got_entry
   bfd *abfd;
   /* The index of the symbol, as stored in the relocation r_info, if
      we have a local symbol; -1 otherwise.  */
-  long symndx;
+  long long symndx;
   union
   {
     /* If abfd == NULL, an address that must be stored in the got.  */
@@ -86,7 +86,7 @@ struct score_got_entry
   /* The offset from the beginning of the .got section to the entry
      corresponding to this symbol+addend.  If it's a global symbol
      whose offset is yet to be decided, it's going to be -1.  */
-  long gotidx;
+  long long gotidx;
 };
 
 /* This structure is passed to score_elf_sort_hash_table_f when sorting
@@ -96,14 +96,14 @@ struct score_elf_hash_sort_data
   /* The symbol in the global GOT with the lowest dynamic symbol table index.  */
   struct elf_link_hash_entry *low;
   /* The least dynamic symbol table index corresponding to a symbol with a GOT entry.  */
-  long min_got_dynindx;
+  long long min_got_dynindx;
   /* The greatest dynamic symbol table index corresponding to a symbol
      with a GOT entry that is not referenced (e.g., a dynamic symbol
      with dynamic relocations pointing to it from non-primary GOTs).  */
-  long max_unref_got_dynindx;
+  long long max_unref_got_dynindx;
   /* The greatest dynamic symbol table index not corresponding to a
      symbol without a GOT entry.  */
-  long max_non_got_dynindx;
+  long long max_non_got_dynindx;
 };
 
 struct score_got_info
@@ -224,8 +224,8 @@ score_elf_lo16_reloc (bfd *abfd,
 		      char **error_message ATTRIBUTE_UNUSED)
 {
   bfd_vma addend = 0, offset = 0;
-  unsigned long val;
-  unsigned long hi16_offset, hi16_value, uvalue;
+  unsigned long long val;
+  unsigned long long hi16_offset, hi16_value, uvalue;
 
   hi16_value = bfd_get_32 (abfd, hi16_rel_addr);
   hi16_offset = ((((hi16_value >> 16) & 0x3) << 15) | (hi16_value & 0x7fff)) >> 1;
@@ -345,7 +345,7 @@ score_elf_gprel15_with_gp (bfd *abfd,
 			   bfd_vma gp ATTRIBUTE_UNUSED)
 {
   bfd_vma relocation;
-  unsigned long insn;
+  unsigned long long insn;
 
   if (bfd_is_com_section (symbol->section))
     relocation = 0;
@@ -518,8 +518,8 @@ score_elf_got_lo16_reloc (bfd *abfd,
 			  char **error_message ATTRIBUTE_UNUSED)
 {
   bfd_vma addend = 0, offset = 0;
-  signed long val;
-  signed long hi16_offset, hi16_value, uvalue;
+  signed long long val;
+  signed long long hi16_offset, hi16_value, uvalue;
 
   hi16_value = bfd_get_32 (abfd, hi16_rel_addr);
   hi16_offset = ((((hi16_value >> 16) & 0x3) << 15) | (hi16_value & 0x7fff)) >> 1;
@@ -984,7 +984,7 @@ score_elf_got_info (bfd *abfd, asection **sgotp)
 
 static bfd_boolean
 score_elf_sort_hash_table (struct bfd_link_info *info,
-			   unsigned long max_local)
+			   unsigned long long max_local)
 {
   struct score_elf_hash_sort_data hsd;
   struct score_got_info *g;
@@ -1013,7 +1013,7 @@ score_elf_sort_hash_table (struct bfd_link_info *info,
   /* There should have been enough room in the symbol table to
      accommodate both the GOT and non-GOT symbols.  */
   BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);
-  BFD_ASSERT ((unsigned long) hsd.max_unref_got_dynindx
+  BFD_ASSERT ((unsigned long long) hsd.max_unref_got_dynindx
 	      <= elf_hash_table (info)->dynsymcount);
 
   /* Now we know which dynamic symbol has the lowest dynamic symbol
@@ -1065,7 +1065,7 @@ score_elf_local_relocation_p (bfd *input_bfd,
 			      asection **local_sections,
 			      bfd_boolean check_forced)
 {
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   Elf_Internal_Shdr *symtab_hdr;
   struct score_elf_link_hash_entry *h;
   size_t extsymoff;
@@ -1155,7 +1155,7 @@ score_elf_create_dynamic_relocation (bfd *output_bfd,
   asection *sreloc;
   bfd *dynobj;
   int r_type;
-  long indx;
+  long long indx;
   bfd_boolean defined_p;
 
   r_type = ELF32_R_TYPE (rel->r_info);
@@ -1215,7 +1215,7 @@ score_elf_create_dynamic_relocation (bfd *output_bfd,
 
   /* The relocation is always an REL32 relocation because we don't
      know where the shared library will wind up at load-time.  */
-  outrel[0].r_info = ELF32_R_INFO ((unsigned long) indx, R_SCORE_REL32);
+  outrel[0].r_info = ELF32_R_INFO ((unsigned long long) indx, R_SCORE_REL32);
 
   /* For strict adherence to the ABI specification, we should
      generate a R_SCORE_64 relocation record by itself before the
@@ -1349,7 +1349,7 @@ score_elf_create_local_got_entry (bfd *abfd,
 				  bfd *ibfd ATTRIBUTE_UNUSED,
 				  struct score_got_info *gg,
 				  asection *sgot, bfd_vma value,
-				  unsigned long r_symndx ATTRIBUTE_UNUSED,
+				  unsigned long long r_symndx ATTRIBUTE_UNUSED,
 				  struct score_elf_link_hash_entry *h ATTRIBUTE_UNUSED,
 				  int r_type ATTRIBUTE_UNUSED)
 {
@@ -1554,7 +1554,7 @@ score_elf_record_global_got_symbol (struct elf_link_hash_entry *h,
 
 static bfd_boolean
 score_elf_record_local_got_symbol (bfd *abfd,
-				   long symndx,
+				   long long symndx,
 				   bfd_vma addend,
 				   struct score_got_info *g)
 {
@@ -1585,7 +1585,7 @@ score_elf_record_local_got_symbol (bfd *abfd,
 
 static bfd_vma
 score_elf_local_got_index (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
-			   bfd_vma value, unsigned long r_symndx,
+			   bfd_vma value, unsigned long long r_symndx,
 			   struct score_elf_link_hash_entry *h, int r_type)
 {
   asection *sgot;
@@ -1611,7 +1611,7 @@ score_elf_global_got_index (bfd *abfd, struct elf_link_hash_entry *h)
   bfd_vma got_index;
   asection *sgot;
   struct score_got_info *g;
-  long global_got_dynindx = 0;
+  long long global_got_dynindx = 0;
 
   g = score_elf_got_info (abfd, &sgot);
   if (g->global_gotsym != NULL)
@@ -1720,9 +1720,9 @@ score_elf_add_to_rel (bfd *abfd,
 {
   bfd_signed_vma addend;
   bfd_vma contents;
-  unsigned long offset;
-  unsigned long r_type = howto->type;
-  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue;
+  unsigned long long offset;
+  unsigned long long r_type = howto->type;
+  unsigned long long hi16_addend, hi16_offset, hi16_value, uvalue;
 
   contents = bfd_get_32 (abfd, address);
   /* Get the (signed) value from the instruction.  */
@@ -1820,8 +1820,8 @@ score_elf_final_link_relocate (reloc_howto_type *howto,
 			       asection **local_sections,
 			       bfd_boolean gp_disp_p)
 {
-  unsigned long r_type;
-  unsigned long r_symndx;
+  unsigned long long r_type;
+  unsigned long long r_symndx;
   bfd_byte *hit_data = contents + rel->r_offset;
   bfd_vma addend;
   /* The final GP value to be used for the relocatable, executable, or
@@ -1838,7 +1838,7 @@ score_elf_final_link_relocate (reloc_howto_type *howto,
   bfd_boolean local_p;
   /* The eventual value we will relocate.  */
   bfd_vma value = symbol;
-  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue, offset, abs_value = 0;
+  unsigned long long hi16_addend, hi16_offset, hi16_value, uvalue, offset, abs_value = 0;
 
   Elf_Internal_Sym *sym = 0;
   asection *sec = NULL;
@@ -2055,7 +2055,7 @@ score_elf_final_link_relocate (reloc_howto_type *howto,
 
     case R_SCORE_ABS16:
       value += addend;
-      if ((long) value > 0x7fff || (long) value < -0x8000)
+      if ((long long) value > 0x7fff || (long long) value < -0x8000)
 	return bfd_reloc_overflow;
       bfd_put_16 (input_bfd, value, hit_data);
       return bfd_reloc_ok;
@@ -2175,7 +2175,7 @@ score_elf_final_link_relocate (reloc_howto_type *howto,
 	  value = g;
 	}
 
-      if ((long) value > 0x3fff || (long) value < -0x4000)
+      if ((long long) value > 0x3fff || (long long) value < -0x4000)
 	return bfd_reloc_overflow;
 
       addend = bfd_get_32 (input_bfd, hit_data);
@@ -2245,8 +2245,8 @@ s7_bfd_score_elf_relocate_section (bfd *output_bfd,
   Elf_Internal_Rela *rel;
   Elf_Internal_Rela *relend;
   const char *name;
-  unsigned long offset;
-  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue;
+  unsigned long long offset;
+  unsigned long long hi16_addend, hi16_offset, hi16_value, uvalue;
   size_t extsymoff;
   bfd_boolean gp_disp_p = FALSE;
 
@@ -2278,7 +2278,7 @@ s7_bfd_score_elf_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct score_elf_link_hash_entry *h;
@@ -2614,7 +2614,7 @@ s7_bfd_score_elf_check_relocs (bfd *abfd,
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; ++rel)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       unsigned int r_type;
       struct elf_link_hash_entry *h;
 
diff --git a/bfd/elf32-sh.c b/bfd/elf32-sh.c
index cd2c49c..9c7a3fc 100644
--- a/bfd/elf32-sh.c
+++ b/bfd/elf32-sh.c
@@ -229,7 +229,7 @@ sh_elf_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol_in,
 	      void *data, asection *input_section, bfd *output_bfd,
 	      char **error_message ATTRIBUTE_UNUSED)
 {
-  unsigned long insn;
+  unsigned long long insn;
   bfd_vma sym_value;
   enum elf_sh_reloc_type r_type;
   bfd_vma addr = reloc_entry->address;
@@ -605,7 +605,7 @@ sh_elf_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  indx = ELF32_R_SYM (irelfn->r_info) - symtab_hdr->sh_info;
@@ -1032,7 +1032,7 @@ sh_elf_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr,
 	     and the elf bfd r_offset is called r_vaddr.  */
 
 	  stop = irel->r_offset;
-	  start = (bfd_vma) ((bfd_signed_vma) stop - (long) irel->r_addend);
+	  start = (bfd_vma) ((bfd_signed_vma) stop - (long long) irel->r_addend);
 
 	  if (start > addr
 	      && start < toaddr
@@ -1056,7 +1056,7 @@ sh_elf_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr,
 	case R_SH_USES:
 	  start = irel->r_offset;
 	  stop = (bfd_vma) ((bfd_signed_vma) start
-			    + (long) irel->r_addend
+			    + (long long) irel->r_addend
 			    + 4);
 	  break;
 	}
@@ -1204,7 +1204,7 @@ sh_elf_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr,
 
 	      stop = irelscan->r_offset;
 	      start
-		= (bfd_vma) ((bfd_signed_vma) stop - (long) irelscan->r_addend);
+		= (bfd_vma) ((bfd_signed_vma) stop - (long long) irelscan->r_addend);
 
 	      /* STOP is in a different section, so it won't change.  */
 	      if (start > addr && start < toaddr)
@@ -2037,7 +2037,7 @@ get_plt_info (bfd *abfd, bfd_boolean pic_p)
 
 inline static void
 install_plt_field (bfd *output_bfd, bfd_boolean code_p ATTRIBUTE_UNUSED,
-		   unsigned long value, bfd_byte *addr)
+		   unsigned long long value, bfd_byte *addr)
 {
   bfd_put_32 (output_bfd, value, addr);
 }
@@ -3317,7 +3317,7 @@ sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
 
 inline static bfd_vma
 sh_elf_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
-		      int reloc_type, long dynindx, bfd_vma addend)
+		      int reloc_type, long long dynindx, bfd_vma addend)
 {
   Elf_Internal_Rela outrel;
   bfd_vma reloc_offset;
@@ -3463,11 +3463,11 @@ sh_elf_initialize_funcdesc (bfd *output_bfd,
    otherwise.  */
 
 static bfd_reloc_status_type
-install_movi20_field (bfd *output_bfd, unsigned long relocation,
+install_movi20_field (bfd *output_bfd, unsigned long long relocation,
 		      bfd *input_bfd, asection *input_section,
 		      bfd_byte *contents, bfd_vma offset)
 {
-  unsigned long cur_val;
+  unsigned long long cur_val;
   bfd_byte *addr;
   bfd_reloc_status_type r;
 
@@ -3550,7 +3550,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -5382,7 +5382,7 @@ sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       r_type = ELF32_R_TYPE (rel->r_info);
@@ -5845,7 +5845,7 @@ sh_elf_set_mach_from_flags (bfd *abfd)
    Return -1 if no match is found.  */
 
 int
-sh_elf_get_flags_from_mach (unsigned long mach)
+sh_elf_get_flags_from_mach (unsigned long long mach)
 {
   int i = ARRAY_SIZE (sh_ef_bfd_table) - 1;
 
@@ -5884,8 +5884,8 @@ sh_elf_copy_private_data (bfd * ibfd, bfd * obfd)
 int
 sh_find_elf_flags (unsigned int arch_set)
 {
-  extern unsigned long sh_get_bfd_mach_from_arch_set (unsigned int);
-  unsigned long bfd_mach = sh_get_bfd_mach_from_arch_set (arch_set);
+  extern unsigned long long sh_get_bfd_mach_from_arch_set (unsigned int);
+  unsigned long long bfd_mach = sh_get_bfd_mach_from_arch_set (arch_set);
 
   return sh_elf_get_flags_from_mach (bfd_mach);
 }
diff --git a/bfd/elf32-sparc.c b/bfd/elf32-sparc.c
index 4378b61..0758a9c 100644
--- a/bfd/elf32-sparc.c
+++ b/bfd/elf32-sparc.c
@@ -71,9 +71,9 @@ elf32_sparc_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 {
   bfd *obfd = info->output_bfd;
   bfd_boolean error;
-  unsigned long ibfd_mach;
+  unsigned long long ibfd_mach;
   /* FIXME: This should not be static.  */
-  static unsigned long previous_ibfd_e_flags = (unsigned long) -1;
+  static unsigned long long previous_ibfd_e_flags = (unsigned long long) -1;
 
   if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
       || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
@@ -96,7 +96,7 @@ elf32_sparc_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 
   if (((elf_elfheader (ibfd)->e_flags & EF_SPARC_LEDATA)
        != previous_ibfd_e_flags)
-      && previous_ibfd_e_flags != (unsigned long) -1)
+      && previous_ibfd_e_flags != (unsigned long long) -1)
     {
       _bfd_error_handler
 	(_("%pB: linking little endian files with big endian files"), ibfd);
diff --git a/bfd/elf32-spu.c b/bfd/elf32-spu.c
index c3bfbbd..df57c7f 100644
--- a/bfd/elf32-spu.c
+++ b/bfd/elf32-spu.c
@@ -201,7 +201,7 @@ spu_elf_rel9 (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
 {
   bfd_size_type octets;
   bfd_vma val;
-  long insn;
+  long long insn;
 
   /* If this is a relocatable link (output_bfd test tells us), just
      call the generic function.  Any adjustment will be done at final
@@ -496,7 +496,7 @@ get_sym_h (struct elf_link_hash_entry **hp,
 	   Elf_Internal_Sym **symp,
 	   asection **symsecp,
 	   Elf_Internal_Sym **locsymsp,
-	   unsigned long r_symndx,
+	   unsigned long long r_symndx,
 	   bfd *ibfd)
 {
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
@@ -2117,7 +2117,7 @@ spu_elf_build_stubs (struct bfd_link_info *info)
 
 	  if (ovl_index != 0)
 	    {
-	      unsigned long off = ovl_index * 16;
+	      unsigned long long off = ovl_index * 16;
 	      unsigned int ovl_buf = spu_elf_section_data (s)->u.o.ovl_buf;
 
 	      bfd_put_32 (htab->ovtab->owner, s->vma, p + off);
@@ -2497,7 +2497,7 @@ func_name (struct function_info *fun)
       if (name == NULL)
 	return "(null)";
       sprintf (name, "%s+%lx", sec->name,
-	       (unsigned long) fun->u.sym->st_value & 0xffffffff);
+	       (unsigned long long) fun->u.sym->st_value & 0xffffffff);
       return name;
     }
   ibfd = sec->owner;
@@ -3596,7 +3596,7 @@ mark_overlay_section (struct function_info *fun,
 struct _uos_param {
   asection *exclude_input_section;
   asection *exclude_output_section;
-  unsigned long clearing;
+  unsigned long long clearing;
 };
 
 /* Undo some of mark_overlay_section's work.  */
diff --git a/bfd/elf32-tic6x.c b/bfd/elf32-tic6x.c
index 768bfb8..aa48f0c 100644
--- a/bfd/elf32-tic6x.c
+++ b/bfd/elf32-tic6x.c
@@ -2234,7 +2234,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel ++)
     {
       int r_type;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       arelent bfd_reloc;
       reloc_howto_type *howto;
       Elf_Internal_Sym *sym;
@@ -2321,7 +2321,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
 	      && (htab->elf.splt == NULL || h->plt.offset == (bfd_vma) -1)
 	      : r_symndx != STN_UNDEF && bfd_is_und_section (sec))
 	    {
-	      unsigned long oldval;
+	      unsigned long long oldval;
 	      oldval = bfd_get_32 (input_bfd, contents + rel->r_offset);
 
 	      if ((oldval & 0x7e) == 0x12)
@@ -2426,7 +2426,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
 		}
 	      else
 		{
-		  long indx;
+		  long long indx;
 
 		  outrel.r_addend = relocation + rel->r_addend;
 
@@ -4190,8 +4190,8 @@ elf32_tic6x_fix_exidx_coverage (asection **text_section_order,
 
 /* Add ADDEND to lower 31 bits of VAL, leaving other bits unmodified.  */
 
-static unsigned long
-elf32_tic6x_add_low31 (unsigned long val, bfd_vma addend)
+static unsigned long long
+elf32_tic6x_add_low31 (unsigned long long val, bfd_vma addend)
 {
   return (val & ~0x7ffffffful) | ((val + addend) & 0x7ffffffful);
 }
@@ -4204,8 +4204,8 @@ static void
 elf32_tic6x_copy_exidx_entry (bfd *output_bfd, bfd_byte *to, bfd_byte *from,
 			      bfd_vma offset)
 {
-  unsigned long first_word = bfd_get_32 (output_bfd, from);
-  unsigned long second_word = bfd_get_32 (output_bfd, from + 4);
+  unsigned long long first_word = bfd_get_32 (output_bfd, from);
+  unsigned long long second_word = bfd_get_32 (output_bfd, from + 4);
 
   offset >>= 1;
   /* High bit of first word is supposed to be zero.  */
@@ -4289,7 +4289,7 @@ elf32_tic6x_write_section (bfd *output_bfd,
 					  + text_sec->output_offset
 					  + text_sec->size;
 		    bfd_vma exidx_offset = offset + out_index * 8;
-		    unsigned long prel31_offset;
+		    unsigned long long prel31_offset;
 
 		    /* Note: this is meant to be equivalent to an
 		       R_C6000_PREL31 relocation.  These synthetic
diff --git a/bfd/elf32-tilepro.c b/bfd/elf32-tilepro.c
index 55b19f8..840e314 100644
--- a/bfd/elf32-tilepro.c
+++ b/bfd/elf32-tilepro.c
@@ -2684,7 +2684,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
       int r_type, tls_type;
       bfd_boolean is_tls_iele, is_tls_le;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       tilepro_create_func create_func;
@@ -3114,7 +3114,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		    }
 		  else
 		    {
-		      long indx;
+		      long long indx;
 
 		      outrel.r_addend = relocation + rel->r_addend;
 
diff --git a/bfd/elf32-v850.c b/bfd/elf32-v850.c
index 430153a..8c4d302 100644
--- a/bfd/elf32-v850.c
+++ b/bfd/elf32-v850.c
@@ -71,7 +71,7 @@ v850_elf_check_relocs (bfd *abfd,
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
@@ -217,7 +217,7 @@ typedef struct hi16s_location
 {
   bfd_vma		  addend;
   bfd_byte *		  address;
-  unsigned long		  counter;
+  unsigned long long		  counter;
   bfd_boolean		  found;
   struct hi16s_location * next;
 }
@@ -225,7 +225,7 @@ hi16s_location;
 
 static hi16s_location * previous_hi16s;
 static hi16s_location * free_hi16s;
-static unsigned long    hi16s_counter;
+static unsigned long long    hi16s_counter;
 
 static void
 remember_hi16s_reloc (bfd *abfd, bfd_vma addend, bfd_byte *address)
@@ -434,8 +434,8 @@ find_remembered_hi16s_reloc (bfd_vma addend, bfd_boolean *already_found)
        0x00006fff   which is wrong (assuming that fred is at 0xffff).  */
 
 static bfd_boolean
-v850_elf_perform_lo16_relocation (bfd *abfd, unsigned long *insn,
-				  unsigned long addend)
+v850_elf_perform_lo16_relocation (bfd *abfd, unsigned long long *insn,
+				  unsigned long long addend)
 {
 #define BIT15_SET(x) ((x) & 0x8000)
 #define OVERFLOWS(a,i) ((((a) & 0xffff) + (i)) > 0xffff)
@@ -453,7 +453,7 @@ v850_elf_perform_lo16_relocation (bfd *abfd, unsigned long *insn,
 	{
 	  if (! already_updated)
 	    {
-	      unsigned long hi_insn = bfd_get_16 (abfd, hi16s_address);
+	      unsigned long long hi_insn = bfd_get_16 (abfd, hi16s_address);
 	      hi_insn += 1;
 	      bfd_put_16 (abfd, hi_insn, hi16s_address);
 	    }
@@ -482,8 +482,8 @@ v850_elf_perform_relocation (bfd *abfd,
 			     bfd_vma addend,
 			     bfd_byte *address)
 {
-  unsigned long insn;
-  unsigned long result;
+  unsigned long long insn;
+  unsigned long long result;
   bfd_signed_vma saddend = (bfd_signed_vma) addend;
 
   switch (r_type)
@@ -818,7 +818,7 @@ v850_elf_reloc (bfd *abfd ATTRIBUTE_UNUSED,
 		bfd *obfd,
 		char **err ATTRIBUTE_UNUSED)
 {
-  long relocation;
+  long long relocation;
 
   /* If there is an output BFD,
      and the symbol is not a section name (which is only defined at final link time),
@@ -2054,7 +2054,7 @@ v850_elf_final_link_relocate (reloc_howto_type *howto,
     case R_V850_SDA_16_16_SPLIT_OFFSET:
     case R_V810_GPWLO_1:
       {
-	unsigned long		     gp;
+	unsigned long long		     gp;
 	struct bfd_link_hash_entry * h;
 
 	if (sym_sec == NULL)
@@ -2082,7 +2082,7 @@ v850_elf_final_link_relocate (reloc_howto_type *howto,
     case R_V850_TDA_6_8_OFFSET:
     case R_V850_TDA_16_16_OFFSET:
       {
-	unsigned long		     ep;
+	unsigned long long		     ep;
 	struct bfd_link_hash_entry * h;
 
 	/* Get the value of __ep.  */
@@ -2101,7 +2101,7 @@ v850_elf_final_link_relocate (reloc_howto_type *howto,
 
     case R_V850_CALLT_6_7_OFFSET:
       {
-	unsigned long		     ctbp;
+	unsigned long long		     ctbp;
 	struct bfd_link_hash_entry * h;
 
 	/* Get the value of __ctbp.  */
@@ -2120,7 +2120,7 @@ v850_elf_final_link_relocate (reloc_howto_type *howto,
     case R_V850_CALLT_15_16_OFFSET:
     case R_V850_CALLT_16_16_OFFSET:
       {
-	unsigned long		     ctbp;
+	unsigned long long		     ctbp;
 	struct bfd_link_hash_entry * h;
 
 	if (sym_sec == NULL)
@@ -2193,7 +2193,7 @@ v850_elf_relocate_section (bfd *output_bfd,
     {
       unsigned int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -2686,7 +2686,7 @@ static bfd_boolean
 v850_elf_object_p (bfd *abfd)
 {
   enum bfd_architecture arch;
-  unsigned long mach;
+  unsigned long long mach;
 
   switch (elf_elfheader (abfd)->e_machine)
     {
@@ -2724,7 +2724,7 @@ static void
 v850_elf_final_write_processing (bfd *abfd,
 				 bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
 
   switch (bfd_get_arch (abfd))
     {
@@ -3303,7 +3303,7 @@ v850_elf_relax_delete_bytes (bfd *abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry * h;
 
 	  /* An external symbol.  */
@@ -3680,7 +3680,7 @@ v850_elf_relax_section (bfd *abfd,
 		}
 	      else
 		{
-		  unsigned long indx;
+		  unsigned long long indx;
 		  struct elf_link_hash_entry * h;
 
 		  /* An external symbol.  */
@@ -3732,7 +3732,7 @@ v850_elf_relax_section (bfd *abfd,
 		}
 	      else
 		{
-		  unsigned long indx;
+		  unsigned long long indx;
 		  struct elf_link_hash_entry *h;
 
 		  /* An external symbol.  */
@@ -3931,7 +3931,7 @@ v850_elf_relax_section (bfd *abfd,
 		}
 	      else
 		{
-		  unsigned long indx;
+		  unsigned long long indx;
 		  struct elf_link_hash_entry * h;
 
 		  /* An external symbol.  */
diff --git a/bfd/elf32-vax.c b/bfd/elf32-vax.c
index 0236180..e733fa0 100644
--- a/bfd/elf32-vax.c
+++ b/bfd/elf32-vax.c
@@ -576,7 +576,7 @@ elf_vax_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
@@ -1291,7 +1291,7 @@ elf_vax_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       asection *sec;
@@ -1524,7 +1524,7 @@ elf_vax_relocate_section (bfd *output_bfd,
 		    }
 		  else
 		    {
-		      long indx;
+		      long long indx;
 
 		      if (bfd_is_abs_section (sec))
 			indx = 0;
diff --git a/bfd/elf32-visium.c b/bfd/elf32-visium.c
index e8f1c4c..7bf42b1 100644
--- a/bfd/elf32-visium.c
+++ b/bfd/elf32-visium.c
@@ -513,7 +513,7 @@ visium_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -569,7 +569,7 @@ visium_elf_relocate_section (bfd *output_bfd,
   for (rel = relocs; rel < relend; rel++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -838,7 +838,7 @@ visium_elf_print_private_bfd_data (bfd *abfd, void *ptr)
   _bfd_elf_print_private_bfd_data (abfd, ptr);
 
   flags = elf_elfheader (abfd)->e_flags;
-  fprintf (file, _("private flags = 0x%lx:"), (long) flags);
+  fprintf (file, _("private flags = 0x%lx:"), (long long) flags);
 
   if (flags & EF_VISIUM_ARCH_GR6)
     fprintf (file, " -mtune=gr6");
diff --git a/bfd/elf32-xc16x.c b/bfd/elf32-xc16x.c
index 66fe33d..274ceac 100644
--- a/bfd/elf32-xc16x.c
+++ b/bfd/elf32-xc16x.c
@@ -244,7 +244,7 @@ elf32_xc16x_info_to_howto (bfd *abfd, arelent *bfd_reloc,
 }
 
 static bfd_reloc_status_type
-elf32_xc16x_final_link_relocate (unsigned long r_type,
+elf32_xc16x_final_link_relocate (unsigned long long r_type,
 				 bfd *input_bfd,
 				 bfd *output_bfd ATTRIBUTE_UNUSED,
 				 asection *input_section ATTRIBUTE_UNUSED,
@@ -354,7 +354,7 @@ elf32_xc16x_relocate_section (bfd *output_bfd,
   for (; rel < relend; rel++)
     {
       unsigned int r_type;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -411,7 +411,7 @@ static void
 elf32_xc16x_final_write_processing (bfd *abfd,
 				    bfd_boolean linker ATTRIBUTE_UNUSED)
 {
-  unsigned long val;
+  unsigned long long val;
 
   switch (bfd_get_mach (abfd))
     {
@@ -432,7 +432,7 @@ elf32_xc16x_final_write_processing (bfd *abfd,
   elf_elfheader (abfd)->e_flags |= val;
 }
 
-static unsigned long
+static unsigned long long
 elf32_xc16x_mach (flagword flags)
 {
   switch (flags)
diff --git a/bfd/elf32-xstormy16.c b/bfd/elf32-xstormy16.c
index 4cd7e62..f63774e 100644
--- a/bfd/elf32-xstormy16.c
+++ b/bfd/elf32-xstormy16.c
@@ -430,7 +430,7 @@ xstormy16_elf_check_relocs (bfd *abfd,
   relend = relocs + sec->reloc_count;
   for (rel = relocs; rel < relend; ++rel)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       bfd_vma *offset;
 
@@ -785,7 +785,7 @@ xstormy16_elf_relocate_section (bfd *			output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *	   howto;
-      unsigned long		   r_symndx;
+      unsigned long long		   r_symndx;
       Elf_Internal_Sym *	   sym;
       asection *		   sec;
       struct elf_link_hash_entry * h;
diff --git a/bfd/elf32-xtensa.c b/bfd/elf32-xtensa.c
index 44c1074..03b7433 100644
--- a/bfd/elf32-xtensa.c
+++ b/bfd/elf32-xtensa.c
@@ -97,10 +97,10 @@ static Elf_Internal_Sym *retrieve_local_syms (bfd *);
 
 static asection *elf_xtensa_get_plt_section (struct bfd_link_info *, int);
 static asection *elf_xtensa_get_gotplt_section (struct bfd_link_info *, int);
-static asection *get_elf_r_symndx_section (bfd *, unsigned long);
+static asection *get_elf_r_symndx_section (bfd *, unsigned long long);
 static struct elf_link_hash_entry *get_elf_r_symndx_hash_entry
-  (bfd *, unsigned long);
-static bfd_vma get_elf_r_symndx_offset (bfd *, unsigned long);
+  (bfd *, unsigned long long);
+static bfd_vma get_elf_r_symndx_offset (bfd *, unsigned long long);
 static bfd_boolean is_reloc_sym_weak (bfd *, Elf_Internal_Rela *);
 static bfd_boolean pcrel_reloc_fits (xtensa_opcode, int, bfd_vma, bfd_vma);
 static bfd_boolean xtensa_is_property_section (asection *);
@@ -887,7 +887,7 @@ xtensa_read_table_entries (bfd *abfd,
       if (irel && irel->r_offset == off)
 	{
 	  bfd_vma sym_off;
-	  unsigned long r_symndx = ELF32_R_SYM (irel->r_info);
+	  unsigned long long r_symndx = ELF32_R_SYM (irel->r_info);
 	  BFD_ASSERT (ELF32_R_TYPE (irel->r_info) == R_XTENSA_32);
 
 	  if (get_elf_r_symndx_section (abfd, r_symndx) != section)
@@ -2188,7 +2188,7 @@ bfd_elf_xtensa_reloc (bfd *abfd,
       *error_message = vsprint_msg (*error_message, ": (%s + 0x%lx)",
 				    strlen (symbol->name) + 17,
 				    symbol->name,
-				    (unsigned long) reloc_entry->addend);
+				    (unsigned long long) reloc_entry->addend);
     }
 
   return flag;
@@ -2481,7 +2481,7 @@ elf_xtensa_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       char sym_type;
@@ -3431,7 +3431,7 @@ static bfd_boolean
 elf_xtensa_object_p (bfd *abfd)
 {
   int mach;
-  unsigned long arch = elf_elfheader (abfd)->e_flags & EF_XTENSA_MACH;
+  unsigned long long arch = elf_elfheader (abfd)->e_flags & EF_XTENSA_MACH;
 
   switch (arch)
     {
@@ -3456,7 +3456,7 @@ elf_xtensa_final_write_processing (bfd *abfd,
 				   bfd_boolean linker ATTRIBUTE_UNUSED)
 {
   int mach;
-  unsigned long val;
+  unsigned long long val;
 
   switch (mach = bfd_get_mach (abfd))
     {
@@ -4816,7 +4816,7 @@ static bfd_vma
 r_reloc_get_target_offset (const r_reloc *r_rel)
 {
   bfd_vma target_offset;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
 
   BFD_ASSERT (!r_reloc_is_const (r_rel));
   r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
@@ -4828,7 +4828,7 @@ r_reloc_get_target_offset (const r_reloc *r_rel)
 static struct elf_link_hash_entry *
 r_reloc_get_hash_entry (const r_reloc *r_rel)
 {
-  unsigned long r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
+  unsigned long long r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
   return get_elf_r_symndx_hash_entry (r_rel->abfd, r_symndx);
 }
 
@@ -4836,7 +4836,7 @@ r_reloc_get_hash_entry (const r_reloc *r_rel)
 static asection *
 r_reloc_get_section (const r_reloc *r_rel)
 {
-  unsigned long r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
+  unsigned long long r_symndx = ELF32_R_SYM (r_rel->rela.r_info);
   return get_elf_r_symndx_section (r_rel->abfd, r_symndx);
 }
 
@@ -5031,7 +5031,7 @@ typedef struct value_map_hash_table_struct value_map_hash_table;
 struct literal_value_struct
 {
   r_reloc r_rel;
-  unsigned long value;
+  unsigned long long value;
   bfd_boolean is_abs_literal;
 };
 
@@ -5055,7 +5055,7 @@ struct value_map_hash_table_struct
 static void
 init_literal_value (literal_value *lit,
 		    const r_reloc *r_rel,
-		    unsigned long value,
+		    unsigned long long value,
 		    bfd_boolean is_abs_literal)
 {
   lit->r_rel = *r_rel;
@@ -5731,7 +5731,7 @@ print_action (FILE *fp, text_action *r)
 
   fprintf (fp, "%s: %s[0x%lx] \"%s\" %d\n",
 	   r->sec->owner->filename,
-	   r->sec->name, (unsigned long) r->offset, t, r->removed_bytes);
+	   r->sec->name, (unsigned long long) r->offset, t, r->removed_bytes);
 }
 
 static int
@@ -8887,7 +8887,7 @@ identify_literal_placement (bfd *abfd,
   xtensa_relax_info *relax_info;
   bfd_boolean literal_placed = FALSE;
   r_reloc r_rel;
-  unsigned long value;
+  unsigned long long value;
   bfd_boolean final_static_link;
   bfd_size_type sec_size;
 
@@ -9989,7 +9989,7 @@ shrink_dynamic_reloc_sections (struct bfd_link_info *info,
   struct elf_xtensa_link_hash_table *htab;
   Elf_Internal_Shdr *symtab_hdr;
   struct elf_link_hash_entry **sym_hashes;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   int r_type;
   struct elf_link_hash_entry *h;
   bfd_boolean dynamic_symbol;
@@ -10284,7 +10284,7 @@ relax_property_section (bfd *abfd,
 	      /* Translate the relocation's destination.  */
 	      bfd_vma old_offset = val.r_rel.target_offset;
 	      bfd_vma new_offset;
-	      long old_size, new_size;
+	      long long old_size, new_size;
 	      int removed_by_old_offset =
 		removed_by_actions_map (&target_relax_info->action_list,
 					old_offset, FALSE);
@@ -10766,7 +10766,7 @@ elf_xtensa_get_gotplt_section (struct bfd_link_info *info, int chunk)
    . an absolute value, return the absolute section.  */
 
 static asection *
-get_elf_r_symndx_section (bfd *abfd, unsigned long r_symndx)
+get_elf_r_symndx_section (bfd *abfd, unsigned long long r_symndx)
 {
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   asection *target_sec = NULL;
@@ -10789,7 +10789,7 @@ get_elf_r_symndx_section (bfd *abfd, unsigned long r_symndx)
     }
   else
     {
-      unsigned long indx = r_symndx - symtab_hdr->sh_info;
+      unsigned long long indx = r_symndx - symtab_hdr->sh_info;
       struct elf_link_hash_entry *h = elf_sym_hashes (abfd)[indx];
 
       while (h->root.type == bfd_link_hash_indirect
@@ -10819,9 +10819,9 @@ get_elf_r_symndx_section (bfd *abfd, unsigned long r_symndx)
 
 
 static struct elf_link_hash_entry *
-get_elf_r_symndx_hash_entry (bfd *abfd, unsigned long r_symndx)
+get_elf_r_symndx_hash_entry (bfd *abfd, unsigned long long r_symndx)
 {
-  unsigned long indx;
+  unsigned long long indx;
   struct elf_link_hash_entry *h;
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
 
@@ -10840,7 +10840,7 @@ get_elf_r_symndx_hash_entry (bfd *abfd, unsigned long r_symndx)
 /* Get the section-relative offset for a symbol number.  */
 
 static bfd_vma
-get_elf_r_symndx_offset (bfd *abfd, unsigned long r_symndx)
+get_elf_r_symndx_offset (bfd *abfd, unsigned long long r_symndx)
 {
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   bfd_vma offset = 0;
@@ -10853,7 +10853,7 @@ get_elf_r_symndx_offset (bfd *abfd, unsigned long r_symndx)
     }
   else
     {
-      unsigned long indx = r_symndx - symtab_hdr->sh_info;
+      unsigned long long indx = r_symndx - symtab_hdr->sh_info;
       struct elf_link_hash_entry *h =
 	elf_sym_hashes (abfd)[indx];
 
@@ -10871,7 +10871,7 @@ get_elf_r_symndx_offset (bfd *abfd, unsigned long r_symndx)
 static bfd_boolean
 is_reloc_sym_weak (bfd *abfd, Elf_Internal_Rela *rel)
 {
-  unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
+  unsigned long long r_symndx = ELF32_R_SYM (rel->r_info);
   struct elf_link_hash_entry *h;
 
   h = get_elf_r_symndx_hash_entry (abfd, r_symndx);
diff --git a/bfd/elf64-alpha.c b/bfd/elf64-alpha.c
index d59c596..681e792 100644
--- a/bfd/elf64-alpha.c
+++ b/bfd/elf64-alpha.c
@@ -150,7 +150,7 @@ struct alpha_elf_reloc_entry
   unsigned int reltext : 1;
 
   /* How many did we find?  */
-  unsigned long count;
+  unsigned long long count;
 };
 
 struct alpha_elf_link_hash_entry
@@ -397,7 +397,7 @@ elf64_alpha_do_reloc_gpdisp (bfd *abfd, bfd_vma gpdisp, bfd_byte *p_ldah,
 {
   bfd_reloc_status_type ret = bfd_reloc_ok;
   bfd_vma addend;
-  unsigned long i_ldah, i_lda;
+  unsigned long long i_ldah, i_lda;
 
   i_ldah = bfd_get_32 (abfd, p_ldah);
   i_lda = bfd_get_32 (abfd, p_lda);
@@ -1679,7 +1679,7 @@ elf64_alpha_output_extsym (struct alpha_elf_link_hash_entry *h, void * data)
 
 static struct alpha_elf_got_entry *
 get_got_entry (bfd *abfd, struct alpha_elf_link_hash_entry *h,
-	       unsigned long r_type, unsigned long r_symndx,
+	       unsigned long long r_type, unsigned long long r_symndx,
 	       bfd_vma r_addend)
 {
   struct alpha_elf_got_entry *gotent;
@@ -1819,7 +1819,7 @@ elf64_alpha_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	NEED_DYNREL = 4
       };
 
-      unsigned long r_symndx, r_type;
+      unsigned long long r_symndx, r_type;
       struct alpha_elf_link_hash_entry *h;
       unsigned int gotent_flags;
       bfd_boolean maybe_dynamic;
@@ -2549,7 +2549,7 @@ static void
 elf64_alpha_size_plt_section (struct bfd_link_info *info)
 {
   asection *splt, *spltrel, *sgotplt;
-  unsigned long entries;
+  unsigned long long entries;
   struct alpha_elf_link_hash_table * htab;
 
   htab = alpha_elf_hash_table (info);
@@ -2661,7 +2661,7 @@ elf64_alpha_calc_dynrel_sizes (struct alpha_elf_link_hash_entry *h,
 {
   bfd_boolean dynamic;
   struct alpha_elf_reloc_entry *relent;
-  unsigned long entries;
+  unsigned long long entries;
 
   /* If the symbol was defined as a common symbol in a regular object
      file, and there was no definition in any dynamic object, then the
@@ -2715,7 +2715,7 @@ elf64_alpha_size_rela_got_1 (struct alpha_elf_link_hash_entry *h,
 {
   bfd_boolean dynamic;
   struct alpha_elf_got_entry *gotent;
-  unsigned long entries;
+  unsigned long long entries;
 
   /* If we're using a plt for this symbol, then all of its relocations
      for its got entries go into .rela.plt.  */
@@ -2755,7 +2755,7 @@ elf64_alpha_size_rela_got_1 (struct alpha_elf_link_hash_entry *h,
 static void
 elf64_alpha_size_rela_got_section (struct bfd_link_info *info)
 {
-  unsigned long entries;
+  unsigned long long entries;
   bfd *i;
   asection *srel;
   struct alpha_elf_link_hash_table * htab;
@@ -3002,7 +3002,7 @@ elf64_alpha_find_reloc_at_ofs (Elf_Internal_Rela *rel,
 
 static bfd_boolean
 elf64_alpha_relax_got_load (struct alpha_relax_info *info, bfd_vma symval,
-			    Elf_Internal_Rela *irel, unsigned long r_type)
+			    Elf_Internal_Rela *irel, unsigned long long r_type)
 {
   unsigned int insn;
   bfd_signed_vma disp;
@@ -3490,7 +3490,7 @@ elf64_alpha_relax_tls_get_addr (struct alpha_relax_info *info, bfd_vma symval,
   unsigned int insn, tlsgd_reg;
   Elf_Internal_Rela *gpdisp, *hint;
   bfd_boolean dynamic, use_gottprel;
-  unsigned long new_symndx;
+  unsigned long long new_symndx;
 
   dynamic = alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info);
 
@@ -3555,7 +3555,7 @@ elf64_alpha_relax_tls_get_addr (struct alpha_relax_info *info, bfd_vma symval,
   {
     struct alpha_elf_got_entry *lit_gotent;
     struct alpha_elf_link_hash_entry *lit_h;
-    unsigned long indx;
+    unsigned long long indx;
 
     BFD_ASSERT (ELF64_R_SYM (irel[1].r_info) >= info->symtab_hdr->sh_info);
     indx = ELF64_R_SYM (irel[1].r_info) - info->symtab_hdr->sh_info;
@@ -3820,8 +3820,8 @@ elf64_alpha_relax_section (bfd *abfd, asection *sec,
     {
       bfd_vma symval;
       struct alpha_elf_got_entry *gotent;
-      unsigned long r_type = ELF64_R_TYPE (irel->r_info);
-      unsigned long r_symndx = ELF64_R_SYM (irel->r_info);
+      unsigned long long r_type = ELF64_R_TYPE (irel->r_info);
+      unsigned long long r_symndx = ELF64_R_SYM (irel->r_info);
 
       /* Early exit for unhandled or unrelaxable relocations.  */
       if (r_type != R_ALPHA_LITERAL)
@@ -3893,7 +3893,7 @@ elf64_alpha_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct alpha_elf_link_hash_entry *h;
 
 	  indx = r_symndx - symtab_hdr->sh_info;
@@ -4039,7 +4039,7 @@ elf64_alpha_relax_section (bfd *abfd, asection *sec,
 static void
 elf64_alpha_emit_dynrel (bfd *abfd, struct bfd_link_info *info,
 			 asection *sec, asection *srel, bfd_vma offset,
-			 long dynindx, long rtype, bfd_vma addend)
+			 long long dynindx, long long rtype, bfd_vma addend)
 {
   Elf_Internal_Rela outrel;
   bfd_byte *loc;
@@ -4076,7 +4076,7 @@ elf64_alpha_relocate_section_r (bfd *output_bfd ATTRIBUTE_UNUSED,
 				Elf_Internal_Sym *local_syms,
 				asection **local_sections)
 {
-  unsigned long symtab_hdr_sh_info;
+  unsigned long long symtab_hdr_sh_info;
   Elf_Internal_Rela *rel;
   Elf_Internal_Rela *relend;
   struct elf_link_hash_entry **sym_hashes;
@@ -4088,10 +4088,10 @@ elf64_alpha_relocate_section_r (bfd *output_bfd ATTRIBUTE_UNUSED,
   relend = relocs + input_section->reloc_count;
   for (rel = relocs; rel < relend; rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
-      unsigned long r_type;
+      unsigned long long r_type;
 
       r_type = ELF64_R_TYPE (rel->r_info);
       if (r_type >= R_ALPHA_max)
@@ -4231,7 +4231,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
       struct alpha_elf_got_entry *gotent;
       bfd_reloc_status_type r;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym = NULL;
       asection *sec = NULL;
       bfd_vma value;
@@ -4239,7 +4239,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
       bfd_boolean dynamic_symbol_p;
       bfd_boolean unresolved_reloc = FALSE;
       bfd_boolean undef_weak_ref = FALSE;
-      unsigned long r_type;
+      unsigned long long r_type;
 
       r_type = ELF64_R_TYPE(rel->r_info);
       if (r_type >= R_ALPHA_max)
@@ -4526,7 +4526,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	case R_ALPHA_DTPREL64:
 	case R_ALPHA_TPREL64:
 	  {
-	    long dynindx, dyntype = r_type;
+	    long long dynindx, dyntype = r_type;
 	    bfd_vma dynaddend;
 
 	    /* Careful here to remember RELATIVE relocations for global
@@ -4898,7 +4898,7 @@ elf64_alpha_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,
 	   gotent = gotent->next)
 	{
 	  asection *sgot;
-	  long r_type;
+	  long long r_type;
 
 	  if (gotent->use_count == 0)
 	    continue;
diff --git a/bfd/elf64-hppa.c b/bfd/elf64-hppa.c
index 2e66c92..4a3784f 100644
--- a/bfd/elf64-hppa.c
+++ b/bfd/elf64-hppa.c
@@ -62,7 +62,7 @@ struct elf64_hppa_link_hash_entry
   /* The index of the (possibly local) symbol in the input bfd and its
      associated BFD.  Needed so that we can have relocs against local
      symbols in shared libraries.  */
-  long sym_indx;
+  long long sym_indx;
   bfd *owner;
 
   /* Dynamic symbols may need to have two different values.  One for
@@ -524,7 +524,7 @@ elf64_hppa_check_relocs (bfd *abfd,
 
   if (bfd_link_pic (info) && hppa_info->section_syms_bfd != abfd)
     {
-      unsigned long i;
+      unsigned long long i;
       unsigned int highest_shndx;
       Elf_Internal_Sym *local_syms = NULL;
       Elf_Internal_Sym *isym, *isymend;
@@ -625,7 +625,7 @@ elf64_hppa_check_relocs (bfd *abfd,
 	  NEED_DYNREL = 16,
 	};
 
-      unsigned long r_symndx = ELF64_R_SYM (rel->r_info);
+      unsigned long long r_symndx = ELF64_R_SYM (rel->r_info);
       struct elf64_hppa_link_hash_entry *hh;
       int need_entry;
       bfd_boolean maybe_dynamic;
@@ -636,7 +636,7 @@ elf64_hppa_check_relocs (bfd *abfd,
 	{
 	  /* We're dealing with a global symbol -- find its hash entry
 	     and mark it as being referenced.  */
-	  long indx = r_symndx - symtab_hdr->sh_info;
+	  long long indx = r_symndx - symtab_hdr->sh_info;
 	  hh = hppa_elf_hash_entry (elf_sym_hashes (abfd)[indx]);
 	  while (hh->eh.root.type == bfd_link_hash_indirect
 		 || hh->eh.root.type == bfd_link_hash_warning)
@@ -3835,7 +3835,7 @@ elf64_hppa_relocate_section (bfd *output_bfd,
     {
       int r_type;
       reloc_howto_type *howto = elf_hppa_howto_table + ELF_R_TYPE (rel->r_info);
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *eh;
       Elf_Internal_Sym *sym;
       asection *sym_sec;
diff --git a/bfd/elf64-ia64-vms.c b/bfd/elf64-ia64-vms.c
index bc66b17..158be31 100644
--- a/bfd/elf64-ia64-vms.c
+++ b/bfd/elf64-ia64-vms.c
@@ -401,7 +401,7 @@ elf64_ia64_relax_section (bfd *abfd, asection *sec,
 
   for (irel = internal_relocs; irel < irelend; irel++)
     {
-      unsigned long r_type = ELF64_R_TYPE (irel->r_info);
+      unsigned long long r_type = ELF64_R_TYPE (irel->r_info);
       bfd_vma symaddr, reladdr, trampoff, toff, roff;
       asection *tsec;
       struct one_fixup *f;
@@ -487,7 +487,7 @@ elf64_ia64_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  indx = ELF64_R_SYM (irel->r_info) - symtab_hdr->sh_info;
@@ -1932,7 +1932,7 @@ elf64_ia64_check_relocs (bfd *abfd, struct bfd_link_info *info,
   };
   int need_entry;
   struct elf_link_hash_entry *h;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   bfd_boolean maybe_dynamic;
 
   if (bfd_link_relocatable (info))
@@ -1955,7 +1955,7 @@ elf64_ia64_check_relocs (bfd *abfd, struct bfd_link_info *info,
       r_symndx = ELF64_R_SYM (rel->r_info);
       if (r_symndx >= symtab_hdr->sh_info)
 	{
-	  long indx = r_symndx - symtab_hdr->sh_info;
+	  long long indx = r_symndx - symtab_hdr->sh_info;
 	  h = elf_sym_hashes (abfd)[indx];
 	  while (h->root.type == bfd_link_hash_indirect
 		 || h->root.type == bfd_link_hash_warning)
@@ -2102,7 +2102,7 @@ elf64_ia64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	{
 	  /* We're dealing with a global symbol -- find its hash entry
 	     and mark it as being referenced.  */
-	  long indx = r_symndx - symtab_hdr->sh_info;
+	  long long indx = r_symndx - symtab_hdr->sh_info;
 	  h = elf_sym_hashes (abfd)[indx];
 	  while (h->root.type == bfd_link_hash_indirect
 		 || h->root.type == bfd_link_hash_warning)
@@ -3424,7 +3424,7 @@ elf64_ia64_relocate_section (bfd *output_bfd,
       struct elf64_ia64_dyn_sym_info *dyn_i;
       bfd_reloc_status_type r;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       unsigned int r_type;
       bfd_vma value;
@@ -4686,7 +4686,7 @@ elf64_vms_final_write_processing (bfd *abfd,
 
   if (! elf_flags_init (abfd))
     {
-      unsigned long flags = 0;
+      unsigned long long flags = 0;
 
       if (abfd->xvec->byteorder == BFD_ENDIAN_BIG)
 	flags |= EF_IA_64_BE;
@@ -4720,7 +4720,7 @@ elf64_vms_close_and_cleanup (bfd *abfd)
 {
   if (bfd_get_format (abfd) == bfd_object)
     {
-      long isize;
+      long long isize;
 
       /* Pad to 8 byte boundary for IPF/VMS.  */
       isize = bfd_get_size (abfd);
diff --git a/bfd/elf64-mips.c b/bfd/elf64-mips.c
index 7c9916f..91e582a 100644
--- a/bfd/elf64-mips.c
+++ b/bfd/elf64-mips.c
@@ -82,7 +82,7 @@ static reloc_howto_type *bfd_elf64_bfd_reloc_type_lookup
   (bfd *, bfd_reloc_code_real_type);
 static bfd_boolean mips_elf64_info_to_howto_rela
   (bfd *, arelent *, Elf_Internal_Rela *);
-static long mips_elf64_get_dynamic_reloc_upper_bound
+static long long mips_elf64_get_dynamic_reloc_upper_bound
   (bfd *);
 static bfd_boolean mips_elf64_slurp_one_reloc_table
   (bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type, arelent *,
@@ -3980,7 +3980,7 @@ mips_elf64_info_to_howto_rela (bfd *abfd,
 /* Since each entry in an SHT_REL or SHT_RELA section can represent up
    to three relocs, we must tell the user to allocate more space.  */
 
-static long
+static long long
 mips_elf64_get_dynamic_reloc_upper_bound (bfd *abfd)
 {
   return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 3;
@@ -4519,7 +4519,7 @@ mips_elf64_write_rela (bfd *abfd, asection *sec,
 static bfd_boolean
 mips_elf64_object_p (bfd *abfd)
 {
-  unsigned long mach;
+  unsigned long long mach;
 
   /* Irix 6 is broken.  Object file symbol tables are not always
      sorted correctly such that local symbols precede global symbols,
@@ -4626,13 +4626,13 @@ elf64_mips_write_core_note (bfd *abfd, char *buf, int *bufsiz, int note_type,
       {
 	char data[480];
 	va_list ap;
-	long pid;
+	long long pid;
 	int cursig;
 	const void *greg;
 
 	va_start (ap, note_type);
 	memset (data, 0, 112);
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	bfd_put_32 (abfd, pid, data + 32);
 	cursig = va_arg (ap, int);
 	bfd_put_16 (abfd, cursig, data + 12);
diff --git a/bfd/elf64-mmix.c b/bfd/elf64-mmix.c
index 6f56b31..875d9ef 100644
--- a/bfd/elf64-mmix.c
+++ b/bfd/elf64-mmix.c
@@ -1381,7 +1381,7 @@ mmix_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   for (rel = relocs; rel < relend; rel ++)
     {
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -1979,7 +1979,7 @@ mmix_elf_check_relocs (bfd *abfd,
   for (rel = relocs; rel < rel_end; rel++)
     {
       struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       r_symndx = ELF64_R_SYM (rel->r_info);
       if (r_symndx < symtab_hdr->sh_info)
@@ -2417,8 +2417,8 @@ _bfd_mmix_after_linker_allocation (bfd *abfd ATTRIBUTE_UNUSED,
 	/* xgettext:c-format */
 	(_("internal inconsistency: remaining %lu != max %lu;"
 	   " please report this bug"),
-	 (unsigned long) gregdata->n_remaining_bpo_relocs_this_relaxation_round,
-	 (unsigned long) gregdata->n_bpo_relocs);
+	 (unsigned long long) gregdata->n_remaining_bpo_relocs_this_relaxation_round,
+	 (unsigned long long) gregdata->n_bpo_relocs);
       return FALSE;
     }
 
@@ -2511,8 +2511,8 @@ mmix_dump_bpo_gregs (struct bfd_link_info *link_info,
 	     gregdata->reloc_request[i].bpo_reloc_no,
 	     gregdata->reloc_request[i].valid,
 
-	     (unsigned long) (gregdata->reloc_request[i].value >> 32),
-	     (unsigned long) gregdata->reloc_request[i].value,
+	     (unsigned long long) (gregdata->reloc_request[i].value >> 32),
+	     (unsigned long long) gregdata->reloc_request[i].value,
 	     gregdata->reloc_request[i].regindex,
 	     gregdata->reloc_request[i].offset);
 }
@@ -2677,7 +2677,7 @@ mmix_elf_relax_section (bfd *abfd,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 
 	  /* An external symbol.  */
 	  indx = ELF64_R_SYM (irel->r_info) - symtab_hdr->sh_info;
diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
index 894a3b7..b1bcc6d 100644
--- a/bfd/elf64-ppc.c
+++ b/bfd/elf64-ppc.c
@@ -2578,7 +2578,7 @@ ppc64_elf_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
 		    bfd *output_bfd, char **error_message)
 {
   enum elf_ppc64_reloc_type r_type;
-  long insn;
+  long long insn;
   bfd_size_type octets;
   bfd_vma value;
 
@@ -2670,7 +2670,7 @@ ppc64_elf_brtaken_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
 			 void *data, asection *input_section,
 			 bfd *output_bfd, char **error_message)
 {
-  long insn;
+  long long insn;
   enum elf_ppc64_reloc_type r_type;
   bfd_size_type octets;
   /* Assume 'at' branch hints.  */
@@ -3060,13 +3060,13 @@ ppc64_elf_write_core_note (bfd *abfd, char *buf, int *bufsiz, int note_type,
       {
 	char data[504];
 	va_list ap;
-	long pid;
+	long long pid;
 	int cursig;
 	const void *greg;
 
 	va_start (ap, note_type);
 	memset (data, 0, 112);
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	bfd_put_32 (abfd, pid, data + 32);
 	cursig = va_arg (ap, int);
 	bfd_put_16 (abfd, cursig, data + 12);
@@ -3114,7 +3114,7 @@ struct _ppc64_elf_section_data
       asection **func_sec;
 
       /* After editing .opd, adjust references to opd local syms.  */
-      long *adjust;
+      long long *adjust;
     } opd;
 
     /* An array for toc sections, indexed by offset/8.  */
@@ -3257,9 +3257,9 @@ compare_symbols (const void *ap, const void *bp)
 /* Search SYMS for a symbol of the given VALUE.  */
 
 static asymbol *
-sym_exists_at (asymbol **syms, long lo, long hi, unsigned int id, bfd_vma value)
+sym_exists_at (asymbol **syms, long long lo, long long hi, unsigned int id, bfd_vma value)
 {
-  long mid;
+  long long mid;
 
   if (id == (unsigned) -1)
     {
@@ -3307,10 +3307,10 @@ section_covers_vma (bfd *abfd ATTRIBUTE_UNUSED, asection *section, void *ptr)
    entry syms.  Also generate @plt symbols for the glink branch table.
    Returns count of synthetic symbols in RET or -1 on error.  */
 
-static long
+static long long
 ppc64_elf_get_synthetic_symtab (bfd *abfd,
-				long static_count, asymbol **static_syms,
-				long dyn_count, asymbol **dyn_syms,
+				long long static_count, asymbol **static_syms,
+				long long dyn_count, asymbol **dyn_syms,
 				asymbol **ret)
 {
   asymbol *s;
@@ -4197,10 +4197,10 @@ struct ppc_link_hash_table
   bfd_size_type got_reli_size;
 
   /* Statistics.  */
-  unsigned long stub_count[ppc_stub_global_entry];
+  unsigned long long stub_count[ppc_stub_global_entry];
 
   /* Number of stubs against global syms.  */
-  unsigned long stub_globals;
+  unsigned long long stub_globals;
 
   /* Set if we're linking code with function descriptors.  */
   unsigned int opd_abi:1;
@@ -5312,7 +5312,7 @@ ppc64_elf_before_check_relocs (bfd *ibfd, struct bfd_link_info *info)
       for (rel = relocs; rel < rel_end; rel++)
 	{
 	  enum elf_ppc64_reloc_type r_type = ELF64_R_TYPE (rel->r_info);
-	  unsigned long r_symndx = ELF64_R_SYM (rel->r_info);
+	  unsigned long long r_symndx = ELF64_R_SYM (rel->r_info);
 
 	  if (r_type == R_PPC64_ADDR64
 	      && ELF64_R_TYPE ((rel + 1)->r_info) == R_PPC64_TOC
@@ -5397,7 +5397,7 @@ ppc64_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
 
 static struct plt_entry **
 update_local_sym_info (bfd *abfd, Elf_Internal_Shdr *symtab_hdr,
-		       unsigned long r_symndx, bfd_vma r_addend, int tls_type)
+		       unsigned long long r_symndx, bfd_vma r_addend, int tls_type)
 {
   struct got_entry **local_got_ents = elf_local_got_ents (abfd);
   struct plt_entry **local_plt;
@@ -5544,7 +5544,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       enum elf_ppc64_reloc_type r_type;
       int tls_type;
@@ -6145,7 +6145,7 @@ static bfd_boolean
 ppc64_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 {
   bfd *obfd = info->output_bfd;
-  unsigned long iflags, oflags;
+  unsigned long long iflags, oflags;
 
   if ((ibfd->flags & BFD_LINKER_CREATED) != 0)
     return TRUE;
@@ -6295,7 +6295,7 @@ opd_entry_value (asection *opd_sec,
 	  if (ELF64_R_TYPE (look->r_info) == R_PPC64_ADDR64
 	      && ELF64_R_TYPE ((look + 1)->r_info) == R_PPC64_TOC)
 	    {
-	      unsigned long symndx = ELF64_R_SYM (look->r_info);
+	      unsigned long long symndx = ELF64_R_SYM (look->r_info);
 	      asection *sec = NULL;
 
 	      if (symndx >= symtab_hdr->sh_info
@@ -6404,7 +6404,7 @@ ppc64_elf_maybe_function_sym (const asymbol *sym, asection *sec,
 	  /* opd_entry_value will use cached relocs that have been
 	     adjusted, but with raw symbols.  That means both local
 	     and global symbols need adjusting.  */
-	  long adjust = opd->adjust[OPD_NDX (symval)];
+	  long long adjust = opd->adjust[OPD_NDX (symval)];
 	  if (adjust == -1)
 	    return 0;
 	  symval += adjust;
@@ -7493,7 +7493,7 @@ get_sym_h (struct elf_link_hash_entry **hp,
 	   asection **symsecp,
 	   unsigned char **tls_maskp,
 	   Elf_Internal_Sym **locsymsp,
-	   unsigned long r_symndx,
+	   unsigned long long r_symndx,
 	   bfd *ibfd)
 {
   Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);
@@ -7583,13 +7583,13 @@ get_sym_h (struct elf_link_hash_entry **hp,
 
 static int
 get_tls_mask (unsigned char **tls_maskp,
-	      unsigned long *toc_symndx,
+	      unsigned long long *toc_symndx,
 	      bfd_vma *toc_addend,
 	      Elf_Internal_Sym **locsymsp,
 	      const Elf_Internal_Rela *rel,
 	      bfd *ibfd)
 {
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   int next_r;
   struct elf_link_hash_entry *h;
   Elf_Internal_Sym *sym;
@@ -7641,7 +7641,7 @@ tocsave_find (struct ppc_link_hash_table *htab,
 	      const Elf_Internal_Rela *irela,
 	      bfd *ibfd)
 {
-  unsigned long r_indx;
+  unsigned long long r_indx;
   struct elf_link_hash_entry *h;
   Elf_Internal_Sym *sym;
   struct tocsave_entry ent, *p;
@@ -7706,7 +7706,7 @@ adjust_opd_syms (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
   opd = get_opd_info (sym_sec);
   if (opd != NULL && opd->adjust != NULL)
     {
-      long adjust = opd->adjust[OPD_NDX (eh->elf.root.u.def.value)];
+      long long adjust = opd->adjust[OPD_NDX (eh->elf.root.u.def.value)];
       if (adjust == -1)
 	{
 	  /* This entry has been deleted.  */
@@ -7798,7 +7798,7 @@ dec_dynrel_count (bfd_vma r_info,
 
   if (local_syms != NULL)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       bfd *ibfd = sec->owner;
 
       r_symndx = ELF64_R_SYM (r_info);
@@ -7950,7 +7950,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)
       for (rel = relstart; rel < relend; )
 	{
 	  enum elf_ppc64_reloc_type r_type;
-	  unsigned long r_symndx;
+	  unsigned long long r_symndx;
 	  asection *sym_sec;
 	  struct elf_link_hash_entry *h;
 	  Elf_Internal_Sym *sym;
@@ -8063,7 +8063,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)
 	  bfd_size_type amt;
 
 	  new_contents = NULL;
-	  amt = OPD_NDX (sec->size) * sizeof (long);
+	  amt = OPD_NDX (sec->size) * sizeof (long long);
 	  opd = &ppc64_elf_section_data (sec)->u.opd;
 	  opd->adjust = bfd_zalloc (sec->owner, amt);
 	  if (opd->adjust == NULL)
@@ -8107,12 +8107,12 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)
 	  write_rel = relstart;
 	  for (rel = relstart; rel < relend; )
 	    {
-	      unsigned long r_symndx;
+	      unsigned long long r_symndx;
 	      asection *sym_sec;
 	      struct elf_link_hash_entry *h;
 	      struct ppc_link_hash_entry *fdh = NULL;
 	      Elf_Internal_Sym *sym;
-	      long opd_ent_size;
+	      long long opd_ent_size;
 	      Elf_Internal_Rela *next_rel;
 	      bfd_boolean skip;
 
@@ -8186,7 +8186,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)
 	      else
 		{
 		  /* We'll be keeping this opd entry.  */
-		  long adjust;
+		  long long adjust;
 
 		  if (fdh != NULL)
 		    {
@@ -8391,7 +8391,7 @@ ppc64_elf_inline_plt (struct bfd_link_info *info)
 	    for (rel = relstart; rel < relend; )
 	      {
 		enum elf_ppc64_reloc_type r_type;
-		unsigned long r_symndx;
+		unsigned long long r_symndx;
 		asection *sym_sec;
 		struct elf_link_hash_entry *h;
 		Elf_Internal_Sym *sym;
@@ -8654,7 +8654,7 @@ ppc64_elf_tls_optimize (struct bfd_link_info *info)
 	      for (rel = relstart; rel < relend; rel++)
 		{
 		  enum elf_ppc64_reloc_type r_type;
-		  unsigned long r_symndx;
+		  unsigned long long r_symndx;
 		  struct elf_link_hash_entry *h;
 		  Elf_Internal_Sym *sym;
 		  asection *sym_sec;
@@ -8662,7 +8662,7 @@ ppc64_elf_tls_optimize (struct bfd_link_info *info)
 		  unsigned char tls_set, tls_clear, tls_type = 0;
 		  bfd_vma value;
 		  bfd_boolean ok_tprel, is_local;
-		  long toc_ref_index = 0;
+		  long long toc_ref_index = 0;
 		  int expecting_tls_get_addr = 0;
 		  bfd_boolean ret = FALSE;
 
@@ -9079,7 +9079,7 @@ ppc64_elf_tls_optimize (struct bfd_link_info *info)
 struct adjust_toc_info
 {
   asection *toc;
-  unsigned long *skip;
+  unsigned long long *skip;
   bfd_boolean global_toc_syms;
 };
 
@@ -9090,7 +9090,7 @@ adjust_toc_syms (struct elf_link_hash_entry *h, void *inf)
 {
   struct ppc_link_hash_entry *eh;
   struct adjust_toc_info *toc_inf = (struct adjust_toc_info *) inf;
-  unsigned long i;
+  unsigned long long i;
 
   if (h->root.type != bfd_link_hash_defined
       && h->root.type != bfd_link_hash_defweak)
@@ -9181,7 +9181,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
       Elf_Internal_Shdr *symtab_hdr;
       Elf_Internal_Sym *local_syms;
       Elf_Internal_Rela *relstart, *rel, *toc_relocs;
-      unsigned long *skip, *drop;
+      unsigned long long *skip, *drop;
       unsigned char *used;
       unsigned char *keep, last, some_unused;
 
@@ -9220,7 +9220,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
 	  for (rel = relstart; rel < relstart + sec->reloc_count; ++rel)
 	    {
 	      enum elf_ppc64_reloc_type r_type;
-	      unsigned long r_symndx;
+	      unsigned long long r_symndx;
 	      asection *sym_sec;
 	      struct elf_link_hash_entry *h;
 	      Elf_Internal_Sym *sym;
@@ -9299,7 +9299,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
 	  for (rel = toc_relocs; rel < toc_relocs + toc->reloc_count; ++rel)
 	    {
 	      enum elf_ppc64_reloc_type r_type;
-	      unsigned long r_symndx;
+	      unsigned long long r_symndx;
 	      asection *sym_sec;
 	      struct elf_link_hash_entry *h;
 	      Elf_Internal_Sym *sym;
@@ -9417,7 +9417,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
 	      for (rel = relstart; rel < relstart + sec->reloc_count; ++rel)
 		{
 		  enum elf_ppc64_reloc_type r_type;
-		  unsigned long r_symndx;
+		  unsigned long long r_symndx;
 		  asection *sym_sec;
 		  struct elf_link_hash_entry *h;
 		  Elf_Internal_Sym *sym;
@@ -9596,7 +9596,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
       if (some_unused)
 	{
 	  bfd_byte *contents, *src;
-	  unsigned long off;
+	  unsigned long long off;
 	  Elf_Internal_Sym *sym;
 	  bfd_boolean local_toc_syms = FALSE;
 
@@ -9639,7 +9639,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
 	      for (rel = relstart; rel < relstart + sec->reloc_count; ++rel)
 		{
 		  enum elf_ppc64_reloc_type r_type;
-		  unsigned long r_symndx;
+		  unsigned long long r_symndx;
 		  asection *sym_sec;
 		  struct elf_link_hash_entry *h;
 		  bfd_vma val;
@@ -9687,7 +9687,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
 		    {
 		      Elf_Internal_Rela *tocrel
 			= toc_relocs + (skip[val >> 3] >> 2);
-		      unsigned long tsym = ELF64_R_SYM (tocrel->r_info);
+		      unsigned long long tsym = ELF64_R_SYM (tocrel->r_info);
 
 		      switch (r_type)
 			{
@@ -9736,7 +9736,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
 	      if (sym->st_value != 0
 		  && bfd_section_from_elf_index (ibfd, sym->st_shndx) == toc)
 		{
-		  unsigned long i;
+		  unsigned long long i;
 
 		  if (sym->st_value > toc->rawsize)
 		    i = toc->rawsize >> 3;
@@ -10675,7 +10675,7 @@ ppc_type_of_stub (asection *input_sec,
 		  struct ppc_link_hash_entry **hash,
 		  struct plt_entry **plt_ent,
 		  bfd_vma destination,
-		  unsigned long local_off)
+		  unsigned long long local_off)
 {
   struct ppc_link_hash_entry *h = *hash;
   bfd_vma location;
@@ -10715,7 +10715,7 @@ ppc_type_of_stub (asection *input_sec,
       Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (input_sec->owner);
       struct plt_entry **local_plt = (struct plt_entry **)
 	elf_local_got_ents (input_sec->owner) + symtab_hdr->sh_info;
-      unsigned long r_symndx = ELF64_R_SYM (rel->r_info);
+      unsigned long long r_symndx = ELF64_R_SYM (rel->r_info);
 
       if (local_plt[r_symndx] != NULL)
 	{
@@ -11227,7 +11227,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	  if (stub_entry->h != NULL)
 	    {
 	      struct elf_link_hash_entry **hashes;
-	      unsigned long symndx;
+	      unsigned long long symndx;
 	      struct ppc_link_hash_entry *h;
 
 	      hashes = elf_sym_hashes (htab->params->stub_bfd);
@@ -12137,7 +12137,7 @@ toc_adjusting_stub_needed (struct bfd_link_info *info, asection *isec)
       for (rel = relstart; rel < relstart + isec->reloc_count; ++rel)
 	{
 	  enum elf_ppc64_reloc_type r_type;
-	  unsigned long r_symndx;
+	  unsigned long long r_symndx;
 	  struct elf_link_hash_entry *h;
 	  struct ppc_link_hash_entry *eh;
 	  Elf_Internal_Sym *sym;
@@ -12203,7 +12203,7 @@ toc_adjusting_stub_needed (struct bfd_link_info *info, asection *isec)
 	    {
 	      if (h == NULL && opd->adjust != NULL)
 		{
-		  long adjust;
+		  long long adjust;
 
 		  adjust = opd->adjust[OPD_NDX (sym_value)];
 		  if (adjust == -1)
@@ -12722,7 +12722,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)
 		  asection *sym_sec, *code_sec;
 		  bfd_vma sym_value, code_value;
 		  bfd_vma destination;
-		  unsigned long local_off;
+		  unsigned long long local_off;
 		  bfd_boolean ok_dest;
 		  struct ppc_link_hash_entry *hash;
 		  struct ppc_link_hash_entry *fdh;
@@ -12823,7 +12823,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)
 
 		      if (hash == NULL && opd->adjust != NULL)
 			{
-			  long adjust = opd->adjust[OPD_NDX (sym_value)];
+			  long long adjust = opd->adjust[OPD_NDX (sym_value)];
 			  if (adjust == -1)
 			    continue;
 			  code_value += adjust;
@@ -13956,7 +13956,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,
       struct ppc_link_hash_entry *h;
       struct ppc_link_hash_entry *fdh;
       const char *sym_name;
-      unsigned long r_symndx, toc_symndx;
+      unsigned long long r_symndx, toc_symndx;
       bfd_vma toc_addend;
       unsigned char tls_mask, tls_gd, tls_type;
       unsigned char sym_type;
@@ -14008,7 +14008,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	  opd = get_opd_info (sec);
 	  if (opd != NULL && opd->adjust != NULL)
 	    {
-	      long adjust = opd->adjust[OPD_NDX (sym->st_value
+	      long long adjust = opd->adjust[OPD_NDX (sym->st_value
 						 + rel->r_addend)];
 	      if (adjust == -1)
 		relocation = 0;
@@ -14718,13 +14718,13 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 		 replaced by an insn to restore r2.  */
 	      else if (rel->r_offset + 8 <= input_section->size)
 		{
-		  unsigned long br;
+		  unsigned long long br;
 
 		  br = bfd_get_32 (input_bfd,
 				   contents + rel->r_offset);
 		  if ((br & 1) != 0)
 		    {
-		      unsigned long nop;
+		      unsigned long long nop;
 
 		      nop = bfd_get_32 (input_bfd,
 					contents + rel->r_offset + 4);
@@ -14993,7 +14993,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	    asection *got;
 	    bfd_vma *offp;
 	    bfd_vma off;
-	    unsigned long indx = 0;
+	    unsigned long long indx = 0;
 	    struct got_entry *ent;
 
 	    if (tls_type == (TLS_TLS | TLS_LD)
@@ -15410,7 +15410,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	      bfd_boolean skip, relocate;
 	      asection *sreloc;
 	      bfd_vma out_off;
-	      long indx = 0;
+	      long long indx = 0;
 
 	      /* When generating a dynamic object, these relocations
 		 are copied into the output file to be resolved at run
@@ -16018,7 +16018,7 @@ ppc64_elf_output_symbol_hook (struct bfd_link_info *info,
 			      struct elf_link_hash_entry *h)
 {
   struct _opd_sec_data *opd;
-  long adjust;
+  long long adjust;
   bfd_vma value;
 
   if (h != NULL)
diff --git a/bfd/elf64-s390.c b/bfd/elf64-s390.c
index 93a3c7c..d34ffc8 100644
--- a/bfd/elf64-s390.c
+++ b/bfd/elf64-s390.c
@@ -2122,7 +2122,7 @@ elf_s390_relocate_section (bfd *output_bfd,
     {
       unsigned int r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       asection *sec;
@@ -2704,7 +2704,7 @@ elf_s390_relocate_section (bfd *output_bfd,
 		    }
 		  else
 		    {
-		      long sindx;
+		      long long sindx;
 
 		      if (bfd_is_abs_section (sec))
 			sindx = 0;
@@ -3500,7 +3500,7 @@ elf_s390_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
   bfd *abfd = info->output_bfd;
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
   struct elf_s390_link_hash_table *htab = elf_s390_hash_table (info);
-  unsigned long r_symndx = ELF64_R_SYM (rela->r_info);
+  unsigned long long r_symndx = ELF64_R_SYM (rela->r_info);
   Elf_Internal_Sym sym;
 
   if (htab->elf.dynsym == NULL
@@ -3777,12 +3777,12 @@ elf_s390_write_core_note (bfd *abfd, char *buf, int *bufsiz,
     case NT_PRSTATUS:
       {
 	char data[336] = { 0 };
-	long pid;
+	long long pid;
 	int cursig;
 	const void *gregs;
 
 	va_start (ap, note_type);
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	cursig = va_arg (ap, int);
 	gregs = va_arg (ap, const void *);
 	va_end (ap);
diff --git a/bfd/elf64-sparc.c b/bfd/elf64-sparc.c
index 8c45d32..f238fe4 100644
--- a/bfd/elf64-sparc.c
+++ b/bfd/elf64-sparc.c
@@ -33,13 +33,13 @@
    section can represent up to two relocs, we must tell the user to allocate
    more space.  */
 
-static long
+static long long
 elf64_sparc_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
 {
   return (sec->reloc_count * 2 + 1) * sizeof (arelent *);
 }
 
-static long
+static long long
 elf64_sparc_get_dynamic_reloc_upper_bound (bfd *abfd)
 {
   return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 2;
@@ -215,7 +215,7 @@ elf64_sparc_slurp_reloc_table (bfd *abfd, asection *asect,
 
 /* Canonicalize the relocs.  */
 
-static long
+static long long
 elf64_sparc_canonicalize_reloc (bfd *abfd, sec_ptr section,
 				arelent **relptr, asymbol **symbols)
 {
@@ -245,12 +245,12 @@ elf64_sparc_canonicalize_reloc (bfd *abfd, sec_ptr section,
    the dynamic symbol table, is considered to be a dynamic reloc
    section.  */
 
-static long
+static long long
 elf64_sparc_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
 					asymbol **syms)
 {
   asection *s;
-  long ret;
+  long long ret;
 
   if (elf_dynsymtab (abfd) == 0)
     {
@@ -265,7 +265,7 @@ elf64_sparc_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
 	  && (elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
 	{
 	  arelent *p;
-	  long count, i;
+	  long long count, i;
 
 	  if (! elf64_sparc_slurp_reloc_table (abfd, s, syms, TRUE))
 	    return -1;
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index c3a6c31..854582a 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -450,7 +450,7 @@ elf_x86_64_write_core_note (bfd *abfd, char *buf, int *bufsiz,
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
   va_list ap;
   const char *fname, *psargs;
-  long pid;
+  long long pid;
   int cursig;
   const void *gregs;
 
@@ -487,7 +487,7 @@ elf_x86_64_write_core_note (bfd *abfd, char *buf, int *bufsiz,
 
     case NT_PRSTATUS:
       va_start (ap, note_type);
-      pid = va_arg (ap, long);
+      pid = va_arg (ap, long long);
       cursig = va_arg (ap, int);
       gregs = va_arg (ap, const void *);
       va_end (ap);
@@ -1026,7 +1026,7 @@ elf_x86_64_check_tls_transition (bfd *abfd,
 				 const Elf_Internal_Rela *relend)
 {
   unsigned int val;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   bfd_boolean largepic = FALSE;
   struct elf_link_hash_entry *h;
   bfd_vma offset;
@@ -1272,7 +1272,7 @@ elf_x86_64_tls_transition (struct bfd_link_info *info, bfd *abfd,
 			   const Elf_Internal_Rela *rel,
 			   const Elf_Internal_Rela *relend,
 			   struct elf_link_hash_entry *h,
-			   unsigned long r_symndx,
+			   unsigned long long r_symndx,
 			   bfd_boolean from_relocate_section)
 {
   unsigned int from_type = *r_type;
@@ -2405,7 +2405,7 @@ elf_x86_64_relocate_section (bfd *output_bfd,
     {
       unsigned int r_type, r_type_tls;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       struct elf_x86_link_hash_entry *eh;
       Elf_Internal_Sym *sym;
@@ -3218,7 +3218,7 @@ direct:
 		    }
 		  else
 		    {
-		      long sindx;
+		      long long sindx;
 
 		      if (bfd_is_abs_section (sec))
 			sindx = 0;
@@ -4368,7 +4368,7 @@ elf_x86_64_reloc_type_class (const struct bfd_link_info *info,
     {
       /* Check relocation against STT_GNU_IFUNC symbol if there are
 	 dynamic symbols.  */
-      unsigned long r_symndx = htab->r_sym (rela->r_info);
+      unsigned long long r_symndx = htab->r_sym (rela->r_info);
       if (r_symndx != STN_UNDEF)
 	{
 	  Elf_Internal_Sym sym;
@@ -4534,18 +4534,18 @@ static const struct elf_x86_lazy_plt_layout elf_x86_64_nacl_plt;
 /* Similar to _bfd_elf_get_synthetic_symtab.  Support PLTs with all
    dynamic relocations.   */
 
-static long
+static long long
 elf_x86_64_get_synthetic_symtab (bfd *abfd,
-				 long symcount ATTRIBUTE_UNUSED,
+				 long long symcount ATTRIBUTE_UNUSED,
 				 asymbol **syms ATTRIBUTE_UNUSED,
-				 long dynsymcount,
+				 long long dynsymcount,
 				 asymbol **dynsyms,
 				 asymbol **ret)
 {
-  long count, i, n;
+  long long count, i, n;
   int j;
   bfd_byte *plt_contents;
-  long relsize;
+  long long relsize;
   const struct elf_x86_lazy_plt_layout *lazy_plt;
   const struct elf_x86_non_lazy_plt_layout *non_lazy_plt;
   const struct elf_x86_lazy_plt_layout *lazy_bnd_plt;
diff --git a/bfd/elfcode.h b/bfd/elfcode.h
index fb02e25..4e6cbe2 100644
--- a/bfd/elfcode.h
+++ b/bfd/elfcode.h
@@ -829,7 +829,7 @@ elf_object_p (bfd *abfd)
 	   || elf_section_data (s)->this_hdr.sh_type == SHT_RELA)
 	  && elf_section_data (s)->this_hdr.sh_info > 0)
 	{
-	  unsigned long targ_index;
+	  unsigned long long targ_index;
 	  asection *targ_sec;
 
 	  targ_index = elf_section_data (s)->this_hdr.sh_info;
@@ -1125,12 +1125,12 @@ elf_checksum_contents (bfd *abfd,
   return TRUE;
 }
 
-long
+long long
 elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
 {
   Elf_Internal_Shdr *hdr;
   Elf_Internal_Shdr *verhdr;
-  unsigned long symcount;	/* Number of external ELF symbols */
+  unsigned long long symcount;	/* Number of external ELF symbols */
   elf_symbol_type *sym;		/* Pointer to current bfd symbol */
   elf_symbol_type *symbase;	/* Buffer for generated bfd symbols */
   Elf_Internal_Sym *isym;
@@ -1361,7 +1361,7 @@ elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
   /* Fill in the user's symbol pointer vector if needed.  */
   if (symptrs)
     {
-      long l = symcount;
+      long long l = symcount;
 
       sym = symbase;
       while (l-- > 0)
@@ -1456,7 +1456,7 @@ elf_slurp_reloc_table_from_section (bfd *abfd,
 	  _bfd_error_handler
 	    /* xgettext:c-format */
 	    (_("%pB(%pA): relocation %d has invalid symbol index %ld"),
-	     abfd, asect, i, (long) ELF_R_SYM (rela.r_info));
+	     abfd, asect, i, (long long) ELF_R_SYM (rela.r_info));
 	  bfd_set_error (bfd_error_bad_value);
 	  relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
 	}
@@ -1573,24 +1573,24 @@ elf_debug_section (int num, Elf_Internal_Shdr *hdr)
 {
   fprintf (stderr, "\nSection#%d '%s' 0x%.8lx\n", num,
 	   hdr->bfd_section != NULL ? hdr->bfd_section->name : "",
-	   (long) hdr);
+	   (long long) hdr);
   fprintf (stderr,
 	   "sh_name      = %ld\tsh_type      = %ld\tsh_flags     = %ld\n",
-	   (long) hdr->sh_name,
-	   (long) hdr->sh_type,
-	   (long) hdr->sh_flags);
+	   (long long) hdr->sh_name,
+	   (long long) hdr->sh_type,
+	   (long long) hdr->sh_flags);
   fprintf (stderr,
 	   "sh_addr      = %ld\tsh_offset    = %ld\tsh_size      = %ld\n",
-	   (long) hdr->sh_addr,
-	   (long) hdr->sh_offset,
-	   (long) hdr->sh_size);
+	   (long long) hdr->sh_addr,
+	   (long long) hdr->sh_offset,
+	   (long long) hdr->sh_size);
   fprintf (stderr,
 	   "sh_link      = %ld\tsh_info      = %ld\tsh_addralign = %ld\n",
-	   (long) hdr->sh_link,
-	   (long) hdr->sh_info,
-	   (long) hdr->sh_addralign);
+	   (long long) hdr->sh_link,
+	   (long long) hdr->sh_info,
+	   (long long) hdr->sh_addralign);
   fprintf (stderr, "sh_entsize   = %ld\n",
-	   (long) hdr->sh_entsize);
+	   (long long) hdr->sh_entsize);
   fflush (stderr);
 }
 #endif
@@ -1599,13 +1599,13 @@ elf_debug_section (int num, Elf_Internal_Shdr *hdr)
 static void
 elf_debug_file (Elf_Internal_Ehdr *ehdrp)
 {
-  fprintf (stderr, "e_entry      = 0x%.8lx\n", (long) ehdrp->e_entry);
-  fprintf (stderr, "e_phoff      = %ld\n", (long) ehdrp->e_phoff);
-  fprintf (stderr, "e_phnum      = %ld\n", (long) ehdrp->e_phnum);
-  fprintf (stderr, "e_phentsize  = %ld\n", (long) ehdrp->e_phentsize);
-  fprintf (stderr, "e_shoff      = %ld\n", (long) ehdrp->e_shoff);
-  fprintf (stderr, "e_shnum      = %ld\n", (long) ehdrp->e_shnum);
-  fprintf (stderr, "e_shentsize  = %ld\n", (long) ehdrp->e_shentsize);
+  fprintf (stderr, "e_entry      = 0x%.8lx\n", (long long) ehdrp->e_entry);
+  fprintf (stderr, "e_phoff      = %ld\n", (long long) ehdrp->e_phoff);
+  fprintf (stderr, "e_phnum      = %ld\n", (long long) ehdrp->e_phnum);
+  fprintf (stderr, "e_phentsize  = %ld\n", (long long) ehdrp->e_phentsize);
+  fprintf (stderr, "e_shoff      = %ld\n", (long long) ehdrp->e_shoff);
+  fprintf (stderr, "e_shnum      = %ld\n", (long long) ehdrp->e_shnum);
+  fprintf (stderr, "e_shentsize  = %ld\n", (long long) ehdrp->e_shentsize);
 }
 #endif
 
diff --git a/bfd/elflink.c b/bfd/elflink.c
index aabbf7f..bbca14c 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -60,7 +60,7 @@ static bfd_boolean _bfd_elf_fix_symbol_flags
 
 asection *
 _bfd_elf_section_for_symbol (struct elf_reloc_cookie *cookie,
-			     unsigned long r_symndx,
+			     unsigned long long r_symndx,
 			     bfd_boolean discard)
 {
   if (r_symndx >= cookie->locsymcount
@@ -749,7 +749,7 @@ bfd_elf_record_link_assignment (bfd *output_bfd,
 int
 bfd_elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
 					  bfd *input_bfd,
-					  long input_indx)
+					  long long input_indx)
 {
   bfd_size_type amt;
   struct elf_link_local_dynamic_entry *entry;
@@ -833,10 +833,10 @@ bfd_elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
 
 /* Return the dynindex of a local dynamic symbol.  */
 
-long
+long long
 _bfd_elf_link_lookup_local_dynindx (struct bfd_link_info *info,
 				    bfd *input_bfd,
-				    long input_indx)
+				    long long input_indx)
 {
   struct elf_link_local_dynamic_entry *e;
 
@@ -937,12 +937,12 @@ _bfd_elf_omit_section_dynsym_all
    and strip_excluded_output_sections setting dynindx for sections
    that are stripped.)  */
 
-static unsigned long
+static unsigned long long
 _bfd_elf_link_renumber_dynsyms (bfd *output_bfd,
 				struct bfd_link_info *info,
-				unsigned long *section_sym_count)
+				unsigned long long *section_sym_count)
 {
-  unsigned long dynsymcount = 0;
+  unsigned long long dynsymcount = 0;
   bfd_boolean do_sec = section_sym_count != NULL;
 
   if (bfd_link_pic (info)
@@ -2525,7 +2525,7 @@ elf_link_read_relocs_from_section (bfd *abfd,
 		/* xgettext:c-format */
 		(_("%pB: bad reloc symbol index (%#" PRIx64 " >= %#lx)"
 		   " for offset %#" PRIx64 " in section `%pA'"),
-		 abfd, (uint64_t) r_symndx, (unsigned long) nsyms,
+		 abfd, (uint64_t) r_symndx, (unsigned long long) nsyms,
 		 (uint64_t) irela->r_offset, sec);
 	      bfd_set_error (bfd_error_bad_value);
 	      return FALSE;
@@ -4042,7 +4042,7 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	  bfd_byte *dynbuf;
 	  bfd_byte *extdyn;
 	  unsigned int elfsec;
-	  unsigned long shlink;
+	  unsigned long long shlink;
 
 	  if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
 	    {
@@ -5097,7 +5097,7 @@ error_free_dyn:
 	  relend = rel + s->reloc_count;
 	  for ( ; rel < relend; rel++)
 	    {
-	      unsigned long r_symndx = rel->r_info >> r_sym_shift;
+	      unsigned long long r_symndx = rel->r_info >> r_sym_shift;
 	      struct elf_link_hash_entry *h;
 
 	      /* Skip local symbols.  */
@@ -5733,7 +5733,7 @@ bfd_elf_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 
 struct hash_codes_info
 {
-  unsigned long *hashcodes;
+  unsigned long long *hashcodes;
   bfd_boolean error;
 };
 
@@ -5745,7 +5745,7 @@ elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
 {
   struct hash_codes_info *inf = (struct hash_codes_info *) data;
   const char *name;
-  unsigned long ha;
+  unsigned long long ha;
   char *alc = NULL;
 
   /* Ignore indirect symbols.  These are added by the versioning code.  */
@@ -5790,20 +5790,20 @@ struct collect_gnu_hash_codes
 {
   bfd *output_bfd;
   const struct elf_backend_data *bed;
-  unsigned long int nsyms;
-  unsigned long int maskbits;
-  unsigned long int *hashcodes;
-  unsigned long int *hashval;
-  unsigned long int *indx;
-  unsigned long int *counts;
+  unsigned long long int nsyms;
+  unsigned long long int maskbits;
+  unsigned long long int *hashcodes;
+  unsigned long long int *hashval;
+  unsigned long long int *indx;
+  unsigned long long int *counts;
   bfd_vma *bitmask;
   bfd_byte *contents;
-  long int min_dynindx;
-  unsigned long int bucketcount;
-  unsigned long int symindx;
-  long int local_indx;
-  long int shift1, shift2;
-  unsigned long int mask;
+  long long int min_dynindx;
+  unsigned long long int bucketcount;
+  unsigned long long int symindx;
+  long long int local_indx;
+  long long int shift1, shift2;
+  unsigned long long int mask;
   bfd_boolean error;
 };
 
@@ -5815,7 +5815,7 @@ elf_collect_gnu_hash_codes (struct elf_link_hash_entry *h, void *data)
 {
   struct collect_gnu_hash_codes *s = (struct collect_gnu_hash_codes *) data;
   const char *name;
-  unsigned long ha;
+  unsigned long long ha;
   char *alc = NULL;
 
   /* Ignore indirect symbols.  These are added by the versioning code.  */
@@ -5868,8 +5868,8 @@ static bfd_boolean
 elf_renumber_gnu_hash_syms (struct elf_link_hash_entry *h, void *data)
 {
   struct collect_gnu_hash_codes *s = (struct collect_gnu_hash_codes *) data;
-  unsigned long int bucket;
-  unsigned long int val;
+  unsigned long long int bucket;
+  unsigned long long int val;
 
   /* Ignore indirect symbols.  */
   if (h->dynindx == -1)
@@ -5889,7 +5889,7 @@ elf_renumber_gnu_hash_syms (struct elf_link_hash_entry *h, void *data)
   s->bitmask[val] |= ((bfd_vma) 1) << (s->hashval[h->dynindx] & s->mask);
   s->bitmask[val]
     |= ((bfd_vma) 1) << ((s->hashval[h->dynindx] >> s->shift2) & s->mask);
-  val = s->hashval[h->dynindx] & ~(unsigned long int) 1;
+  val = s->hashval[h->dynindx] & ~(unsigned long long int) 1;
   if (s->counts[bucket] == 1)
     /* Last element terminates the chain.  */
     val |= 1;
@@ -5935,12 +5935,12 @@ static const size_t elf_buckets[] =
    (= short chain lengths) and table size.  */
 static size_t
 compute_bucket_count (struct bfd_link_info *info ATTRIBUTE_UNUSED,
-		      unsigned long int *hashcodes ATTRIBUTE_UNUSED,
-		      unsigned long int nsyms,
+		      unsigned long long int *hashcodes ATTRIBUTE_UNUSED,
+		      unsigned long long int nsyms,
 		      int gnu_hash)
 {
   size_t best_size = 0;
-  unsigned long int i;
+  unsigned long long int i;
 
   /* We have a problem here.  The following code to optimize the table
      size requires an integer type with more the 32 bits.  If
@@ -5954,7 +5954,7 @@ compute_bucket_count (struct bfd_link_info *info ATTRIBUTE_UNUSED,
       bfd *dynobj = elf_hash_table (info)->dynobj;
       size_t dynsymcount = elf_hash_table (info)->dynsymcount;
       const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
-      unsigned long int *counts;
+      unsigned long long int *counts;
       bfd_size_type amt;
       unsigned int no_improvement_count = 0;
 
@@ -5976,8 +5976,8 @@ compute_bucket_count (struct bfd_link_info *info ATTRIBUTE_UNUSED,
       /* Create array where we count the collisions in.  We must use bfd_malloc
 	 since the size could be large.  */
       amt = maxsize;
-      amt *= sizeof (unsigned long int);
-      counts = (unsigned long int *) bfd_malloc (amt);
+      amt *= sizeof (unsigned long long int);
+      counts = (unsigned long long int *) bfd_malloc (amt);
       if (counts == NULL)
 	return 0;
 
@@ -5988,13 +5988,13 @@ compute_bucket_count (struct bfd_link_info *info ATTRIBUTE_UNUSED,
 	{
 	  /* Walk through the array of hashcodes and count the collisions.  */
 	  BFD_HOST_U_64_BIT max;
-	  unsigned long int j;
-	  unsigned long int fact;
+	  unsigned long long int j;
+	  unsigned long long int fact;
 
 	  if (gnu_hash && (i & 31) == 0)
 	    continue;
 
-	  memset (counts, '\0', i * sizeof (unsigned long int));
+	  memset (counts, '\0', i * sizeof (unsigned long long int));
 
 	  /* Determine how often each hash bucket is used.  */
 	  for (j = 0; j < nsyms; ++j)
@@ -7050,7 +7050,7 @@ bfd_boolean
 bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
 {
   const struct elf_backend_data *bed;
-  unsigned long section_sym_count;
+  unsigned long long section_sym_count;
   bfd_size_type dynsymcount = 0;
 
   if (!is_elf_hash_table (info->hash))
@@ -7122,18 +7122,18 @@ bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
 	 computes the hash values for all the names we export.  */
       if (info->emit_hash)
 	{
-	  unsigned long int *hashcodes;
+	  unsigned long long int *hashcodes;
 	  struct hash_codes_info hashinf;
 	  bfd_size_type amt;
-	  unsigned long int nsyms;
+	  unsigned long long int nsyms;
 	  size_t bucketcount;
 	  size_t hash_entry_size;
 
 	  /* Compute the hash values for all exported symbols.  At the same
 	     time store the values in an array so that we could use them for
 	     optimizations.  */
-	  amt = dynsymcount * sizeof (unsigned long int);
-	  hashcodes = (unsigned long int *) bfd_malloc (amt);
+	  amt = dynsymcount * sizeof (unsigned long long int);
+	  hashcodes = (unsigned long long int *) bfd_malloc (amt);
 	  if (hashcodes == NULL)
 	    return FALSE;
 	  hashinf.hashcodes = hashcodes;
@@ -7184,8 +7184,8 @@ bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
 	  /* Compute the hash values for all exported symbols.  At the same
 	     time store the values in an array so that we could use them for
 	     optimizations.  */
-	  amt = dynsymcount * 2 * sizeof (unsigned long int);
-	  cinfo.hashcodes = (long unsigned int *) bfd_malloc (amt);
+	  amt = dynsymcount * 2 * sizeof (unsigned long long int);
+	  cinfo.hashcodes = (long long unsigned int *) bfd_malloc (amt);
 	  if (cinfo.hashcodes == NULL)
 	    return FALSE;
 
@@ -7241,7 +7241,7 @@ bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
 	    }
 	  else
 	    {
-	      unsigned long int maskwords, maskbitslog2, x;
+	      unsigned long long int maskwords, maskbitslog2, x;
 	      BFD_ASSERT (cinfo.min_dynindx != -1);
 
 	      x = cinfo.nsyms;
@@ -7266,7 +7266,7 @@ bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
 	      cinfo.shift2 = maskbitslog2;
 	      cinfo.maskbits = 1 << maskbitslog2;
 	      maskwords = 1 << (maskbitslog2 - cinfo.shift1);
-	      amt = bucketcount * sizeof (unsigned long int) * 2;
+	      amt = bucketcount * sizeof (unsigned long long int) * 2;
 	      amt += maskwords * sizeof (bfd_vma);
 	      cinfo.bitmask = (bfd_vma *) bfd_malloc (amt);
 	      if (cinfo.bitmask == NULL)
@@ -7275,7 +7275,7 @@ bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
 		  return FALSE;
 		}
 
-	      cinfo.counts = (long unsigned int *) (cinfo.bitmask + maskwords);
+	      cinfo.counts = (long long unsigned int *) (cinfo.bitmask + maskwords);
 	      cinfo.indx = cinfo.counts + bucketcount;
 	      cinfo.symindx = dynsymcount - cinfo.nsyms;
 	      memset (cinfo.bitmask, 0, maskwords * sizeof (bfd_vma));
@@ -7689,7 +7689,7 @@ bfd_elf_get_bfd_needed_list (bfd *abfd,
   asection *s;
   bfd_byte *dynbuf = NULL;
   unsigned int elfsec;
-  unsigned long shlink;
+  unsigned long long shlink;
   bfd_byte *extdyn, *extdynend;
   size_t extdynsize;
   void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
@@ -7762,7 +7762,7 @@ bfd_elf_get_bfd_needed_list (bfd *abfd,
 
 struct elf_symbuf_symbol
 {
-  unsigned long st_name;	/* Symbol name, index in string tbl */
+  unsigned long long st_name;	/* Symbol name, index in string tbl */
   unsigned char st_info;	/* Type and binding attributes */
   unsigned char st_other;	/* Visibilty, and target specific */
 };
@@ -8137,7 +8137,7 @@ struct elf_final_link_info
   Elf_Internal_Sym *internal_syms;
   /* Array large enough to hold a symbol index for each local symbol
      of any input BFD.  */
-  long *indices;
+  long long *indices;
   /* Array large enough to hold a section pointer for each local
      symbol of any input BFD.  */
   asection **sections;
@@ -8256,7 +8256,7 @@ resolve_symbol (const char *name,
 						   sym->st_name);
 #ifdef DEBUG
       printf ("Comparing string: '%s' vs. '%s' = 0x%lx\n",
-	      name, candidate, (unsigned long) sym->st_value);
+	      name, candidate, (unsigned long long) sym->st_value);
 #endif
       if (candidate && strcmp (candidate, name) == 0)
 	{
@@ -8266,7 +8266,7 @@ resolve_symbol (const char *name,
 	  *result += sec->output_offset + sec->output_section->vma;
 #ifdef DEBUG
 	  printf ("Found symbol with value %8.8lx\n",
-		  (unsigned long) *result);
+		  (unsigned long long) *result);
 #endif
 	  return TRUE;
 	}
@@ -8286,7 +8286,7 @@ resolve_symbol (const char *name,
 		 + global_entry->u.def.section->output_offset);
 #ifdef DEBUG
       printf ("Found GLOBAL symbol '%s' with value %8.8lx\n",
-	      global_entry->root.string, (unsigned long) *result);
+	      global_entry->root.string, (unsigned long long) *result);
 #endif
       return TRUE;
     }
@@ -8504,7 +8504,7 @@ eval_symbol (bfd_vma *result,
 
 static void
 put_value (bfd_vma size,
-	   unsigned long chunksz,
+	   unsigned long long chunksz,
 	   bfd *input_bfd,
 	   bfd_vma x,
 	   bfd_byte *location)
@@ -8546,7 +8546,7 @@ put_value (bfd_vma size,
 
 static bfd_vma
 get_value (bfd_vma size,
-	   unsigned long chunksz,
+	   unsigned long long chunksz,
 	   bfd *input_bfd,
 	   bfd_byte *location)
 {
@@ -8599,15 +8599,15 @@ get_value (bfd_vma size,
 }
 
 static void
-decode_complex_addend (unsigned long *start,   /* in bits */
-		       unsigned long *oplen,   /* in bits */
-		       unsigned long *len,     /* in bits */
-		       unsigned long *wordsz,  /* in bytes */
-		       unsigned long *chunksz, /* in bytes */
-		       unsigned long *lsb0_p,
-		       unsigned long *signed_p,
-		       unsigned long *trunc_p,
-		       unsigned long encoded)
+decode_complex_addend (unsigned long long *start,   /* in bits */
+		       unsigned long long *oplen,   /* in bits */
+		       unsigned long long *len,     /* in bits */
+		       unsigned long long *wordsz,  /* in bytes */
+		       unsigned long long *chunksz, /* in bytes */
+		       unsigned long long *lsb0_p,
+		       unsigned long long *signed_p,
+		       unsigned long long *trunc_p,
+		       unsigned long long encoded)
 {
   * start     =	 encoded	& 0x3F;
   * len	      = (encoded >>  6) & 0x3F;
@@ -8627,7 +8627,7 @@ bfd_elf_perform_complex_relocation (bfd *input_bfd,
 				    bfd_vma relocation)
 {
   bfd_vma shift, x, mask;
-  unsigned long start, oplen, len, wordsz, chunksz, lsb0_p, signed_p, trunc_p;
+  unsigned long long start, oplen, len, wordsz, chunksz, lsb0_p, signed_p, trunc_p;
   bfd_reloc_status_type r;
 
   /*  Perform this reloc, since it is complex.
@@ -8656,8 +8656,8 @@ bfd_elf_perform_complex_relocation (bfd *input_bfd,
 	  "chunksz %ld, start %ld, len %ld, oplen %ld\n"
 	  "    dest: %8.8lx, mask: %8.8lx, reloc: %8.8lx\n",
 	  lsb0_p, signed_p, trunc_p, wordsz, chunksz, start, len,
-	  oplen, (unsigned long) x, (unsigned long) mask,
-	  (unsigned long) relocation);
+	  oplen, (unsigned long long) x, (unsigned long long) mask,
+	  (unsigned long long) relocation);
 #endif
 
   r = bfd_reloc_ok;
@@ -8677,8 +8677,8 @@ bfd_elf_perform_complex_relocation (bfd *input_bfd,
 	  "         shifted mask: %8.8lx\n"
 	  " shifted/masked reloc: %8.8lx\n"
 	  "               result: %8.8lx\n",
-	  (unsigned long) relocation, (unsigned long) (mask << shift),
-	  (unsigned long) ((relocation & mask) << shift), (unsigned long) x);
+	  (unsigned long long) relocation, (unsigned long long) (mask << shift),
+	  (unsigned long long) ((relocation & mask) << shift), (unsigned long long) x);
 #endif
   put_value (wordsz, chunksz, input_bfd, x,
 	     contents + rel->r_offset * bfd_octets_per_byte (input_bfd));
@@ -9359,15 +9359,15 @@ elf_link_output_symstrtab (struct elf_final_link_info *flinfo,
   if (name == NULL
       || *name == '\0'
       || (input_sec->flags & SEC_EXCLUDE))
-    elfsym->st_name = (unsigned long) -1;
+    elfsym->st_name = (unsigned long long) -1;
   else
     {
       /* Call _bfd_elf_strtab_offset after _bfd_elf_strtab_finalize
 	 to get the final offset for st_name.  */
       elfsym->st_name
-	= (unsigned long) _bfd_elf_strtab_add (flinfo->symstrtab,
+	= (unsigned long long) _bfd_elf_strtab_add (flinfo->symstrtab,
 					       name, FALSE);
-      if (elfsym->st_name == (unsigned long) -1)
+      if (elfsym->st_name == (unsigned long long) -1)
 	return 0;
     }
 
@@ -9438,11 +9438,11 @@ elf_link_swap_symbols_out (struct elf_final_link_info *flinfo)
   for (i = 0; i < hash_table->strtabcount; i++)
     {
       struct elf_sym_strtab *elfsym = &hash_table->strtab[i];
-      if (elfsym->sym.st_name == (unsigned long) -1)
+      if (elfsym->sym.st_name == (unsigned long long) -1)
 	elfsym->sym.st_name = 0;
       else
 	elfsym->sym.st_name
-	  = (unsigned long) _bfd_elf_strtab_offset (flinfo->symstrtab,
+	  = (unsigned long long) _bfd_elf_strtab_offset (flinfo->symstrtab,
 						    elfsym->sym.st_name);
       bed->s->swap_symbol_out (flinfo->output_bfd, &elfsym->sym,
 			       ((bfd_byte *) symbuf
@@ -9688,7 +9688,7 @@ elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
   Elf_Internal_Sym sym;
   asection *input_sec;
   const struct elf_backend_data *bed;
-  long indx;
+  long long indx;
   int ret;
   unsigned int type;
 
@@ -10291,7 +10291,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
   Elf_Internal_Sym *isymbuf;
   Elf_Internal_Sym *isym;
   Elf_Internal_Sym *isymend;
-  long *pindex;
+  long long *pindex;
   asection **ppsection;
   asection *o;
   const struct elf_backend_data *bed;
@@ -10346,7 +10346,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
       asection *isec;
       const char *name;
       Elf_Internal_Sym osym;
-      long indx;
+      long long indx;
       int ret;
 
       *pindex = -1;
@@ -10532,7 +10532,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 	{
 	  /* Deal with the group signature symbol.  */
 	  struct bfd_elf_section_data *sec_data = elf_section_data (o);
-	  unsigned long symndx = sec_data->this_hdr.sh_info;
+	  unsigned long long symndx = sec_data->this_hdr.sh_info;
 	  asection *osec = o->output_section;
 
 	  BFD_ASSERT (bfd_link_relocatable (flinfo->info));
@@ -10562,7 +10562,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		  Elf_Internal_Sym sym = isymbuf[symndx];
 		  asection *sec = flinfo->sections[symndx]->output_section;
 		  const char *name;
-		  long indx;
+		  long long indx;
 		  int ret;
 
 		  name = bfd_elf_string_from_elf_section (input_bfd,
@@ -10680,7 +10680,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 	  relend = rel + o->reloc_count;
 	  for ( ; rel < relend; rel++)
 	    {
-	      unsigned long r_symndx = rel->r_info >> r_sym_shift;
+	      unsigned long long r_symndx = rel->r_info >> r_sym_shift;
 	      unsigned int s_type;
 	      asection **ps, *sec;
 	      struct elf_link_hash_entry *h = NULL;
@@ -10761,12 +10761,12 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		  printf ("Encountered a complex symbol!");
 		  printf (" (input_bfd %s, section %s, reloc %ld\n",
 			  input_bfd->filename, o->name,
-			  (long) (rel - internal_relocs));
+			  (long long) (rel - internal_relocs));
 		  printf (" symbol: idx  %8.8lx, name %s\n",
 			  r_symndx, sym_name);
 		  printf (" reloc : info %8.8lx, addr %8.8lx\n",
-			  (unsigned long) rel->r_info,
-			  (unsigned long) rel->r_offset);
+			  (unsigned long long) rel->r_info,
+			  (unsigned long long) rel->r_offset);
 #endif
 		  if (!eval_symbol (&val, &sym_name, input_bfd, flinfo, dot,
 				    isymbuf, locsymcount, s_type == STT_SRELC))
@@ -10878,7 +10878,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		last_offset += o->output_section->vma;
 	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
 		{
-		  unsigned long r_symndx;
+		  unsigned long long r_symndx;
 		  asection *sec;
 		  Elf_Internal_Sym sym;
 
@@ -10928,7 +10928,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 			  && flinfo->sections[r_symndx] == NULL))
 		    {
 		      struct elf_link_hash_entry *rh;
-		      unsigned long indx;
+		      unsigned long long indx;
 
 		      /* This is a reloc against a global symbol.  We
 			 have not yet output all the local symbols, so
@@ -11012,10 +11012,10 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		    {
 		      if (flinfo->indices[r_symndx] == -1)
 			{
-			  unsigned long shlink;
+			  unsigned long long shlink;
 			  const char *name;
 			  asection *osec;
-			  long indx;
+			  long long indx;
 
 			  if (flinfo->info->strip == strip_all)
 			    {
@@ -11189,7 +11189,7 @@ elf_reloc_link_order (bfd *output_bfd,
 		      struct bfd_link_order *link_order)
 {
   reloc_howto_type *howto;
-  long indx;
+  long long indx;
   bfd_vma offset;
   bfd_vma addend;
   struct bfd_elf_section_reloc_data *reldata;
@@ -11514,9 +11514,9 @@ elf_output_implib (bfd *abfd, struct bfd_link_info *info)
   enum bfd_architecture arch;
   unsigned int mach;
   asymbol **sympp = NULL;
-  long symsize;
-  long symcount;
-  long src_count;
+  long long symsize;
+  long long symcount;
+  long long src_count;
   elf_symbol_type *osymbuf;
 
   implib_bfd = info->out_implib_bfd;
@@ -12065,8 +12065,8 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
       if (flinfo.internal_syms == NULL)
 	goto error_return;
 
-      amt = max_sym_count * sizeof (long);
-      flinfo.indices = (long int *) bfd_malloc (amt);
+      amt = max_sym_count * sizeof (long long);
+      flinfo.indices = (long long int *) bfd_malloc (amt);
       if (flinfo.indices == NULL)
 	goto error_return;
 
@@ -12283,7 +12283,7 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
 	    {
 	      int indx;
 	      bfd_byte *dest;
-	      long dynindx;
+	      long long dynindx;
 
 	      dynindx = elf_section_data (s)->dynindx;
 	      if (dynindx <= 0)
@@ -12962,7 +12962,7 @@ _bfd_elf_gc_mark_rsec (struct bfd_link_info *info, asection *sec,
 		       struct elf_reloc_cookie *cookie,
 		       bfd_boolean *start_stop)
 {
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   struct elf_link_hash_entry *h;
 
   r_symndx = cookie->rel->r_info >> cookie->r_sym_shift;
@@ -13950,7 +13950,7 @@ bfd_elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
 
   for (; rcookie->rel < rcookie->relend; rcookie->rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       if (! rcookie->bad_symtab)
 	if (rcookie->rel->r_offset > offset)
@@ -14322,7 +14322,7 @@ _bfd_elf_default_got_elt_size (bfd *abfd,
 			       struct bfd_link_info *info ATTRIBUTE_UNUSED,
 			       struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
 			       bfd *ibfd ATTRIBUTE_UNUSED,
-			       unsigned long symndx ATTRIBUTE_UNUSED)
+			       unsigned long long symndx ATTRIBUTE_UNUSED)
 {
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
   return bed->s->arch_size / 8;
diff --git a/bfd/elfn32-mips.c b/bfd/elfn32-mips.c
index 10e10bf..03c691f 100644
--- a/bfd/elfn32-mips.c
+++ b/bfd/elfn32-mips.c
@@ -3400,7 +3400,7 @@ gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
 		 void *data, bfd_vma gp)
 {
   bfd_vma relocation;
-  unsigned long val;
+  unsigned long long val;
 
   if (bfd_is_com_section (symbol->section))
     relocation = 0;
@@ -3850,7 +3850,7 @@ mips_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
 static bfd_boolean
 mips_elf_n32_object_p (bfd *abfd)
 {
-  unsigned long mach;
+  unsigned long long mach;
 
   if (!ABI_N32_P (abfd))
     return FALSE;
@@ -3998,13 +3998,13 @@ elf32_mips_write_core_note (bfd *abfd, char *buf, int *bufsiz, int note_type,
       {
 	char data[440];
 	va_list ap;
-	long pid;
+	long long pid;
 	int cursig;
 	const void *greg;
 
 	va_start (ap, note_type);
 	memset (data, 0, 72);
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	bfd_put_32 (abfd, pid, data + 24);
 	cursig = va_arg (ap, int);
 	bfd_put_16 (abfd, cursig, data + 12);
diff --git a/bfd/elfnn-aarch64.c b/bfd/elfnn-aarch64.c
index cf321f3..ed820a9 100644
--- a/bfd/elfnn-aarch64.c
+++ b/bfd/elfnn-aarch64.c
@@ -2498,7 +2498,7 @@ struct elf_aarch64_link_hash_entry
 static unsigned int
 elfNN_aarch64_symbol_got_type (struct elf_link_hash_entry *h,
 			       bfd *abfd,
-			       unsigned long r_symndx)
+			       unsigned long long r_symndx)
 {
   if (h)
     return elf_aarch64_hash_entry (h)->got_type;
@@ -4816,7 +4816,7 @@ aarch64_can_relax_tls (bfd *input_bfd,
 		       struct bfd_link_info *info,
 		       bfd_reloc_code_real_type r_type,
 		       struct elf_link_hash_entry *h,
-		       unsigned long r_symndx)
+		       unsigned long long r_symndx)
 {
   unsigned int symbol_got_type;
   unsigned int reloc_got_type;
@@ -4847,7 +4847,7 @@ aarch64_tls_transition (bfd *input_bfd,
 			struct bfd_link_info *info,
 			unsigned int r_type,
 			struct elf_link_hash_entry *h,
-			unsigned long r_symndx)
+			unsigned long long r_symndx)
 {
   bfd_reloc_code_real_type bfd_r_type
     = elfNN_aarch64_bfd_reloc_from_type (input_bfd, r_type);
@@ -4887,7 +4887,7 @@ tpoff_base (struct bfd_link_info *info)
 
 static bfd_vma *
 symbol_got_offset_ref (bfd *input_bfd, struct elf_link_hash_entry *h,
-		       unsigned long r_symndx)
+		       unsigned long long r_symndx)
 {
   /* Calculate the address of the GOT entry for symbol
      referred to in h.  */
@@ -4905,7 +4905,7 @@ symbol_got_offset_ref (bfd *input_bfd, struct elf_link_hash_entry *h,
 
 static void
 symbol_got_offset_mark (bfd *input_bfd, struct elf_link_hash_entry *h,
-			unsigned long r_symndx)
+			unsigned long long r_symndx)
 {
   bfd_vma *p;
   p = symbol_got_offset_ref (input_bfd, h, r_symndx);
@@ -4914,7 +4914,7 @@ symbol_got_offset_mark (bfd *input_bfd, struct elf_link_hash_entry *h,
 
 static int
 symbol_got_offset_mark_p (bfd *input_bfd, struct elf_link_hash_entry *h,
-			  unsigned long r_symndx)
+			  unsigned long long r_symndx)
 {
   bfd_vma value;
   value = * symbol_got_offset_ref (input_bfd, h, r_symndx);
@@ -4923,7 +4923,7 @@ symbol_got_offset_mark_p (bfd *input_bfd, struct elf_link_hash_entry *h,
 
 static bfd_vma
 symbol_got_offset (bfd *input_bfd, struct elf_link_hash_entry *h,
-		   unsigned long r_symndx)
+		   unsigned long long r_symndx)
 {
   bfd_vma value;
   value = * symbol_got_offset_ref (input_bfd, h, r_symndx);
@@ -4933,7 +4933,7 @@ symbol_got_offset (bfd *input_bfd, struct elf_link_hash_entry *h,
 
 static bfd_vma *
 symbol_tlsdesc_got_offset_ref (bfd *input_bfd, struct elf_link_hash_entry *h,
-			       unsigned long r_symndx)
+			       unsigned long long r_symndx)
 {
   /* Calculate the address of the GOT entry for symbol
      referred to in h.  */
@@ -4955,7 +4955,7 @@ symbol_tlsdesc_got_offset_ref (bfd *input_bfd, struct elf_link_hash_entry *h,
 
 static void
 symbol_tlsdesc_got_offset_mark (bfd *input_bfd, struct elf_link_hash_entry *h,
-				unsigned long r_symndx)
+				unsigned long long r_symndx)
 {
   bfd_vma *p;
   p = symbol_tlsdesc_got_offset_ref (input_bfd, h, r_symndx);
@@ -4965,7 +4965,7 @@ symbol_tlsdesc_got_offset_mark (bfd *input_bfd, struct elf_link_hash_entry *h,
 static int
 symbol_tlsdesc_got_offset_mark_p (bfd *input_bfd,
 				  struct elf_link_hash_entry *h,
-				  unsigned long r_symndx)
+				  unsigned long long r_symndx)
 {
   bfd_vma value;
   value = * symbol_tlsdesc_got_offset_ref (input_bfd, h, r_symndx);
@@ -4974,7 +4974,7 @@ symbol_tlsdesc_got_offset_mark_p (bfd *input_bfd,
 
 static bfd_vma
 symbol_tlsdesc_got_offset (bfd *input_bfd, struct elf_link_hash_entry *h,
-			  unsigned long r_symndx)
+			  unsigned long long r_symndx)
 {
   bfd_vma value;
   value = * symbol_tlsdesc_got_offset_ref (input_bfd, h, r_symndx);
@@ -5001,7 +5001,7 @@ make_branch_to_erratum_835769_stub (struct bfd_hash_entry *gen_entry,
   struct elf_aarch64_stub_hash_entry *stub_entry;
   struct erratum_835769_branch_to_stub_data *data;
   bfd_byte *contents;
-  unsigned long branch_insn = 0;
+  unsigned long long branch_insn = 0;
   bfd_vma veneered_insn_loc, veneer_entry_loc;
   bfd_signed_vma branch_offset;
   unsigned int target;
@@ -5194,7 +5194,7 @@ elfNN_aarch64_final_link_relocate (reloc_howto_type *howto,
   unsigned int r_type = howto->type;
   bfd_reloc_code_real_type bfd_r_type
     = elfNN_aarch64_bfd_reloc_from_howto (howto);
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   bfd_byte *hit_data = contents + rel->r_offset;
   bfd_vma place, off, got_entry_addr = 0;
   bfd_signed_vma signed_addend;
@@ -5954,7 +5954,7 @@ elfNN_aarch64_tls_relax (struct elf_aarch64_link_hash_table *globals,
 {
   bfd_boolean is_local = h == NULL;
   unsigned int r_type = ELFNN_R_TYPE (rel->r_info);
-  unsigned long insn;
+  unsigned long long insn;
 
   BFD_ASSERT (globals && input_bfd && contents && rel);
 
@@ -6366,7 +6366,7 @@ elfNN_aarch64_relocate_section (bfd *output_bfd,
       bfd_reloc_code_real_type bfd_r_type;
       bfd_reloc_code_real_type relaxed_bfd_r_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       asection *sec;
       struct elf_link_hash_entry *h;
@@ -6955,7 +6955,7 @@ static bfd_boolean
 elfNN_aarch64_print_private_bfd_data (bfd *abfd, void *ptr)
 {
   FILE *file = (FILE *) ptr;
-  unsigned long flags;
+  unsigned long long flags;
 
   BFD_ASSERT (abfd != NULL && ptr != NULL);
 
@@ -7815,7 +7815,7 @@ elfNN_aarch64_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSE
 	 dynamic symbols.  */
       bfd *abfd = info->output_bfd;
       const struct elf_backend_data *bed = get_elf_backend_data (abfd);
-      unsigned long r_symndx = ELFNN_R_SYM (rela->r_info);
+      unsigned long long r_symndx = ELFNN_R_SYM (rela->r_info);
       if (r_symndx != STN_UNDEF)
 	{
 	  Elf_Internal_Sym sym;
diff --git a/bfd/elfnn-ia64.c b/bfd/elfnn-ia64.c
index e6551df..d6325af 100644
--- a/bfd/elfnn-ia64.c
+++ b/bfd/elfnn-ia64.c
@@ -399,7 +399,7 @@ elfNN_ia64_relax_section (bfd *abfd, asection *sec,
 
   for (irel = internal_relocs; irel < irelend; irel++)
     {
-      unsigned long r_type = ELFNN_R_TYPE (irel->r_info);
+      unsigned long long r_type = ELFNN_R_TYPE (irel->r_info);
       bfd_vma symaddr, reladdr, trampoff, toff, roff;
       asection *tsec;
       struct one_fixup *f;
@@ -487,7 +487,7 @@ elfNN_ia64_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  indx = ELFNN_R_SYM (irel->r_info) - symtab_hdr->sh_info;
@@ -1027,7 +1027,7 @@ elfNN_ia64_final_write_processing (bfd *abfd,
 
   if (! elf_flags_init (abfd))
     {
-      unsigned long flags = 0;
+      unsigned long long flags = 0;
 
       if (abfd->xvec->byteorder == BFD_ENDIAN_BIG)
 	flags |= EF_IA_64_BE;
@@ -2175,7 +2175,7 @@ elfNN_ia64_check_relocs (bfd *abfd, struct bfd_link_info *info,
   };
   int need_entry;
   struct elf_link_hash_entry *h;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   bfd_boolean maybe_dynamic;
 
   if (bfd_link_relocatable (info))
@@ -2198,7 +2198,7 @@ elfNN_ia64_check_relocs (bfd *abfd, struct bfd_link_info *info,
       r_symndx = ELFNN_R_SYM (rel->r_info);
       if (r_symndx >= symtab_hdr->sh_info)
 	{
-	  long indx = r_symndx - symtab_hdr->sh_info;
+	  long long indx = r_symndx - symtab_hdr->sh_info;
 	  h = elf_sym_hashes (abfd)[indx];
 	  while (h->root.type == bfd_link_hash_indirect
 		 || h->root.type == bfd_link_hash_warning)
@@ -2371,7 +2371,7 @@ elfNN_ia64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	{
 	  /* We're dealing with a global symbol -- find its hash entry
 	     and mark it as being referenced.  */
-	  long indx = r_symndx - symtab_hdr->sh_info;
+	  long long indx = r_symndx - symtab_hdr->sh_info;
 	  h = elf_sym_hashes (abfd)[indx];
 	  while (h->root.type == bfd_link_hash_indirect
 		 || h->root.type == bfd_link_hash_warning)
@@ -2568,7 +2568,7 @@ elfNN_ia64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	  if (!h && bfd_link_pic (info))
 	    {
 	      if (! (bfd_elf_link_record_local_dynamic_symbol
-		     (info, abfd, (long) r_symndx)))
+		     (info, abfd, (long long) r_symndx)))
 		return FALSE;
 	    }
 
@@ -2704,7 +2704,7 @@ allocate_local_got (struct elfNN_ia64_dyn_sym_info *dyn_i,
 
 /* Search for the index of a global symbol in it's defining object file.  */
 
-static long
+static long long
 global_sym_index (struct elf_link_hash_entry *h)
 {
   struct elf_link_hash_entry **p;
@@ -3252,7 +3252,7 @@ static void
 elfNN_ia64_install_dyn_reloc (bfd *abfd, struct bfd_link_info *info,
 			      asection *sec, asection *srel,
 			      bfd_vma offset, unsigned int type,
-			      long dynindx, bfd_vma addend)
+			      long long dynindx, bfd_vma addend)
 {
   Elf_Internal_Rela outrel;
   bfd_byte *loc;
@@ -3284,7 +3284,7 @@ elfNN_ia64_install_dyn_reloc (bfd *abfd, struct bfd_link_info *info,
 static bfd_vma
 set_got_entry (bfd *abfd, struct bfd_link_info *info,
 	       struct elfNN_ia64_dyn_sym_info *dyn_i,
-	       long dynindx, bfd_vma addend, bfd_vma value,
+	       long long dynindx, bfd_vma addend, bfd_vma value,
 	       unsigned int dyn_r_type)
 {
   struct elfNN_ia64_link_hash_table *ia64_info;
@@ -3847,7 +3847,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
       struct elfNN_ia64_dyn_sym_info *dyn_i;
       bfd_reloc_status_type r;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       Elf_Internal_Sym *sym;
       unsigned int r_type;
       bfd_vma value;
@@ -3980,7 +3980,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 	      && (input_section->flags & SEC_ALLOC) != 0)
 	    {
 	      unsigned int dyn_r_type;
-	      long dynindx;
+	      long long dynindx;
 	      bfd_vma addend;
 
 	      BFD_ASSERT (srel != NULL);
@@ -4107,7 +4107,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 	    }
 	  if (!dyn_i->want_fptr || bfd_link_pie (info))
 	    {
-	      long dynindx;
+	      long long dynindx;
 	      unsigned int dyn_r_type = r_type;
 	      bfd_vma addend = rel->r_addend;
 
@@ -4147,7 +4147,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 	      else
 		{
 		  dynindx = (_bfd_elf_link_lookup_local_dynindx
-			     (info, input_bfd, (long) r_symndx));
+			     (info, input_bfd, (long long) r_symndx));
 		  value = 0;
 		}
 
@@ -4166,7 +4166,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 	case R_IA64_LTOFF_FPTR64MSB:
 	case R_IA64_LTOFF_FPTR64LSB:
 	  {
-	    long dynindx;
+	    long long dynindx;
 
 	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
 	    if (dyn_i->want_fptr)
@@ -4191,7 +4191,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 		  }
 		else
 		  dynindx = (_bfd_elf_link_lookup_local_dynindx
-			     (info, input_bfd, (long) r_symndx));
+			     (info, input_bfd, (long long) r_symndx));
 		value = 0;
 	      }
 
@@ -4395,7 +4395,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
 	case R_IA64_LTOFF_DTPREL22:
 	  {
 	    int got_r_type;
-	    long dynindx = h ? h->dynindx : -1;
+	    long long dynindx = h ? h->dynindx : -1;
 	    bfd_vma r_addend = rel->r_addend;
 
 	    switch (r_type)
diff --git a/bfd/elfnn-riscv.c b/bfd/elfnn-riscv.c
index 934704a..7af9117 100644
--- a/bfd/elfnn-riscv.c
+++ b/bfd/elfnn-riscv.c
@@ -417,7 +417,7 @@ riscv_elf_copy_indirect_symbol (struct bfd_link_info *info,
 
 static bfd_boolean
 riscv_elf_record_tls_type (bfd *abfd, struct elf_link_hash_entry *h,
-			   unsigned long symndx, char tls_type)
+			   unsigned long long symndx, char tls_type)
 {
   char *new_tls_type = &_bfd_riscv_elf_tls_type (abfd, h, symndx);
 
@@ -434,7 +434,7 @@ riscv_elf_record_tls_type (bfd *abfd, struct elf_link_hash_entry *h,
 
 static bfd_boolean
 riscv_elf_record_got_reference (bfd *abfd, struct bfd_link_info *info,
-				struct elf_link_hash_entry *h, long symndx)
+				struct elf_link_hash_entry *h, long long symndx)
 {
   struct riscv_elf_link_hash_table *htab = riscv_elf_hash_table (info);
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
@@ -1720,7 +1720,7 @@ riscv_elf_relocate_section (bfd *output_bfd,
   relend = relocs + input_section->reloc_count;
   for (rel = relocs; rel < relend; rel++)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       asection *sec;
@@ -3466,7 +3466,7 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  indx = ELFNN_R_SYM (rel->r_info) - symtab_hdr->sh_info;
diff --git a/bfd/elfxx-aarch64.c b/bfd/elfxx-aarch64.c
index 61a5ffb..951dae0 100644
--- a/bfd/elfxx-aarch64.c
+++ b/bfd/elfxx-aarch64.c
@@ -660,13 +660,13 @@ _bfd_aarch64_elf_write_core_note (bfd *abfd, char *buf, int *bufsiz, int note_ty
       {
 	char data[392];
 	va_list ap;
-	long pid;
+	long long pid;
 	int cursig;
 	const void *greg;
 
 	va_start (ap, note_type);
 	memset (data, 0, sizeof (data));
-	pid = va_arg (ap, long);
+	pid = va_arg (ap, long long);
 	bfd_put_32 (abfd, pid, data + 32);
 	cursig = va_arg (ap, int);
 	bfd_put_16 (abfd, cursig, data + 12);
diff --git a/bfd/elfxx-ia64.c b/bfd/elfxx-ia64.c
index 290dcd8..7d6f5fa 100644
--- a/bfd/elfxx-ia64.c
+++ b/bfd/elfxx-ia64.c
@@ -386,7 +386,7 @@ ia64_elf_relax_br (bfd_byte *contents, bfd_vma off)
 {
   unsigned int template_val, mlx;
   bfd_vma t0, t1, s0, s1, s2, br_code;
-  long br_slot;
+  long long br_slot;
   bfd_byte *hit_addr;
 
   hit_addr = (bfd_byte *) (contents + off);
diff --git a/bfd/elfxx-mips.c b/bfd/elfxx-mips.c
index c33b276..868917a 100644
--- a/bfd/elfxx-mips.c
+++ b/bfd/elfxx-mips.c
@@ -78,7 +78,7 @@ struct mips_got_entry
   bfd *abfd;
   /* The index of the symbol, as stored in the relocation r_info, if
      we have a local symbol; -1 otherwise.  */
-  long symndx;
+  long long symndx;
   union
   {
     /* If abfd == NULL, an address that must be stored in the got.  */
@@ -104,7 +104,7 @@ struct mips_got_entry
   /* The offset from the beginning of the .got section to the entry
      corresponding to this symbol+addend.  If it's a global symbol
      whose offset is yet to be decided, it's going to be -1.  */
-  long gotidx;
+  long long gotidx;
 };
 
 /* This structure represents a GOT page reference from an input bfd.
@@ -119,7 +119,7 @@ struct mips_got_entry
    reference decays to a global GOT reference.  */
 struct mips_got_page_ref
 {
-  long symndx;
+  long long symndx;
   union
   {
     struct mips_elf_link_hash_entry *h;
@@ -632,12 +632,12 @@ static const char * const mips_elf_dynsym_rtproc_names[] =
 
 typedef struct
 {
-  unsigned long id1;		/* Always one?  */
-  unsigned long num;		/* Number of compact relocation entries.  */
-  unsigned long id2;		/* Always two?  */
-  unsigned long offset;		/* The file offset of the first relocation.  */
-  unsigned long reserved0;	/* Zero?  */
-  unsigned long reserved1;	/* Zero?  */
+  unsigned long long id1;		/* Always one?  */
+  unsigned long long num;		/* Number of compact relocation entries.  */
+  unsigned long long id2;		/* Always two?  */
+  unsigned long long offset;		/* The file offset of the first relocation.  */
+  unsigned long long reserved0;	/* Zero?  */
+  unsigned long long reserved1;	/* Zero?  */
 } Elf32_compact_rel;
 
 typedef struct
@@ -656,8 +656,8 @@ typedef struct
   unsigned int rtype : 4;	/* Relocation types. See below.  */
   unsigned int dist2to : 8;
   unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
-  unsigned long konst;		/* KONST field. See below.  */
-  unsigned long vaddr;		/* VADDR to be relocated.  */
+  unsigned long long konst;		/* KONST field. See below.  */
+  unsigned long long vaddr;		/* VADDR to be relocated.  */
 } Elf32_crinfo;
 
 typedef struct
@@ -666,7 +666,7 @@ typedef struct
   unsigned int rtype : 4;	/* Relocation types. See below.  */
   unsigned int dist2to : 8;
   unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
-  unsigned long konst;		/* KONST field. See below.  */
+  unsigned long long konst;		/* KONST field. See below.  */
 } Elf32_crinfo2;
 
 typedef struct
@@ -724,22 +724,22 @@ typedef struct
 
 typedef struct runtime_pdr {
 	bfd_vma	adr;		/* Memory address of start of procedure.  */
-	long	regmask;	/* Save register mask.  */
-	long	regoffset;	/* Save register offset.  */
-	long	fregmask;	/* Save floating point register mask.  */
-	long	fregoffset;	/* Save floating point register offset.  */
-	long	frameoffset;	/* Frame size.  */
+	long long	regmask;	/* Save register mask.  */
+	long long	regoffset;	/* Save register offset.  */
+	long long	fregmask;	/* Save floating point register mask.  */
+	long long	fregoffset;	/* Save floating point register offset.  */
+	long long	frameoffset;	/* Frame size.  */
 	short	framereg;	/* Frame pointer register.  */
 	short	pcreg;		/* Offset or reg of return pc.  */
-	long	irpss;		/* Index into the runtime string table.  */
-	long	reserved;
+	long long	irpss;		/* Index into the runtime string table.  */
+	long long	reserved;
 	struct exception_info *exception_info;/* Pointer to exception array.  */
 } RPDR, *pRPDR;
 #define cbRPDR sizeof (RPDR)
 #define rpdNil ((pRPDR) 0)
 
 static struct mips_got_entry *mips_elf_create_local_got_entry
-  (bfd *, struct bfd_link_info *, bfd *, bfd_vma, unsigned long,
+  (bfd *, struct bfd_link_info *, bfd *, bfd_vma, unsigned long long,
    struct mips_elf_link_hash_entry *, int);
 static bfd_boolean mips_elf_sort_hash_table_f
   (struct mips_elf_link_hash_entry *, void *);
@@ -1437,8 +1437,8 @@ mips_elf_create_procedure_table (void *handle, bfd *abfd,
   char *str;
   bfd_size_type size;
   bfd_size_type count;
-  unsigned long sindex;
-  unsigned long i;
+  unsigned long long sindex;
+  unsigned long long i;
   PDR pdr;
   SYMR sym;
   const char *no_name_func = _("static procedure (no name)");
@@ -1491,7 +1491,7 @@ mips_elf_create_procedure_table (void *handle, bfd *abfd,
 	goto error_return;
 
       count = hdr->ipdMax;
-      for (i = 0; i < (unsigned long) count; i++, rp++)
+      for (i = 0; i < (unsigned long long) count; i++, rp++)
 	{
 	  (*swap->swap_pdr_in) (abfd, epdr + i, &pdr);
 	  (*swap->swap_sym_in) (abfd, &esym[pdr.isym], &sym);
@@ -1667,7 +1667,7 @@ section_allows_mips16_refs_p (asection *section)
    stub section of some kind.  Return the R_SYMNDX of the target
    function, or 0 if we can't decide which function that is.  */
 
-static unsigned long
+static unsigned long long
 mips16_stub_symndx (const struct elf_backend_data *bed,
 		    asection *sec ATTRIBUTE_UNUSED,
 		    const Elf_Internal_Rela *relocs,
@@ -2640,7 +2640,7 @@ static void
 bfd_elf32_swap_crinfo_out (bfd *abfd, const Elf32_crinfo *in,
 			   Elf32_External_crinfo *ex)
 {
-  unsigned long l;
+  unsigned long long l;
 
   l = (((in->ctype & CRINFO_CTYPE) << CRINFO_CTYPE_SH)
        | ((in->rtype & CRINFO_RTYPE) << CRINFO_RTYPE_SH)
@@ -3306,8 +3306,8 @@ mips_elf_count_got_entry (struct bfd_link_info *info,
 static void
 mips_elf_output_dynamic_relocation (bfd *output_bfd,
 				    asection *sreloc,
-				    unsigned long reloc_index,
-				    unsigned long indx,
+				    unsigned long long reloc_index,
+				    unsigned long long indx,
 				    int r_type,
 				    bfd_vma offset)
 {
@@ -3497,7 +3497,7 @@ mips_elf_gotplt_index (struct bfd_link_info *info,
 
 static bfd_vma
 mips_elf_local_got_index (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
-			  bfd_vma value, unsigned long r_symndx,
+			  bfd_vma value, unsigned long long r_symndx,
 			  struct mips_elf_link_hash_entry *h, int r_type)
 {
   struct mips_elf_link_hash_table *htab;
@@ -3523,7 +3523,7 @@ mips_elf_primary_global_got_index (bfd *obfd, struct bfd_link_info *info,
 				   struct elf_link_hash_entry *h)
 {
   struct mips_elf_link_hash_table *htab;
-  long global_got_dynindx;
+  long long global_got_dynindx;
   struct mips_got_info *g;
   bfd_vma got_index;
 
@@ -3679,7 +3679,7 @@ mips_elf_got_offset_from_index (struct bfd_link_info *info, bfd *output_bfd,
 static struct mips_got_entry *
 mips_elf_create_local_got_entry (bfd *abfd, struct bfd_link_info *info,
 				 bfd *ibfd, bfd_vma value,
-				 unsigned long r_symndx,
+				 unsigned long long r_symndx,
 				 struct mips_elf_link_hash_entry *h,
 				 int r_type)
 {
@@ -4001,7 +4001,7 @@ mips_elf_record_global_got_symbol (struct elf_link_hash_entry *h,
    where SYMNDX is a local symbol.  Reserve a GOT entry for it.  */
 
 static bfd_boolean
-mips_elf_record_local_got_symbol (bfd *abfd, long symndx, bfd_vma addend,
+mips_elf_record_local_got_symbol (bfd *abfd, long long symndx, bfd_vma addend,
 				  struct bfd_link_info *info, int r_type)
 {
   struct mips_elf_link_hash_table *htab;
@@ -4027,7 +4027,7 @@ mips_elf_record_local_got_symbol (bfd *abfd, long symndx, bfd_vma addend,
 
 static bfd_boolean
 mips_elf_record_got_page_ref (struct bfd_link_info *info, bfd *abfd,
-			      long symndx, struct elf_link_hash_entry *h,
+			      long long symndx, struct elf_link_hash_entry *h,
 			      bfd_signed_vma addend)
 {
   struct mips_elf_link_hash_table *htab;
@@ -4663,7 +4663,7 @@ mips_elf_merge_got (bfd *abfd, struct mips_got_info *g,
    an index in a different GOT.  */
 
 static bfd_boolean
-mips_elf_set_gotidx (void **entryp, long gotidx)
+mips_elf_set_gotidx (void **entryp, long long gotidx)
 {
   struct mips_got_entry *entry;
 
@@ -4989,7 +4989,7 @@ mips_elf_next_relocation (bfd *abfd ATTRIBUTE_UNUSED, unsigned int r_type,
 			  const Elf_Internal_Rela *relocation,
 			  const Elf_Internal_Rela *relend)
 {
-  unsigned long r_symndx = ELF_R_SYM (abfd, relocation->r_info);
+  unsigned long long r_symndx = ELF_R_SYM (abfd, relocation->r_info);
 
   while (relocation < relend)
     {
@@ -5011,7 +5011,7 @@ mips_elf_local_relocation_p (bfd *input_bfd,
 			     const Elf_Internal_Rela *relocation,
 			     asection **local_sections)
 {
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   Elf_Internal_Shdr *symtab_hdr;
   size_t extsymoff;
 
@@ -5295,7 +5295,7 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
   bfd_boolean gnu_local_gp_p = FALSE;
   Elf_Internal_Shdr *symtab_hdr;
   size_t extsymoff;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   int r_type;
   /* TRUE if overflow occurred during the calculation of the
      relocation value.  */
@@ -6534,7 +6534,7 @@ mips_elf_create_dynamic_relocation (bfd *output_bfd,
   asection *sreloc;
   bfd *dynobj;
   int r_type;
-  long indx;
+  long long indx;
   bfd_boolean defined_p;
   struct mips_elf_link_hash_table *htab;
 
@@ -6641,7 +6641,7 @@ mips_elf_create_dynamic_relocation (bfd *output_bfd,
   else
     /* The relocation is always an REL32 relocation because we don't
        know where the shared library will wind up at load-time.  */
-    outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long) indx,
+    outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long long) indx,
 				   R_MIPS_REL32);
 
   /* For strict adherence to the ABI specification, we should
@@ -6745,7 +6745,7 @@ mips_elf_create_dynamic_relocation (bfd *output_bfd,
 
 /* Return the MACH for a MIPS e_flags value.  */
 
-unsigned long
+unsigned long long
 _bfd_elf_mips_mach (flagword flags)
 {
   switch (flags & EF_MIPS_MACH)
@@ -8134,7 +8134,7 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
   name = bfd_get_section_name (abfd, sec);
   if (FN_STUB_P (name))
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
 
       /* Look at the relocation information to figure out which symbol
 	 this is for.  */
@@ -8204,7 +8204,7 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	     this BFD.  */
 	  if (mips_elf_tdata (abfd)->local_stubs == NULL)
 	    {
-	      unsigned long symcount;
+	      unsigned long long symcount;
 	      asection **n;
 	      bfd_size_type amt;
 
@@ -8258,7 +8258,7 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
     }
   else if (CALL_STUB_P (name) || CALL_FP_STUB_P (name))
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct mips_elf_link_hash_entry *h;
       asection **loc;
 
@@ -8330,7 +8330,7 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	     this BFD.  */
 	  if (mips_elf_tdata (abfd)->local_call_stubs == NULL)
 	    {
-	      unsigned long symcount;
+	      unsigned long long symcount;
 	      asection **n;
 	      bfd_size_type amt;
 
@@ -8386,7 +8386,7 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
   contents = NULL;
   for (rel = relocs; rel < rel_end; ++rel)
     {
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       unsigned int r_type;
       struct elf_link_hash_entry *h;
       bfd_boolean can_make_dynamic_p;
@@ -10072,7 +10072,7 @@ _bfd_mips_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
       bfd_boolean rela_relocation_p = TRUE;
       unsigned int r_type = ELF_R_TYPE (output_bfd, rel->r_info);
       const char *msg;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       asection *sec;
       Elf_Internal_Shdr *symtab_hdr;
       struct elf_link_hash_entry *h;
@@ -10093,7 +10093,7 @@ _bfd_mips_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 	}
       else
 	{
-	  unsigned long extsymoff;
+	  unsigned long long extsymoff;
 
 	  extsymoff = 0;
 	  if (!elf_bad_symtab (input_bfd))
@@ -10809,7 +10809,7 @@ _bfd_mips_elf_finish_dynamic_symbol (bfd *output_bfd,
 	    }
 	  if (stub_size == stub_big_size)
 	    {
-	      long dynindx_hi = (h->dynindx >> 16) & 0x7fff;
+	      long long dynindx_hi = (h->dynindx >> 16) & 0x7fff;
 
 	      bfd_put_micromips_32 (output_bfd,
 				    STUB_LUI_MICROMIPS (dynindx_hi),
@@ -12870,9 +12870,9 @@ _bfd_elf_mips_get_relocated_section_contents
   asection *input_section = link_order->u.indirect.section;
   bfd_size_type sz;
 
-  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
+  long long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
   arelent **reloc_vector = NULL;
-  long reloc_count;
+  long long reloc_count;
 
   if (reloc_size < 0)
     goto error_return;
@@ -13090,8 +13090,8 @@ mips_elf_relax_delete_bytes (bfd *abfd,
    opcodes/micromips-opc.c.  */
 
 struct opcode_descriptor {
-  unsigned long match;
-  unsigned long mask;
+  unsigned long long match;
+  unsigned long long mask;
 };
 
 /* The $ra register aka $31.  */
@@ -13293,9 +13293,9 @@ static const struct opcode_descriptor nop_insn_16 =
 #define MATCH(opcode, insn) ((opcode & insn.mask) == insn.match)
 
 static int
-find_match (unsigned long opcode, const struct opcode_descriptor insn[])
+find_match (unsigned long long opcode, const struct opcode_descriptor insn[])
 {
-  unsigned long indx;
+  unsigned long long indx;
 
   for (indx = 0; insn[indx].mask != 0; indx++)
     if (MATCH (opcode, insn[indx]))
@@ -13315,7 +13315,7 @@ find_match (unsigned long opcode, const struct opcode_descriptor insn[])
 static int
 check_br16_dslot (bfd *abfd, bfd_byte *ptr)
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bdsize;
 
   opcode = bfd_get_16 (abfd, ptr);
@@ -13341,7 +13341,7 @@ check_br16_dslot (bfd *abfd, bfd_byte *ptr)
 static int
 check_br32_dslot (bfd *abfd, bfd_byte *ptr)
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bdsize;
 
   opcode = bfd_get_micromips_32 (abfd, ptr);
@@ -13362,9 +13362,9 @@ check_br32_dslot (bfd *abfd, bfd_byte *ptr)
    that doesn't fiddle with REG, then return TRUE, otherwise FALSE.  */
 
 static bfd_boolean
-check_br16 (bfd *abfd, bfd_byte *ptr, unsigned long reg)
+check_br16 (bfd *abfd, bfd_byte *ptr, unsigned long long reg)
 {
-  unsigned long opcode;
+  unsigned long long opcode;
 
   opcode = bfd_get_16 (abfd, ptr);
   if (MATCH (opcode, b_insn_16)
@@ -13385,9 +13385,9 @@ check_br16 (bfd *abfd, bfd_byte *ptr, unsigned long reg)
    then return TRUE, otherwise FALSE.  */
 
 static bfd_boolean
-check_br32 (bfd *abfd, bfd_byte *ptr, unsigned long reg)
+check_br32 (bfd *abfd, bfd_byte *ptr, unsigned long long reg)
 {
-  unsigned long opcode;
+  unsigned long long opcode;
 
   opcode = bfd_get_micromips_32 (abfd, ptr);
   if (MATCH (opcode, j_insn_32)
@@ -13419,7 +13419,7 @@ check_relocated_bzc (bfd *abfd, const bfd_byte *ptr, bfd_vma offset,
 		     const Elf_Internal_Rela *irelend)
 {
   const Elf_Internal_Rela *irel;
-  unsigned long opcode;
+  unsigned long long opcode;
 
   opcode = bfd_get_micromips_32 (abfd, ptr);
   if (find_match (opcode, bzc_insns_32) < 0)
@@ -13477,10 +13477,10 @@ _bfd_mips_elf_relax_section (bfd *abfd, asection *sec,
   irelend = internal_relocs + sec->reloc_count;
   for (irel = internal_relocs; irel < irelend; irel++)
     {
-      unsigned long r_symndx = ELF32_R_SYM (irel->r_info);
+      unsigned long long r_symndx = ELF32_R_SYM (irel->r_info);
       unsigned int r_type = ELF32_R_TYPE (irel->r_info);
       bfd_boolean target_is_micromips_code_p;
-      unsigned long opcode;
+      unsigned long long opcode;
       bfd_vma symval;
       bfd_vma pcrval;
       bfd_byte *ptr;
@@ -13545,7 +13545,7 @@ _bfd_mips_elf_relax_section (bfd *abfd, asection *sec,
 	}
       else
 	{
-	  unsigned long indx;
+	  unsigned long long indx;
 	  struct elf_link_hash_entry *h;
 
 	  /* An external symbol.  */
@@ -13600,8 +13600,8 @@ _bfd_mips_elf_relax_section (bfd *abfd, asection *sec,
       if (r_type == R_MICROMIPS_HI16 && MATCH (opcode, lui_insn))
 	{
 	  bfd_boolean bzc = FALSE;
-	  unsigned long nextopc;
-	  unsigned long reg;
+	  unsigned long long nextopc;
+	  unsigned long long reg;
 	  bfd_vma offset;
 
 	  /* Give up if the previous reloc was a HI16 against this symbol
@@ -13735,7 +13735,7 @@ _bfd_mips_elf_relax_section (bfd *abfd, asection *sec,
 								 ptr + 4),
 					   nop_insn_32) ? 4 : 0))))
 	{
-	  unsigned long reg;
+	  unsigned long long reg;
 
 	  reg = OP32_SREG (opcode) ? OP32_SREG (opcode) : OP32_TREG (opcode);
 
@@ -13782,7 +13782,7 @@ _bfd_mips_elf_relax_section (bfd *abfd, asection *sec,
 		   || ((fndopc = find_match (opcode, bz_rt_insns_32)) >= 0
 		       && OP16_VALID_REG (OP32_TREG (opcode)))))
 	{
-	  unsigned long reg;
+	  unsigned long long reg;
 
 	  reg = OP32_SREG (opcode) ? OP32_SREG (opcode) : OP32_TREG (opcode);
 
@@ -13808,7 +13808,7 @@ _bfd_mips_elf_relax_section (bfd *abfd, asection *sec,
 	       && irel->r_offset + 7 < sec->size
 	       && MATCH (opcode, jal_insn_32_bd32))
 	{
-	  unsigned long n32opc;
+	  unsigned long long n32opc;
 	  bfd_boolean relaxed = FALSE;
 
 	  n32opc = bfd_get_micromips_32 (abfd, ptr + 4);
@@ -13978,7 +13978,7 @@ _bfd_mips_elf_linker_flags (struct bfd_link_info *info, bfd_boolean insn32,
 
 struct mips_mach_extension
 {
-  unsigned long extension, base;
+  unsigned long long extension, base;
 };
 
 
@@ -14059,7 +14059,7 @@ static const struct mips_mach_extension mips_mach_extensions[] =
 /* Return true if bfd machine EXTENSION is an extension of machine BASE.  */
 
 static bfd_boolean
-mips_mach_extends_p (unsigned long base, unsigned long extension)
+mips_mach_extends_p (unsigned long long base, unsigned long long extension)
 {
   size_t i;
 
@@ -14087,7 +14087,7 @@ mips_mach_extends_p (unsigned long base, unsigned long extension)
 
 /* Return the BFD mach for each .MIPS.abiflags ISA Extension.  */
 
-static unsigned long
+static unsigned long long
 bfd_mips_isa_ext_mach (unsigned int isa_ext)
 {
   switch (isa_ext)
@@ -14745,7 +14745,7 @@ _bfd_mips_elf_final_link (bfd *abfd, struct bfd_link_info *info)
 	      asection *input_section;
 	      bfd *input_bfd;
 	      bfd_size_type size;
-	      unsigned long last;
+	      unsigned long long last;
 	      bfd_size_type gpentry;
 
 	      if (p->type != bfd_indirect_link_order)
@@ -14769,8 +14769,8 @@ _bfd_mips_elf_final_link (bfd *abfd, struct bfd_link_info *info)
 		{
 		  Elf32_External_gptab ext_gptab;
 		  Elf32_gptab int_gptab;
-		  unsigned long val;
-		  unsigned long add;
+		  unsigned long long val;
+		  unsigned long long add;
 		  bfd_boolean exact;
 		  unsigned int look;
 
@@ -15989,11 +15989,11 @@ _bfd_mips_elf_plt_sym_val (bfd_vma i, const asection *plt,
    of ASYMBOL to carry ISA annotation.  The encoding used is the same as
    with the ST_OTHER member of the ELF symbol.  */
 
-long
+long long
 _bfd_mips_elf_get_synthetic_symtab (bfd *abfd,
-				    long symcount ATTRIBUTE_UNUSED,
+				    long long symcount ATTRIBUTE_UNUSED,
 				    asymbol **syms ATTRIBUTE_UNUSED,
-				    long dynsymcount, asymbol **dynsyms,
+				    long long dynsymcount, asymbol **dynsyms,
 				    asymbol **ret)
 {
   static const char pltname[] = "_PROCEDURE_LINKAGE_TABLE_";
@@ -16016,14 +16016,14 @@ _bfd_mips_elf_get_synthetic_symtab (bfd *abfd,
   asymbol *send;
   size_t size;
   char *names;
-  long counti;
+  long long counti;
   arelent *p;
   asymbol *s;
   char *nend;
-  long count;
-  long pi;
-  long i;
-  long n;
+  long long count;
+  long long pi;
+  long long i;
+  long long n;
 
   *ret = NULL;
 
diff --git a/bfd/elfxx-mips.h b/bfd/elfxx-mips.h
index b8ea714..e6c1a67 100644
--- a/bfd/elfxx-mips.h
+++ b/bfd/elfxx-mips.h
@@ -135,7 +135,7 @@ extern bfd_reloc_status_type _bfd_mips_elf_lo16_reloc
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
 extern bfd_reloc_status_type _bfd_mips_elf_generic_reloc
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
-extern unsigned long _bfd_elf_mips_mach
+extern unsigned long long _bfd_elf_mips_mach
   (flagword);
 extern bfd_vma _bfd_mips_elf_sign_extend
   (bfd_vma, int);
@@ -153,8 +153,8 @@ extern bfd_boolean _bfd_mips_elf_init_stubs
    asection *(*) (const char *, asection *, asection *));
 extern bfd_vma _bfd_mips_elf_plt_sym_val
   (bfd_vma, const asection *, const arelent *rel);
-extern long _bfd_mips_elf_get_synthetic_symtab
-  (bfd *, long, asymbol **, long, asymbol **, asymbol **);
+extern long long _bfd_mips_elf_get_synthetic_symtab
+  (bfd *, long long, asymbol **, long long, asymbol **, asymbol **);
 extern bfd_boolean _bfd_mips_elf_gc_mark_extra_sections
   (struct bfd_link_info *, elf_gc_mark_hook_fn);
 extern void _bfd_mips_post_process_headers
diff --git a/bfd/elfxx-sparc.c b/bfd/elfxx-sparc.c
index 81812af..8cf34d2 100644
--- a/bfd/elfxx-sparc.c
+++ b/bfd/elfxx-sparc.c
@@ -1080,7 +1080,7 @@ elf_sparc_get_local_sym_hash (struct _bfd_sparc_elf_link_hash_table *htab,
 {
   struct _bfd_sparc_elf_link_hash_entry e, *ret;
   asection *sec = abfd->sections;
-  unsigned long r_symndx;
+  unsigned long long r_symndx;
   hashval_t h;
   void **slot;
 
@@ -2926,7 +2926,7 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,
     {
       int r_type, tls_type;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       struct _bfd_sparc_elf_link_hash_entry *eh;
       Elf_Internal_Sym *sym;
@@ -3499,7 +3499,7 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,
 		    }
 		  else
 		    {
-		      long indx;
+		      long long indx;
 
 		      outrel.r_addend = relocation + rel->r_addend;
 
@@ -4902,7 +4902,7 @@ _bfd_sparc_elf_object_p (bfd *abfd)
 
   if (ABI_64_P (abfd))
     {
-      unsigned long mach = bfd_mach_sparc_v9;
+      unsigned long long mach = bfd_mach_sparc_v9;
 
       if (hwcaps2->i & m8_hwcaps2_mask)
 	mach = bfd_mach_sparc_v9m8;
diff --git a/bfd/elfxx-tilegx.c b/bfd/elfxx-tilegx.c
index f029cd2..706b309 100644
--- a/bfd/elfxx-tilegx.c
+++ b/bfd/elfxx-tilegx.c
@@ -2962,7 +2962,7 @@ tilegx_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
       int r_type, tls_type;
       bfd_boolean is_tls_iele, is_tls_le;
       reloc_howto_type *howto;
-      unsigned long r_symndx;
+      unsigned long long r_symndx;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
       tilegx_create_func create_func;
@@ -3502,7 +3502,7 @@ tilegx_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 		    }
 		  else
 		    {
-		      long indx;
+		      long long indx;
 
 		      outrel.r_addend = relocation + rel->r_addend;
 
diff --git a/bfd/elfxx-x86.c b/bfd/elfxx-x86.c
index 827bb6c..70dd4a0 100644
--- a/bfd/elfxx-x86.c
+++ b/bfd/elfxx-x86.c
@@ -2140,21 +2140,21 @@ elf_x86_64_valid_plt_reloc_p (unsigned int type)
 	  || type == R_X86_64_IRELATIVE);
 }
 
-long
+long long
 _bfd_x86_elf_get_synthetic_symtab (bfd *abfd,
-				   long count,
-				   long relsize,
+				   long long count,
+				   long long relsize,
 				   bfd_vma got_addr,
 				   struct elf_x86_plt plts[],
 				   asymbol **dynsyms,
 				   asymbol **ret)
 {
-  long size, i, n, len;
+  long long size, i, n, len;
   int j;
   unsigned int plt_got_offset, plt_entry_size;
   asymbol *s;
   bfd_byte *plt_contents;
-  long dynrelcount;
+  long long dynrelcount;
   arelent **dynrelbuf, *p;
   char *names;
   const struct elf_backend_data *bed;
@@ -2231,7 +2231,7 @@ _bfd_x86_elf_get_synthetic_symtab (bfd *abfd,
   for (j = 0; plts[j].name != NULL; j++)
     if ((plt_contents = plts[j].contents) != NULL)
       {
-	long k;
+	long long k;
 	bfd_vma offset;
 	asection *plt;
 	struct elf_x86_plt *plt_p = &plts[j];
@@ -2258,7 +2258,7 @@ _bfd_x86_elf_get_synthetic_symtab (bfd *abfd,
 	  {
 	    int off;
 	    bfd_vma got_vma;
-	    long min, max, mid;
+	    long long min, max, mid;
 
 	    /* Get the GOT offset for i386 or the PC-relative offset
 	       for x86-64, a signed 32-bit integer.  */
diff --git a/bfd/elfxx-x86.h b/bfd/elfxx-x86.h
index 6a56094..a70b33c 100644
--- a/bfd/elfxx-x86.h
+++ b/bfd/elfxx-x86.h
@@ -584,7 +584,7 @@ struct elf_x86_plt
   unsigned int plt_got_offset;
   unsigned int plt_entry_size;
   unsigned int plt_got_insn_size;	/* Only used for x86-64.  */
-  long count;
+  long long count;
 };
 
 #define elf_x86_tdata(abfd) \
@@ -674,8 +674,8 @@ extern asection * _bfd_x86_elf_gc_mark_hook
   (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
    struct elf_link_hash_entry *, Elf_Internal_Sym *);
 
-extern long _bfd_x86_elf_get_synthetic_symtab
-  (bfd *, long, long, bfd_vma, struct elf_x86_plt [], asymbol **,
+extern long long _bfd_x86_elf_get_synthetic_symtab
+  (bfd *, long long, long long, bfd_vma, struct elf_x86_plt [], asymbol **,
    asymbol **);
 
 extern enum elf_property_kind _bfd_x86_elf_parse_gnu_properties
diff --git a/bfd/hash.c b/bfd/hash.c
index 852a95e..fb5a9db 100644
--- a/bfd/hash.c
+++ b/bfd/hash.c
@@ -304,50 +304,50 @@ SUBSUBSECTION
    greater than N, and near a power of two.  Copied from libiberty.
    Returns zero for ridiculously large N to signify an error.  */
 
-static unsigned long
-higher_prime_number (unsigned long n)
+static unsigned long long
+higher_prime_number (unsigned long long n)
 {
   /* These are primes that are near, but slightly smaller than, a
      power of two.  */
-  static const unsigned long primes[] =
+  static const unsigned long long primes[] =
     {
-      (unsigned long) 31,
-      (unsigned long) 61,
-      (unsigned long) 127,
-      (unsigned long) 251,
-      (unsigned long) 509,
-      (unsigned long) 1021,
-      (unsigned long) 2039,
-      (unsigned long) 4093,
-      (unsigned long) 8191,
-      (unsigned long) 16381,
-      (unsigned long) 32749,
-      (unsigned long) 65521,
-      (unsigned long) 131071,
-      (unsigned long) 262139,
-      (unsigned long) 524287,
-      (unsigned long) 1048573,
-      (unsigned long) 2097143,
-      (unsigned long) 4194301,
-      (unsigned long) 8388593,
-      (unsigned long) 16777213,
-      (unsigned long) 33554393,
-      (unsigned long) 67108859,
-      (unsigned long) 134217689,
-      (unsigned long) 268435399,
-      (unsigned long) 536870909,
-      (unsigned long) 1073741789,
-      (unsigned long) 2147483647,
+      (unsigned long long) 31,
+      (unsigned long long) 61,
+      (unsigned long long) 127,
+      (unsigned long long) 251,
+      (unsigned long long) 509,
+      (unsigned long long) 1021,
+      (unsigned long long) 2039,
+      (unsigned long long) 4093,
+      (unsigned long long) 8191,
+      (unsigned long long) 16381,
+      (unsigned long long) 32749,
+      (unsigned long long) 65521,
+      (unsigned long long) 131071,
+      (unsigned long long) 262139,
+      (unsigned long long) 524287,
+      (unsigned long long) 1048573,
+      (unsigned long long) 2097143,
+      (unsigned long long) 4194301,
+      (unsigned long long) 8388593,
+      (unsigned long long) 16777213,
+      (unsigned long long) 33554393,
+      (unsigned long long) 67108859,
+      (unsigned long long) 134217689,
+      (unsigned long long) 268435399,
+      (unsigned long long) 536870909,
+      (unsigned long long) 1073741789,
+      (unsigned long long) 2147483647,
 					/* 4294967291L */
-      ((unsigned long) 2147483647) + ((unsigned long) 2147483644),
+      ((unsigned long long) 2147483647) + ((unsigned long long) 2147483644),
   };
 
-  const unsigned long *low = &primes[0];
-  const unsigned long *high = &primes[sizeof (primes) / sizeof (primes[0])];
+  const unsigned long long *low = &primes[0];
+  const unsigned long long *high = &primes[sizeof (primes) / sizeof (primes[0])];
 
   while (low != high)
     {
-      const unsigned long *mid = low + (high - low) / 2;
+      const unsigned long long *mid = low + (high - low) / 2;
       if (n >= *mid)
 	low = mid + 1;
       else
@@ -360,7 +360,7 @@ higher_prime_number (unsigned long n)
   return *low;
 }
 
-static unsigned long bfd_default_hash_table_size = DEFAULT_SIZE;
+static unsigned long long bfd_default_hash_table_size = DEFAULT_SIZE;
 
 /* Create a new hash table, given a number of entries.  */
 
@@ -372,7 +372,7 @@ bfd_hash_table_init_n (struct bfd_hash_table *table,
 		       unsigned int entsize,
 		       unsigned int size)
 {
-  unsigned long alloc;
+  unsigned long long alloc;
 
   alloc = size;
   alloc *= sizeof (struct bfd_hash_entry *);
@@ -427,11 +427,11 @@ bfd_hash_table_free (struct bfd_hash_table *table)
   table->memory = NULL;
 }
 
-static inline unsigned long
+static inline unsigned long long
 bfd_hash_hash (const char *string, unsigned int *lenp)
 {
   const unsigned char *s;
-  unsigned long hash;
+  unsigned long long hash;
   unsigned int len;
   unsigned int c;
 
@@ -460,7 +460,7 @@ bfd_hash_lookup (struct bfd_hash_table *table,
 		 bfd_boolean create,
 		 bfd_boolean copy)
 {
-  unsigned long hash;
+  unsigned long long hash;
   struct bfd_hash_entry *hashp;
   unsigned int len;
   unsigned int _index;
@@ -502,7 +502,7 @@ bfd_hash_lookup (struct bfd_hash_table *table,
 struct bfd_hash_entry *
 bfd_hash_insert (struct bfd_hash_table *table,
 		 const char *string,
-		 unsigned long hash)
+		 unsigned long long hash)
 {
   struct bfd_hash_entry *hashp;
   unsigned int _index;
@@ -519,10 +519,10 @@ bfd_hash_insert (struct bfd_hash_table *table,
 
   if (!table->frozen && table->count > table->size * 3 / 4)
     {
-      unsigned long newsize = higher_prime_number (table->size);
+      unsigned long long newsize = higher_prime_number (table->size);
       struct bfd_hash_entry **newtable;
       unsigned int hi;
-      unsigned long alloc = newsize * sizeof (struct bfd_hash_entry *);
+      unsigned long long alloc = newsize * sizeof (struct bfd_hash_entry *);
 
       /* If we can't find a higher prime, or we can't possibly alloc
 	 that much memory, don't try to grow the table.  */
@@ -661,11 +661,11 @@ bfd_hash_traverse (struct bfd_hash_table *table,
   table->frozen = 0;
 }
 
-unsigned long
-bfd_hash_set_default_size (unsigned long hash_size)
+unsigned long long
+bfd_hash_set_default_size (unsigned long long hash_size)
 {
   /* Extend this prime list if you want more granularity of hash table size.  */
-  static const unsigned long hash_size_primes[] =
+  static const unsigned long long hash_size_primes[] =
     {
       31, 61, 127, 251, 509, 1021, 2039, 4091, 8191, 16381, 32749, 65537
     };
diff --git a/bfd/hpux-core.c b/bfd/hpux-core.c
index 3d2f621..200dce7 100644
--- a/bfd/hpux-core.c
+++ b/bfd/hpux-core.c
@@ -92,7 +92,7 @@ struct hpux_core_struct
 {
   int sig;
   int lwpid;		   /* Kernel thread ID. */
-  unsigned long user_tid;  /* User thread ID. */
+  unsigned long long user_tid;  /* User thread ID. */
   char cmd[MAXCOMLEN + 1];
 };
 
diff --git a/bfd/i386lynx.c b/bfd/i386lynx.c
index ff44979..6089656 100644
--- a/bfd/i386lynx.c
+++ b/bfd/i386lynx.c
@@ -508,7 +508,7 @@ NAME(lynx,squirt_out_relocs) (bfd *abfd, asection *section)
 }
 
 /* This is stupid.  This function should be a boolean predicate */
-static long
+static long long
 NAME(lynx,canonicalize_reloc) (bfd *abfd,
 			       sec_ptr section,
 			       arelent **relptr,
diff --git a/bfd/ihex.c b/bfd/ihex.c
index 80bcbe9..a977036 100644
--- a/bfd/ihex.c
+++ b/bfd/ihex.c
@@ -894,7 +894,7 @@ ihex_write_object_contents (bfd *abfd)
 static bfd_boolean
 ihex_set_arch_mach (bfd *abfd,
 		    enum bfd_architecture arch,
-		    unsigned long mach)
+		    unsigned long long mach)
 {
   if (! bfd_default_set_arch_mach (abfd, arch, mach))
     {
diff --git a/bfd/libaout.h b/bfd/libaout.h
index 0a421e4..00f5893 100644
--- a/bfd/libaout.h
+++ b/bfd/libaout.h
@@ -218,7 +218,7 @@ struct aout_backend_data
 
 struct internal_exec
 {
-  long a_info;			/* Magic number and flags, packed.  */
+  long long a_info;			/* Magic number and flags, packed.  */
   bfd_vma a_text;		/* Length of text, in bytes.  */
   bfd_vma a_data;		/* Length of data, in bytes.  */
   bfd_vma a_bss;		/* Length of uninitialized data area in mem.  */
@@ -314,7 +314,7 @@ enum machine_type
 
 #ifndef N_SET_DYNAMIC
 # define N_SET_DYNAMIC(execp, dynamic) \
-((execp)->a_info = (dynamic) ? (long) ((execp)->a_info | 0x80000000) : \
+((execp)->a_info = (dynamic) ? (long long) ((execp)->a_info | 0x80000000) : \
 ((execp)->a_info & 0x7fffffff))
 #endif
 
@@ -384,14 +384,14 @@ struct aoutdata
   unsigned symbol_entry_size;
 
   /* Page size - needed for alignment of demand paged files.  */
-  unsigned long page_size;
+  unsigned long long page_size;
 
   /* Segment size - needed for alignment of demand paged files.  */
-  unsigned long segment_size;
+  unsigned long long segment_size;
 
   /* Zmagic disk block size - need to align the start of the text
      section in ZMAGIC binaries.  Normally the same as page_size.  */
-  unsigned long zmagic_disk_block_size;
+  unsigned long long zmagic_disk_block_size;
 
   unsigned exec_bytes_size;
   unsigned vma_adjusted : 1;
@@ -482,10 +482,10 @@ extern bfd_boolean NAME (aout, mkobject)
   (bfd *);
 
 extern enum machine_type NAME (aout, machine_type)
-  (enum bfd_architecture, unsigned long, bfd_boolean *);
+  (enum bfd_architecture, unsigned long long, bfd_boolean *);
 
 extern bfd_boolean NAME (aout, set_arch_mach)
-  (bfd *, enum bfd_architecture, unsigned long);
+  (bfd *, enum bfd_architecture, unsigned long long);
 
 extern bfd_boolean NAME (aout, new_section_hook)
   (bfd *, asection *);
@@ -509,10 +509,10 @@ extern bfd_boolean NAME (aout, write_syms)
 extern void NAME (aout, reclaim_symbol_table)
   (bfd *);
 
-extern long NAME (aout, get_symtab_upper_bound)
+extern long long NAME (aout, get_symtab_upper_bound)
   (bfd *);
 
-extern long NAME (aout, canonicalize_symtab)
+extern long long NAME (aout, canonicalize_symtab)
   (bfd *, asymbol **);
 
 extern void NAME (aout, swap_ext_reloc_in)
@@ -532,10 +532,10 @@ extern reloc_howto_type * NAME (aout, reloc_name_lookup)
 extern bfd_boolean NAME (aout, slurp_reloc_table)
   (bfd *, sec_ptr, asymbol **);
 
-extern long NAME (aout, canonicalize_reloc)
+extern long long NAME (aout, canonicalize_reloc)
   (bfd *, sec_ptr, arelent **, asymbol **);
 
-extern long NAME (aout, get_reloc_upper_bound)
+extern long long NAME (aout, get_reloc_upper_bound)
   (bfd *, sec_ptr);
 
 extern void NAME (aout, reclaim_reloc)
@@ -554,7 +554,7 @@ extern bfd_boolean NAME (aout, find_nearest_line)
   (bfd *, asymbol **, asection *, bfd_vma,
    const char **, const char **, unsigned int *, unsigned int *);
 
-extern long NAME (aout, read_minisymbols)
+extern long long NAME (aout, read_minisymbols)
   (bfd *, bfd_boolean, void * *, unsigned int *);
 
 extern asymbol * NAME (aout, minisymbol_to_symbol)
diff --git a/bfd/libbfd-in.h b/bfd/libbfd-in.h
index e53b255..941aeb4 100644
--- a/bfd/libbfd-in.h
+++ b/bfd/libbfd-in.h
@@ -81,7 +81,7 @@ struct artdata
   char *extended_names;		/* Clever intel extension.  */
   bfd_size_type extended_names_size; /* Size of extended names.  */
   /* When more compilers are standard C, this can be a time_t.  */
-  long  armap_timestamp;	/* Timestamp value written into armap.
+  long long  armap_timestamp;	/* Timestamp value written into armap.
 				   This is used for BSD archives to check
 				   that the timestamp is recent enough
 				   for the BSD linker to not complain,
@@ -215,9 +215,9 @@ extern int _bfd_int_bfd_0
   (bfd *) ATTRIBUTE_HIDDEN;
 extern unsigned int _bfd_uint_bfd_0
   (bfd *) ATTRIBUTE_HIDDEN;
-extern long _bfd_long_bfd_0
+extern long long _bfd_long_bfd_0
   (bfd *) ATTRIBUTE_HIDDEN;
-extern long _bfd_long_bfd_n1_error
+extern long long _bfd_long_bfd_n1_error
   (bfd *) ATTRIBUTE_HIDDEN;
 extern void _bfd_void_bfd
   (bfd *) ATTRIBUTE_HIDDEN;
@@ -247,7 +247,7 @@ extern bfd_boolean _bfd_coff_write_armap
 extern void *_bfd_generic_read_ar_hdr
   (bfd *) ATTRIBUTE_HIDDEN;
 extern void _bfd_ar_spacepad
-  (char *, size_t, const char *, long) ATTRIBUTE_HIDDEN;
+  (char *, size_t, const char *, long long) ATTRIBUTE_HIDDEN;
 extern bfd_boolean _bfd_ar_sizepad
   (char *, size_t, bfd_size_type) ATTRIBUTE_HIDDEN;
 
@@ -439,7 +439,7 @@ extern bfd_boolean _bfd_vms_lib_ia64_mkarchive
    support.  Use BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols).  */
 
 #define _bfd_nosymbols_get_symtab_upper_bound _bfd_long_bfd_n1_error
-extern long _bfd_nosymbols_canonicalize_symtab
+extern long long _bfd_nosymbols_canonicalize_symtab
   (bfd *, asymbol **) ATTRIBUTE_HIDDEN;
 #define _bfd_nosymbols_make_empty_symbol _bfd_generic_make_empty_symbol
 extern void _bfd_nosymbols_print_symbol
@@ -463,8 +463,8 @@ extern bfd_boolean _bfd_nosymbols_find_line
 extern bfd_boolean _bfd_nosymbols_find_inliner_info
   (bfd *, const char **, const char **, unsigned int *) ATTRIBUTE_HIDDEN;
 extern asymbol *_bfd_nosymbols_bfd_make_debug_symbol
-  (bfd *, void *, unsigned long) ATTRIBUTE_HIDDEN;
-extern long _bfd_nosymbols_read_minisymbols
+  (bfd *, void *, unsigned long long) ATTRIBUTE_HIDDEN;
+extern long long _bfd_nosymbols_read_minisymbols
   (bfd *, bfd_boolean, void **, unsigned int *) ATTRIBUTE_HIDDEN;
 extern asymbol *_bfd_nosymbols_minisymbol_to_symbol
   (bfd *, bfd_boolean, const void *, asymbol *) ATTRIBUTE_HIDDEN;
@@ -472,9 +472,9 @@ extern asymbol *_bfd_nosymbols_minisymbol_to_symbol
 /* Routines to use for BFD_JUMP_TABLE_RELOCS when there is no reloc
    support.  Use BFD_JUMP_TABLE_RELOCS (_bfd_norelocs).  */
 
-extern long _bfd_norelocs_get_reloc_upper_bound
+extern long long _bfd_norelocs_get_reloc_upper_bound
   (bfd *, asection *) ATTRIBUTE_HIDDEN;
-extern long _bfd_norelocs_canonicalize_reloc
+extern long long _bfd_norelocs_canonicalize_reloc
   (bfd *, asection *, arelent **, asymbol **) ATTRIBUTE_HIDDEN;
 extern void _bfd_norelocs_set_reloc
   (bfd *, asection *, arelent **, unsigned int) ATTRIBUTE_HIDDEN;
@@ -487,7 +487,7 @@ extern reloc_howto_type *_bfd_norelocs_bfd_reloc_name_lookup
    be written.  Use BFD_JUMP_TABLE_WRITE (_bfd_nowrite).  */
 
 extern bfd_boolean _bfd_nowrite_set_arch_mach
-  (bfd *, enum bfd_architecture, unsigned long) ATTRIBUTE_HIDDEN;
+  (bfd *, enum bfd_architecture, unsigned long long) ATTRIBUTE_HIDDEN;
 extern bfd_boolean _bfd_nowrite_set_section_contents
   (bfd *, asection *, const void *, file_ptr, bfd_size_type) ATTRIBUTE_HIDDEN;
 
@@ -546,10 +546,10 @@ extern struct bfd_link_hash_entry *_bfd_nolink_bfd_define_start_stop
 #define _bfd_nodynamic_get_dynamic_symtab_upper_bound _bfd_long_bfd_n1_error
 #define _bfd_nodynamic_canonicalize_dynamic_symtab \
   _bfd_nosymbols_canonicalize_symtab
-extern long _bfd_nodynamic_get_synthetic_symtab
-  (bfd *, long, asymbol **, long, asymbol **, asymbol **) ATTRIBUTE_HIDDEN;
+extern long long _bfd_nodynamic_get_synthetic_symtab
+  (bfd *, long long, asymbol **, long long, asymbol **, asymbol **) ATTRIBUTE_HIDDEN;
 #define _bfd_nodynamic_get_dynamic_reloc_upper_bound _bfd_long_bfd_n1_error
-extern long _bfd_nodynamic_canonicalize_dynamic_reloc
+extern long long _bfd_nodynamic_canonicalize_dynamic_reloc
   (bfd *, arelent **, asymbol **) ATTRIBUTE_HIDDEN;
 
 /* Generic routine to determine of the given symbol is a local
@@ -558,7 +558,7 @@ extern bfd_boolean bfd_generic_is_local_label_name
   (bfd *, const char *) ATTRIBUTE_HIDDEN;
 
 /* Generic minisymbol routines.  */
-extern long _bfd_generic_read_minisymbols
+extern long long _bfd_generic_read_minisymbols
   (bfd *, bfd_boolean, void **, unsigned int *) ATTRIBUTE_HIDDEN;
 extern asymbol *_bfd_generic_minisymbol_to_symbol
   (bfd *, bfd_boolean, const void *, asymbol *) ATTRIBUTE_HIDDEN;
diff --git a/bfd/libbfd.c b/bfd/libbfd.c
index 971be4f..76031b6 100644
--- a/bfd/libbfd.c
+++ b/bfd/libbfd.c
@@ -147,7 +147,7 @@ _bfd_uint_bfd_0 (bfd *ignore ATTRIBUTE_UNUSED)
    return 0;
 }
 
-long
+long long
 _bfd_long_bfd_0 (bfd *ignore ATTRIBUTE_UNUSED)
 {
   return 0;
@@ -156,7 +156,7 @@ _bfd_long_bfd_0 (bfd *ignore ATTRIBUTE_UNUSED)
 /* A routine which is used in target vectors for unsupported
    operations which return -1 on error.  */
 
-long
+long long
 _bfd_long_bfd_n1_error (bfd *ignore_abfd ATTRIBUTE_UNUSED)
 {
   bfd_set_error (bfd_error_invalid_operation);
@@ -180,14 +180,14 @@ _bfd_void_bfd_asection (bfd *abfd ATTRIBUTE_UNUSED,
 {
 }
 
-long
+long long
 _bfd_norelocs_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
 				     asection *sec ATTRIBUTE_UNUSED)
 {
   return sizeof (arelent *);
 }
 
-long
+long long
 _bfd_norelocs_canonicalize_reloc (bfd *abfd ATTRIBUTE_UNUSED,
 				  asection *sec ATTRIBUTE_UNUSED,
 				  arelent **relptr,
@@ -262,7 +262,7 @@ bfd_malloc (bfd_size_type size)
 
   if (size != sz
       /* This is to pacify memory checkers like valgrind.  */
-      || ((signed long) sz) < 0)
+      || ((signed long long) sz) < 0)
     {
       bfd_set_error (bfd_error_no_memory);
       return NULL;
@@ -304,7 +304,7 @@ bfd_realloc (void *ptr, bfd_size_type size)
 
   if (size != sz
       /* This is to pacify memory checkers like valgrind.  */
-      || ((signed long) sz) < 0)
+      || ((signed long long) sz) < 0)
     {
       bfd_set_error (bfd_error_no_memory);
       return NULL;
@@ -638,12 +638,12 @@ bfd_vma
 bfd_getb32 (const void *p)
 {
   const bfd_byte *addr = (const bfd_byte *) p;
-  unsigned long v;
+  unsigned long long v;
 
-  v = (unsigned long) addr[0] << 24;
-  v |= (unsigned long) addr[1] << 16;
-  v |= (unsigned long) addr[2] << 8;
-  v |= (unsigned long) addr[3];
+  v = (unsigned long long) addr[0] << 24;
+  v |= (unsigned long long) addr[1] << 16;
+  v |= (unsigned long long) addr[2] << 8;
+  v |= (unsigned long long) addr[3];
   return v;
 }
 
@@ -651,12 +651,12 @@ bfd_vma
 bfd_getl32 (const void *p)
 {
   const bfd_byte *addr = (const bfd_byte *) p;
-  unsigned long v;
+  unsigned long long v;
 
-  v = (unsigned long) addr[0];
-  v |= (unsigned long) addr[1] << 8;
-  v |= (unsigned long) addr[2] << 16;
-  v |= (unsigned long) addr[3] << 24;
+  v = (unsigned long long) addr[0];
+  v |= (unsigned long long) addr[1] << 8;
+  v |= (unsigned long long) addr[2] << 16;
+  v |= (unsigned long long) addr[3] << 24;
   return v;
 }
 
@@ -664,12 +664,12 @@ bfd_signed_vma
 bfd_getb_signed_32 (const void *p)
 {
   const bfd_byte *addr = (const bfd_byte *) p;
-  unsigned long v;
+  unsigned long long v;
 
-  v = (unsigned long) addr[0] << 24;
-  v |= (unsigned long) addr[1] << 16;
-  v |= (unsigned long) addr[2] << 8;
-  v |= (unsigned long) addr[3];
+  v = (unsigned long long) addr[0] << 24;
+  v |= (unsigned long long) addr[1] << 16;
+  v |= (unsigned long long) addr[2] << 8;
+  v |= (unsigned long long) addr[3];
   return COERCE32 (v);
 }
 
@@ -677,12 +677,12 @@ bfd_signed_vma
 bfd_getl_signed_32 (const void *p)
 {
   const bfd_byte *addr = (const bfd_byte *) p;
-  unsigned long v;
+  unsigned long long v;
 
-  v = (unsigned long) addr[0];
-  v |= (unsigned long) addr[1] << 8;
-  v |= (unsigned long) addr[2] << 16;
-  v |= (unsigned long) addr[3] << 24;
+  v = (unsigned long long) addr[0];
+  v |= (unsigned long long) addr[1] << 8;
+  v |= (unsigned long long) addr[2] << 16;
+  v |= (unsigned long long) addr[3] << 24;
   return COERCE32 (v);
 }
 
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
index a884aab..bea0d76 100644
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -86,7 +86,7 @@ struct artdata
   char *extended_names;		/* Clever intel extension.  */
   bfd_size_type extended_names_size; /* Size of extended names.  */
   /* When more compilers are standard C, this can be a time_t.  */
-  long  armap_timestamp;	/* Timestamp value written into armap.
+  long long  armap_timestamp;	/* Timestamp value written into armap.
 				   This is used for BSD archives to check
 				   that the timestamp is recent enough
 				   for the BSD linker to not complain,
@@ -220,9 +220,9 @@ extern int _bfd_int_bfd_0
   (bfd *) ATTRIBUTE_HIDDEN;
 extern unsigned int _bfd_uint_bfd_0
   (bfd *) ATTRIBUTE_HIDDEN;
-extern long _bfd_long_bfd_0
+extern long long _bfd_long_bfd_0
   (bfd *) ATTRIBUTE_HIDDEN;
-extern long _bfd_long_bfd_n1_error
+extern long long _bfd_long_bfd_n1_error
   (bfd *) ATTRIBUTE_HIDDEN;
 extern void _bfd_void_bfd
   (bfd *) ATTRIBUTE_HIDDEN;
@@ -252,7 +252,7 @@ extern bfd_boolean _bfd_coff_write_armap
 extern void *_bfd_generic_read_ar_hdr
   (bfd *) ATTRIBUTE_HIDDEN;
 extern void _bfd_ar_spacepad
-  (char *, size_t, const char *, long) ATTRIBUTE_HIDDEN;
+  (char *, size_t, const char *, long long) ATTRIBUTE_HIDDEN;
 extern bfd_boolean _bfd_ar_sizepad
   (char *, size_t, bfd_size_type) ATTRIBUTE_HIDDEN;
 
@@ -444,7 +444,7 @@ extern bfd_boolean _bfd_vms_lib_ia64_mkarchive
    support.  Use BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols).  */
 
 #define _bfd_nosymbols_get_symtab_upper_bound _bfd_long_bfd_n1_error
-extern long _bfd_nosymbols_canonicalize_symtab
+extern long long _bfd_nosymbols_canonicalize_symtab
   (bfd *, asymbol **) ATTRIBUTE_HIDDEN;
 #define _bfd_nosymbols_make_empty_symbol _bfd_generic_make_empty_symbol
 extern void _bfd_nosymbols_print_symbol
@@ -468,8 +468,8 @@ extern bfd_boolean _bfd_nosymbols_find_line
 extern bfd_boolean _bfd_nosymbols_find_inliner_info
   (bfd *, const char **, const char **, unsigned int *) ATTRIBUTE_HIDDEN;
 extern asymbol *_bfd_nosymbols_bfd_make_debug_symbol
-  (bfd *, void *, unsigned long) ATTRIBUTE_HIDDEN;
-extern long _bfd_nosymbols_read_minisymbols
+  (bfd *, void *, unsigned long long) ATTRIBUTE_HIDDEN;
+extern long long _bfd_nosymbols_read_minisymbols
   (bfd *, bfd_boolean, void **, unsigned int *) ATTRIBUTE_HIDDEN;
 extern asymbol *_bfd_nosymbols_minisymbol_to_symbol
   (bfd *, bfd_boolean, const void *, asymbol *) ATTRIBUTE_HIDDEN;
@@ -477,9 +477,9 @@ extern asymbol *_bfd_nosymbols_minisymbol_to_symbol
 /* Routines to use for BFD_JUMP_TABLE_RELOCS when there is no reloc
    support.  Use BFD_JUMP_TABLE_RELOCS (_bfd_norelocs).  */
 
-extern long _bfd_norelocs_get_reloc_upper_bound
+extern long long _bfd_norelocs_get_reloc_upper_bound
   (bfd *, asection *) ATTRIBUTE_HIDDEN;
-extern long _bfd_norelocs_canonicalize_reloc
+extern long long _bfd_norelocs_canonicalize_reloc
   (bfd *, asection *, arelent **, asymbol **) ATTRIBUTE_HIDDEN;
 extern void _bfd_norelocs_set_reloc
   (bfd *, asection *, arelent **, unsigned int) ATTRIBUTE_HIDDEN;
@@ -492,7 +492,7 @@ extern reloc_howto_type *_bfd_norelocs_bfd_reloc_name_lookup
    be written.  Use BFD_JUMP_TABLE_WRITE (_bfd_nowrite).  */
 
 extern bfd_boolean _bfd_nowrite_set_arch_mach
-  (bfd *, enum bfd_architecture, unsigned long) ATTRIBUTE_HIDDEN;
+  (bfd *, enum bfd_architecture, unsigned long long) ATTRIBUTE_HIDDEN;
 extern bfd_boolean _bfd_nowrite_set_section_contents
   (bfd *, asection *, const void *, file_ptr, bfd_size_type) ATTRIBUTE_HIDDEN;
 
@@ -551,10 +551,10 @@ extern struct bfd_link_hash_entry *_bfd_nolink_bfd_define_start_stop
 #define _bfd_nodynamic_get_dynamic_symtab_upper_bound _bfd_long_bfd_n1_error
 #define _bfd_nodynamic_canonicalize_dynamic_symtab \
   _bfd_nosymbols_canonicalize_symtab
-extern long _bfd_nodynamic_get_synthetic_symtab
-  (bfd *, long, asymbol **, long, asymbol **, asymbol **) ATTRIBUTE_HIDDEN;
+extern long long _bfd_nodynamic_get_synthetic_symtab
+  (bfd *, long long, asymbol **, long long, asymbol **, asymbol **) ATTRIBUTE_HIDDEN;
 #define _bfd_nodynamic_get_dynamic_reloc_upper_bound _bfd_long_bfd_n1_error
-extern long _bfd_nodynamic_canonicalize_dynamic_reloc
+extern long long _bfd_nodynamic_canonicalize_dynamic_reloc
   (bfd *, arelent **, asymbol **) ATTRIBUTE_HIDDEN;
 
 /* Generic routine to determine of the given symbol is a local
@@ -563,7 +563,7 @@ extern bfd_boolean bfd_generic_is_local_label_name
   (bfd *, const char *) ATTRIBUTE_HIDDEN;
 
 /* Generic minisymbol routines.  */
-extern long _bfd_generic_read_minisymbols
+extern long long _bfd_generic_read_minisymbols
   (bfd *, bfd_boolean, void **, unsigned int *) ATTRIBUTE_HIDDEN;
 extern asymbol *_bfd_generic_minisymbol_to_symbol
   (bfd *, bfd_boolean, const void *, asymbol *) ATTRIBUTE_HIDDEN;
diff --git a/bfd/libcoff-in.h b/bfd/libcoff-in.h
index edb1b7d..114bde9 100644
--- a/bfd/libcoff-in.h
+++ b/bfd/libcoff-in.h
@@ -59,10 +59,10 @@ typedef struct coff_tdata
   file_ptr sym_filepos;
 
   struct coff_ptr_struct *raw_syments;
-  unsigned long raw_syment_count;
+  unsigned long long raw_syment_count;
 
   /* These are only valid once writing has begun.  */
-  unsigned long int relocbase;
+  unsigned long long int relocbase;
 
   /* These members communicate important constants about the symbol table
      to GDB's symbol-reading code.  These `constants' unfortunately vary
@@ -108,7 +108,7 @@ typedef struct coff_tdata
   void * dwarf2_find_line_info;
 
   /* The timestamp from the COFF file header.  */
-  long timestamp;
+  long long timestamp;
 
   /* Copy of some of the f_flags bits in the COFF filehdr structure,
      used by ARM code.  */
@@ -184,7 +184,7 @@ struct xcoff_tdata
 
   /* Used by the XCOFF backend linker.  */
   asection **csects;
-  long *debug_indices;
+  long long *debug_indices;
   unsigned int *lineno_counts;
   unsigned int import_file_id;
 };
@@ -206,8 +206,8 @@ struct xcoff_section_tdata
      going to clobber it there.  */
   unsigned int lineno_count;
   /* The first and last symbol indices for symbols used by this csect.  */
-  unsigned long first_symndx;
-  unsigned long last_symndx;
+  unsigned long long first_symndx;
+  unsigned long long last_symndx;
 };
 
 /* An accessor macro the xcoff_section_tdata structure.  */
@@ -221,7 +221,7 @@ struct pei_section_tdata
   /* The virtual size of the section.  */
   bfd_size_type virt_size;
   /* The PE section flags.  */
-  long pe_flags;
+  long long pe_flags;
 };
 
 /* An accessor macro for the pei_section_tdata structure.  */
@@ -236,7 +236,7 @@ struct coff_link_hash_entry
 
   /* Symbol index in output file.  Set to -1 initially.  Set to -2 if
      there is a reloc against this symbol.  */
-  long indx;
+  long long indx;
 
   /* Symbol type.  */
   unsigned short type;
@@ -302,9 +302,9 @@ extern const bfd_target *coff_object_p
   (bfd *);
 extern struct bfd_section *coff_section_from_bfd_index
   (bfd *, int);
-extern long coff_get_symtab_upper_bound
+extern long long coff_get_symtab_upper_bound
   (bfd *);
-extern long coff_canonicalize_symtab
+extern long long coff_canonicalize_symtab
   (bfd *, asymbol **);
 extern int coff_count_linenumbers
   (bfd *);
@@ -331,7 +331,7 @@ extern bfd_boolean _bfd_coff_free_symbols
   (bfd *);
 extern struct coff_ptr_struct *coff_get_normalized_symtab
   (bfd *);
-extern long coff_get_reloc_upper_bound
+extern long long coff_get_reloc_upper_bound
   (bfd *, sec_ptr);
 extern asymbol *coff_make_empty_symbol
   (bfd *);
@@ -344,7 +344,7 @@ extern void coff_get_symbol_info
 extern bfd_boolean _bfd_coff_is_local_label_name
   (bfd *, const char *);
 extern asymbol *coff_bfd_make_debug_symbol
-  (bfd *, void *, unsigned long);
+  (bfd *, void *, unsigned long long);
 extern bfd_boolean coff_find_nearest_line
   (bfd *, asymbol **, asection *, bfd_vma,
    const char **, const char **, unsigned int *, unsigned int *);
@@ -389,7 +389,7 @@ struct coff_debug_merge_element
   unsigned int type;
 
   /* Symbol index for complex type.  */
-  long tagndx;
+  long long tagndx;
 };
 
 /* A linked list of debug merge entries for a given name.  */
@@ -403,7 +403,7 @@ struct coff_debug_merge_type
   int type_class;
 
   /* Symbol index where this type is defined.  */
-  long indx;
+  long long indx;
 
   /* List of elements.  */
   struct coff_debug_merge_element *elements;
@@ -475,12 +475,12 @@ struct coff_final_link_info
      each output section, indexed by the target_index field.  */
   struct coff_link_section_info *section_info;
   /* Symbol index of last C_FILE symbol (-1 if none).  */
-  long last_file_index;
+  long long last_file_index;
   /* Contents of last C_FILE symbol.  */
   struct internal_syment last_file;
   /* Symbol index of first aux entry of last .bf symbol with an empty
      endndx field (-1 if none).  */
-  long last_bf_index;
+  long long last_bf_index;
   /* Contents of last_bf_index aux entry.  */
   union internal_auxent last_bf;
   /* Hash table used to merge debug information.  */
@@ -491,7 +491,7 @@ struct coff_final_link_info
   asection **sec_ptrs;
   /* Buffer large enough to hold output indices of symbols of any
      input file.  */
-  long *sym_indices;
+  long long *sym_indices;
   /* Buffer large enough to hold output symbols for any input file.  */
   bfd_byte *outsyms;
   /* Buffer large enough to hold external line numbers for any input
@@ -584,13 +584,13 @@ extern bfd_boolean bfd_coff_gc_sections
 
 /* Functions in xcofflink.c.  */
 
-extern long _bfd_xcoff_get_dynamic_symtab_upper_bound
+extern long long _bfd_xcoff_get_dynamic_symtab_upper_bound
   (bfd *);
-extern long _bfd_xcoff_canonicalize_dynamic_symtab
+extern long long _bfd_xcoff_canonicalize_dynamic_symtab
   (bfd *, asymbol **);
-extern long _bfd_xcoff_get_dynamic_reloc_upper_bound
+extern long long _bfd_xcoff_get_dynamic_reloc_upper_bound
   (bfd *);
-extern long _bfd_xcoff_canonicalize_dynamic_reloc
+extern long long _bfd_xcoff_canonicalize_dynamic_reloc
   (bfd *, arelent **, asymbol **);
 extern struct bfd_link_hash_table *_bfd_xcoff_bfd_link_hash_table_create
   (bfd *);
diff --git a/bfd/libcoff.h b/bfd/libcoff.h
index a31866f..c280059 100644
--- a/bfd/libcoff.h
+++ b/bfd/libcoff.h
@@ -63,10 +63,10 @@ typedef struct coff_tdata
   file_ptr sym_filepos;
 
   struct coff_ptr_struct *raw_syments;
-  unsigned long raw_syment_count;
+  unsigned long long raw_syment_count;
 
   /* These are only valid once writing has begun.  */
-  unsigned long int relocbase;
+  unsigned long long int relocbase;
 
   /* These members communicate important constants about the symbol table
      to GDB's symbol-reading code.  These `constants' unfortunately vary
@@ -112,7 +112,7 @@ typedef struct coff_tdata
   void * dwarf2_find_line_info;
 
   /* The timestamp from the COFF file header.  */
-  long timestamp;
+  long long timestamp;
 
   /* Copy of some of the f_flags bits in the COFF filehdr structure,
      used by ARM code.  */
@@ -188,7 +188,7 @@ struct xcoff_tdata
 
   /* Used by the XCOFF backend linker.  */
   asection **csects;
-  long *debug_indices;
+  long long *debug_indices;
   unsigned int *lineno_counts;
   unsigned int import_file_id;
 };
@@ -210,8 +210,8 @@ struct xcoff_section_tdata
      going to clobber it there.  */
   unsigned int lineno_count;
   /* The first and last symbol indices for symbols used by this csect.  */
-  unsigned long first_symndx;
-  unsigned long last_symndx;
+  unsigned long long first_symndx;
+  unsigned long long last_symndx;
 };
 
 /* An accessor macro the xcoff_section_tdata structure.  */
@@ -225,7 +225,7 @@ struct pei_section_tdata
   /* The virtual size of the section.  */
   bfd_size_type virt_size;
   /* The PE section flags.  */
-  long pe_flags;
+  long long pe_flags;
 };
 
 /* An accessor macro for the pei_section_tdata structure.  */
@@ -240,7 +240,7 @@ struct coff_link_hash_entry
 
   /* Symbol index in output file.  Set to -1 initially.  Set to -2 if
      there is a reloc against this symbol.  */
-  long indx;
+  long long indx;
 
   /* Symbol type.  */
   unsigned short type;
@@ -306,9 +306,9 @@ extern const bfd_target *coff_object_p
   (bfd *);
 extern struct bfd_section *coff_section_from_bfd_index
   (bfd *, int);
-extern long coff_get_symtab_upper_bound
+extern long long coff_get_symtab_upper_bound
   (bfd *);
-extern long coff_canonicalize_symtab
+extern long long coff_canonicalize_symtab
   (bfd *, asymbol **);
 extern int coff_count_linenumbers
   (bfd *);
@@ -335,7 +335,7 @@ extern bfd_boolean _bfd_coff_free_symbols
   (bfd *);
 extern struct coff_ptr_struct *coff_get_normalized_symtab
   (bfd *);
-extern long coff_get_reloc_upper_bound
+extern long long coff_get_reloc_upper_bound
   (bfd *, sec_ptr);
 extern asymbol *coff_make_empty_symbol
   (bfd *);
@@ -348,7 +348,7 @@ extern void coff_get_symbol_info
 extern bfd_boolean _bfd_coff_is_local_label_name
   (bfd *, const char *);
 extern asymbol *coff_bfd_make_debug_symbol
-  (bfd *, void *, unsigned long);
+  (bfd *, void *, unsigned long long);
 extern bfd_boolean coff_find_nearest_line
   (bfd *, asymbol **, asection *, bfd_vma,
    const char **, const char **, unsigned int *, unsigned int *);
@@ -393,7 +393,7 @@ struct coff_debug_merge_element
   unsigned int type;
 
   /* Symbol index for complex type.  */
-  long tagndx;
+  long long tagndx;
 };
 
 /* A linked list of debug merge entries for a given name.  */
@@ -407,7 +407,7 @@ struct coff_debug_merge_type
   int type_class;
 
   /* Symbol index where this type is defined.  */
-  long indx;
+  long long indx;
 
   /* List of elements.  */
   struct coff_debug_merge_element *elements;
@@ -479,12 +479,12 @@ struct coff_final_link_info
      each output section, indexed by the target_index field.  */
   struct coff_link_section_info *section_info;
   /* Symbol index of last C_FILE symbol (-1 if none).  */
-  long last_file_index;
+  long long last_file_index;
   /* Contents of last C_FILE symbol.  */
   struct internal_syment last_file;
   /* Symbol index of first aux entry of last .bf symbol with an empty
      endndx field (-1 if none).  */
-  long last_bf_index;
+  long long last_bf_index;
   /* Contents of last_bf_index aux entry.  */
   union internal_auxent last_bf;
   /* Hash table used to merge debug information.  */
@@ -495,7 +495,7 @@ struct coff_final_link_info
   asection **sec_ptrs;
   /* Buffer large enough to hold output indices of symbols of any
      input file.  */
-  long *sym_indices;
+  long long *sym_indices;
   /* Buffer large enough to hold output symbols for any input file.  */
   bfd_byte *outsyms;
   /* Buffer large enough to hold external line numbers for any input
@@ -588,13 +588,13 @@ extern bfd_boolean bfd_coff_gc_sections
 
 /* Functions in xcofflink.c.  */
 
-extern long _bfd_xcoff_get_dynamic_symtab_upper_bound
+extern long long _bfd_xcoff_get_dynamic_symtab_upper_bound
   (bfd *);
-extern long _bfd_xcoff_canonicalize_dynamic_symtab
+extern long long _bfd_xcoff_canonicalize_dynamic_symtab
   (bfd *, asymbol **);
-extern long _bfd_xcoff_get_dynamic_reloc_upper_bound
+extern long long _bfd_xcoff_get_dynamic_reloc_upper_bound
   (bfd *);
-extern long _bfd_xcoff_canonicalize_dynamic_reloc
+extern long long _bfd_xcoff_canonicalize_dynamic_reloc
   (bfd *, arelent **, asymbol **);
 extern struct bfd_link_hash_table *_bfd_xcoff_bfd_link_hash_table_create
   (bfd *);
diff --git a/bfd/libecoff.h b/bfd/libecoff.h
index 0de4e96..55998d5 100644
--- a/bfd/libecoff.h
+++ b/bfd/libecoff.h
@@ -95,8 +95,8 @@ typedef struct ecoff_tdata
 
   /* The start and end of the text segment.  Only valid for an
      existing file, not for one we are creating.  */
-  unsigned long text_start;
-  unsigned long text_end;
+  unsigned long long text_start;
+  unsigned long long text_end;
 
   /* The cached gp value.  This is used when relocating.  */
   bfd_vma gp;
@@ -110,9 +110,9 @@ typedef struct ecoff_tdata
      input files are combined into the masks of the output file.
      These are not all used for all targets, but that's OK, because
      the relevant ones are the only ones swapped in and out.  */
-  unsigned long gprmask;
-  unsigned long fprmask;
-  unsigned long cprmask[4];
+  unsigned long long gprmask;
+  unsigned long long fprmask;
+  unsigned long long cprmask[4];
 
   /* The ECOFF symbolic debugging information.  */
   struct ecoff_debug_info debug_info;
@@ -205,7 +205,7 @@ struct ecoff_link_hash_entry
 {
   struct bfd_link_hash_entry root;
   /* Symbol index in output file.  */
-  long indx;
+  long long indx;
   /* BFD that ext field value came from.  */
   bfd *abfd;
   /* ECOFF external symbol information.  */
@@ -278,8 +278,8 @@ extern bfd_boolean _bfd_ecoff_write_armap
 #define _bfd_ecoff_update_armap_timestamp _bfd_bool_bfd_true
 #define _bfd_ecoff_bfd_is_target_special_symbol _bfd_bool_bfd_asymbol_false
 
-extern long _bfd_ecoff_get_symtab_upper_bound (bfd *);
-extern long _bfd_ecoff_canonicalize_symtab (bfd *, asymbol **);
+extern long long _bfd_ecoff_get_symtab_upper_bound (bfd *);
+extern long long _bfd_ecoff_canonicalize_symtab (bfd *, asymbol **);
 extern asymbol *_bfd_ecoff_make_empty_symbol (bfd *);
 extern void _bfd_ecoff_print_symbol
   (bfd *, void *, asymbol *, bfd_print_symbol_type);
@@ -300,12 +300,12 @@ extern bfd_boolean _bfd_ecoff_find_nearest_line
 #define _bfd_ecoff_find_inliner_info _bfd_nosymbols_find_inliner_info
 
 #define _bfd_ecoff_get_reloc_upper_bound coff_get_reloc_upper_bound
-extern long _bfd_ecoff_canonicalize_reloc
+extern long long _bfd_ecoff_canonicalize_reloc
   (bfd *, asection *, arelent **, asymbol **);
 /* ecoff_bfd_reloc_type_lookup defined by backend. */
 
 extern bfd_boolean _bfd_ecoff_set_arch_mach
-  (bfd *, enum bfd_architecture, unsigned long);
+  (bfd *, enum bfd_architecture, unsigned long long);
 extern bfd_boolean _bfd_ecoff_set_section_contents
   (bfd *, asection *, const void * location, file_ptr, bfd_size_type);
 
diff --git a/bfd/libpei.h b/bfd/libpei.h
index b07cf72..ad9cfe4 100644
--- a/bfd/libpei.h
+++ b/bfd/libpei.h
@@ -354,7 +354,7 @@ bfd_boolean _bfd_XXi_final_link_postscript (bfd *, struct coff_final_link_info *
 void	    _bfd_XXi_swap_debugdir_in (bfd *, void *, void *);
 unsigned    _bfd_XXi_swap_debugdir_out (bfd *, void *, void *);
 unsigned    _bfd_XXi_write_codeview_record (bfd *, file_ptr, CODEVIEW_INFO *);
-CODEVIEW_INFO * _bfd_XXi_slurp_codeview_record (bfd * abfd, file_ptr where, unsigned long length, CODEVIEW_INFO *cvinfo);
+CODEVIEW_INFO * _bfd_XXi_slurp_codeview_record (bfd * abfd, file_ptr where, unsigned long long length, CODEVIEW_INFO *cvinfo);
 
 /* The following are needed only for ONE of pe or pei, but don't
    otherwise vary; peicode.h fixes up ifdefs but we provide the
diff --git a/bfd/libxcoff.h b/bfd/libxcoff.h
index 87ac3c0..48a3611 100644
--- a/bfd/libxcoff.h
+++ b/bfd/libxcoff.h
@@ -37,7 +37,7 @@ struct xcoff_backend_data_rec
 
   /* Architecture and machine for coff_set_arch_mach_hook.  */
   enum bfd_architecture _xcoff_architecture;
-  long _xcoff_machine;
+  long long _xcoff_machine;
 
   /* Function pointers to xcoff specific swap routines.  */
   void (* _xcoff_swap_ldhdr_in) (bfd *, const void *, struct internal_ldhdr *);
@@ -61,7 +61,7 @@ struct xcoff_backend_data_rec
   /* Loader version
      1 : XCOFF32
      2 : XCOFF64.  */
-  unsigned long _xcoff_ldhdr_version;
+  unsigned long long _xcoff_ldhdr_version;
 
   bfd_boolean (* _xcoff_put_symbol_name)
     (struct bfd_link_info *, struct bfd_strtab_hash *,
@@ -90,10 +90,10 @@ struct xcoff_backend_data_rec
 
   /* Global linkage.  The first word of global linkage code must be be
      modified by filling in the correct TOC offset.  */
-  unsigned long *_xcoff_glink_code;
+  unsigned long long *_xcoff_glink_code;
 
   /* Size of the global link code in bytes of the xcoff_glink_code table.  */
-  unsigned long _xcoff_glink_size;
+  unsigned long long _xcoff_glink_size;
 
   /* rtinit.  */
   unsigned int _xcoff_rtinit_size;
diff --git a/bfd/linker.c b/bfd/linker.c
index 6b4c8e5..af2768a 100644
--- a/bfd/linker.c
+++ b/bfd/linker.c
@@ -791,8 +791,8 @@ bfd_generic_link_read_symbols (bfd *abfd)
 {
   if (bfd_get_outsymbols (abfd) == NULL)
     {
-      long symsize;
-      long symcount;
+      long long symsize;
+      long long symcount;
 
       symsize = bfd_get_symtab_upper_bound (abfd);
       if (symsize < 0)
@@ -1855,10 +1855,10 @@ _bfd_generic_final_link (bfd *abfd, struct bfd_link_info *info)
 		{
 		  asection *input_section;
 		  bfd *input_bfd;
-		  long relsize;
+		  long long relsize;
 		  arelent **relocs;
 		  asymbol **symbols;
-		  long reloc_count;
+		  long long reloc_count;
 
 		  input_section = p->u.indirect.section;
 		  input_bfd = input_section->owner;
@@ -1877,7 +1877,7 @@ _bfd_generic_final_link (bfd *abfd, struct bfd_link_info *info)
 		  free (relocs);
 		  if (reloc_count < 0)
 		    return FALSE;
-		  BFD_ASSERT ((unsigned long) reloc_count
+		  BFD_ASSERT ((unsigned long long) reloc_count
 			      == input_section->reloc_count);
 		  o->reloc_count += reloc_count;
 		}
diff --git a/bfd/mach-o-i386.c b/bfd/mach-o-i386.c
index 4918e5e..a6eb8a1 100644
--- a/bfd/mach-o-i386.c
+++ b/bfd/mach-o-i386.c
@@ -294,48 +294,48 @@ bfd_mach_o_i386_print_thread (bfd *abfd, bfd_mach_o_thread_flavour *thread,
 	return FALSE;
       fprintf (file, "   x86_THREAD_STATE:\n");
       fprintf (file, "    flavor: 0x%08lx  count: 0x%08lx\n",
-	       (unsigned long)bfd_get_32 (abfd, buf + 0),
-	       (unsigned long)bfd_get_32 (abfd, buf + 4));
+	       (unsigned long long)bfd_get_32 (abfd, buf + 0),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 4));
       fprintf (file, "     eax: %08lx  ebx: %08lx  ecx: %08lx  edx: %08lx\n",
-	       (unsigned long)bfd_get_32 (abfd, buf + 8),
-	       (unsigned long)bfd_get_32 (abfd, buf + 12),
-	       (unsigned long)bfd_get_32 (abfd, buf + 16),
-	       (unsigned long)bfd_get_32 (abfd, buf + 20));
+	       (unsigned long long)bfd_get_32 (abfd, buf + 8),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 12),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 16),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 20));
       fprintf (file, "     edi: %08lx  esi: %08lx  ebp: %08lx  esp: %08lx\n",
-	       (unsigned long)bfd_get_32 (abfd, buf + 24),
-	       (unsigned long)bfd_get_32 (abfd, buf + 28),
-	       (unsigned long)bfd_get_32 (abfd, buf + 32),
-	       (unsigned long)bfd_get_32 (abfd, buf + 36));
+	       (unsigned long long)bfd_get_32 (abfd, buf + 24),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 28),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 32),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 36));
       fprintf (file, "      ss: %08lx  flg: %08lx  eip: %08lx   cs: %08lx\n",
-	       (unsigned long)bfd_get_32 (abfd, buf + 40),
-	       (unsigned long)bfd_get_32 (abfd, buf + 44),
-	       (unsigned long)bfd_get_32 (abfd, buf + 48),
-	       (unsigned long)bfd_get_32 (abfd, buf + 52));
+	       (unsigned long long)bfd_get_32 (abfd, buf + 40),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 44),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 48),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 52));
       fprintf (file, "      ds: %08lx   es: %08lx   fs: %08lx   gs: %08lx\n",
-	       (unsigned long)bfd_get_32 (abfd, buf + 56),
-	       (unsigned long)bfd_get_32 (abfd, buf + 60),
-	       (unsigned long)bfd_get_32 (abfd, buf + 64),
-	       (unsigned long)bfd_get_32 (abfd, buf + 68));
+	       (unsigned long long)bfd_get_32 (abfd, buf + 56),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 60),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 64),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 68));
       return TRUE;
     case BFD_MACH_O_x86_FLOAT_STATE:
       if (thread->size < 8)
 	return FALSE;
       fprintf (file, "   x86_FLOAT_STATE:\n");
       fprintf (file, "    flavor: 0x%08lx  count: 0x%08lx\n",
-	       (unsigned long)bfd_get_32 (abfd, buf + 0),
-	       (unsigned long)bfd_get_32 (abfd, buf + 4));
+	       (unsigned long long)bfd_get_32 (abfd, buf + 0),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 4));
       return TRUE;
     case BFD_MACH_O_x86_EXCEPTION_STATE:
       if (thread->size < 8 + 3 * 4)
 	return FALSE;
       fprintf (file, "   x86_EXCEPTION_STATE:\n");
       fprintf (file, "    flavor: 0x%08lx  count: 0x%08lx\n",
-	       (unsigned long)bfd_get_32 (abfd, buf + 0),
-	       (unsigned long)bfd_get_32 (abfd, buf + 4));
+	       (unsigned long long)bfd_get_32 (abfd, buf + 0),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 4));
       fprintf (file, "    trapno: %08lx  err: %08lx  faultaddr: %08lx\n",
-	       (unsigned long)bfd_get_32 (abfd, buf + 8),
-	       (unsigned long)bfd_get_32 (abfd, buf + 12),
-	       (unsigned long)bfd_get_32 (abfd, buf + 16));
+	       (unsigned long long)bfd_get_32 (abfd, buf + 8),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 12),
+	       (unsigned long long)bfd_get_32 (abfd, buf + 16));
       return TRUE;
     default:
       break;
diff --git a/bfd/mach-o-x86-64.c b/bfd/mach-o-x86-64.c
index 9ee93a4..76a9175 100644
--- a/bfd/mach-o-x86-64.c
+++ b/bfd/mach-o-x86-64.c
@@ -344,7 +344,7 @@ bfd_mach_o_x86_64_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
 }
 
 static bfd_boolean
-bfd_mach_o_section_type_valid_for_x86_64 (unsigned long val)
+bfd_mach_o_section_type_valid_for_x86_64 (unsigned long long val)
 {
   if (val == BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS
       || val == BFD_MACH_O_S_LAZY_SYMBOL_POINTERS
diff --git a/bfd/mach-o.c b/bfd/mach-o.c
index ce72a3d..6cc04e3 100644
--- a/bfd/mach-o.c
+++ b/bfd/mach-o.c
@@ -593,7 +593,7 @@ bfd_mach_o_bfd_copy_private_section_data (bfd *ibfd, asection *isection,
 }
 
 static const char *
-cputype (unsigned long value)
+cputype (unsigned long long value)
 {
   switch (value)
     {
@@ -617,7 +617,7 @@ cputype (unsigned long value)
 }
 
 static const char *
-cpusubtype (unsigned long cputype, unsigned long cpusubtype)
+cpusubtype (unsigned long long cputype, unsigned long long cpusubtype)
 {
   static char buffer[128];
 
@@ -696,15 +696,15 @@ bfd_mach_o_bfd_print_private_bfd_data (bfd *abfd, void *ptr)
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
 
   fprintf (file, _(" MACH-O header:\n"));
-  fprintf (file, _("   magic:      %#lx\n"), (long) mdata->header.magic);
-  fprintf (file, _("   cputype:    %#lx (%s)\n"), (long) mdata->header.cputype,
+  fprintf (file, _("   magic:      %#lx\n"), (long long) mdata->header.magic);
+  fprintf (file, _("   cputype:    %#lx (%s)\n"), (long long) mdata->header.cputype,
 	   cputype (mdata->header.cputype));
-  fprintf (file, _("   cpusubtype: %#lx%s\n"), (long) mdata->header.cpusubtype,
+  fprintf (file, _("   cpusubtype: %#lx%s\n"), (long long) mdata->header.cpusubtype,
 	   cpusubtype (mdata->header.cputype, mdata->header.cpusubtype));
-  fprintf (file, _("   filetype:   %#lx\n"), (long) mdata->header.filetype);
-  fprintf (file, _("   ncmds:      %#lx\n"), (long) mdata->header.ncmds);
-  fprintf (file, _("   sizeocmds:  %#lx\n"), (long) mdata->header.sizeofcmds);
-  fprintf (file, _("   flags:      %#lx\n"), (long) mdata->header.flags);
+  fprintf (file, _("   filetype:   %#lx\n"), (long long) mdata->header.filetype);
+  fprintf (file, _("   ncmds:      %#lx\n"), (long long) mdata->header.ncmds);
+  fprintf (file, _("   sizeocmds:  %#lx\n"), (long long) mdata->header.sizeofcmds);
+  fprintf (file, _("   flags:      %#lx\n"), (long long) mdata->header.flags);
   fprintf (file, _("   version:    %x\n"), mdata->header.version);
   
   return TRUE;
@@ -741,8 +741,8 @@ bfd_mach_o_bfd_copy_private_header_data (bfd *ibfd, bfd *obfd)
       else if (imdata->header.cputype != 0)
 	/* Urg - what has happened ?  */
 	_bfd_error_handler (_("incompatible cputypes in mach-o files: %ld vs %ld"),
-			    (long) imdata->header.cputype,
-			    (long) omdata->header.cputype);
+			    (long long) imdata->header.cputype,
+			    (long long) omdata->header.cputype);
     }
 
   /* Copy the cpusubtype.  */
@@ -870,7 +870,7 @@ bfd_mach_o_bfd_set_private_flags (bfd *abfd, flagword flags)
 
 /* Count the total number of symbols.  */
 
-static long
+static long long
 bfd_mach_o_count_symbols (bfd *abfd)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
@@ -880,21 +880,21 @@ bfd_mach_o_count_symbols (bfd *abfd)
   return mdata->symtab->nsyms;
 }
 
-long
+long long
 bfd_mach_o_get_symtab_upper_bound (bfd *abfd)
 {
-  long nsyms = bfd_mach_o_count_symbols (abfd);
+  long long nsyms = bfd_mach_o_count_symbols (abfd);
 
   return ((nsyms + 1) * sizeof (asymbol *));
 }
 
-long
+long long
 bfd_mach_o_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
-  long nsyms = bfd_mach_o_count_symbols (abfd);
+  long long nsyms = bfd_mach_o_count_symbols (abfd);
   bfd_mach_o_symtab_command *sym = mdata->symtab;
-  unsigned long j;
+  unsigned long long j;
 
   if (nsyms < 0)
     return nsyms;
@@ -925,11 +925,11 @@ bfd_mach_o_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 
 /* Create synthetic symbols for indirect symbols.  */
 
-long
+long long
 bfd_mach_o_get_synthetic_symtab (bfd *abfd,
-				 long symcount ATTRIBUTE_UNUSED,
+				 long long symcount ATTRIBUTE_UNUSED,
 				 asymbol **syms ATTRIBUTE_UNUSED,
-				 long dynsymcount ATTRIBUTE_UNUSED,
+				 long long dynsymcount ATTRIBUTE_UNUSED,
 				 asymbol **dynsyms ATTRIBUTE_UNUSED,
 				 asymbol **ret)
 {
@@ -939,7 +939,7 @@ bfd_mach_o_get_synthetic_symtab (bfd *abfd,
   asymbol *s;
   char * s_start;
   char * s_end;
-  unsigned long count, i, j, n;
+  unsigned long long count, i, j, n;
   size_t size;
   char *names;
   char *nul_name;
@@ -1120,7 +1120,7 @@ static void
 bfd_mach_o_convert_architecture (bfd_mach_o_cpu_type mtype,
 				 bfd_mach_o_cpu_subtype msubtype,
 				 enum bfd_architecture *type,
-				 unsigned long *subtype)
+				 unsigned long long *subtype)
 {
   *subtype = bfd_arch_unknown;
 
@@ -1416,7 +1416,7 @@ bfd_mach_o_write_dyld_info (bfd *abfd, bfd_mach_o_load_command *command)
   return TRUE;
 }
 
-long
+long long
 bfd_mach_o_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
 				  asection *asect)
 {
@@ -1595,12 +1595,12 @@ bfd_mach_o_pre_canonicalize_one_reloc (bfd *abfd,
 }
 
 static int
-bfd_mach_o_canonicalize_relocs (bfd *abfd, unsigned long filepos,
-				unsigned long count,
+bfd_mach_o_canonicalize_relocs (bfd *abfd, unsigned long long filepos,
+				unsigned long long count,
 				arelent *res, asymbol **syms)
 {
   bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
-  unsigned long i;
+  unsigned long long i;
   struct mach_o_reloc_info_external *native_relocs;
   bfd_size_type native_size;
 
@@ -1633,12 +1633,12 @@ bfd_mach_o_canonicalize_relocs (bfd *abfd, unsigned long filepos,
   return -1;
 }
 
-long
+long long
 bfd_mach_o_canonicalize_reloc (bfd *abfd, asection *asect,
 			       arelent **rels, asymbol **syms)
 {
   bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
-  unsigned long i;
+  unsigned long long i;
   arelent *res;
 
   if (asect->reloc_count == 0)
@@ -1673,7 +1673,7 @@ bfd_mach_o_canonicalize_reloc (bfd *abfd, asection *asect,
   return i;
 }
 
-long
+long long
 bfd_mach_o_get_dynamic_reloc_upper_bound (bfd *abfd)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
@@ -1684,14 +1684,14 @@ bfd_mach_o_get_dynamic_reloc_upper_bound (bfd *abfd)
     * sizeof (arelent *);
 }
 
-long
+long long
 bfd_mach_o_canonicalize_dynamic_reloc (bfd *abfd, arelent **rels,
 				       struct bfd_symbol **syms)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
   bfd_mach_o_dysymtab_command *dysymtab = mdata->dysymtab;
   bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
-  unsigned long i;
+  unsigned long long i;
   arelent *res;
 
   if (dysymtab == NULL)
@@ -1807,7 +1807,7 @@ bfd_mach_o_write_relocs (bfd *abfd, bfd_mach_o_section *section)
       /* Lower the relocation info.  */
       if (pinfo->r_scattered)
 	{
-	  unsigned long v;
+	  unsigned long long v;
 
 	  v = BFD_MACH_O_SR_SCATTERED
 	    | (pinfo->r_pcrel ? BFD_MACH_O_SR_PCREL : 0)
@@ -1953,7 +1953,7 @@ static bfd_boolean
 bfd_mach_o_write_symtab_content (bfd *abfd, bfd_mach_o_symtab_command *sym)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
-  unsigned long i;
+  unsigned long long i;
   unsigned int wide = bfd_mach_o_wide_p (abfd);
   struct bfd_strtab_hash *strtab;
   asymbol **symbols = bfd_get_outsymbols (abfd);
@@ -2115,7 +2115,7 @@ bfd_mach_o_build_dysymtab (bfd *abfd, bfd_mach_o_dysymtab_command *cmd)
   if (bfd_get_symcount (abfd) > 0)
     {
       asymbol **symbols = bfd_get_outsymbols (abfd);
-      unsigned long i;
+      unsigned long long i;
 
        /* Count the number of each kind of symbol.  */
       for (i = 0; i < bfd_get_symcount (abfd); ++i)
@@ -2328,7 +2328,7 @@ bfd_mach_o_write_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)
 
       for (i = 0; i < cmd->nextrefsyms; i++)
 	{
-	  unsigned long v;
+	  unsigned long long v;
 	  unsigned char raw[4];
 	  bfd_mach_o_dylib_reference *ref = &cmd->ext_refs[i];
 
@@ -2460,7 +2460,7 @@ bfd_mach_o_cf_symbols (const void *a, const void *b)
 static bfd_boolean
 bfd_mach_o_mangle_symbols (bfd *abfd)
 {
-  unsigned long i;
+  unsigned long long i;
   asymbol **symbols = bfd_get_outsymbols (abfd);
 
   if (symbols == NULL || bfd_get_symcount (abfd) == 0)
@@ -2708,7 +2708,7 @@ bfd_mach_o_write_contents (bfd *abfd)
   for (cmd = mdata->first_command; cmd != NULL; cmd = cmd->next)
     {
       struct mach_o_load_command_external raw;
-      unsigned long typeflag;
+      unsigned long long typeflag;
 
       typeflag = cmd->type | (cmd->type_required ? BFD_MACH_O_LC_REQ_DYLD : 0);
 
@@ -3523,7 +3523,7 @@ bfd_mach_o_new_section_hook (bfd *abfd, asection *sec)
 
 static void
 bfd_mach_o_init_section_from_mach_o (bfd *abfd, asection *sec,
-				     unsigned long prot)
+				     unsigned long long prot)
 {
   flagword flags;
   bfd_mach_o_section *section;
@@ -3595,7 +3595,7 @@ bfd_mach_o_make_bfd_section (bfd *abfd,
 }
 
 static asection *
-bfd_mach_o_read_section_32 (bfd *abfd, unsigned long prot)
+bfd_mach_o_read_section_32 (bfd *abfd, unsigned long long prot)
 {
   struct mach_o_section_32_external raw;
   asection *sec;
@@ -3639,7 +3639,7 @@ bfd_mach_o_read_section_32 (bfd *abfd, unsigned long prot)
 }
 
 static asection *
-bfd_mach_o_read_section_64 (bfd *abfd, unsigned long prot)
+bfd_mach_o_read_section_64 (bfd *abfd, unsigned long long prot)
 {
   struct mach_o_section_64_external raw;
   asection *sec;
@@ -3682,7 +3682,7 @@ bfd_mach_o_read_section_64 (bfd *abfd, unsigned long prot)
 }
 
 static asection *
-bfd_mach_o_read_section (bfd *abfd, unsigned long prot, unsigned int wide)
+bfd_mach_o_read_section (bfd *abfd, unsigned long long prot, unsigned int wide)
 {
   if (wide)
     return bfd_mach_o_read_section_64 (abfd, prot);
@@ -3694,7 +3694,7 @@ static bfd_boolean
 bfd_mach_o_read_symtab_symbol (bfd *abfd,
 			       bfd_mach_o_symtab_command *sym,
 			       bfd_mach_o_asymbol *s,
-			       unsigned long i)
+			       unsigned long long i)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
   unsigned int wide = mach_o_wide_p (&mdata->header);
@@ -3706,7 +3706,7 @@ bfd_mach_o_read_symtab_symbol (bfd *abfd,
   unsigned char section = -1;
   short desc = -1;
   symvalue value = -1;
-  unsigned long stroff = -1;
+  unsigned long long stroff = -1;
   unsigned int symtype = -1;
 
   BFD_ASSERT (sym->strtab != NULL);
@@ -3905,7 +3905,7 @@ bfd_mach_o_read_symtab_symbols (bfd *abfd)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
   bfd_mach_o_symtab_command *sym = mdata->symtab;
-  unsigned long i;
+  unsigned long long i;
 
   if (sym == NULL || sym->symbols)
     /* Return now if there are no symbols or if already loaded.  */
@@ -4294,7 +4294,7 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)
       for (i = 0; i < cmd->nmodtab; i++)
 	{
 	  bfd_mach_o_dylib_module *module = &cmd->dylib_module[i];
-	  unsigned long v;
+	  unsigned long long v;
 	  unsigned char buf[56];
 
 	  if (bfd_bread ((void *) buf, module_len, abfd) != module_len)
@@ -4330,7 +4330,7 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)
 
   if (cmd->ntoc != 0)
     {
-      unsigned long i;
+      unsigned long long i;
 
       cmd->dylib_toc = bfd_alloc2
 	(abfd, cmd->ntoc, sizeof (bfd_mach_o_dylib_table_of_content));
@@ -4379,7 +4379,7 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)
 
   if (cmd->nextrefsyms != 0)
     {
-      unsigned long v;
+      unsigned long long v;
       unsigned int i;
 
       cmd->ext_refs = bfd_alloc2
@@ -4481,7 +4481,7 @@ bfd_mach_o_read_str (bfd *abfd, bfd_mach_o_load_command *command)
 {
   bfd_mach_o_str_command *cmd = &command->command.str;
   struct mach_o_str_command_external raw;
-  unsigned long off;
+  unsigned long long off;
 
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return FALSE;
@@ -4684,7 +4684,7 @@ bfd_mach_o_read_segment (bfd *abfd,
 			 unsigned int wide)
 {
   bfd_mach_o_segment_command *seg = &command->command.segment;
-  unsigned long i;
+  unsigned long long i;
 
   if (wide)
     {
@@ -4900,7 +4900,7 @@ bfd_mach_o_flatten_sections (bfd *abfd)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
   bfd_mach_o_load_command *cmd;
-  long csect = 0;
+  long long csect = 0;
 
   /* Count total number of sections.  */
   mdata->nsects = 0;
@@ -4945,7 +4945,7 @@ bfd_mach_o_scan_start_address (bfd *abfd)
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
   bfd_mach_o_thread_command *thr = NULL;
   bfd_mach_o_load_command *cmd;
-  unsigned long i;
+  unsigned long long i;
 
   for (cmd = mdata->first_command; cmd != NULL; cmd = cmd->next)
     if (cmd->type == BFD_MACH_O_LC_THREAD
@@ -5026,7 +5026,7 @@ bfd_mach_o_scan_start_address (bfd *abfd)
 bfd_boolean
 bfd_mach_o_set_arch_mach (bfd *abfd,
 			  enum bfd_architecture arch,
-			  unsigned long machine)
+			  unsigned long long machine)
 {
   bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
 
@@ -5047,7 +5047,7 @@ bfd_mach_o_scan (bfd *abfd,
 {
   unsigned int i;
   enum bfd_architecture cputype;
-  unsigned long cpusubtype;
+  unsigned long long cpusubtype;
   unsigned int hdrsize;
 
   hdrsize = mach_o_wide_p (header) ?
@@ -5290,17 +5290,17 @@ bfd_mach_o_get_base_address (bfd *abfd)
 
 typedef struct mach_o_fat_archentry
 {
-  unsigned long cputype;
-  unsigned long cpusubtype;
-  unsigned long offset;
-  unsigned long size;
-  unsigned long align;
+  unsigned long long cputype;
+  unsigned long long cpusubtype;
+  unsigned long long offset;
+  unsigned long long size;
+  unsigned long long align;
 } mach_o_fat_archentry;
 
 typedef struct mach_o_fat_data_struct
 {
-  unsigned long magic;
-  unsigned long nfat_arch;
+  unsigned long long magic;
+  unsigned long long nfat_arch;
   mach_o_fat_archentry *archentries;
 } mach_o_fat_data_struct;
 
@@ -5309,7 +5309,7 @@ bfd_mach_o_fat_archive_p (bfd *abfd)
 {
   mach_o_fat_data_struct *adata = NULL;
   struct mach_o_fat_header_external hdr;
-  unsigned long i;
+  unsigned long long i;
 
   if (bfd_seek (abfd, 0, SEEK_SET) != 0
       || bfd_bread (&hdr, sizeof (hdr), abfd) != sizeof (hdr))
@@ -5364,7 +5364,7 @@ bfd_mach_o_fat_archive_p (bfd *abfd)
 static void
 bfd_mach_o_fat_member_init (bfd *abfd,
 			    enum bfd_architecture arch_type,
-			    unsigned long arch_subtype,
+			    unsigned long long arch_subtype,
 			    mach_o_fat_archentry *entry)
 {
   struct areltdata *areltdata;
@@ -5398,10 +5398,10 @@ bfd_mach_o_fat_openr_next_archived_file (bfd *archive, bfd *prev)
 {
   mach_o_fat_data_struct *adata;
   mach_o_fat_archentry *entry = NULL;
-  unsigned long i;
+  unsigned long long i;
   bfd *nbfd;
   enum bfd_architecture arch_type;
-  unsigned long arch_subtype;
+  unsigned long long arch_subtype;
 
   adata = (mach_o_fat_data_struct *) archive->tdata.mach_o_fat_data;
   BFD_ASSERT (adata != NULL);
@@ -5506,7 +5506,7 @@ bfd_mach_o_fat_extract (bfd *abfd,
     {
       struct mach_o_fat_archentry *e = &adata->archentries[i];
       enum bfd_architecture cpu_type;
-      unsigned long cpu_subtype;
+      unsigned long long cpu_subtype;
 
       bfd_mach_o_convert_architecture (e->cputype, e->cpusubtype,
 				       &cpu_type, &cpu_subtype);
@@ -5565,7 +5565,7 @@ bfd_mach_o_lookup_command (bfd *abfd,
   return num;
 }
 
-unsigned long
+unsigned long long
 bfd_mach_o_stack_addr (enum bfd_mach_o_cpu_type type)
 {
   switch (type)
@@ -5667,7 +5667,7 @@ bfd_mach_o_core_fetch_environment (bfd *abfd,
 				   unsigned int *rlen)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
-  unsigned long stackaddr = bfd_mach_o_stack_addr (mdata->header.cputype);
+  unsigned long long stackaddr = bfd_mach_o_stack_addr (mdata->header.cputype);
   bfd_mach_o_load_command *cmd;
 
   for (cmd = mdata->first_command; cmd != NULL; cmd = cmd->next)
@@ -5681,15 +5681,15 @@ bfd_mach_o_core_fetch_environment (bfd *abfd,
 
       if ((seg->vmaddr + seg->vmsize) == stackaddr)
 	{
-	  unsigned long start = seg->fileoff;
-	  unsigned long end = seg->fileoff + seg->filesize;
+	  unsigned long long start = seg->fileoff;
+	  unsigned long long end = seg->fileoff + seg->filesize;
 	  unsigned char *buf = bfd_malloc (1024);
-	  unsigned long size = 1024;
+	  unsigned long long size = 1024;
 
 	  for (;;)
 	    {
 	      bfd_size_type nread = 0;
-	      unsigned long offset;
+	      unsigned long long offset;
 	      int found_nonnull = 0;
 
 	      if (size > (end - start))
@@ -5715,9 +5715,9 @@ bfd_mach_o_core_fetch_environment (bfd *abfd,
 
 	      for (offset = 4; offset <= size; offset += 4)
 		{
-		  unsigned long val;
+		  unsigned long long val;
 
-		  val = *((unsigned long *) (buf + size - offset));
+		  val = *((unsigned long long *) (buf + size - offset));
 		  if (! found_nonnull)
 		    {
 		      if (val != 0)
@@ -5725,8 +5725,8 @@ bfd_mach_o_core_fetch_environment (bfd *abfd,
 		    }
 		  else if (val == 0x0)
 		    {
-		      unsigned long bottom;
-		      unsigned long top;
+		      unsigned long long bottom;
+		      unsigned long long top;
 
 		      bottom = seg->fileoff + seg->filesize - offset;
 		      top = seg->fileoff + seg->filesize - 4;
diff --git a/bfd/mach-o.h b/bfd/mach-o.h
index d80d439..3a91625 100644
--- a/bfd/mach-o.h
+++ b/bfd/mach-o.h
@@ -31,13 +31,13 @@ extern "C" {
 
 typedef struct bfd_mach_o_header
 {
-  unsigned long magic;
-  unsigned long cputype;
-  unsigned long cpusubtype;
-  unsigned long filetype;
-  unsigned long ncmds;
-  unsigned long sizeofcmds;
-  unsigned long flags;
+  unsigned long long magic;
+  unsigned long long cputype;
+  unsigned long long cpusubtype;
+  unsigned long long filetype;
+  unsigned long long ncmds;
+  unsigned long long sizeofcmds;
+  unsigned long long flags;
   unsigned int reserved;
   /* Version 1: 32 bits, version 2: 64 bits.  */
   unsigned int version;
@@ -68,13 +68,13 @@ typedef struct bfd_mach_o_section
   bfd_vma addr;
   bfd_vma size;
   bfd_vma offset;
-  unsigned long align;
+  unsigned long long align;
   bfd_vma reloff;
-  unsigned long nreloc;
-  unsigned long flags;
-  unsigned long reserved1;
-  unsigned long reserved2;
-  unsigned long reserved3;
+  unsigned long long nreloc;
+  unsigned long long flags;
+  unsigned long long reserved1;
+  unsigned long long reserved2;
+  unsigned long long reserved3;
 
   /* Corresponding bfd section.  */
   asection *bfdsection;
@@ -96,11 +96,11 @@ typedef struct bfd_mach_o_segment_command
   bfd_vma vmaddr;
   bfd_vma vmsize;
   bfd_vma fileoff;
-  unsigned long filesize;
-  unsigned long maxprot;	/* Maximum permitted protection.  */
-  unsigned long initprot;	/* Initial protection.  */
-  unsigned long nsects;
-  unsigned long flags;
+  unsigned long long filesize;
+  unsigned long long maxprot;	/* Maximum permitted protection.  */
+  unsigned long long initprot;	/* Initial protection.  */
+  unsigned long long nsects;
+  unsigned long long flags;
 
   /* Linked list of sections.  */
   bfd_mach_o_section *sect_head;
@@ -186,36 +186,36 @@ bfd_mach_o_symtab_command;
 typedef struct bfd_mach_o_dylib_module
 {
   /* Index into the string table indicating the name of the module.  */
-  unsigned long module_name_idx;
+  unsigned long long module_name_idx;
   char *module_name;
 
   /* Index into the symbol table of the first defined external symbol provided
      by the module.  */
-  unsigned long iextdefsym;
+  unsigned long long iextdefsym;
 
   /* Number of external symbols provided by this module.  */
-  unsigned long nextdefsym;
+  unsigned long long nextdefsym;
 
   /* Index into the external reference table of the first entry
      provided by this module.  */
-  unsigned long irefsym;
+  unsigned long long irefsym;
 
   /* Number of external reference entries provided by this module.  */
-  unsigned long nrefsym;
+  unsigned long long nrefsym;
 
   /* Index into the symbol table of the first local symbol provided by this
      module.  */
-  unsigned long ilocalsym;
+  unsigned long long ilocalsym;
 
   /* Number of local symbols provided by this module.  */
-  unsigned long nlocalsym;
+  unsigned long long nlocalsym;
 
   /* Index into the external relocation table of the first entry provided
      by this module.  */
-  unsigned long iextrel;
+  unsigned long long iextrel;
 
   /* Number of external relocation entries provided by this module.  */
-  unsigned long nextrel;
+  unsigned long long nextrel;
 
   /* Index in the module initialization section to the pointers for this
      module.  */
@@ -233,7 +233,7 @@ typedef struct bfd_mach_o_dylib_module
 
   /* Number of data byte for this module that are used in the __module_info
      section of the __OBJC segment.  */
-  unsigned long objc_module_info_size;
+  unsigned long long objc_module_info_size;
 
   /* Statically linked address of the start of the data for this module
      in the __module_info section of the __OBJC_segment.  */
@@ -244,20 +244,20 @@ bfd_mach_o_dylib_module;
 typedef struct bfd_mach_o_dylib_table_of_content
 {
   /* Index into the symbol table to the defined external symbol.  */
-  unsigned long symbol_index;
+  unsigned long long symbol_index;
 
   /* Index into the module table to the module for this entry.  */
-  unsigned long module_index;
+  unsigned long long module_index;
 }
 bfd_mach_o_dylib_table_of_content;
 
 typedef struct bfd_mach_o_dylib_reference
 {
   /* Index into the symbol table for the symbol being referenced.  */
-  unsigned long isym;
+  unsigned long long isym;
 
   /* Type of the reference being made (use REFERENCE_FLAGS constants).  */
-  unsigned long flags;
+  unsigned long long flags;
 }
 bfd_mach_o_dylib_reference;
 #define BFD_MACH_O_REFERENCE_SIZE 4
@@ -278,12 +278,12 @@ typedef struct bfd_mach_o_dysymtab_command
      binding (indirectly through the module table and the reference symbol
      table when this is a dynamically linked shared library file).  */
 
-  unsigned long ilocalsym;    /* Index to local symbols.  */
-  unsigned long nlocalsym;    /* Number of local symbols.  */
-  unsigned long iextdefsym;   /* Index to externally defined symbols.  */
-  unsigned long nextdefsym;   /* Number of externally defined symbols.  */
-  unsigned long iundefsym;    /* Index to undefined symbols.  */
-  unsigned long nundefsym;    /* Number of undefined symbols.  */
+  unsigned long long ilocalsym;    /* Index to local symbols.  */
+  unsigned long long nlocalsym;    /* Number of local symbols.  */
+  unsigned long long iextdefsym;   /* Index to externally defined symbols.  */
+  unsigned long long nextdefsym;   /* Number of externally defined symbols.  */
+  unsigned long long iundefsym;    /* Index to undefined symbols.  */
+  unsigned long long nundefsym;    /* Number of undefined symbols.  */
 
   /* For the for the dynamic binding process to find which module a symbol
      is defined in the table of contents is used (analogous to the ranlib
@@ -292,8 +292,8 @@ typedef struct bfd_mach_o_dysymtab_command
      library file.  For executable and object modules the defined external
      symbols are sorted by name and is use as the table of contents.  */
 
-  unsigned long tocoff;       /* File offset to table of contents.  */
-  unsigned long ntoc;	      /* Number of entries in table of contents.  */
+  unsigned long long tocoff;       /* File offset to table of contents.  */
+  unsigned long long ntoc;	      /* Number of entries in table of contents.  */
 
   /* To support dynamic binding of "modules" (whole object files) the symbol
      table must reflect the modules that the file was created from.  This is
@@ -303,8 +303,8 @@ typedef struct bfd_mach_o_dysymtab_command
      shared library file.  For executable and object modules the file only
      contains one module so everything in the file belongs to the module.  */
 
-  unsigned long modtaboff;    /* File offset to module table.  */
-  unsigned long nmodtab;      /* Number of module table entries.  */
+  unsigned long long modtaboff;    /* File offset to module table.  */
+  unsigned long long nmodtab;      /* Number of module table entries.  */
 
   /* To support dynamic module binding the module structure for each module
      indicates the external references (defined and undefined) each module
@@ -314,8 +314,8 @@ typedef struct bfd_mach_o_dysymtab_command
      executable and object modules the defined external symbols and the
      undefined external symbols indicates the external references.  */
 
-  unsigned long extrefsymoff;  /* Offset to referenced symbol table.  */
-  unsigned long nextrefsyms;   /* Number of referenced symbol table entries.  */
+  unsigned long long extrefsymoff;  /* Offset to referenced symbol table.  */
+  unsigned long long nextrefsyms;   /* Number of referenced symbol table entries.  */
 
   /* The sections that contain "symbol pointers" and "routine stubs" have
      indexes and (implied counts based on the size of the section and fixed
@@ -326,8 +326,8 @@ typedef struct bfd_mach_o_dysymtab_command
      the symbol table to the symbol that the pointer or stub is referring to.
      The indirect symbol table is ordered to match the entries in the section.  */
 
-  unsigned long indirectsymoff; /* File offset to the indirect symbol table.  */
-  unsigned long nindirectsyms;  /* Number of indirect symbol table entries.  */
+  unsigned long long indirectsymoff; /* File offset to the indirect symbol table.  */
+  unsigned long long nindirectsyms;  /* Number of indirect symbol table entries.  */
 
   /* To support relocating an individual module in a library file quickly the
      external relocation entries for each module in the library need to be
@@ -353,15 +353,15 @@ typedef struct bfd_mach_o_dysymtab_command
      remaining external relocation entries for them (for merged sections
      remaining relocation entries must be local).  */
 
-  unsigned long extreloff;    /* Offset to external relocation entries.  */
-  unsigned long nextrel;      /* Number of external relocation entries.  */
+  unsigned long long extreloff;    /* Offset to external relocation entries.  */
+  unsigned long long nextrel;      /* Number of external relocation entries.  */
 
   /* All the local relocation entries are grouped together (they are not
      grouped by their module since they are only used if the object is moved
      from it statically link edited address).  */
 
-  unsigned long locreloff;    /* Offset to local relocation entries.  */
-  unsigned long nlocrel;      /* Number of local relocation entries.  */
+  unsigned long long locreloff;    /* Offset to local relocation entries.  */
+  unsigned long long nlocrel;      /* Number of local relocation entries.  */
 
   bfd_mach_o_dylib_module *dylib_module;
   bfd_mach_o_dylib_table_of_content *dylib_toc;
@@ -405,15 +405,15 @@ bfd_mach_o_prebind_cksum_command;
 
 typedef struct bfd_mach_o_thread_flavour
 {
-  unsigned long flavour;
-  unsigned long offset;
-  unsigned long size;
+  unsigned long long flavour;
+  unsigned long long offset;
+  unsigned long long size;
 }
 bfd_mach_o_thread_flavour;
 
 typedef struct bfd_mach_o_thread_command
 {
-  unsigned long nflavours;
+  unsigned long long nflavours;
   bfd_mach_o_thread_flavour *flavours;
   asection *section;
 }
@@ -434,9 +434,9 @@ bfd_mach_o_dylinker_command;
 typedef struct bfd_mach_o_dylib_command
 {
   unsigned int name_offset;	       /* Offset to library's path name.  */
-  unsigned long timestamp;	       /* Library's build time stamp.  */
-  unsigned long current_version;       /* Library's current version number.  */
-  unsigned long compatibility_version; /* Library's compatibility vers number.  */
+  unsigned long long timestamp;	       /* Library's build time stamp.  */
+  unsigned long long current_version;       /* Library's current version number.  */
+  unsigned long long compatibility_version; /* Library's compatibility vers number.  */
   char *name_str;
 }
 bfd_mach_o_dylib_command;
@@ -466,15 +466,15 @@ bfd_mach_o_uuid_command;
 
 typedef struct bfd_mach_o_linkedit_command
 {
-  unsigned long dataoff;
-  unsigned long datasize;
+  unsigned long long dataoff;
+  unsigned long long datasize;
 }
 bfd_mach_o_linkedit_command;
 
 typedef struct bfd_mach_o_str_command
 {
-  unsigned long stroff;
-  unsigned long str_len;
+  unsigned long long stroff;
+  unsigned long long str_len;
   char *str;
 }
 bfd_mach_o_str_command;
@@ -601,7 +601,7 @@ typedef struct mach_o_data_struct
   bfd_mach_o_load_command *last_command;
 
   /* Flatten array of sections.  The array is 0-based.  */
-  unsigned long nsects;
+  unsigned long long nsects;
   bfd_mach_o_section **sections;
 
   /* Used while writing: current length of the output file.  This is used
@@ -628,7 +628,7 @@ bfd_mach_o_data_struct;
 typedef struct bfd_mach_o_xlat_name
 {
   const char *name;
-  unsigned long val;
+  unsigned long long val;
 }
 bfd_mach_o_xlat_name;
 
@@ -649,7 +649,7 @@ const bfd_target *bfd_mach_o_core_p (bfd *);
 const bfd_target *bfd_mach_o_fat_archive_p (bfd *);
 bfd *bfd_mach_o_fat_openr_next_archived_file (bfd *, bfd *);
 bfd_boolean bfd_mach_o_set_arch_mach (bfd *, enum bfd_architecture,
-				      unsigned long);
+				      unsigned long long);
 int bfd_mach_o_lookup_command (bfd *, bfd_mach_o_load_command_type, bfd_mach_o_load_command **);
 bfd_boolean bfd_mach_o_new_section_hook (bfd *, asection *);
 bfd_boolean bfd_mach_o_write_contents (bfd *);
@@ -660,19 +660,19 @@ bfd_boolean bfd_mach_o_bfd_copy_private_section_data (bfd *, asection *,
 bfd_boolean bfd_mach_o_bfd_copy_private_header_data (bfd *, bfd *);
 bfd_boolean bfd_mach_o_bfd_set_private_flags (bfd *, flagword);
 bfd_boolean bfd_mach_o_bfd_print_private_bfd_data (bfd *, void *);
-long bfd_mach_o_get_symtab_upper_bound (bfd *);
-long bfd_mach_o_canonicalize_symtab (bfd *, asymbol **);
-long bfd_mach_o_get_synthetic_symtab (bfd *, long, asymbol **, long,
+long long bfd_mach_o_get_symtab_upper_bound (bfd *);
+long long bfd_mach_o_canonicalize_symtab (bfd *, asymbol **);
+long long bfd_mach_o_get_synthetic_symtab (bfd *, long long, asymbol **, long long,
 				      asymbol **, asymbol **ret);
-long bfd_mach_o_get_reloc_upper_bound (bfd *, asection *);
-long bfd_mach_o_canonicalize_reloc (bfd *, asection *, arelent **, asymbol **);
-long bfd_mach_o_get_dynamic_reloc_upper_bound (bfd *);
-long bfd_mach_o_canonicalize_dynamic_reloc (bfd *, arelent **, asymbol **);
+long long bfd_mach_o_get_reloc_upper_bound (bfd *, asection *);
+long long bfd_mach_o_canonicalize_reloc (bfd *, asection *, arelent **, asymbol **);
+long long bfd_mach_o_get_dynamic_reloc_upper_bound (bfd *);
+long long bfd_mach_o_canonicalize_dynamic_reloc (bfd *, arelent **, asymbol **);
 asymbol *bfd_mach_o_make_empty_symbol (bfd *);
 void bfd_mach_o_get_symbol_info (bfd *, asymbol *, symbol_info *);
 void bfd_mach_o_print_symbol (bfd *, void *, asymbol *, bfd_print_symbol_type);
 int bfd_mach_o_sizeof_headers (bfd *, struct bfd_link_info *);
-unsigned long bfd_mach_o_stack_addr (enum bfd_mach_o_cpu_type);
+unsigned long long bfd_mach_o_stack_addr (enum bfd_mach_o_cpu_type);
 int bfd_mach_o_core_fetch_environment (bfd *, unsigned char **, unsigned int *);
 char *bfd_mach_o_core_file_failing_command (bfd *);
 int bfd_mach_o_core_file_failing_signal (bfd *);
@@ -752,7 +752,7 @@ typedef struct bfd_mach_o_backend_data
   bfd_boolean (*_bfd_mach_o_print_thread)(bfd *, bfd_mach_o_thread_flavour *,
 					  void *, char *);
   const mach_o_segment_name_xlat *segsec_names_xlat;
-  bfd_boolean (*bfd_mach_o_section_type_valid_for_target) (unsigned long);
+  bfd_boolean (*bfd_mach_o_section_type_valid_for_target) (unsigned long long);
 }
 bfd_mach_o_backend_data;
 
diff --git a/bfd/merge.c b/bfd/merge.c
index 7904552..b037d31 100644
--- a/bfd/merge.c
+++ b/bfd/merge.c
@@ -137,7 +137,7 @@ sec_merge_hash_lookup (struct sec_merge_hash *table, const char *string,
 		       unsigned int alignment, bfd_boolean create)
 {
   const unsigned char *s;
-  unsigned long hash;
+  unsigned long long hash;
   unsigned int c;
   struct sec_merge_hash_entry *hashp;
   unsigned int len, i;
diff --git a/bfd/mmo.c b/bfd/mmo.c
index 6a3e255..b7caf93 100644
--- a/bfd/mmo.c
+++ b/bfd/mmo.c
@@ -393,8 +393,8 @@ static bfd_boolean mmo_create_symbol (bfd *, const char *, bfd_vma,
 				      enum mmo_sym_type, unsigned int);
 static bfd_boolean mmo_get_section_contents (bfd *, asection *, void *,
 					     file_ptr, bfd_size_type);
-static long mmo_get_symtab_upper_bound (bfd *);
-static long mmo_canonicalize_symtab (bfd *, asymbol **);
+static long long mmo_get_symtab_upper_bound (bfd *);
+static long long mmo_canonicalize_symtab (bfd *, asymbol **);
 static void mmo_get_symbol_info (bfd *, asymbol *, symbol_info *);
 static void mmo_print_symbol (bfd *, void *, asymbol *,
 			      bfd_print_symbol_type);
@@ -1023,7 +1023,7 @@ mmo_get_spec_section (bfd *abfd, int spec_data_number)
   bfd_vma section_vma;
   mmo_data_list_type *loc;
   flagword flags;
-  long orig_pos;
+  long long orig_pos;
 
   /* If this isn't the "special" special data, then make a placeholder
      section.  */
@@ -2025,15 +2025,15 @@ mmo_scan (bfd *abfd)
 		/* Check that the YZ field is right.  Subtract the size of
 		   this LOP_END in the calculation; YZ does not include
 		   it.  */
-		if ((long) (y * 256 + z) * 4 != (curpos - stab_loc) - 4)
+		if ((long long) (y * 256 + z) * 4 != (curpos - stab_loc) - 4)
 		  {
 		    _bfd_error_handler
 		      /* xgettext:c-format */
 		      (_("%pB: invalid mmo file: YZ of lop_end (%ld)"
 			 " not equal to the number of tetras to the preceding"
 			 " lop_stab (%ld)\n"),
-		       abfd, (long) (y * 256 + z),
-		       (long) (curpos - stab_loc - 4)/4);
+		       abfd, (long long) (y * 256 + z),
+		       (long long) (curpos - stab_loc - 4)/4);
 		    bfd_set_error (bfd_error_bad_value);
 		    goto error_return;
 		  }
@@ -2154,7 +2154,7 @@ mmo_get_section_contents (bfd *abfd ATTRIBUTE_UNUSED,
 
 /* Return the amount of memory needed to read the symbol table.  */
 
-static long
+static long long
 mmo_get_symtab_upper_bound (bfd *abfd)
 {
   return (abfd->symcount + 1) * sizeof (asymbol *);
@@ -2180,7 +2180,7 @@ mmo_sort_mmo_symbols (const void *arg1, const void *arg2)
 
 /* Translate the symbol table.  */
 
-static long
+static long long
 mmo_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
   unsigned int symcount = bfd_get_symcount (abfd);
diff --git a/bfd/opncls.c b/bfd/opncls.c
index e275045..7ad140e 100644
--- a/bfd/opncls.c
+++ b/bfd/opncls.c
@@ -930,7 +930,7 @@ void *
 bfd_alloc (bfd *abfd, bfd_size_type size)
 {
   void *ret;
-  unsigned long ul_size = (unsigned long) size;
+  unsigned long long ul_size = (unsigned long long) size;
 
   if (size != ul_size
       /* Note - although objalloc_alloc takes an unsigned long as its
@@ -940,7 +940,7 @@ bfd_alloc (bfd *abfd, bfd_size_type size)
 	 ((unsigned long) -1) bytes.  Also memory checkers will often
 	 complain about attempts to allocate a negative amount of memory.
 	 So to stop these problems we fail if the size is negative.  */
-      || ((signed long) ul_size) < 0)
+      || ((signed long long) ul_size) < 0)
     {
       bfd_set_error (bfd_error_no_memory);
       return NULL;
@@ -1077,12 +1077,12 @@ RETURNS
 	Return the updated CRC32 value.
 */
 
-unsigned long
-bfd_calc_gnu_debuglink_crc32 (unsigned long crc,
+unsigned long long
+bfd_calc_gnu_debuglink_crc32 (unsigned long long crc,
 			      const unsigned char *buf,
 			      bfd_size_type len)
 {
-  static const unsigned long crc32_table[256] =
+  static const unsigned long long crc32_table[256] =
     {
       0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
       0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
@@ -1175,7 +1175,7 @@ static char *
 bfd_get_debug_link_info_1 (bfd *abfd, void *crc32_out)
 {
   asection *sect;
-  unsigned long *crc32 = (unsigned long *) crc32_out;
+  unsigned long long *crc32 = (unsigned long long *) crc32_out;
   bfd_byte *contents;
   unsigned int crc_offset;
   char *name;
@@ -1237,7 +1237,7 @@ RETURNS
 */
 
 char *
-bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
+bfd_get_debug_link_info (bfd *abfd, unsigned long long *crc32_out)
 {
   return bfd_get_debug_link_info_1 (abfd, crc32_out);
 }
@@ -1324,15 +1324,15 @@ static bfd_boolean
 separate_debug_file_exists (const char *name, void *crc32_p)
 {
   static unsigned char buffer [8 * 1024];
-  unsigned long file_crc = 0;
+  unsigned long long file_crc = 0;
   FILE *f;
   bfd_size_type count;
-  unsigned long crc;
+  unsigned long long crc;
 
   BFD_ASSERT (name);
   BFD_ASSERT (crc32_p);
 
-  crc = *(unsigned long *) crc32_p;
+  crc = *(unsigned long long *) crc32_p;
 
   f = _bfd_real_fopen (name, FOPEN_RB);
   if (f == NULL)
@@ -1589,7 +1589,7 @@ RETURNS
 char *
 bfd_follow_gnu_debuglink (bfd *abfd, const char *dir)
 {
-  unsigned long crc32;
+  unsigned long long crc32;
 
   return find_separate_debug_file (abfd, dir, TRUE,
 				   bfd_get_debug_link_info_1,
@@ -1736,7 +1736,7 @@ bfd_fill_in_gnu_debuglink_section (bfd *abfd,
 				   const char *filename)
 {
   bfd_size_type debuglink_size;
-  unsigned long crc32;
+  unsigned long long crc32;
   char * contents;
   bfd_size_type crc_offset;
   FILE * handle;
diff --git a/bfd/pdp11.c b/bfd/pdp11.c
index 339fa62..4545e9a 100644
--- a/bfd/pdp11.c
+++ b/bfd/pdp11.c
@@ -676,7 +676,7 @@ NAME (aout, mkobject) (bfd *abfd)
 
 enum machine_type
 NAME (aout, machine_type) (enum bfd_architecture arch,
-			   unsigned long machine,
+			   unsigned long long machine,
 			   bfd_boolean *unknown)
 {
   enum machine_type arch_flags;
@@ -763,7 +763,7 @@ NAME (aout, machine_type) (enum bfd_architecture arch,
 bfd_boolean
 NAME (aout, set_arch_mach) (bfd *abfd,
 			    enum bfd_architecture arch,
-			    unsigned long machine)
+			    unsigned long long machine)
 {
   if (! bfd_default_set_arch_mach (abfd, arch, machine))
     return FALSE;
@@ -1655,7 +1655,7 @@ error_return:
 }
 
 
-long
+long long
 NAME (aout, canonicalize_symtab) (bfd *abfd, asymbol **location)
 {
   unsigned int counter = 0;
@@ -1944,7 +1944,7 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)
 
 /* This is stupid.  This function should be a boolean predicate.  */
 
-long
+long long
 NAME (aout, canonicalize_reloc) (bfd *abfd,
 				 sec_ptr section,
 				 arelent **relptr,
@@ -1985,7 +1985,7 @@ NAME (aout, canonicalize_reloc) (bfd *abfd,
   return section->reloc_count;
 }
 
-long
+long long
 NAME (aout, get_reloc_upper_bound) (bfd *abfd, sec_ptr asect)
 {
   if (bfd_get_format (abfd) != bfd_object)
@@ -2020,7 +2020,7 @@ NAME (aout, get_reloc_upper_bound) (bfd *abfd, sec_ptr asect)
 }
 
 
-long
+long long
 NAME (aout, get_symtab_upper_bound) (bfd *abfd)
 {
   if (!NAME (aout, slurp_symbol_table) (abfd))
@@ -2109,7 +2109,7 @@ NAME (aout, print_symbol) (bfd * abfd,
    symbols.  The minisymbol_to_symbol function translates these into
    BFD asymbol structures.  */
 
-long
+long long
 NAME (aout, read_minisymbols) (bfd *abfd,
 			       bfd_boolean dynamic,
 			       void * *minisymsp,
@@ -4449,12 +4449,12 @@ static bfd_vma
 bfd_getp32 (const void *p)
 {
   const bfd_byte *addr = p;
-  unsigned long v;
+  unsigned long long v;
 
-  v = (unsigned long) addr[1] << 24;
-  v |= (unsigned long) addr[0] << 16;
-  v |= (unsigned long) addr[3] << 8;
-  v |= (unsigned long) addr[2];
+  v = (unsigned long long) addr[1] << 24;
+  v |= (unsigned long long) addr[0] << 16;
+  v |= (unsigned long long) addr[3] << 8;
+  v |= (unsigned long long) addr[2];
   return v;
 }
 
@@ -4464,12 +4464,12 @@ static bfd_signed_vma
 bfd_getp_signed_32 (const void *p)
 {
   const bfd_byte *addr = p;
-  unsigned long v;
+  unsigned long long v;
 
-  v = (unsigned long) addr[1] << 24;
-  v |= (unsigned long) addr[0] << 16;
-  v |= (unsigned long) addr[3] << 8;
-  v |= (unsigned long) addr[2];
+  v = (unsigned long long) addr[1] << 24;
+  v |= (unsigned long long) addr[0] << 16;
+  v |= (unsigned long long) addr[3] << 8;
+  v |= (unsigned long long) addr[2];
   return COERCE32 (v);
 }
 
diff --git a/bfd/peXXigen.c b/bfd/peXXigen.c
index 598f2ca..014f29a 100644
--- a/bfd/peXXigen.c
+++ b/bfd/peXXigen.c
@@ -1019,7 +1019,7 @@ _bfd_XXi_swap_scnhdr_out (bfd * abfd, void * in, void * out)
     typedef struct
     {
       char section_name[SCNNMLEN];
-      unsigned long	must_have;
+      unsigned long long	must_have;
     }
     pe_required_section_flags;
 
@@ -1146,7 +1146,7 @@ _bfd_XXi_swap_debugdir_out (bfd * abfd, void * inp, void * extp)
 }
 
 CODEVIEW_INFO *
-_bfd_XXi_slurp_codeview_record (bfd * abfd, file_ptr where, unsigned long length, CODEVIEW_INFO *cvinfo)
+_bfd_XXi_slurp_codeview_record (bfd * abfd, file_ptr where, unsigned long long length, CODEVIEW_INFO *cvinfo)
 {
   char buffer[256+1];
 
@@ -1320,7 +1320,7 @@ pe_print_idata (bfd * abfd, void * vfile)
 
   /* xgettext:c-format */
   fprintf (file, _("\nThere is an import table in %s at 0x%lx\n"),
-	   section->name, (unsigned long) addr);
+	   section->name, (unsigned long long) addr);
 
   dataoff = addr - section->vma;
 
@@ -1362,7 +1362,7 @@ pe_print_idata (bfd * abfd, void * vfile)
 
       fprintf (file,
 	       _("\nFunction descriptor located at the start address: %04lx\n"),
-	       (unsigned long int) (abfd->start_address));
+	       (unsigned long long int) (abfd->start_address));
       fprintf (file,
 	       /* xgettext:c-format */
 	       _("\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n"),
@@ -1408,7 +1408,7 @@ pe_print_idata (bfd * abfd, void * vfile)
       char *dll;
 
       /* Print (i + extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress).  */
-      fprintf (file, " %08lx\t", (unsigned long) (i + adj));
+      fprintf (file, " %08lx\t", (unsigned long long) (i + adj));
       hint_addr = bfd_get_32 (abfd, data + i);
       time_stamp = bfd_get_32 (abfd, data + i + 4);
       forward_chain = bfd_get_32 (abfd, data + i + 8);
@@ -1416,11 +1416,11 @@ pe_print_idata (bfd * abfd, void * vfile)
       first_thunk = bfd_get_32 (abfd, data + i + 16);
 
       fprintf (file, "%08lx %08lx %08lx %08lx %08lx\n",
-	       (unsigned long) hint_addr,
-	       (unsigned long) time_stamp,
-	       (unsigned long) forward_chain,
-	       (unsigned long) dll_name,
-	       (unsigned long) first_thunk);
+	       (unsigned long long) hint_addr,
+	       (unsigned long long) time_stamp,
+	       (unsigned long long) forward_chain,
+	       (unsigned long long) dll_name,
+	       (unsigned long long) first_thunk);
 
       if (hint_addr == 0 && first_thunk == 0)
 	break;
@@ -1502,8 +1502,8 @@ pe_print_idata (bfd * abfd, void * vfile)
 	  for (j = 0; idx + j + 8 <= datasize; j += 8)
 	    {
 	      bfd_size_type amt;
-	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
-	      unsigned long member_high = bfd_get_32 (abfd, data + idx + j + 4);
+	      unsigned long long member = bfd_get_32 (abfd, data + idx + j);
+	      unsigned long long member_high = bfd_get_32 (abfd, data + idx + j + 4);
 
 	      if (!member && !member_high)
 		break;
@@ -1535,14 +1535,14 @@ pe_print_idata (bfd * abfd, void * vfile)
 		  && first_thunk != hint_addr
 		  && j + 4 <= ft_datasize)
 		fprintf (file, "\t%04lx",
-			 (unsigned long) bfd_get_32 (abfd, ft_data + j));
+			 (unsigned long long) bfd_get_32 (abfd, ft_data + j));
 	      fprintf (file, "\n");
 	    }
 #else
 	  for (j = 0; idx + j + 4 <= datasize; j += 4)
 	    {
 	      bfd_size_type amt;
-	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
+	      unsigned long long member = bfd_get_32 (abfd, data + idx + j);
 
 	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */
 	      if (member == 0)
@@ -1575,7 +1575,7 @@ pe_print_idata (bfd * abfd, void * vfile)
 		  && first_thunk != hint_addr
 		  && j + 4 <= ft_datasize)
 		fprintf (file, "\t%04lx",
-			 (unsigned long) bfd_get_32 (abfd, ft_data + j));
+			 (unsigned long long) bfd_get_32 (abfd, ft_data + j));
 
 	      fprintf (file, "\n");
 	    }
@@ -1604,14 +1604,14 @@ pe_print_edata (bfd * abfd, void * vfile)
   bfd_vma       adj;
   struct EDT_type
   {
-    long export_flags;		/* Reserved - should be zero.  */
-    long time_stamp;
+    long long export_flags;		/* Reserved - should be zero.  */
+    long long time_stamp;
     short major_ver;
     short minor_ver;
     bfd_vma name;		/* RVA - relative to image base.  */
-    long base;			/* Ordinal base.  */
-    unsigned long num_functions;/* Number in the export address table.  */
-    unsigned long num_names;	/* Number in the name pointer table.  */
+    long long base;			/* Ordinal base.  */
+    unsigned long long num_functions;/* Number in the export address table.  */
+    unsigned long long num_names;	/* Number in the name pointer table.  */
     bfd_vma eat_addr;		/* RVA to the export address table.  */
     bfd_vma npt_addr;		/* RVA to the Export Name Pointer Table.  */
     bfd_vma ot_addr;		/* RVA to the Ordinal Table.  */
@@ -1682,7 +1682,7 @@ pe_print_edata (bfd * abfd, void * vfile)
 
   /* xgettext:c-format */
   fprintf (file, _("\nThere is an export table in %s at 0x%lx\n"),
-	   section->name, (unsigned long) addr);
+	   section->name, (unsigned long long) addr);
 
   data = (bfd_byte *) bfd_malloc (datasize);
   if (data == NULL)
@@ -1713,10 +1713,10 @@ pe_print_edata (bfd * abfd, void * vfile)
 	   section->name);
 
   fprintf (file,
-	   _("Export Flags \t\t\t%lx\n"), (unsigned long) edt.export_flags);
+	   _("Export Flags \t\t\t%lx\n"), (unsigned long long) edt.export_flags);
 
   fprintf (file,
-	   _("Time/Date stamp \t\t%lx\n"), (unsigned long) edt.time_stamp);
+	   _("Time/Date stamp \t\t%lx\n"), (unsigned long long) edt.time_stamp);
 
   fprintf (file,
 	   /* xgettext:c-format */
@@ -1784,8 +1784,8 @@ pe_print_edata (bfd * abfd, void * vfile)
       /* PR 17512 file: 140-165018-0.004.  */
       || data + edt.eat_addr - adj < data)
     fprintf (file, _("\tInvalid Export Address Table rva (0x%lx) or entry count (0x%lx)\n"),
-	     (long) edt.eat_addr,
-	     (long) edt.num_functions);
+	     (long long) edt.eat_addr,
+	     (long long) edt.num_functions);
   else for (i = 0; i < edt.num_functions; ++i)
     {
       bfd_vma eat_member = bfd_get_32 (abfd,
@@ -1799,9 +1799,9 @@ pe_print_edata (bfd * abfd, void * vfile)
 	  /* Should locate a function descriptor.  */
 	  fprintf (file,
 		   "\t[%4ld] +base[%4ld] %04lx %s -- %.*s\n",
-		   (long) i,
-		   (long) (i + edt.base),
-		   (unsigned long) eat_member,
+		   (long long) i,
+		   (long long) (i + edt.base),
+		   (unsigned long long) eat_member,
 		   _("Forwarder RVA"),
 		   (int)(datasize - (eat_member - adj)),
 		   data + eat_member - adj);
@@ -1811,9 +1811,9 @@ pe_print_edata (bfd * abfd, void * vfile)
 	  /* Should locate a function descriptor in the reldata section.  */
 	  fprintf (file,
 		   "\t[%4ld] +base[%4ld] %04lx %s\n",
-		   (long) i,
-		   (long) (i + edt.base),
-		   (unsigned long) eat_member,
+		   (long long) i,
+		   (long long) (i + edt.base),
+		   (unsigned long long) eat_member,
 		   _("Export RVA"));
 	}
     }
@@ -1830,15 +1830,15 @@ pe_print_edata (bfd * abfd, void * vfile)
       || (data + edt.npt_addr - adj) < data)
     /* xgettext:c-format */
     fprintf (file, _("\tInvalid Name Pointer Table rva (0x%lx) or entry count (0x%lx)\n"),
-	     (long) edt.npt_addr,
-	     (long) edt.num_names);
+	     (long long) edt.npt_addr,
+	     (long long) edt.num_names);
   /* PR 17512: file: 140-147171-0.004.  */
   else if (edt.ot_addr + (edt.num_names * 2) - adj >= datasize
 	   || data + edt.ot_addr - adj < data)
     /* xgettext:c-format */
     fprintf (file, _("\tInvalid Ordinal Table rva (0x%lx) or entry count (0x%lx)\n"),
-	     (long) edt.ot_addr,
-	     (long) edt.num_names);
+	     (long long) edt.ot_addr,
+	     (long long) edt.num_names);
   else for (i = 0; i < edt.num_names; ++i)
     {
       bfd_vma  name_ptr;
@@ -1851,13 +1851,13 @@ pe_print_edata (bfd * abfd, void * vfile)
 	{
 	  /* xgettext:c-format */
 	  fprintf (file, _("\t[%4ld] <corrupt offset: %lx>\n"),
-		   (long) ord, (long) name_ptr);
+		   (long long) ord, (long long) name_ptr);
 	}
       else
 	{
 	  char * name = (char *) data + name_ptr - adj;
 
-	  fprintf (file, "\t[%4ld] %.*s\n", (long) ord,
+	  fprintf (file, "\t[%4ld] %.*s\n", (long long) ord,
 		   (int)((char *)(data + datasize) - name), name);
 	}
     }
@@ -1905,7 +1905,7 @@ pe_print_pdata (bfd * abfd, void * vfile)
     fprintf (file,
 	     /* xgettext:c-format */
 	     _("warning, .pdata section size (%ld) is not a multiple of %d\n"),
-	     (long) stop, onaline);
+	     (long long) stop, onaline);
 
   fprintf (file,
 	   _("\nThe Function Table (interpreted .pdata section contents)\n"));
@@ -1927,7 +1927,7 @@ pe_print_pdata (bfd * abfd, void * vfile)
     {
       /* xgettext:c-format */
       fprintf (file, _("Virtual size of .pdata section (%ld) larger than real size (%ld)\n"),
-	       (long) stop, (long) datasize);
+	       (long long) stop, (long long) datasize);
       return FALSE;
     }
 
@@ -2028,7 +2028,7 @@ static asymbol **
 slurp_symtab (bfd *abfd, sym_cache *psc)
 {
   asymbol ** sy = NULL;
-  long storage;
+  long long storage;
 
   if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
     {
@@ -2102,7 +2102,7 @@ _bfd_XX_print_ce_compressed_pdata (bfd * abfd, void * vfile)
     fprintf (file,
 	     /* xgettext:c-format */
 	     _("warning, .pdata section size (%ld) is not a multiple of %d\n"),
-	     (long) stop, onaline);
+	     (long long) stop, onaline);
 
   fprintf (file,
 	   _("\nThe Function Table (interpreted .pdata section contents)\n"));
@@ -2244,7 +2244,7 @@ pe_print_reloc (bfd * abfd, void * vfile)
     {
       int j;
       bfd_vma virtual_address;
-      unsigned long number, size;
+      unsigned long long number, size;
       bfd_byte *chunk_end;
 
       /* The .reloc section is a sequence of blocks, with a header consisting
@@ -2260,7 +2260,7 @@ pe_print_reloc (bfd * abfd, void * vfile)
       fprintf (file,
 	       /* xgettext:c-format */
 	       _("\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n"),
-	       (unsigned long) virtual_address, size, size, number);
+	       (unsigned long long) virtual_address, size, size, number);
 
       chunk_end = p - 8 + size;
       if (chunk_end > end)
@@ -2278,7 +2278,7 @@ pe_print_reloc (bfd * abfd, void * vfile)
 	  fprintf (file,
 		   /* xgettext:c-format */
 		   _("\treloc %4d offset %4x [%4lx] %s"),
-		   j, off, (unsigned long) (off + virtual_address), tbl[t]);
+		   j, off, (unsigned long long) (off + virtual_address), tbl[t]);
 
 	  p += 2;
 	  j++;
@@ -2331,7 +2331,7 @@ rsrc_print_resource_entries (FILE *	    file,
 			     rsrc_regions * regions,
 			     bfd_vma	    rva_bias)
 {
-  unsigned long entry, addr, size;
+  unsigned long long entry, addr, size;
   bfd_byte * leaf;
 
   if (data + 8 >= regions->section_end)
@@ -2340,7 +2340,7 @@ rsrc_print_resource_entries (FILE *	    file,
   /* xgettext:c-format */
   fprintf (file, _("%03x %*.s Entry: "), (int)(data - regions->section_start), indent, " ");
 
-  entry = (unsigned long) bfd_get_32 (abfd, data);
+  entry = (unsigned long long) bfd_get_32 (abfd, data);
   if (is_name)
     {
       bfd_byte * name;
@@ -2399,7 +2399,7 @@ rsrc_print_resource_entries (FILE *	    file,
   else
     fprintf (file, _("ID: %#08lx"), entry);
 
-  entry = (long) bfd_get_32 (abfd, data + 4);
+  entry = (long long) bfd_get_32 (abfd, data + 4);
   fprintf (file, _(", Value: %#08lx\n"), entry);
 
   if (HighBitSet  (entry))
@@ -2424,8 +2424,8 @@ rsrc_print_resource_entries (FILE *	    file,
   /* xgettext:c-format */
   fprintf (file, _("%03x %*.s  Leaf: Addr: %#08lx, Size: %#08lx, Codepage: %d\n"),
 	   (int) (entry), indent, " ",
-	   addr = (long) bfd_get_32 (abfd, leaf),
-	   size = (long) bfd_get_32 (abfd, leaf + 4),
+	   addr = (long long) bfd_get_32 (abfd, leaf),
+	   size = (long long) bfd_get_32 (abfd, leaf + 4),
 	   (int) bfd_get_32 (abfd, leaf + 8));
 
   /* Check that the reserved entry is 0.  */
@@ -2474,7 +2474,7 @@ rsrc_print_resource_directory (FILE *	      file,
   /* xgettext:c-format */
   fprintf (file, _(" Table: Char: %d, Time: %08lx, Ver: %d/%d, Num Names: %d, IDs: %d\n"),
 	   (int) bfd_get_32 (abfd, data),
-	   (long) bfd_get_32 (abfd, data + 4),
+	   (long long) bfd_get_32 (abfd, data + 4),
 	   (int)  bfd_get_16 (abfd, data + 8),
 	   (int)  bfd_get_16 (abfd, data + 10),
 	   num_names = (int) bfd_get_16 (abfd, data + 12),
@@ -2665,7 +2665,7 @@ pe_print_debugdata (bfd * abfd, void * vfile)
     }
 
   fprintf (file, _("\nThere is a debug directory in %s at 0x%lx\n\n"),
-	   section->name, (unsigned long) addr);
+	   section->name, (unsigned long long) addr);
 
   dataoff = addr - section->vma;
 
@@ -2804,11 +2804,11 @@ _bfd_XX_print_private_bfd_data_common (bfd * abfd, void * vfile)
     fprintf (file, "\t(%s)",name);
   fprintf (file, "\nMajorLinkerVersion\t%d\n", i->MajorLinkerVersion);
   fprintf (file, "MinorLinkerVersion\t%d\n", i->MinorLinkerVersion);
-  fprintf (file, "SizeOfCode\t\t%08lx\n", (unsigned long) i->SizeOfCode);
+  fprintf (file, "SizeOfCode\t\t%08lx\n", (unsigned long long) i->SizeOfCode);
   fprintf (file, "SizeOfInitializedData\t%08lx\n",
-	   (unsigned long) i->SizeOfInitializedData);
+	   (unsigned long long) i->SizeOfInitializedData);
   fprintf (file, "SizeOfUninitializedData\t%08lx\n",
-	   (unsigned long) i->SizeOfUninitializedData);
+	   (unsigned long long) i->SizeOfUninitializedData);
   fprintf (file, "AddressOfEntryPoint\t");
   bfd_fprintf_vma (abfd, file, i->AddressOfEntryPoint);
   fprintf (file, "\nBaseOfCode\t\t");
@@ -2831,10 +2831,10 @@ _bfd_XX_print_private_bfd_data_common (bfd * abfd, void * vfile)
   fprintf (file, "MinorImageVersion\t%d\n", i->MinorImageVersion);
   fprintf (file, "MajorSubsystemVersion\t%d\n", i->MajorSubsystemVersion);
   fprintf (file, "MinorSubsystemVersion\t%d\n", i->MinorSubsystemVersion);
-  fprintf (file, "Win32Version\t\t%08lx\n", (unsigned long) i->Reserved1);
-  fprintf (file, "SizeOfImage\t\t%08lx\n", (unsigned long) i->SizeOfImage);
-  fprintf (file, "SizeOfHeaders\t\t%08lx\n", (unsigned long) i->SizeOfHeaders);
-  fprintf (file, "CheckSum\t\t%08lx\n", (unsigned long) i->CheckSum);
+  fprintf (file, "Win32Version\t\t%08lx\n", (unsigned long long) i->Reserved1);
+  fprintf (file, "SizeOfImage\t\t%08lx\n", (unsigned long long) i->SizeOfImage);
+  fprintf (file, "SizeOfHeaders\t\t%08lx\n", (unsigned long long) i->SizeOfHeaders);
+  fprintf (file, "CheckSum\t\t%08lx\n", (unsigned long long) i->CheckSum);
 
   switch (i->Subsystem)
     {
@@ -2890,16 +2890,16 @@ _bfd_XX_print_private_bfd_data_common (bfd * abfd, void * vfile)
   bfd_fprintf_vma (abfd, file, i->SizeOfHeapReserve);
   fprintf (file, "\nSizeOfHeapCommit\t");
   bfd_fprintf_vma (abfd, file, i->SizeOfHeapCommit);
-  fprintf (file, "\nLoaderFlags\t\t%08lx\n", (unsigned long) i->LoaderFlags);
+  fprintf (file, "\nLoaderFlags\t\t%08lx\n", (unsigned long long) i->LoaderFlags);
   fprintf (file, "NumberOfRvaAndSizes\t%08lx\n",
-	   (unsigned long) i->NumberOfRvaAndSizes);
+	   (unsigned long long) i->NumberOfRvaAndSizes);
 
   fprintf (file, "\nThe Data Directory\n");
   for (j = 0; j < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; j++)
     {
       fprintf (file, "Entry %1x ", j);
       bfd_fprintf_vma (abfd, file, i->DataDirectory[j].VirtualAddress);
-      fprintf (file, " %08lx ", (unsigned long) i->DataDirectory[j].Size);
+      fprintf (file, " %08lx ", (unsigned long long) i->DataDirectory[j].Size);
       fprintf (file, "%s\n", dir_names[j]);
     }
 
@@ -3120,7 +3120,7 @@ rsrc_count_entries (bfd *	   abfd,
 		    bfd_byte *	   dataend,
 		    bfd_vma	   rva_bias)
 {
-  unsigned long entry, addr, size;
+  unsigned long long entry, addr, size;
 
   if (data + 8 >= dataend)
     return dataend + 1;
@@ -3129,7 +3129,7 @@ rsrc_count_entries (bfd *	   abfd,
     {
       bfd_byte * name;
 
-      entry = (long) bfd_get_32 (abfd, data);
+      entry = (long long) bfd_get_32 (abfd, data);
 
       if (HighBitSet (entry))
 	name = datastart + WithoutHighBit (entry);
@@ -3144,7 +3144,7 @@ rsrc_count_entries (bfd *	   abfd,
 	return dataend + 1;
     }
 
-  entry = (long) bfd_get_32 (abfd, data + 4);
+  entry = (long long) bfd_get_32 (abfd, data + 4);
 
   if (HighBitSet (entry))
     {
@@ -3159,8 +3159,8 @@ rsrc_count_entries (bfd *	   abfd,
   if (datastart + entry + 16 >= dataend)
     return dataend + 1;
 
-  addr = (long) bfd_get_32 (abfd, datastart + entry);
-  size = (long) bfd_get_32 (abfd, datastart + entry + 4);
+  addr = (long long) bfd_get_32 (abfd, datastart + entry);
+  size = (long long) bfd_get_32 (abfd, datastart + entry + 4);
 
   return datastart + addr - rva_bias + size;
 }
@@ -3267,7 +3267,7 @@ rsrc_parse_entry (bfd *		   abfd,
 		  bfd_vma	   rva_bias,
 		  rsrc_directory * parent)
 {
-  unsigned long val, addr, size;
+  unsigned long long val, addr, size;
 
   val = bfd_get_32 (abfd, data);
 
diff --git a/bfd/pef-traceback.h b/bfd/pef-traceback.h
index a6e2b69..1b0102c 100644
--- a/bfd/pef-traceback.h
+++ b/bfd/pef-traceback.h
@@ -132,7 +132,7 @@ struct traceback_table
 /* Order and type encoding of parameters:  */
 struct traceback_table_fixedparams
 {
-  unsigned long paraminfo;
+  unsigned long long paraminfo;
 };
 
 /* Left-justified bit-encoding as follows:  */
@@ -152,7 +152,7 @@ struct traceback_table_fixedparams
 /* Offset from start of code to TracebackTbl.  */
 struct traceback_table_tboff
 {
-  unsigned long tb_offset;
+  unsigned long long tb_offset;
 };
 
 /* The following is present only if int_hndl (in flags2) in fixed part is present ...  */
@@ -160,7 +160,7 @@ struct traceback_table_tboff
 /* What interrupts are handled by the routine.  */
 struct traceback_table_interrupts
 {
-  long hand_mask;
+  long long hand_mask;
 };
 
 /* The following are present only if has_ctl (in flags1) in fixed part is present...  */
@@ -168,8 +168,8 @@ struct traceback_table_interrupts
 /* Controlled automatic storage info:  */
 struct traceback_table_anchors
 {
-  unsigned long ctl_info;	/* Number of controlled automatic anchors.  */
-  long ctl_info_disp[1];	/* Array of stack displacements where each.  */
+  unsigned long long ctl_info;	/* Number of controlled automatic anchors.  */
+  long long ctl_info_disp[1];	/* Array of stack displacements where each.  */
 };				/* Anchor is located (array STARTS here).  */
 
 /* The following are present only if name_present (in flags2) in fixed
diff --git a/bfd/pef.c b/bfd/pef.c
index 5746b96..2cbade7 100644
--- a/bfd/pef.c
+++ b/bfd/pef.c
@@ -197,7 +197,7 @@ bfd_pef_parse_traceback_table (bfd *abfd,
     offset += 4;
 
   if (file != NULL)
-    fprintf (file, " [length = 0x%lx]", (unsigned long) offset);
+    fprintf (file, " [length = 0x%lx]", (unsigned long long) offset);
 
   return offset;
 }
@@ -236,12 +236,12 @@ bfd_pef_print_symbol (bfd *abfd,
 }
 
 static void
-bfd_pef_convert_architecture (unsigned long architecture,
+bfd_pef_convert_architecture (unsigned long long architecture,
 			      enum bfd_architecture *type,
-			      unsigned long *subtype)
+			      unsigned long long *subtype)
 {
-  const unsigned long ARCH_POWERPC = 0x70777063; /* 'pwpc'.  */
-  const unsigned long ARCH_M68K = 0x6d36386b; /* 'm68k'.  */
+  const unsigned long long ARCH_POWERPC = 0x70777063; /* 'pwpc'.  */
+  const unsigned long long ARCH_M68K = 0x6d36386b; /* 'm68k'.  */
 
   *subtype = bfd_arch_unknown;
   *type = bfd_arch_unknown;
@@ -275,7 +275,7 @@ static const char *bfd_pef_section_name (bfd_pef_section *section)
     }
 }
 
-static unsigned long bfd_pef_section_flags (bfd_pef_section *section)
+static unsigned long long bfd_pef_section_flags (bfd_pef_section *section)
 {
   switch (section->section_kind)
     {
@@ -367,7 +367,7 @@ bfd_pef_parse_imported_symbol (bfd *abfd ATTRIBUTE_UNUSED,
 			       size_t len,
 			       bfd_pef_imported_symbol *symbol)
 {
-  unsigned long value;
+  unsigned long long value;
 
   BFD_ASSERT (len == 4);
 
@@ -491,7 +491,7 @@ bfd_pef_scan_start_address (bfd *abfd)
     goto end;
 
   for (section = abfd->sections; section != NULL; section = section->next)
-    if ((long) (section->index + 1) == header.main_section)
+    if ((long long) (section->index + 1) == header.main_section)
       break;
 
   if (section == NULL)
@@ -517,7 +517,7 @@ bfd_pef_scan (bfd *abfd,
 {
   unsigned int i;
   enum bfd_architecture cputype;
-  unsigned long cpusubtype;
+  unsigned long long cpusubtype;
 
   mdata->header = *header;
 
@@ -617,7 +617,7 @@ bfd_pef_parse_traceback_tables (bfd *abfd,
 				asection *sec,
 				unsigned char *buf,
 				size_t len,
-				long *nsym,
+				long long *nsym,
 				asymbol **csym)
 {
   char *name;
@@ -629,7 +629,7 @@ bfd_pef_parse_traceback_tables (bfd *abfd,
   size_t tbnamelen;
 
   size_t pos = 0;
-  unsigned long count = 0;
+  unsigned long long count = 0;
   int ret;
 
   for (;;)
@@ -698,7 +698,7 @@ static int
 bfd_pef_parse_function_stub (bfd *abfd ATTRIBUTE_UNUSED,
 			     unsigned char *buf,
 			     size_t len,
-			     unsigned long *offset)
+			     unsigned long long *offset)
 {
   BFD_ASSERT (len == 24);
 
@@ -728,16 +728,16 @@ bfd_pef_parse_function_stubs (bfd *abfd,
 			      size_t codelen,
 			      unsigned char *loaderbuf,
 			      size_t loaderlen,
-			      unsigned long *nsym,
+			      unsigned long long *nsym,
 			      asymbol **csym)
 {
   const char *const sprefix = "__stub_";
   size_t codepos = 0;
-  unsigned long count = 0;
+  unsigned long long count = 0;
   bfd_pef_loader_header header;
   bfd_pef_imported_library *libraries = NULL;
   bfd_pef_imported_symbol *imports = NULL;
-  unsigned long i;
+  unsigned long long i;
   int ret;
 
   if (loaderlen < 56)
@@ -782,7 +782,7 @@ bfd_pef_parse_function_stubs (bfd *abfd,
       asymbol sym;
       const char *symname;
       char *name;
-      unsigned long sym_index;
+      unsigned long long sym_index;
 
       if (csym && (csym[count] == NULL))
 	break;
@@ -877,10 +877,10 @@ bfd_pef_parse_function_stubs (bfd *abfd,
   return -1;
 }
 
-static long
+static long long
 bfd_pef_parse_symbols (bfd *abfd, asymbol **csym)
 {
-  unsigned long count = 0;
+  unsigned long long count = 0;
 
   asection *codesec = NULL;
   unsigned char *codebuf = NULL;
@@ -915,7 +915,7 @@ bfd_pef_parse_symbols (bfd *abfd, asymbol **csym)
   count = 0;
   if (codesec != NULL)
     {
-      long ncount = 0;
+      long long ncount = 0;
       bfd_pef_parse_traceback_tables (abfd, codesec, codebuf, codelen,
 				      &ncount, csym);
       count += ncount;
@@ -923,7 +923,7 @@ bfd_pef_parse_symbols (bfd *abfd, asymbol **csym)
 
   if ((codesec != NULL) && (loadersec != NULL))
     {
-      unsigned long ncount = 0;
+      unsigned long long ncount = 0;
       bfd_pef_parse_function_stubs
 	(abfd, codesec, codebuf, codelen, loaderbuf, loaderlen, &ncount,
 	 (csym != NULL) ? (csym + count) : NULL);
@@ -943,29 +943,29 @@ bfd_pef_parse_symbols (bfd *abfd, asymbol **csym)
   return count;
 }
 
-static long
+static long long
 bfd_pef_count_symbols (bfd *abfd)
 {
   return bfd_pef_parse_symbols (abfd, NULL);
 }
 
-static long
+static long long
 bfd_pef_get_symtab_upper_bound (bfd *abfd)
 {
-  long nsyms = bfd_pef_count_symbols (abfd);
+  long long nsyms = bfd_pef_count_symbols (abfd);
 
   if (nsyms < 0)
     return nsyms;
   return ((nsyms + 1) * sizeof (asymbol *));
 }
 
-static long
+static long long
 bfd_pef_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
-  long i;
+  long long i;
   asymbol *syms;
-  long ret;
-  long nsyms = bfd_pef_count_symbols (abfd);
+  long long ret;
+  long long nsyms = bfd_pef_count_symbols (abfd);
 
   if (nsyms < 0)
     return nsyms;
diff --git a/bfd/pef.h b/bfd/pef.h
index efc6d48..096a80c 100644
--- a/bfd/pef.h
+++ b/bfd/pef.h
@@ -25,46 +25,46 @@
 
 struct bfd_pef_header
 {
-  unsigned long tag1;
-  unsigned long tag2;
-  unsigned long architecture;
-  unsigned long format_version;
-  unsigned long timestamp;
-  unsigned long old_definition_version;
-  unsigned long old_implementation_version;
-  unsigned long current_version;
+  unsigned long long tag1;
+  unsigned long long tag2;
+  unsigned long long architecture;
+  unsigned long long format_version;
+  unsigned long long timestamp;
+  unsigned long long old_definition_version;
+  unsigned long long old_implementation_version;
+  unsigned long long current_version;
   unsigned short section_count;
   unsigned short instantiated_section_count;
-  unsigned long reserved;
+  unsigned long long reserved;
 };
 typedef struct bfd_pef_header bfd_pef_header;
 
 struct bfd_pef_loader_header
 {
-  long main_section;
-  unsigned long main_offset;
-  long init_section;
-  unsigned long init_offset;
-  long term_section;
-  unsigned long term_offset;
-  unsigned long imported_library_count;
-  unsigned long total_imported_symbol_count;
-  unsigned long reloc_section_count;
-  unsigned long reloc_instr_offset;
-  unsigned long loader_strings_offset;
-  unsigned long export_hash_offset;
-  unsigned long export_hash_table_power;
-  unsigned long exported_symbol_count;
+  long long main_section;
+  unsigned long long main_offset;
+  long long init_section;
+  unsigned long long init_offset;
+  long long term_section;
+  unsigned long long term_offset;
+  unsigned long long imported_library_count;
+  unsigned long long total_imported_symbol_count;
+  unsigned long long reloc_section_count;
+  unsigned long long reloc_instr_offset;
+  unsigned long long loader_strings_offset;
+  unsigned long long export_hash_offset;
+  unsigned long long export_hash_table_power;
+  unsigned long long exported_symbol_count;
 };
 typedef struct bfd_pef_loader_header bfd_pef_loader_header;
 
 struct bfd_pef_imported_library
 {
-  unsigned long name_offset;
-  unsigned long old_implementation_version;
-  unsigned long current_version;
-  unsigned long imported_symbol_count;
-  unsigned long first_imported_symbol;
+  unsigned long long name_offset;
+  unsigned long long old_implementation_version;
+  unsigned long long current_version;
+  unsigned long long imported_symbol_count;
+  unsigned long long first_imported_symbol;
   unsigned char options;
   unsigned char reserved_a;
   unsigned short reserved_b;
@@ -80,7 +80,7 @@ enum bfd_pef_imported_library_options
 struct bfd_pef_imported_symbol
 {
   unsigned char symbol_class;
-  unsigned long name;
+  unsigned long long name;
 };
 typedef struct bfd_pef_imported_symbol bfd_pef_imported_symbol;
 
@@ -102,13 +102,13 @@ enum bfd_pef_imported_symbol_class
 
 struct bfd_pef_section
 {
-  long name_offset;
-  unsigned long header_offset;
-  unsigned long default_address;
-  unsigned long total_length;
-  unsigned long unpacked_length;
-  unsigned long container_length;
-  unsigned long container_offset;
+  long long name_offset;
+  unsigned long long header_offset;
+  unsigned long long default_address;
+  unsigned long long total_length;
+  unsigned long long unpacked_length;
+  unsigned long long container_length;
+  unsigned long long container_offset;
   unsigned char section_kind;
   unsigned char share_kind;
   unsigned char alignment;
@@ -147,27 +147,27 @@ typedef struct bfd_pef_data_struct bfd_pef_data_struct;
 
 struct bfd_pef_xlib_header
 {
-  unsigned long tag1;
-  unsigned long tag2;
-  unsigned long current_format;
-  unsigned long container_strings_offset;
-  unsigned long export_hash_offset;
-  unsigned long export_key_offset;
-  unsigned long export_symbol_offset;
-  unsigned long export_names_offset;
-  unsigned long export_hash_table_power;
-  unsigned long exported_symbol_count;
-
-  unsigned long frag_name_offset;
-  unsigned long frag_name_length;
-  unsigned long dylib_path_offset;
-  unsigned long dylib_path_length;
-  unsigned long cpu_family;
-  unsigned long cpu_model;
-  unsigned long date_time_stamp;
-  unsigned long current_version;
-  unsigned long old_definition_version;
-  unsigned long old_implementation_version;
+  unsigned long long tag1;
+  unsigned long long tag2;
+  unsigned long long current_format;
+  unsigned long long container_strings_offset;
+  unsigned long long export_hash_offset;
+  unsigned long long export_key_offset;
+  unsigned long long export_symbol_offset;
+  unsigned long long export_names_offset;
+  unsigned long long export_hash_table_power;
+  unsigned long long exported_symbol_count;
+
+  unsigned long long frag_name_offset;
+  unsigned long long frag_name_length;
+  unsigned long long dylib_path_offset;
+  unsigned long long dylib_path_length;
+  unsigned long long cpu_family;
+  unsigned long long cpu_model;
+  unsigned long long date_time_stamp;
+  unsigned long long current_version;
+  unsigned long long old_definition_version;
+  unsigned long long old_implementation_version;
 };
 typedef struct bfd_pef_xlib_header bfd_pef_xlib_header;
 
diff --git a/bfd/pei-x86_64.c b/bfd/pei-x86_64.c
index 3a0248d..860ca65 100644
--- a/bfd/pei-x86_64.c
+++ b/bfd/pei-x86_64.c
@@ -436,7 +436,7 @@ pex64_dump_xdata (FILE *file, bfd *abfd,
 
   /* PR 17512: file: 2245-7442-0.004.  */
   if (ui.CountOfCodes * 2 + ui.rawUnwindCodes > xdata + xdata_section->size)
-    fprintf (file, _("Too many unwind codes (%ld)\n"), (long) ui.CountOfCodes);
+    fprintf (file, _("Too many unwind codes (%ld)\n"), (long long) ui.CountOfCodes);
   else
     pex64_xdata_print_uwd_codes (file, abfd, &ui, rf);
 
@@ -527,7 +527,7 @@ pex64_bfd_print_pdata_section (bfd *abfd, void *vfile, asection *pdata_section)
     fprintf (file,
 	     /* xgettext:c-format */
 	     _("Warning: %s section size (%ld) is not a multiple of %d\n"),
-	     pdata_section->name, (long) stop, onaline);
+	     pdata_section->name, (long long) stop, onaline);
 
   datasize = pdata_section->size;
   if (datasize == 0)
@@ -549,8 +549,8 @@ pex64_bfd_print_pdata_section (bfd *abfd, void *vfile, asection *pdata_section)
 	fprintf (file,
 		 /* xgettext:c-format */
 		 _("Warning: %s section size (%ld) is smaller than virtual size (%ld)\n"),
-		 pdata_section->name, (unsigned long) datasize,
-		 (unsigned long) stop);
+		 pdata_section->name, (unsigned long long) datasize,
+		 (unsigned long long) stop);
 	/* Be sure not to read passed datasize.  */
 	stop = datasize / onaline;
       }
diff --git a/bfd/plugin.c b/bfd/plugin.c
index 7c5bba2..e945f35 100644
--- a/bfd/plugin.c
+++ b/bfd/plugin.c
@@ -457,11 +457,11 @@ bfd_plugin_core_file_pid (bfd *abfd ATTRIBUTE_UNUSED)
   return 0;
 }
 
-static long
+static long long
 bfd_plugin_get_symtab_upper_bound (bfd *abfd)
 {
   struct plugin_data_struct *plugin_data = abfd->tdata.plugin_data;
-  long nsyms = plugin_data->nsyms;
+  long long nsyms = plugin_data->nsyms;
 
   BFD_ASSERT (nsyms >= 0);
 
@@ -488,12 +488,12 @@ convert_flags (const struct ld_plugin_symbol *sym)
    }
 }
 
-static long
+static long long
 bfd_plugin_canonicalize_symtab (bfd *abfd,
 				asymbol **alocation)
 {
   struct plugin_data_struct *plugin_data = abfd->tdata.plugin_data;
-  long nsyms = plugin_data->nsyms;
+  long long nsyms = plugin_data->nsyms;
   const struct ld_plugin_symbol *syms = plugin_data->syms;
   static asection fake_section;
   static asection fake_common_section;
diff --git a/bfd/ppcboot.c b/bfd/ppcboot.c
index 0d92fd1..ab43bb4 100644
--- a/bfd/ppcboot.c
+++ b/bfd/ppcboot.c
@@ -114,7 +114,7 @@ ppcboot_mkobject (bfd *abfd)
 static bfd_boolean
 ppcboot_set_arch_mach (bfd *abfd,
 		       enum bfd_architecture arch,
-		       unsigned long machine)
+		       unsigned long long machine)
 {
   if (arch == bfd_arch_unknown)
     arch = bfd_arch_powerpc;
@@ -233,7 +233,7 @@ ppcboot_get_section_contents (bfd *abfd,
 
 /* Return the amount of memory needed to read the symbol table.  */
 
-static long
+static long long
 ppcboot_get_symtab_upper_bound (bfd *abfd ATTRIBUTE_UNUSED)
 {
   return (PPCBOOT_SYMS + 1) * sizeof (asymbol *);
@@ -270,7 +270,7 @@ mangle_name (bfd *abfd, char *suffix)
 
 /* Return the symbol table.  */
 
-static long
+static long long
 ppcboot_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
   asection *sec = ppcboot_get_tdata (abfd)->sec;
@@ -385,15 +385,15 @@ ppcboot_bfd_print_private_bfd_data (bfd *abfd, void * farg)
 {
   FILE *f = (FILE *)farg;
   ppcboot_data_t *tdata = ppcboot_get_tdata (abfd);
-  long entry_offset = bfd_getl_signed_32 (tdata->header.entry_offset);
-  long length = bfd_getl_signed_32 (tdata->header.length);
+  long long entry_offset = bfd_getl_signed_32 (tdata->header.entry_offset);
+  long long length = bfd_getl_signed_32 (tdata->header.length);
   int i;
 
   fprintf (f, _("\nppcboot header:\n"));
   fprintf (f, _("Entry offset        = 0x%.8lx (%ld)\n"),
-	   (unsigned long) entry_offset, entry_offset);
+	   (unsigned long long) entry_offset, entry_offset);
   fprintf (f, _("Length              = 0x%.8lx (%ld)\n"),
-	   (unsigned long) length, length);
+	   (unsigned long long) length, length);
 
   if (tdata->header.flags)
     fprintf (f, _("Flag field          = 0x%.2x\n"), tdata->header.flags);
@@ -406,8 +406,8 @@ ppcboot_bfd_print_private_bfd_data (bfd *abfd, void * farg)
 
   for (i = 0; i < 4; i++)
     {
-      long sector_begin  = bfd_getl_signed_32 (tdata->header.partition[i].sector_begin);
-      long sector_length = bfd_getl_signed_32 (tdata->header.partition[i].sector_length);
+      long long sector_begin  = bfd_getl_signed_32 (tdata->header.partition[i].sector_begin);
+      long long sector_length = bfd_getl_signed_32 (tdata->header.partition[i].sector_length);
 
       /* Skip all 0 entries */
       if (!tdata->header.partition[i].partition_begin.ind
@@ -437,11 +437,11 @@ ppcboot_bfd_print_private_bfd_data (bfd *abfd, void * farg)
 
       /* xgettext:c-format */
       fprintf (f, _("Partition[%d] sector = 0x%.8lx (%ld)\n"),
-	       i, (unsigned long) sector_begin, sector_begin);
+	       i, (unsigned long long) sector_begin, sector_begin);
 
       /* xgettext:c-format */
       fprintf (f, _("Partition[%d] length = 0x%.8lx (%ld)\n"),
-	       i, (unsigned long) sector_length, sector_length);
+	       i, (unsigned long long) sector_length, sector_length);
     }
 
   fprintf (f, "\n");
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 68bc8a8..5076d4b 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -920,7 +920,7 @@ space consuming.  For each target:
     {
     case 5:
       {
-	long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
+	long long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
 	x >>= 8;
 	DOIT (x);
 	bfd_put_16 (abfd, (bfd_vma) (x >> 8), (bfd_byte *) data + octets);
@@ -945,14 +945,14 @@ space consuming.  For each target:
       break;
     case 2:
       {
-	long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
+	long long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
 	DOIT (x);
 	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
       }
       break;
     case -2:
       {
-	long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
+	long long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
 	relocation = -relocation;
 	DOIT (x);
 	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
@@ -961,7 +961,7 @@ space consuming.  For each target:
 
     case -1:
       {
-	long x = bfd_get_16 (abfd, (bfd_byte *) data + octets);
+	long long x = bfd_get_16 (abfd, (bfd_byte *) data + octets);
 	relocation = -relocation;
 	DOIT (x);
 	bfd_put_16 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
@@ -1335,14 +1335,14 @@ space consuming.  For each target:
       break;
     case 2:
       {
-	long x = bfd_get_32 (abfd, data);
+	long long x = bfd_get_32 (abfd, data);
 	DOIT (x);
 	bfd_put_32 (abfd, (bfd_vma) x, data);
       }
       break;
     case -2:
       {
-	long x = bfd_get_32 (abfd, data);
+	long long x = bfd_get_32 (abfd, data);
 	relocation = -relocation;
 	DOIT (x);
 	bfd_put_32 (abfd, (bfd_vma) x, data);
@@ -8215,9 +8215,9 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
 {
   bfd *input_bfd = link_order->u.indirect.section->owner;
   asection *input_section = link_order->u.indirect.section;
-  long reloc_size;
+  long long reloc_size;
   arelent **reloc_vector;
-  long reloc_count;
+  long long reloc_count;
 
   reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
   if (reloc_size < 0)
@@ -8434,7 +8434,7 @@ _bfd_norelocs_bfd_reloc_name_lookup (bfd *abfd,
   return (reloc_howto_type *) _bfd_ptr_bfd_null_error (abfd);
 }
 
-long
+long long
 _bfd_nodynamic_canonicalize_dynamic_reloc (bfd *abfd,
 					   arelent **relp ATTRIBUTE_UNUSED,
 					   asymbol **symp ATTRIBUTE_UNUSED)
diff --git a/bfd/reloc16.c b/bfd/reloc16.c
index 5d67dce..fcb1b71 100644
--- a/bfd/reloc16.c
+++ b/bfd/reloc16.c
@@ -146,9 +146,9 @@ bfd_coff_reloc16_relax_section (bfd *abfd,
   bfd *input_bfd = input_section->owner;
   unsigned *shrinks;
   unsigned shrink = 0;
-  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
+  long long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
   arelent **reloc_vector = NULL;
-  long reloc_count;
+  long long reloc_count;
 
   if (bfd_link_relocatable (link_info))
     (*link_info->callbacks->einfo)
@@ -206,7 +206,7 @@ bfd_coff_reloc16_relax_section (bfd *abfd,
 	{
 	  arelent **parent;
 	  unsigned int i;
-	  long j;
+	  long long j;
 
 	  another_pass = 0;
 
@@ -251,9 +251,9 @@ bfd_coff_reloc16_get_relocated_section_contents
   /* Get enough memory to hold the stuff.  */
   bfd *input_bfd = link_order->u.indirect.section->owner;
   asection *input_section = link_order->u.indirect.section;
-  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
+  long long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
   arelent **reloc_vector;
-  long reloc_count;
+  long long reloc_count;
   bfd_size_type sz;
 
   if (reloc_size < 0)
diff --git a/bfd/rs6000-core.c b/bfd/rs6000-core.c
index a2f0d23..b289ee0 100644
--- a/bfd/rs6000-core.c
+++ b/bfd/rs6000-core.c
@@ -65,7 +65,7 @@
 #include <sys/systemcfg.h>
 
 /* Borrowed from <sys/inttypes.h> on recent AIX versions.  */
-typedef unsigned long ptr_to_uint;
+typedef unsigned long long ptr_to_uint;
 
 #define	core_hdr(bfd)		((CoreHdr *) bfd->tdata.any)
 
@@ -268,7 +268,7 @@ typedef union
 /* Size of the leading portion that old and new core dump structures have in
    common.  */
 #ifdef AIX_CORE_DUMPX_CORE
-#define CORE_COMMONSZ  ((long) &((struct core_dumpx *) 0)->c_entries \
+#define CORE_COMMONSZ  ((long long) &((struct core_dumpx *) 0)->c_entries \
 			+ sizeof (((struct core_dumpx *) 0)->c_entries))
 #else
 #define CORE_COMMONSZ   ((int) &((struct core_dump *) 0)->c_entries \
@@ -488,7 +488,7 @@ rs6000coff_core_p (bfd *abfd)
   if (CORE_NEW (core))
     {
       enum bfd_architecture arch;
-      unsigned long mach;
+      unsigned long long mach;
 
       switch (CNEW_IMPL (core.new_dump))
 	{
@@ -600,9 +600,9 @@ rs6000coff_core_p (bfd *abfd)
 
     /* .data sections from loaded objects.  */
     if (proc64)
-      size = (unsigned long) ((LdInfo *) 0)->l64.ldinfo_filename;
+      size = (unsigned long long) ((LdInfo *) 0)->l64.ldinfo_filename;
     else
-      size = (unsigned long) ((LdInfo *) 0)->l32.ldinfo_filename;
+      size = (unsigned long long) ((LdInfo *) 0)->l32.ldinfo_filename;
 
     while (1)
       {
diff --git a/bfd/section.c b/bfd/section.c
index 7ee3f69..d541b73 100644
--- a/bfd/section.c
+++ b/bfd/section.c
@@ -917,7 +917,7 @@ bfd_get_next_section_by_name (bfd *ibfd, asection *sec)
 {
   struct section_hash_entry *sh;
   const char *name;
-  unsigned long hash;
+  unsigned long long hash;
 
   sh = ((struct section_hash_entry *)
 	((char *) sec - offsetof (struct section_hash_entry, section)));
@@ -998,7 +998,7 @@ bfd_get_section_by_name_if (bfd *abfd, const char *name,
 			    void *user_storage)
 {
   struct section_hash_entry *sh;
-  unsigned long hash;
+  unsigned long long hash;
 
   sh = section_hash_lookup (&abfd->section_htab, name, FALSE, FALSE);
   if (sh == NULL)
diff --git a/bfd/som.c b/bfd/som.c
index d2bdc6f..3c998ec 100644
--- a/bfd/som.c
+++ b/bfd/som.c
@@ -37,7 +37,7 @@ static bfd_boolean som_mkobject (bfd *);
 static bfd_boolean som_is_space (asection *);
 static bfd_boolean som_is_subspace (asection *);
 static int compare_subspaces (const void *, const void *);
-static unsigned long som_compute_checksum (struct som_external_header *);
+static unsigned long long som_compute_checksum (struct som_external_header *);
 static bfd_boolean som_build_and_write_symbol_table (bfd *);
 static unsigned int som_slurp_symbol_table (bfd *);
 
@@ -105,7 +105,7 @@ static unsigned int som_slurp_symbol_table (bfd *);
 
 /* Generic alignment macro.  */
 #define SOM_ALIGN(val, alignment) \
-  (((val) + (alignment) - 1) &~ ((unsigned long) (alignment) - 1))
+  (((val) + (alignment) - 1) &~ ((unsigned long long) (alignment) - 1))
 
 /* SOM allows any one of the four previous relocations to be reused
    with a "R_PREV_FIXUP" relocation entry.  Since R_PREV_FIXUP
@@ -1949,7 +1949,7 @@ static const bfd_target *
 som_object_setup (bfd *abfd,
 		  struct som_header *file_hdrp,
 		  struct som_exec_auxhdr *aux_hdrp,
-		  unsigned long current_offset)
+		  unsigned long long current_offset)
 {
   asection *section;
 
@@ -2072,7 +2072,7 @@ som_object_setup (bfd *abfd,
 static bfd_boolean
 setup_sections (bfd *abfd,
 		struct som_header *file_hdr,
-		unsigned long current_offset)
+		unsigned long long current_offset)
 {
   char *space_strings;
   unsigned int space_index, i;
@@ -2387,7 +2387,7 @@ som_object_p (bfd *abfd)
   struct som_external_header ext_file_hdr;
   struct som_header file_hdr;
   struct som_exec_auxhdr *aux_hdr_ptr = NULL;
-  unsigned long current_offset = 0;
+  unsigned long long current_offset = 0;
   struct som_external_lst_header ext_lst_header;
   struct som_external_som_entry ext_som_entry;
   bfd_size_type amt;
@@ -2717,7 +2717,7 @@ som_is_container (asection *space, asection *subspace)
 
 /* Count and return the number of spaces attached to the given BFD.  */
 
-static unsigned long
+static unsigned long long
 som_count_spaces (bfd *abfd)
 {
   int count = 0;
@@ -2731,7 +2731,7 @@ som_count_spaces (bfd *abfd)
 
 /* Count the number of subspaces attached to the given BFD.  */
 
-static unsigned long
+static unsigned long long
 som_count_subspaces (bfd *abfd)
 {
   int count = 0;
@@ -2796,9 +2796,9 @@ compare_subspaces (const void *arg1, const void *arg2)
 /* Perform various work in preparation for emitting the fixup stream.  */
 
 static void
-som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)
+som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long long num_syms)
 {
-  unsigned long i;
+  unsigned long long i;
   asection *section;
   asymbol **sorted_syms;
   bfd_size_type amt;
@@ -2895,7 +2895,7 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)
 
 static bfd_boolean
 som_write_fixups (bfd *abfd,
-		  unsigned long current_offset,
+		  unsigned long long current_offset,
 		  unsigned int *total_reloc_sizep)
 {
   unsigned int i, j;
@@ -3303,7 +3303,7 @@ som_write_fixups (bfd *abfd,
 
 static bfd_boolean
 som_write_space_strings (bfd *abfd,
-			 unsigned long current_offset,
+			 unsigned long long current_offset,
 			 unsigned int *string_sizep)
 {
   /* Chunk of memory that we can use as buffer space, then throw
@@ -3409,7 +3409,7 @@ som_write_space_strings (bfd *abfd,
 
 static bfd_boolean
 som_write_symbol_strings (bfd *abfd,
-			  unsigned long current_offset,
+			  unsigned long long current_offset,
 			  asymbol **syms,
 			  unsigned int num_syms,
 			  unsigned int *string_sizep,
@@ -3586,9 +3586,9 @@ som_write_symbol_strings (bfd *abfd,
 static bfd_boolean
 som_begin_writing (bfd *abfd)
 {
-  unsigned long current_offset = 0;
+  unsigned long long current_offset = 0;
   unsigned int strings_size = 0;
-  unsigned long num_spaces, num_subspaces, i;
+  unsigned long long num_spaces, num_subspaces, i;
   asection *section;
   unsigned int total_subspaces = 0;
   struct som_exec_auxhdr *exec_header = NULL;
@@ -3947,7 +3947,7 @@ som_finish_writing (bfd *abfd)
   int subspace_index = 0;
   file_ptr location;
   asection *section;
-  unsigned long current_offset;
+  unsigned long long current_offset;
   unsigned int strings_size, total_reloc_size;
   bfd_size_type amt;
   struct som_external_header ext_header;
@@ -4224,7 +4224,7 @@ som_finish_writing (bfd *abfd)
   /* Now write the exec header.  */
   if (abfd->flags & (EXEC_P | DYNAMIC))
     {
-      long tmp, som_length;
+      long long tmp, som_length;
       struct som_exec_auxhdr *exec_header;
       struct som_external_exec_auxhdr ext_exec_header;
 
@@ -4267,11 +4267,11 @@ som_finish_writing (bfd *abfd)
 
 /* Compute and return the checksum for a SOM file header.  */
 
-static unsigned long
+static unsigned long long
 som_compute_checksum (struct som_external_header *hdr)
 {
-  unsigned long checksum, count, i;
-  unsigned long *buffer = (unsigned long *) hdr;
+  unsigned long long checksum, count, i;
+  unsigned long long *buffer = (unsigned long long *) hdr;
 
   checksum = 0;
   count = sizeof (struct som_external_header) / 4;
@@ -4568,7 +4568,7 @@ som_slurp_string_table (bfd *abfd)
 /* Return the amount of data (in bytes) required to hold the symbol
    table for this object.  */
 
-static long
+static long long
 som_get_symtab_upper_bound (bfd *abfd)
 {
   if (!som_slurp_symbol_table (abfd))
@@ -4810,7 +4810,7 @@ som_slurp_symbol_table (bfd *abfd)
 /* Canonicalize a SOM symbol table.  Return the number of entries
    in the symbol table.  */
 
-static long
+static long long
 som_canonicalize_symtab (bfd *abfd, asymbol **location)
 {
   int i;
@@ -4863,7 +4863,7 @@ som_print_symbol (bfd *abfd,
     case bfd_print_symbol_more:
       fprintf (file, "som ");
       fprintf_vma (file, symbol->value);
-      fprintf (file, " %lx", (long) symbol->flags);
+      fprintf (file, " %lx", (long long) symbol->flags);
       break;
     case bfd_print_symbol_all:
       {
@@ -5315,7 +5315,7 @@ som_slurp_reloc_table (bfd *abfd,
 /* Return the number of bytes required to store the relocation
    information associated with the given section.  */
 
-static long
+static long long
 som_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
 {
   /* If section has relocations, then read in the relocation stream
@@ -5336,7 +5336,7 @@ som_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
 /* Convert relocations from SOM (external) form into BFD internal
    form.  Return the number of relocations.  */
 
-static long
+static long long
 som_canonicalize_reloc (bfd *abfd,
 			sec_ptr section,
 			arelent **relptr,
@@ -5493,16 +5493,16 @@ som_bfd_print_private_bfd_data (bfd *abfd, void *farg)
       /* Note that, depending on the HP-UX version, the following fields can be
 	 either ints, or longs.  */
 
-      fprintf (f, "  text size          %#lx\n", (long) exec_header->exec_tsize);
-      fprintf (f, "  text memory offset %#lx\n", (long) exec_header->exec_tmem);
-      fprintf (f, "  text file offset   %#lx\n", (long) exec_header->exec_tfile);
-      fprintf (f, "  data size          %#lx\n", (long) exec_header->exec_dsize);
-      fprintf (f, "  data memory offset %#lx\n", (long) exec_header->exec_dmem);
-      fprintf (f, "  data file offset   %#lx\n", (long) exec_header->exec_dfile);
-      fprintf (f, "  bss size           %#lx\n", (long) exec_header->exec_bsize);
-      fprintf (f, "  entry point        %#lx\n", (long) exec_header->exec_entry);
-      fprintf (f, "  loader flags       %#lx\n", (long) exec_header->exec_flags);
-      fprintf (f, "  bss initializer    %#lx\n", (long) exec_header->exec_bfill);
+      fprintf (f, "  text size          %#lx\n", (long long) exec_header->exec_tsize);
+      fprintf (f, "  text memory offset %#lx\n", (long long) exec_header->exec_tmem);
+      fprintf (f, "  text file offset   %#lx\n", (long long) exec_header->exec_tfile);
+      fprintf (f, "  data size          %#lx\n", (long long) exec_header->exec_dsize);
+      fprintf (f, "  data memory offset %#lx\n", (long long) exec_header->exec_dmem);
+      fprintf (f, "  data file offset   %#lx\n", (long long) exec_header->exec_dfile);
+      fprintf (f, "  bss size           %#lx\n", (long long) exec_header->exec_bsize);
+      fprintf (f, "  entry point        %#lx\n", (long long) exec_header->exec_entry);
+      fprintf (f, "  loader flags       %#lx\n", (long long) exec_header->exec_flags);
+      fprintf (f, "  bss initializer    %#lx\n", (long long) exec_header->exec_bfill);
     }
 
   return TRUE;
@@ -5716,7 +5716,7 @@ som_set_section_contents (bfd *abfd,
 static bfd_boolean
 som_set_arch_mach (bfd *abfd,
 		   enum bfd_architecture arch,
-		   unsigned long machine)
+		   unsigned long long machine)
 {
   /* Allow any architecture to be supported by the SOM backend.  */
   return bfd_default_set_arch_mach (abfd, arch, machine);
diff --git a/bfd/som.h b/bfd/som.h
index 794c9e4..849c53a 100644
--- a/bfd/som.h
+++ b/bfd/som.h
@@ -95,7 +95,7 @@ struct som_exec_data
 
   /* Magic exec flags.  These control things like whether or not
      null pointer dereferencing is allowed and the like.  */
-  long exec_flags;
+  long long exec_flags;
 
   /* We must preserve the version identifier too.  Some versions
      of the HP linker do not grok NEW_VERSION_ID for reasons unknown.  */
diff --git a/bfd/srec.c b/bfd/srec.c
index 66cc72f..64a029a 100644
--- a/bfd/srec.c
+++ b/bfd/srec.c
@@ -867,7 +867,7 @@ srec_get_section_contents (bfd *abfd,
 /* Set the architecture.  We accept an unknown architecture here.  */
 
 static bfd_boolean
-srec_set_arch_mach (bfd *abfd, enum bfd_architecture arch, unsigned long mach)
+srec_set_arch_mach (bfd *abfd, enum bfd_architecture arch, unsigned long long mach)
 {
   if (arch != bfd_arch_unknown)
     return bfd_default_set_arch_mach (abfd, arch, mach);
@@ -1179,7 +1179,7 @@ srec_sizeof_headers (bfd *abfd ATTRIBUTE_UNUSED,
 
 /* Return the amount of memory needed to read the symbol table.  */
 
-static long
+static long long
 srec_get_symtab_upper_bound (bfd *abfd)
 {
   return (bfd_get_symcount (abfd) + 1) * sizeof (asymbol *);
@@ -1187,7 +1187,7 @@ srec_get_symtab_upper_bound (bfd *abfd)
 
 /* Return the symbol table.  */
 
-static long
+static long long
 srec_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
   bfd_size_type symcount = bfd_get_symcount (abfd);
diff --git a/bfd/stabs.c b/bfd/stabs.c
index bdb9f06..92f3fb6 100644
--- a/bfd/stabs.c
+++ b/bfd/stabs.c
@@ -277,7 +277,7 @@ _bfd_link_section_stabs (bfd *abfd,
 	  _bfd_error_handler
 	    /* xgettext:c-format */
 	    (_("%pB(%pA+%#lx): stabs entry has invalid string index"),
-	     abfd, stabsec, (long) (sym - stabbuf));
+	     abfd, stabsec, (long long) (sym - stabbuf));
 	  bfd_set_error (bfd_error_bad_value);
 	  goto error_return;
 	}
diff --git a/bfd/syms.c b/bfd/syms.c
index 187071f..773c7ec 100644
--- a/bfd/syms.c
+++ b/bfd/syms.c
@@ -792,15 +792,15 @@ DESCRIPTION
    This is used when the backend does not provide a more efficient
    version.  It just uses BFD asymbol structures as mini symbols.  */
 
-long
+long long
 _bfd_generic_read_minisymbols (bfd *abfd,
 			       bfd_boolean dynamic,
 			       void **minisymsp,
 			       unsigned int *sizep)
 {
-  long storage;
+  long long storage;
   asymbol **syms = NULL;
-  long symcount;
+  long long symcount;
 
   if (dynamic)
     storage = bfd_get_dynamic_symtab_upper_bound (abfd);
@@ -984,7 +984,7 @@ _bfd_stab_section_find_nearest_line (bfd *abfd,
     }
   else
     {
-      long reloc_size, reloc_count;
+      long long reloc_size, reloc_count;
       arelent **reloc_vector;
       int i;
       char *function_name;
@@ -1060,7 +1060,7 @@ _bfd_stab_section_find_nearest_line (bfd *abfd,
 	  for (pr = reloc_vector; *pr != NULL; pr++)
 	    {
 	      arelent *r;
-	      unsigned long val;
+	      unsigned long long val;
 	      asymbol *sym;
 
 	      r = *pr;
@@ -1283,8 +1283,8 @@ _bfd_stab_section_find_nearest_line (bfd *abfd,
   else
 #endif
     {
-      long low, high;
-      long mid = -1;
+      long long low, high;
+      long long mid = -1;
 
       /* Cache non-existent or invalid.  Do binary search on
 	 indextable.  */
@@ -1428,7 +1428,7 @@ _bfd_stab_section_find_nearest_line (bfd *abfd,
   return TRUE;
 }
 
-long
+long long
 _bfd_nosymbols_canonicalize_symtab (bfd *abfd ATTRIBUTE_UNUSED,
 				    asymbol **location ATTRIBUTE_UNUSED)
 {
@@ -1508,12 +1508,12 @@ _bfd_nosymbols_find_inliner_info
 asymbol *
 _bfd_nosymbols_bfd_make_debug_symbol (bfd *abfd,
 				      void *ptr ATTRIBUTE_UNUSED,
-				      unsigned long sz ATTRIBUTE_UNUSED)
+				      unsigned long long sz ATTRIBUTE_UNUSED)
 {
   return (asymbol *) _bfd_ptr_bfd_null_error (abfd);
 }
 
-long
+long long
 _bfd_nosymbols_read_minisymbols (bfd *abfd,
 				 bfd_boolean dynamic ATTRIBUTE_UNUSED,
 				 void **minisymsp ATTRIBUTE_UNUSED,
@@ -1531,11 +1531,11 @@ _bfd_nosymbols_minisymbol_to_symbol (bfd *abfd,
   return (asymbol *) _bfd_ptr_bfd_null_error (abfd);
 }
 
-long
+long long
 _bfd_nodynamic_get_synthetic_symtab (bfd *abfd,
-				     long symcount ATTRIBUTE_UNUSED,
+				     long long symcount ATTRIBUTE_UNUSED,
 				     asymbol **syms ATTRIBUTE_UNUSED,
-				     long dynsymcount ATTRIBUTE_UNUSED,
+				     long long dynsymcount ATTRIBUTE_UNUSED,
 				     asymbol **dynsyms ATTRIBUTE_UNUSED,
 				     asymbol **ret ATTRIBUTE_UNUSED)
 {
diff --git a/bfd/tekhex.c b/bfd/tekhex.c
index 893d06d..69899d5 100644
--- a/bfd/tekhex.c
+++ b/bfd/tekhex.c
@@ -558,7 +558,7 @@ pass_over (bfd *abfd, bfd_boolean (*func) (bfd *, int, char *, char *))
   return TRUE;
 }
 
-static long
+static long long
 tekhex_canonicalize_symtab (bfd *abfd, asymbol **table)
 {
   tekhex_symbol_type *p = abfd->tdata.tekhex_data->symbols;
@@ -574,7 +574,7 @@ tekhex_canonicalize_symtab (bfd *abfd, asymbol **table)
   return bfd_get_symcount (abfd);
 }
 
-static long
+static long long
 tekhex_get_symtab_upper_bound (bfd *abfd)
 {
   return (abfd->symcount + 1) * (sizeof (struct tekhex_asymbol_struct *));
@@ -686,7 +686,7 @@ tekhex_get_section_contents (bfd *abfd,
 static bfd_boolean
 tekhex_set_arch_mach (bfd *abfd,
 		      enum bfd_architecture arch,
-		      unsigned long machine)
+		      unsigned long long machine)
 {
   /* Ignore errors about unknown architecture.  */
   return (bfd_default_set_arch_mach (abfd, arch, machine)
diff --git a/bfd/trad-core.c b/bfd/trad-core.c
index 7d17688..6538fba 100644
--- a/bfd/trad-core.c
+++ b/bfd/trad-core.c
@@ -205,7 +205,7 @@ trad_unix_core_file_p (bfd *abfd)
      0 is at the place pointed to by u_ar0 (by setting the vma of the start
      of the section to -u_ar0).  GDB uses this info to locate the regs,
      using minor trickery to get around the offset-or-absolute-addr problem.  */
-  core_regsec (abfd)->vma = - (bfd_vma) (unsigned long) u.u_ar0;
+  core_regsec (abfd)->vma = - (bfd_vma) (unsigned long long) u.u_ar0;
 
   core_datasec (abfd)->filepos = NBPG * UPAGES;
   core_stacksec (abfd)->filepos = (NBPG * UPAGES) + NBPG * u.u_dsize
diff --git a/bfd/verilog.c b/bfd/verilog.c
index 64a7869..cad1377 100644
--- a/bfd/verilog.c
+++ b/bfd/verilog.c
@@ -92,7 +92,7 @@ typedef struct verilog_data_struct
 tdata_type;
 
 static bfd_boolean
-verilog_set_arch_mach (bfd *abfd, enum bfd_architecture arch, unsigned long mach)
+verilog_set_arch_mach (bfd *abfd, enum bfd_architecture arch, unsigned long long mach)
 {
   if (arch != bfd_arch_unknown)
     return bfd_default_set_arch_mach (abfd, arch, mach);
diff --git a/bfd/vms-alpha.c b/bfd/vms-alpha.c
index 11817cf..73e6194 100644
--- a/bfd/vms-alpha.c
+++ b/bfd/vms-alpha.c
@@ -501,7 +501,7 @@ _bfd_vms_slurp_eihd (bfd *abfd, unsigned int *eisd_offset,
   *eihs_offset = bfd_getl32 (eihd->symdbgoff);
 
   vms_debug2 ((4, "EIHD size %d imgtype %d symvva 0x%lx eisd %d eihs %d\n",
-	       size, imgtype, (unsigned long)symvva,
+	       size, imgtype, (unsigned long long)symvva,
 	       *eisd_offset, *eihs_offset));
 
   return TRUE;
@@ -562,7 +562,7 @@ _bfd_vms_slurp_eisd (bfd *abfd, unsigned int offset)
       vbn = bfd_getl32 (eisd->vbn);
 
       vms_debug2 ((4, "EISD at 0x%x size 0x%x addr 0x%lx flags 0x%x blk %d\n",
-		   offset, size, (unsigned long)vaddr, flags, vbn));
+		   offset, size, (unsigned long long)vaddr, flags, vbn));
 
       /* VMS combines psects from .obj files into isects in the .exe.  This
 	 process doesn't preserve enough information to reliably determine
@@ -1164,7 +1164,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)
   int gsd_type;
   unsigned int gsd_size;
   unsigned char *vms_rec;
-  unsigned long base_addr;
+  unsigned long long base_addr;
 
   vms_debug2 ((2, "EGSD\n"));
 
@@ -1228,7 +1228,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)
 	    else
 	      {
 		char *name;
-		unsigned long align_addr;
+		unsigned long long align_addr;
 
 		name = _bfd_vms_save_counted_string (&egps->namlng, gsd_size - 4);
 
@@ -1321,7 +1321,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)
 	    if (old_flags & EGSY__V_DEF)
 	      {
 		struct vms_esdf *esdf = (struct vms_esdf *)vms_rec;
-		long psindx;
+		long long psindx;
 
 		entry->value = bfd_getl64 (esdf->value);
 		if (PRIV (sections) == NULL)
@@ -1379,7 +1379,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)
 
 	    if (old_flags & EGSY__V_REL)
 	      {
-		long psindx;
+		long long psindx;
 
 		if (PRIV (sections) == NULL)
 		  return FALSE;
@@ -1441,7 +1441,7 @@ static void
 _bfd_vms_push (bfd *abfd, bfd_vma val, unsigned int reloc)
 {
   vms_debug2 ((4, "<push %08lx (0x%08x) at %d>\n",
-	       (unsigned long)val, reloc, PRIV (stackptr)));
+	       (unsigned long long)val, reloc, PRIV (stackptr)));
 
   PRIV (stack[PRIV (stackptr)]).value = val;
   PRIV (stack[PRIV (stackptr)]).reloc = reloc;
@@ -1469,7 +1469,7 @@ _bfd_vms_pop (bfd *abfd, bfd_vma *val, unsigned int *rel)
   *val = PRIV (stack[PRIV (stackptr)]).value;
   *rel = PRIV (stack[PRIV (stackptr)]).reloc;
 
-  vms_debug2 ((4, "<pop %08lx (0x%08x)>\n", (unsigned long)*val, *rel));
+  vms_debug2 ((4, "<pop %08lx (0x%08x)>\n", (unsigned long long)*val, *rel));
 }
 
 /* Routines to fill sections contents during tir/etir read.  */
@@ -1569,7 +1569,7 @@ image_write (bfd *abfd, unsigned char *ptr, unsigned int size)
 {
 #if VMS_DEBUG
   _bfd_vms_debug (8, "image_write from (%p, %d) to (%ld)\n", ptr, size,
-		  (long)PRIV (image_offset));
+		  (long long)PRIV (image_offset));
   _bfd_hexdump (9, ptr, size, 0);
 #endif
 
@@ -1624,7 +1624,7 @@ image_write_w (bfd * abfd, unsigned int value)
 /* Write 4-byte long to image.  */
 
 static bfd_boolean
-image_write_l (bfd * abfd, unsigned long value)
+image_write_l (bfd * abfd, unsigned long long value)
 {
   unsigned char data[4];
 
@@ -1641,7 +1641,7 @@ image_write_q (bfd * abfd, bfd_vma value)
 {
   unsigned char data[8];
 
-  vms_debug2 ((6, "image_write_q (%08lx)\n", (unsigned long)value));
+  vms_debug2 ((6, "image_write_q (%08lx)\n", (unsigned long long)value));
 
   bfd_putl64 (value, data);
   return image_write (abfd, data, sizeof (data));
@@ -2532,7 +2532,7 @@ _bfd_vms_slurp_object_records (bfd * abfd)
 
   do
     {
-      vms_debug2 ((7, "reading at %08lx\n", (unsigned long)bfd_tell (abfd)));
+      vms_debug2 ((7, "reading at %08lx\n", (unsigned long long)bfd_tell (abfd)));
 
       type = _bfd_vms_get_object_record (abfd);
       if (type < 0)
@@ -2845,9 +2845,9 @@ _bfd_vms_write_eeom (bfd *abfd)
 	  return FALSE;
 	}
       _bfd_vms_output_short (recwr, 0);
-      _bfd_vms_output_long (recwr, (unsigned long) section->target_index);
+      _bfd_vms_output_long (recwr, (unsigned long long) section->target_index);
       _bfd_vms_output_long (recwr,
-			     (unsigned long) bfd_get_start_address (abfd));
+			     (unsigned long long) bfd_get_start_address (abfd));
       _bfd_vms_output_long (recwr, 0);
     }
 
@@ -3466,12 +3466,12 @@ _bfd_vms_write_egsd (bfd *abfd)
 
       vms_debug2 ((3, "sec flags %x\n", section->flags));
       vms_debug2 ((3, "new_flags %x, _raw_size %lu\n",
-		   new_flags, (unsigned long)section->size));
+		   new_flags, (unsigned long long)section->size));
 
       _bfd_vms_output_begin_subrec (recwr, EGSD__C_PSC);
       _bfd_vms_output_short (recwr, section->alignment_power & 0xff);
       _bfd_vms_output_short (recwr, new_flags);
-      _bfd_vms_output_long (recwr, (unsigned long) section->size);
+      _bfd_vms_output_long (recwr, (unsigned long long) section->size);
       _bfd_vms_output_counted (recwr, sname);
       _bfd_vms_output_end_subrec (recwr);
 
@@ -3565,8 +3565,8 @@ _bfd_vms_write_egsd (bfd *abfd)
 	{
 	  /* Symbol definition.  */
 	  bfd_vma code_address = 0;
-	  unsigned long ca_psindx = 0;
-	  unsigned long psindx;
+	  unsigned long long ca_psindx = 0;
+	  unsigned long long psindx;
 
 	  if ((old_flags & BSF_FUNCTION) && symbol->udata.p != NULL)
 	    {
@@ -3682,7 +3682,7 @@ start_etir_or_etbt_record (bfd *abfd, asection *section, bfd_vma offset)
 	{
 	  /* Push start offset.  */
 	  _bfd_vms_output_begin_subrec (recwr, ETIR__C_STA_LW);
-	  _bfd_vms_output_long (recwr, (unsigned long) 0);
+	  _bfd_vms_output_long (recwr, (unsigned long long) 0);
 	  _bfd_vms_output_end_subrec (recwr);
 
 	  /* Set location.  */
@@ -3698,7 +3698,7 @@ start_etir_or_etbt_record (bfd *abfd, asection *section, bfd_vma offset)
 	{
 	  /* Push start offset.  */
 	  _bfd_vms_output_begin_subrec (recwr, ETIR__C_STA_PQ);
-	  _bfd_vms_output_long (recwr, (unsigned long) section->target_index);
+	  _bfd_vms_output_long (recwr, (unsigned long long) section->target_index);
 	  _bfd_vms_output_quad (recwr, offset);
 	  _bfd_vms_output_end_subrec (recwr);
 
@@ -3742,7 +3742,7 @@ sto_imm (bfd *abfd, asection *section,
 	}
 
       _bfd_vms_output_begin_subrec (recwr, ETIR__C_STO_IMM);
-      _bfd_vms_output_long (recwr, (unsigned long) (size));
+      _bfd_vms_output_long (recwr, (unsigned long long) (size));
       _bfd_vms_output_dump (recwr, cptr, size);
       _bfd_vms_output_end_subrec (recwr);
 
@@ -3842,9 +3842,9 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 				     "addr %08lx, off %08lx, len %d: %s\n",
 				  (*(*rptr)->sym_ptr_ptr)->name,
 				  (*(*rptr)->sym_ptr_ptr)->section->name,
-				  (long) (*(*rptr)->sym_ptr_ptr)->value,
-				  (unsigned long)(*rptr)->address,
-				  (unsigned long)(*rptr)->addend,
+				  (long long) (*(*rptr)->sym_ptr_ptr)->value,
+				  (unsigned long long)(*rptr)->address,
+				  (unsigned long long)(*rptr)->addend,
 				  bfd_get_reloc_size ((*rptr)->howto),
 				  ( *rptr)->howto->name);
 		  rptr++;
@@ -3907,7 +3907,7 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 			  _bfd_vms_output_counted (recwr, sym->name);
 			  _bfd_vms_output_end_subrec (recwr);
 			  _bfd_vms_output_begin_subrec (recwr, ETIR__C_STA_LW);
-			  _bfd_vms_output_long (recwr, (unsigned long) addend);
+			  _bfd_vms_output_long (recwr, (unsigned long long) addend);
 			  _bfd_vms_output_end_subrec (recwr);
 			  _bfd_vms_output_begin_subrec (recwr, ETIR__C_OPR_ADD);
 			  _bfd_vms_output_end_subrec (recwr);
@@ -3926,7 +3926,7 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 		    {
 		      etir_output_check (abfd, section, curr_addr, 16);
 		      _bfd_vms_output_begin_subrec (recwr, ETIR__C_STA_LW);
-		      _bfd_vms_output_long (recwr, (unsigned long) sym->value);
+		      _bfd_vms_output_long (recwr, (unsigned long long) sym->value);
 		      _bfd_vms_output_end_subrec (recwr);
 		      _bfd_vms_output_begin_subrec (recwr, ETIR__C_STO_LW);
 		      _bfd_vms_output_end_subrec (recwr);
@@ -3936,7 +3936,7 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 		      etir_output_check (abfd, section, curr_addr, 32);
 		      _bfd_vms_output_begin_subrec (recwr, ETIR__C_STA_PQ);
 		      _bfd_vms_output_long (recwr,
-					    (unsigned long) sec->target_index);
+					    (unsigned long long) sec->target_index);
 		      _bfd_vms_output_quad (recwr, rptr->addend + sym->value);
 		      _bfd_vms_output_end_subrec (recwr);
 		      /* ??? Table B-8 of the OpenVMS Linker Utilily Manual
@@ -3988,7 +3988,7 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 		      etir_output_check (abfd, section, curr_addr, 32);
 		      _bfd_vms_output_begin_subrec (recwr, ETIR__C_STA_PQ);
 		      _bfd_vms_output_long (recwr,
-					    (unsigned long) sec->target_index);
+					    (unsigned long long) sec->target_index);
 		      _bfd_vms_output_quad (recwr, rptr->addend + sym->value);
 		      _bfd_vms_output_end_subrec (recwr);
 		      _bfd_vms_output_begin_subrec (recwr, ETIR__C_STO_OFF);
@@ -4004,7 +4004,7 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 		  etir_output_check (abfd, section, curr_addr, 64);
 		  _bfd_vms_output_begin_subrec (recwr, ETIR__C_STC_LP_PSB);
 		  _bfd_vms_output_long
-		    (recwr, (unsigned long) rptr->addend);
+		    (recwr, (unsigned long long) rptr->addend);
 		  if (rptr->addend > PRIV (vms_linkage_index))
 		    PRIV (vms_linkage_index) = rptr->addend;
 		  _bfd_vms_output_counted (recwr, sym->name);
@@ -4026,13 +4026,13 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 		  etir_output_check (abfd, section, curr_addr,
 				     32 + 1 + strlen (udata->origname));
 		  _bfd_vms_output_begin_subrec (recwr, ETIR__C_STC_NOP_GBL);
-		  _bfd_vms_output_long (recwr, (unsigned long) udata->lkindex);
+		  _bfd_vms_output_long (recwr, (unsigned long long) udata->lkindex);
 		  _bfd_vms_output_long
-		    (recwr, (unsigned long) section->target_index);
+		    (recwr, (unsigned long long) section->target_index);
 		  _bfd_vms_output_quad (recwr, rptr->address);
-		  _bfd_vms_output_long (recwr, (unsigned long) 0x47ff041f);
+		  _bfd_vms_output_long (recwr, (unsigned long long) 0x47ff041f);
 		  _bfd_vms_output_long
-		    (recwr, (unsigned long) section->target_index);
+		    (recwr, (unsigned long long) section->target_index);
 		  _bfd_vms_output_quad (recwr, rptr->addend);
 		  _bfd_vms_output_counted (recwr, udata->origname);
 		  _bfd_vms_output_end_subrec (recwr);
@@ -4049,13 +4049,13 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 				     32 + 1 + strlen (udata->origname));
 		  _bfd_vms_output_begin_subrec (recwr, ETIR__C_STC_LDA_GBL);
 		  _bfd_vms_output_long
-		    (recwr, (unsigned long) udata->lkindex + 1);
+		    (recwr, (unsigned long long) udata->lkindex + 1);
 		  _bfd_vms_output_long
-		    (recwr, (unsigned long) section->target_index);
+		    (recwr, (unsigned long long) section->target_index);
 		  _bfd_vms_output_quad (recwr, rptr->address);
-		  _bfd_vms_output_long (recwr, (unsigned long) 0x237B0000);
+		  _bfd_vms_output_long (recwr, (unsigned long long) 0x237B0000);
 		  _bfd_vms_output_long
-		    (recwr, (unsigned long) udata->bsym->section->target_index);
+		    (recwr, (unsigned long long) udata->bsym->section->target_index);
 		  _bfd_vms_output_quad (recwr, rptr->addend);
 		  _bfd_vms_output_counted (recwr, udata->origname);
 		  _bfd_vms_output_end_subrec (recwr);
@@ -4067,13 +4067,13 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 		  etir_output_check (abfd, section, curr_addr,
 				       32 + 1 + strlen (udata->origname));
 		  _bfd_vms_output_begin_subrec (recwr, ETIR__C_STC_BOH_GBL);
-		  _bfd_vms_output_long (recwr, (unsigned long) udata->lkindex);
+		  _bfd_vms_output_long (recwr, (unsigned long long) udata->lkindex);
 		  _bfd_vms_output_long
-		    (recwr, (unsigned long) section->target_index);
+		    (recwr, (unsigned long long) section->target_index);
 		  _bfd_vms_output_quad (recwr, rptr->address);
-		  _bfd_vms_output_long (recwr, (unsigned long) 0xD3400000);
+		  _bfd_vms_output_long (recwr, (unsigned long long) 0xD3400000);
 		  _bfd_vms_output_long
-		    (recwr, (unsigned long) section->target_index);
+		    (recwr, (unsigned long long) section->target_index);
 		  _bfd_vms_output_quad (recwr, rptr->addend);
 		  _bfd_vms_output_counted (recwr, udata->origname);
 		  _bfd_vms_output_end_subrec (recwr);
@@ -4225,7 +4225,7 @@ parse_module (bfd *abfd, struct module *module, unsigned char *ptr,
 	  module->func_table = funcinfo;
 
 	  vms_debug2 ((3, "routine: %s at 0x%lx\n",
-		       funcinfo->name, (unsigned long) funcinfo->low));
+		       funcinfo->name, (unsigned long long) funcinfo->low));
 	  break;
 
 	case DST__K_RTNEND:
@@ -4542,7 +4542,7 @@ parse_module (bfd *abfd, struct module *module, unsigned char *ptr,
 		      curr_linenum += 1;
 		      cmd_length = 1;
 		      vms_debug2 ((4, "bump pc to 0x%lx and line to %d\n",
-				   (unsigned long)curr_pc, curr_linenum));
+				   (unsigned long long)curr_pc, curr_linenum));
 		    }
 		  else
 		    {
@@ -4568,7 +4568,7 @@ parse_module (bfd *abfd, struct module *module, unsigned char *ptr,
 		  prev_linum = curr_linenum;
 		  prev_pc = curr_pc;
 		  vms_debug2 ((4, "-> correlate pc 0x%lx with line %d\n",
-			       (unsigned long)curr_pc, curr_linenum));
+			       (unsigned long long)curr_pc, curr_linenum));
 		}
 
 	      pcl_ptr += cmd_length;
@@ -4874,7 +4874,7 @@ alpha_vms_convert_symbol (bfd *abfd, struct vms_symbol_entry *e, asymbol *sym)
    terminal NULL pointer. If there are no symbols in the BFD,
    then return 0.  If an error occurs, return -1.  */
 
-static long
+static long long
 alpha_vms_get_symtab_upper_bound (bfd *abfd)
 {
   vms_debug2 ((1, "alpha_vms_get_symtab_upper_bound (%p), %d symbols\n",
@@ -4888,7 +4888,7 @@ alpha_vms_get_symtab_upper_bound (bfd *abfd)
 
    Return number of symbols read.   */
 
-static long
+static long long
 alpha_vms_canonicalize_symtab (bfd *abfd, asymbol **symbols)
 {
   unsigned int i;
@@ -5254,7 +5254,7 @@ alpha_vms_slurp_relocs (bfd *abfd)
 /* Return the number of bytes required to store the relocation
    information associated with the given section.  */
 
-static long
+static long long
 alpha_vms_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *section)
 {
   alpha_vms_slurp_relocs (abfd);
@@ -5265,7 +5265,7 @@ alpha_vms_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *section)
 /* Convert relocations from VMS (external) form into BFD internal
    form.  Return the number of relocations.  */
 
-static long
+static long long
 alpha_vms_canonicalize_reloc (bfd *abfd, asection *section, arelent **relptr,
 			      asymbol **symbols ATTRIBUTE_UNUSED)
 {
@@ -5309,8 +5309,8 @@ reloc_nil (bfd * abfd ATTRIBUTE_UNUSED,
 	sec->name, sym->name);
   vms_debug (2, "reloc sym %s, addr %08lx, addend %08lx, reloc is a %s\n",
 		reloc->sym_ptr_ptr[0]->name,
-		(unsigned long)reloc->address,
-		(unsigned long)reloc->addend, reloc->howto->name);
+		(unsigned long long)reloc->address,
+		(unsigned long long)reloc->addend, reloc->howto->name);
   vms_debug (2, "data at %p\n", data);
   /*  _bfd_hexdump (2, data, bfd_get_reloc_size (reloc->howto), 0); */
 #endif
@@ -5650,11 +5650,11 @@ alpha_vms_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
   return NULL;
 }
 
-static long
+static long long
 alpha_vms_get_synthetic_symtab (bfd *abfd,
-				long symcount ATTRIBUTE_UNUSED,
+				long long symcount ATTRIBUTE_UNUSED,
 				asymbol **usyms ATTRIBUTE_UNUSED,
-				long dynsymcount ATTRIBUTE_UNUSED,
+				long long dynsymcount ATTRIBUTE_UNUSED,
 				asymbol **dynsyms ATTRIBUTE_UNUSED,
 				asymbol **ret)
 {
@@ -9465,7 +9465,7 @@ _bfd_vms_set_section_contents (bfd * abfd,
 
 static bfd_boolean
 alpha_vms_set_arch_mach (bfd *abfd,
-			 enum bfd_architecture arch, unsigned long mach)
+			 enum bfd_architecture arch, unsigned long long mach)
 {
   if (arch != bfd_arch_alpha
       && arch != bfd_arch_unknown)
diff --git a/bfd/vms-lib.c b/bfd/vms-lib.c
index a31cadd..0fa0807 100644
--- a/bfd/vms-lib.c
+++ b/bfd/vms-lib.c
@@ -1937,7 +1937,7 @@ _bfd_vms_lib_build_map (unsigned int nbr_modules,
 {
   unsigned int i;
   asymbol **syms = NULL;
-  long syms_max = 0;
+  long long syms_max = 0;
   struct lib_index *map = NULL;
   unsigned int map_max = 1024;		/* Fine initial default.  */
   unsigned int map_count = 0;
@@ -1949,9 +1949,9 @@ _bfd_vms_lib_build_map (unsigned int nbr_modules,
   /* Gather symbols.  */
   for (i = 0; i < nbr_modules; i++)
     {
-      long storage;
-      long symcount;
-      long src_count;
+      long long storage;
+      long long symcount;
+      long long src_count;
       bfd *current = modules[i].abfd;
 
       if ((bfd_get_file_flags (current) & HAS_SYMS) == 0)
diff --git a/bfd/vms-misc.c b/bfd/vms-misc.c
index 390cb96..73e0a1d 100644
--- a/bfd/vms-misc.c
+++ b/bfd/vms-misc.c
@@ -101,7 +101,7 @@ _bfd_hexdump (int level, unsigned char *ptr, int size, int offset)
 {
   unsigned char *lptr = ptr;
   int count = 0;
-  long start = offset;
+  long long start = offset;
 
   while (size-- > 0)
     {
@@ -327,7 +327,7 @@ _bfd_vms_output_short (struct vms_rec_wr *recwr, unsigned int value)
 /* Output long (32 bit) value.  */
 
 void
-_bfd_vms_output_long (struct vms_rec_wr *recwr, unsigned long value)
+_bfd_vms_output_long (struct vms_rec_wr *recwr, unsigned long long value)
 {
   vms_debug2 ((6, "_bfd_vms_output_long (%08lx)\n", value));
 
@@ -340,7 +340,7 @@ _bfd_vms_output_long (struct vms_rec_wr *recwr, unsigned long value)
 void
 _bfd_vms_output_quad (struct vms_rec_wr *recwr, bfd_vma value)
 {
-  vms_debug2 ((6, "_bfd_vms_output_quad (%08lx)\n", (unsigned long)value));
+  vms_debug2 ((6, "_bfd_vms_output_quad (%08lx)\n", (unsigned long long)value));
 
   bfd_putl64 (value, recwr->buf + recwr->size);
   recwr->size += 8;
diff --git a/bfd/vms.h b/bfd/vms.h
index 24572b4..900f89c 100644
--- a/bfd/vms.h
+++ b/bfd/vms.h
@@ -128,7 +128,7 @@ extern void   _bfd_vms_output_end (bfd *, struct vms_rec_wr *);
 extern int    _bfd_vms_output_check (struct vms_rec_wr *, int);
 extern void   _bfd_vms_output_byte (struct vms_rec_wr *, unsigned);
 extern void   _bfd_vms_output_short (struct vms_rec_wr *, unsigned);
-extern void   _bfd_vms_output_long (struct vms_rec_wr *, unsigned long);
+extern void   _bfd_vms_output_long (struct vms_rec_wr *, unsigned long long);
 extern void   _bfd_vms_output_quad (struct vms_rec_wr *, bfd_vma);
 extern void   _bfd_vms_output_counted (struct vms_rec_wr *, const char *);
 extern void   _bfd_vms_output_dump (struct vms_rec_wr *, const unsigned char *, int);
diff --git a/bfd/wasm-module.c b/bfd/wasm-module.c
index 6806e0f..b8b55c8 100644
--- a/bfd/wasm-module.c
+++ b/bfd/wasm-module.c
@@ -678,7 +678,7 @@ wasm_mkobject (bfd *abfd)
   return TRUE;
 }
 
-static long
+static long long
 wasm_get_symtab_upper_bound (bfd *abfd)
 {
   tdata_type *tdata = abfd->tdata.any;
@@ -686,7 +686,7 @@ wasm_get_symtab_upper_bound (bfd *abfd)
   return (tdata->symcount + 1) * (sizeof (asymbol *));
 }
 
-static long
+static long long
 wasm_canonicalize_symtab (bfd *abfd, asymbol **alocation)
 {
   tdata_type *tdata = abfd->tdata.any;
diff --git a/bfd/xcofflink.c b/bfd/xcofflink.c
index ac95390..7e0eb8c 100644
--- a/bfd/xcofflink.c
+++ b/bfd/xcofflink.c
@@ -130,7 +130,7 @@ struct xcoff_link_hash_table
   struct xcoff_import_file *imports;
 
   /* Required alignment of sections within the output file.  */
-  unsigned long file_align;
+  unsigned long long file_align;
 
   /* Whether the .text section must be read-only.  */
   bfd_boolean textro;
@@ -171,11 +171,11 @@ struct xcoff_final_link_info
      target_index field.  */
   struct xcoff_link_section_info *section_info;
   /* Symbol index of last C_FILE symbol (-1 if none).  */
-  long last_file_index;
+  long long last_file_index;
   /* Contents of last C_FILE symbol.  */
   struct internal_syment last_file;
   /* Symbol index of TOC symbol.  */
-  long toc_symindx;
+  long long toc_symindx;
   /* Start of .loader symbols.  */
   bfd_byte *ldsym;
   /* Next .loader reloc to swap out.  */
@@ -186,7 +186,7 @@ struct xcoff_final_link_info
   struct internal_syment *internal_syms;
   /* Buffer large enough to hold output indices of symbols of any
      input file.  */
-  long *sym_indices;
+  long long *sym_indices;
   /* Buffer large enough to hold output symbols for any input file.  */
   bfd_byte *outsyms;
   /* Buffer large enough to hold external line numbers for any input
@@ -238,7 +238,7 @@ xcoff_get_section_contents (bfd *abfd, asection *sec)
 
 /* Get the size required to hold the dynamic symbols.  */
 
-long
+long long
 _bfd_xcoff_get_dynamic_symtab_upper_bound (bfd *abfd)
 {
   asection *lsec;
@@ -269,7 +269,7 @@ _bfd_xcoff_get_dynamic_symtab_upper_bound (bfd *abfd)
 
 /* Get the dynamic symbols.  */
 
-long
+long long
 _bfd_xcoff_canonicalize_dynamic_symtab (bfd *abfd, asymbol **psyms)
 {
   asection *lsec;
@@ -359,7 +359,7 @@ _bfd_xcoff_canonicalize_dynamic_symtab (bfd *abfd, asymbol **psyms)
 
 /* Get the size required to hold the dynamic relocs.  */
 
-long
+long long
 _bfd_xcoff_get_dynamic_reloc_upper_bound (bfd *abfd)
 {
   asection *lsec;
@@ -390,7 +390,7 @@ _bfd_xcoff_get_dynamic_reloc_upper_bound (bfd *abfd)
 
 /* Get the dynamic relocs.  */
 
-long
+long long
 _bfd_xcoff_canonicalize_dynamic_reloc (bfd *abfd,
 				       arelent **prelocs,
 				       asymbol **syms)
@@ -2916,7 +2916,7 @@ xcoff_mark (struct bfd_link_info *info, asection *sec)
       struct xcoff_link_hash_entry **syms;
       struct internal_reloc *rel, *relend;
       asection **csects;
-      unsigned long i, first, last;
+      unsigned long long i, first, last;
 
       /* Mark all the symbols in this section.  */
       syms = obj_xcoff_sym_hashes (sec->owner);
@@ -3626,9 +3626,9 @@ bfd_xcoff_size_dynamic_sections (bfd *output_bfd,
 				 struct bfd_link_info *info,
 				 const char *libpath,
 				 const char *entry,
-				 unsigned long file_align,
-				 unsigned long maxstack,
-				 unsigned long maxdata,
+				 unsigned long long file_align,
+				 unsigned long long maxstack,
+				 unsigned long long maxdata,
 				 bfd_boolean gc,
 				 int modtype,
 				 bfd_boolean textro,
@@ -3826,7 +3826,7 @@ bfd_xcoff_size_dynamic_sections (bfd *output_bfd,
     {
       asection *subdeb;
       bfd_size_type symcount;
-      long *debug_index;
+      long long *debug_index;
       asection **csectpp;
       unsigned int *lineno_counts;
       struct xcoff_link_hash_entry **sym_hash;
@@ -3844,7 +3844,7 @@ bfd_xcoff_size_dynamic_sections (bfd *output_bfd,
 	goto error_return;
 
       symcount = obj_raw_syment_count (sub);
-      debug_index = bfd_zalloc (sub, symcount * sizeof (long));
+      debug_index = bfd_zalloc (sub, symcount * sizeof (long long));
       if (debug_index == NULL)
 	goto error_return;
       xcoff_data (sub)->debug_indices = debug_index;
@@ -4121,9 +4121,9 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
   struct internal_syment *isymp;
   asection **csectpp;
   unsigned int *lineno_counts;
-  long *debug_index;
-  long *indexp;
-  unsigned long output_index;
+  long long *debug_index;
+  long long *indexp;
+  unsigned long long output_index;
   bfd_byte *outsym;
   unsigned int incls;
   asection *oline;
@@ -4452,7 +4452,7 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 	      indx = isym.n_value;
 	      if (indx < obj_raw_syment_count (input_bfd))
 		{
-		  long symindx;
+		  long long symindx;
 
 		  symindx = flinfo->sym_indices[indx];
 		  if (symindx < 0)
@@ -4529,12 +4529,12 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 
 		  if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_LD)
 		    {
-		      unsigned long indx;
+		      unsigned long long indx;
 
 		      indx = aux.x_csect.x_scnlen.l;
 		      if (indx < obj_raw_syment_count (input_bfd))
 			{
-			  long symindx;
+			  long long symindx;
 
 			  symindx = flinfo->sym_indices[indx];
 			  if (symindx < 0)
@@ -4550,7 +4550,7 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 		}
 	      else if (isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
 		{
-		  unsigned long indx;
+		  unsigned long long indx;
 
 		  if (ISFCN (isymp->n_type)
 		      || ISTAG (isymp->n_sclass)
@@ -4580,7 +4580,7 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 		  indx = aux.x_sym.x_tagndx.l;
 		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
 		    {
-		      long symindx;
+		      long long symindx;
 
 		      symindx = flinfo->sym_indices[indx];
 		      if (symindx < 0)
@@ -4668,7 +4668,7 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 		      if (incls > 0)
 			{
 			  struct internal_syment *iisp, *iispend;
-			  long *iindp;
+			  long long *iindp;
 			  bfd_byte *oos;
 			  bfd_vma range_start, range_end;
 			  int iiadd;
@@ -4796,7 +4796,7 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 	  bfd_vma offset;
 	  struct internal_reloc *irelend;
 	  struct xcoff_link_hash_entry **rel_hash;
-	  long r_symndx;
+	  long long r_symndx;
 
 	  /* Read in the relocs.  */
 	  target_index = o->output_section->target_index;
@@ -4895,7 +4895,7 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 		    }
 		  else
 		    {
-		      long indx;
+		      long long indx;
 
 		      indx = flinfo->sym_indices[r_symndx];
 
@@ -6137,7 +6137,7 @@ _bfd_xcoff_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
   amt = max_sym_count * sizeof (struct internal_syment);
   flinfo.internal_syms = bfd_malloc (amt);
 
-  amt = max_sym_count * sizeof (long);
+  amt = max_sym_count * sizeof (long long);
   flinfo.sym_indices = bfd_malloc (amt);
 
   amt = (max_sym_count + 1) * symesz;
diff --git a/bfd/xsym.c b/bfd/xsym.c
index 56607f0..1ce3deb 100644
--- a/bfd/xsym.c
+++ b/bfd/xsym.c
@@ -86,15 +86,15 @@ pstrcmp (const char *as, const char *bs)
     return 1;
 }
 
-static unsigned long
-compute_offset (unsigned long first_page,
-		unsigned long page_size,
-		unsigned long entry_size,
-		unsigned long sym_index)
+static unsigned long long
+compute_offset (unsigned long long first_page,
+		unsigned long long page_size,
+		unsigned long long entry_size,
+		unsigned long long sym_index)
 {
-  unsigned long entries_per_page = page_size / entry_size;
-  unsigned long page_number = first_page + (sym_index / entries_per_page);
-  unsigned long page_offset = (sym_index % entries_per_page) * entry_size;
+  unsigned long long entries_per_page = page_size / entry_size;
+  unsigned long long page_number = first_page + (sym_index / entries_per_page);
+  unsigned long long page_offset = (sym_index % entries_per_page) * entry_size;
 
   return (page_number * page_size) + page_offset;
 }
@@ -127,7 +127,7 @@ unsigned char *
 bfd_sym_read_name_table (bfd *abfd, bfd_sym_header_block *dshb)
 {
   unsigned char *rstr;
-  long ret;
+  long long ret;
   size_t table_size = dshb->dshb_nte.dti_page_count * dshb->dshb_page_size;
   size_t table_offset = dshb->dshb_nte.dti_first_page * dshb->dshb_page_size;
 
@@ -137,7 +137,7 @@ bfd_sym_read_name_table (bfd *abfd, bfd_sym_header_block *dshb)
 
   bfd_seek (abfd, table_offset, SEEK_SET);
   ret = bfd_bread (rstr, table_size, abfd);
-  if (ret < 0 || (unsigned long) ret != table_size)
+  if (ret < 0 || (unsigned long long) ret != table_size)
     {
       bfd_release (abfd, rstr);
       return NULL;
@@ -204,7 +204,7 @@ int
 bfd_sym_read_header_v32 (bfd *abfd, bfd_sym_header_block *header)
 {
   unsigned char buf[154];
-  long ret;
+  long long ret;
 
   ret = bfd_bread (buf, 154, abfd);
   if (ret != 154)
@@ -245,7 +245,7 @@ int
 bfd_sym_read_version (bfd *abfd, bfd_sym_version *version)
 {
   char version_string[32];
-  long ret;
+  long long ret;
 
   ret = bfd_bread (version_string, sizeof (version_string), abfd);
   if (ret != sizeof (version_string))
@@ -536,11 +536,11 @@ bfd_sym_parse_type_table_entry_v32 (unsigned char *buf,
 int
 bfd_sym_fetch_resources_table_entry (bfd *abfd,
 				     bfd_sym_resources_table_entry *entry,
-				     unsigned long sym_index)
+				     unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_resources_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size;
+  unsigned long long offset;
+  unsigned long long entry_size;
   unsigned char buf[18];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -587,11 +587,11 @@ bfd_sym_fetch_resources_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_modules_table_entry (bfd *abfd,
 				   bfd_sym_modules_table_entry *entry,
-				   unsigned long sym_index)
+				   unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_modules_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size;
+  unsigned long long offset;
+  unsigned long long entry_size;
   unsigned char buf[46];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -638,11 +638,11 @@ bfd_sym_fetch_modules_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_file_references_table_entry (bfd *abfd,
 					   bfd_sym_file_references_table_entry *entry,
-					   unsigned long sym_index)
+					   unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_file_references_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[8];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -688,11 +688,11 @@ bfd_sym_fetch_file_references_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_contained_modules_table_entry (bfd *abfd,
 					     bfd_sym_contained_modules_table_entry *entry,
-					     unsigned long sym_index)
+					     unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_contained_modules_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[6];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -738,11 +738,11 @@ bfd_sym_fetch_contained_modules_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_contained_variables_table_entry (bfd *abfd,
 					       bfd_sym_contained_variables_table_entry *entry,
-					       unsigned long sym_index)
+					       unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_contained_variables_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[26];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -788,11 +788,11 @@ bfd_sym_fetch_contained_variables_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_contained_statements_table_entry (bfd *abfd,
 						bfd_sym_contained_statements_table_entry *entry,
-						unsigned long sym_index)
+						unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_contained_statements_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[8];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -838,11 +838,11 @@ bfd_sym_fetch_contained_statements_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_contained_labels_table_entry (bfd *abfd,
 					    bfd_sym_contained_labels_table_entry *entry,
-					    unsigned long sym_index)
+					    unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_contained_labels_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[12];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -888,11 +888,11 @@ bfd_sym_fetch_contained_labels_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_contained_types_table_entry (bfd *abfd,
 					   bfd_sym_contained_types_table_entry *entry,
-					   unsigned long sym_index)
+					   unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_contained_types_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[0];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -938,11 +938,11 @@ bfd_sym_fetch_contained_types_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_file_references_index_table_entry (bfd *abfd,
 						 bfd_sym_file_references_index_table_entry *entry,
-						 unsigned long sym_index)
+						 unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_file_references_index_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[0];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -988,11 +988,11 @@ bfd_sym_fetch_file_references_index_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_constant_pool_entry (bfd *abfd,
 				   bfd_sym_constant_pool_entry *entry,
-				   unsigned long sym_index)
+				   unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_constant_pool_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[0];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -1038,11 +1038,11 @@ bfd_sym_fetch_constant_pool_entry (bfd *abfd,
 int
 bfd_sym_fetch_type_table_entry (bfd *abfd,
 				bfd_sym_type_table_entry *entry,
-				unsigned long sym_index)
+				unsigned long long sym_index)
 {
   void (*parser) (unsigned char *, size_t, bfd_sym_type_table_entry *);
-  unsigned long offset;
-  unsigned long entry_size = 0;
+  unsigned long long offset;
+  unsigned long long entry_size = 0;
   unsigned char buf[4];
   bfd_sym_data_struct *sdata = NULL;
 
@@ -1085,7 +1085,7 @@ bfd_sym_fetch_type_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_type_information_table_entry (bfd *abfd,
 					    bfd_sym_type_information_table_entry *entry,
-					    unsigned long offset)
+					    unsigned long long offset)
 {
   unsigned char buf[4];
 
@@ -1128,7 +1128,7 @@ bfd_sym_fetch_type_information_table_entry (bfd *abfd,
 int
 bfd_sym_fetch_type_table_information (bfd *abfd,
 				      bfd_sym_type_information_table_entry *entry,
-				      unsigned long sym_index)
+				      unsigned long long sym_index)
 {
   bfd_sym_type_table_entry tindex;
   bfd_sym_data_struct *sdata = NULL;
@@ -1150,7 +1150,7 @@ bfd_sym_fetch_type_table_information (bfd *abfd,
 }
 
 const unsigned char *
-bfd_sym_symbol_name (bfd *abfd, unsigned long sym_index)
+bfd_sym_symbol_name (bfd *abfd, unsigned long long sym_index)
 {
   bfd_sym_data_struct *sdata = NULL;
 
@@ -1169,7 +1169,7 @@ bfd_sym_symbol_name (bfd *abfd, unsigned long sym_index)
 }
 
 const unsigned char *
-bfd_sym_module_name (bfd *abfd, unsigned long sym_index)
+bfd_sym_module_name (bfd *abfd, unsigned long long sym_index)
 {
   bfd_sym_modules_table_entry entry;
 
@@ -1400,7 +1400,7 @@ bfd_sym_print_contained_variables_table_entry (bfd *abfd,
 	     entry->entry.address.scstruct.sca_offset);
   else if (entry->entry.la_size <= BFD_SYM_CVTE_LA_MAX_SIZE)
     {
-      unsigned long i;
+      unsigned long long i;
 
       fprintf (f, ", la [");
       for (i = 0; i < entry->entry.la_size; i++)
@@ -1529,10 +1529,10 @@ bfd_sym_type_basic_name (unsigned char num)
 
 int
 bfd_sym_fetch_long (unsigned char *buf,
-		    unsigned long len,
-		    unsigned long offset,
-		    unsigned long *offsetptr,
-		    long *value)
+		    unsigned long long len,
+		    unsigned long long offset,
+		    unsigned long long *offsetptr,
+		    long long *value)
 {
   int ret;
 
@@ -1597,9 +1597,9 @@ void
 bfd_sym_print_type_information (bfd *abfd,
 				FILE *f,
 				unsigned char *buf,
-				unsigned long len,
-				unsigned long offset,
-				unsigned long *offsetptr)
+				unsigned long long len,
+				unsigned long long offset,
+				unsigned long long *offsetptr)
 {
   unsigned int type;
 
@@ -1633,7 +1633,7 @@ bfd_sym_print_type_information (bfd *abfd,
     {
     case 1:
       {
-	long value;
+	long long value;
 	bfd_sym_type_information_table_entry tinfo;
 
 	bfd_sym_fetch_long (buf, len, offset, &offset, &value);
@@ -1648,7 +1648,7 @@ bfd_sym_print_type_information (bfd *abfd,
 		       bfd_sym_symbol_name (abfd, tinfo.nte_index)[0],
 		       &bfd_sym_symbol_name (abfd, tinfo.nte_index)[1]);
 	  }
-	fprintf (f, " (TTE %lu)", (unsigned long) value);
+	fprintf (f, " (TTE %lu)", (unsigned long long) value);
 	break;
       }
 
@@ -1659,18 +1659,18 @@ bfd_sym_print_type_information (bfd *abfd,
 
     case 3:
       {
-	long value;
+	long long value;
 
 	fprintf (f, "scalar (0x%x) of ", type);
 	bfd_sym_print_type_information (abfd, f, buf, len, offset, &offset);
 	bfd_sym_fetch_long (buf, len, offset, &offset, &value);
-	fprintf (f, " (%lu)", (unsigned long) value);
+	fprintf (f, " (%lu)", (unsigned long long) value);
 	break;
       }
 
     case 5:
       {
-	long lower, upper, nelem;
+	long long lower, upper, nelem;
 	int i;
 
 	fprintf (f, "enumeration (0x%x) of ", type);
@@ -1679,8 +1679,8 @@ bfd_sym_print_type_information (bfd *abfd,
 	bfd_sym_fetch_long (buf, len, offset, &offset, &upper);
 	bfd_sym_fetch_long (buf, len, offset, &offset, &nelem);
 	fprintf (f, " from %lu to %lu with %lu elements: ",
-		 (unsigned long) lower, (unsigned long) upper,
-		 (unsigned long) nelem);
+		 (unsigned long long) lower, (unsigned long long) upper,
+		 (unsigned long long) nelem);
 
 	for (i = 0; i < nelem; i++)
 	  {
@@ -1701,7 +1701,7 @@ bfd_sym_print_type_information (bfd *abfd,
     case 7:
     case 8:
       {
-	long nrec, eloff, i;
+	long long nrec, eloff, i;
 
 	if ((type & 0x3f) == 7)
 	  fprintf (f, "record (0x%x) of ", type);
@@ -1709,13 +1709,13 @@ bfd_sym_print_type_information (bfd *abfd,
 	  fprintf (f, "union (0x%x) of ", type);
 
 	bfd_sym_fetch_long (buf, len, offset, &offset, &nrec);
-	fprintf (f, "%lu elements: ", (unsigned long) nrec);
+	fprintf (f, "%lu elements: ", (unsigned long long) nrec);
 
 	for (i = 0; i < nrec; i++)
 	  {
 	    bfd_sym_fetch_long (buf, len, offset, &offset, &eloff);
 	    fprintf (f, "\n                ");
-	    fprintf (f, "offset %lu: ", (unsigned long) eloff);
+	    fprintf (f, "offset %lu: ", (unsigned long long) eloff);
 	    bfd_sym_print_type_information (abfd, f, buf, len, offset, &offset);
 	  }
 	break;
@@ -1732,7 +1732,7 @@ bfd_sym_print_type_information (bfd *abfd,
 
   case 11:
     {
-      long value;
+      long long value;
 
       fprintf (f, "named type (0x%x) ", type);
       bfd_sym_fetch_long (buf, len, offset, &offset, &value);
@@ -1743,7 +1743,7 @@ bfd_sym_print_type_information (bfd *abfd,
 		 bfd_sym_symbol_name (abfd, value)[0],
 		 &bfd_sym_symbol_name (abfd, value)[1]);
 
-      fprintf (f, " (NTE %lu) with type ", (unsigned long) value);
+      fprintf (f, " (NTE %lu) with type ", (unsigned long long) value);
       bfd_sym_print_type_information (abfd, f, buf, len, offset, &offset);
       break;
     }
@@ -1756,9 +1756,9 @@ bfd_sym_print_type_information (bfd *abfd,
   if (type == (0x40 | 0x6))
     {
       /* Vector.  */
-      long n, width, m;
-      long l;
-      long i;
+      long long n, width, m;
+      long long l;
+      long long i;
 
       bfd_sym_fetch_long (buf, len, offset, &offset, &n);
       bfd_sym_fetch_long (buf, len, offset, &offset, &width);
@@ -1776,7 +1776,7 @@ bfd_sym_print_type_information (bfd *abfd,
   else  if (type & 0x40)
     {
       /* Other packed type.  */
-      long msb, lsb;
+      long long msb, lsb;
 
       bfd_sym_fetch_long (buf, len, offset, &offset, &msb);
       bfd_sym_fetch_long (buf, len, offset, &offset, &lsb);
@@ -1796,7 +1796,7 @@ bfd_sym_print_type_information_table_entry (bfd *abfd,
 					    bfd_sym_type_information_table_entry *entry)
 {
   unsigned char *buf;
-  unsigned long offset;
+  unsigned long long offset;
   unsigned int i;
 
   fprintf (f, "\"%.*s\" (NTE %lu), %lu bytes at %lu, logical size %lu",
@@ -1866,8 +1866,8 @@ bfd_sym_display_name_table_entry (bfd *abfd,
 				  FILE *f,
 				  unsigned char *entry)
 {
-  unsigned long sym_index;
-  unsigned long offset;
+  unsigned long long sym_index;
+  unsigned long long offset;
   bfd_sym_data_struct *sdata = NULL;
 
   BFD_ASSERT (bfd_sym_valid (abfd));
@@ -1897,7 +1897,7 @@ bfd_sym_display_name_table_entry (bfd *abfd,
 void
 bfd_sym_display_name_table (bfd *abfd, FILE *f)
 {
-  unsigned long name_table_len;
+  unsigned long long name_table_len;
   unsigned char *name_table, *name_table_end, *cur;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -1922,7 +1922,7 @@ bfd_sym_display_name_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_resources_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_resources_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -1948,7 +1948,7 @@ bfd_sym_display_resources_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_modules_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_modules_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -1974,7 +1974,7 @@ bfd_sym_display_modules_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_file_references_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_file_references_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -2000,7 +2000,7 @@ bfd_sym_display_file_references_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_contained_modules_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_contained_modules_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -2026,7 +2026,7 @@ bfd_sym_display_contained_modules_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_contained_variables_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_contained_variables_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -2054,7 +2054,7 @@ bfd_sym_display_contained_variables_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_contained_statements_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_contained_statements_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -2080,7 +2080,7 @@ bfd_sym_display_contained_statements_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_contained_labels_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_contained_labels_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -2106,7 +2106,7 @@ bfd_sym_display_contained_labels_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_contained_types_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_contained_types_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -2132,7 +2132,7 @@ bfd_sym_display_contained_types_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_file_references_index_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_file_references_index_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -2158,7 +2158,7 @@ bfd_sym_display_file_references_index_table (bfd *abfd, FILE *f)
 void
 bfd_sym_display_constant_pool (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_constant_pool_entry entry;
   bfd_sym_data_struct *sdata = NULL;
 
@@ -2184,7 +2184,7 @@ bfd_sym_display_constant_pool (bfd *abfd, FILE *f)
 void
 bfd_sym_display_type_information_table (bfd *abfd, FILE *f)
 {
-  unsigned long i;
+  unsigned long long i;
   bfd_sym_type_table_entry sym_index;
   bfd_sym_type_information_table_entry entry;
   bfd_sym_data_struct *sdata = NULL;
@@ -2286,13 +2286,13 @@ bfd_sym_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED, asymbol *symbol, symbol_inf
   bfd_symbol_info (symbol, ret);
 }
 
-long
+long long
 bfd_sym_get_symtab_upper_bound (bfd *abfd ATTRIBUTE_UNUSED)
 {
   return 0;
 }
 
-long
+long long
 bfd_sym_canonicalize_symtab (bfd *abfd ATTRIBUTE_UNUSED, asymbol **sym ATTRIBUTE_UNUSED)
 {
   return 0;
diff --git a/bfd/xsym.h b/bfd/xsym.h
index 22ed52d..bdaff53 100644
--- a/bfd/xsym.h
+++ b/bfd/xsym.h
@@ -96,8 +96,8 @@ typedef enum bfd_sym_symbol_scope bfd_sym_symbol_scope;
 
 struct bfd_sym_file_reference
 {
-  unsigned long fref_frte_index; /* File reference table index.  */
-  unsigned long fref_offset;     /* Absolute offset into source file.  */
+  unsigned long long fref_frte_index; /* File reference table index.  */
+  unsigned long long fref_offset;     /* Absolute offset into source file.  */
 };
 typedef struct bfd_sym_file_reference bfd_sym_file_reference;
 
@@ -121,10 +121,10 @@ struct bfd_sym_resources_table_entry
 {
   unsigned char rte_res_type[4];  /* Resource Type.  */
   unsigned short rte_res_number;  /* Resource Number.  */
-  unsigned long rte_nte_index;    /* Name of the resource.  */
-  unsigned long rte_mte_first;    /* Index of first module in the resource.  */
-  unsigned long rte_mte_last;     /* Index of the last module in the resource.  */
-  unsigned long rte_res_size;     /* Size of the resource.  */
+  unsigned long long rte_nte_index;    /* Name of the resource.  */
+  unsigned long long rte_mte_first;    /* Index of first module in the resource.  */
+  unsigned long long rte_mte_last;     /* Index of the last module in the resource.  */
+  unsigned long long rte_res_size;     /* Size of the resource.  */
 };
 typedef struct bfd_sym_resources_table_entry bfd_sym_resources_table_entry;
 
@@ -145,21 +145,21 @@ typedef struct bfd_sym_resources_table_entry bfd_sym_resources_table_entry;
 
 struct bfd_sym_modules_table_entry
 {
-  unsigned long mte_rte_index;		/* Which resource it is in.  */
-  unsigned long mte_res_offset;		/* Offset into the resource.  */
-  unsigned long mte_size;		/* Size of module.  */
+  unsigned long long mte_rte_index;		/* Which resource it is in.  */
+  unsigned long long mte_res_offset;		/* Offset into the resource.  */
+  unsigned long long mte_size;		/* Size of module.  */
   char mte_kind;			/* What kind of module this is.  */
   char mte_scope;			/* How visible is it?  */
-  unsigned long mte_parent;		/* Containing module.  */
+  unsigned long long mte_parent;		/* Containing module.  */
   bfd_sym_file_reference mte_imp_fref;	/* Implementation source.  */
-  unsigned long mte_imp_end;		/* End of implementation source.  */
-  unsigned long mte_nte_index;		/* The name of the module.  */
-  unsigned long mte_cmte_index;		/* Modules contained in this.  */
-  unsigned long mte_cvte_index;		/* Variables contained in this.  */
-  unsigned long mte_clte_index;		/* Local labels defined here.  */
-  unsigned long mte_ctte_index;		/* Types contained in this.  */
-  unsigned long mte_csnte_idx_1;	/* CSNTE index of mte_snbr_first.  */
-  unsigned long mte_csnte_idx_2;	/* CSNTE index of mte_snbr_last.  */
+  unsigned long long mte_imp_end;		/* End of implementation source.  */
+  unsigned long long mte_nte_index;		/* The name of the module.  */
+  unsigned long long mte_cmte_index;		/* Modules contained in this.  */
+  unsigned long long mte_cvte_index;		/* Variables contained in this.  */
+  unsigned long long mte_clte_index;		/* Local labels defined here.  */
+  unsigned long long mte_ctte_index;		/* Types contained in this.  */
+  unsigned long long mte_csnte_idx_1;	/* CSNTE index of mte_snbr_first.  */
+  unsigned long long mte_csnte_idx_2;	/* CSNTE index of mte_snbr_last.  */
 };
 typedef struct bfd_sym_modules_table_entry bfd_sym_modules_table_entry;
 
@@ -182,24 +182,24 @@ union bfd_sym_file_references_table_entry
   struct
   {
     /* END_OF_LIST, FILE_NAME_INDEX, or module table entry.  */
-    unsigned long type;
+    unsigned long long type;
   }
   generic;
 
   struct
   {
     /* FILE_NAME_INDEX.  */
-    unsigned long type;
-    unsigned long nte_index;
-    unsigned long mod_date;
+    unsigned long long type;
+    unsigned long long nte_index;
+    unsigned long long mod_date;
   }
   filename;
 
   struct
   {
     /* < FILE_NAME_INDEX.  */
-    unsigned long mte_index;
-    unsigned long file_offset;
+    unsigned long long mte_index;
+    unsigned long long file_offset;
   }
   entry;
 };
@@ -218,14 +218,14 @@ union bfd_sym_contained_modules_table_entry
   struct
   {
     /* END_OF_LIST, index.  */
-    unsigned long type;
+    unsigned long long type;
   }
   generic;
 
   struct
   {
-    unsigned long mte_index; /* Index into the Modules Table.  */
-    unsigned long nte_index; /* The name of the module.  */
+    unsigned long long mte_index; /* Index into the Modules Table.  */
+    unsigned long long nte_index; /* The name of the module.  */
   }
   entry;
 };
@@ -269,14 +269,14 @@ union bfd_sym_contained_variables_table_entry
   struct
   {
     /* END_OF_LIST, SOURCE_FILE_CHANGE, or type table entry.  */
-    unsigned long type;
+    unsigned long long type;
   }
   generic;
 
   struct
   {
     /* SOURCE_FILE_CHANGE.  */
-    unsigned long type;
+    unsigned long long type;
     bfd_sym_file_reference fref;
   }
   file;
@@ -284,9 +284,9 @@ union bfd_sym_contained_variables_table_entry
   struct
   {
     /* < SOURCE_FILE_CHANGE.  */
-    unsigned long tte_index;
-    unsigned long nte_index;
-    unsigned long file_delta;			    /* Increment from previous source.  */
+    unsigned long long tte_index;
+    unsigned long long nte_index;
+    unsigned long long file_delta;			    /* Increment from previous source.  */
     unsigned char scope;
     unsigned char la_size;			    /* #bytes of LAs below.  */
 
@@ -297,7 +297,7 @@ union bfd_sym_contained_variables_table_entry
       {
 	unsigned char sca_kind;			    /* Distinguish local from value/var formal.  */
 	unsigned char sca_class;		    /* The storage class itself.  */
-	unsigned long sca_offset;
+	unsigned long long sca_offset;
       }
       scstruct;
 
@@ -311,7 +311,7 @@ union bfd_sym_contained_variables_table_entry
       /* la_size == BFD_SYM_CVTE_BIG_LA 127.  */
       struct
       {
-	unsigned long big_la;			    /* Logical address bytes in constant pool.  */
+	unsigned long long big_la;			    /* Logical address bytes in constant pool.  */
 	unsigned char big_la_kind;		    /* Eqv. cvte_location.sca_kind.  */
       }
       biglastruct;
@@ -345,23 +345,23 @@ union bfd_sym_contained_statements_table_entry
   struct
   {
     /* END_OF_LIST, SOURCE_FILE_CHANGE, or statement table entry.  */
-    unsigned long type;
+    unsigned long long type;
   }
   generic;
 
   struct
   {
     /* SOURCE_FILE_CHANGE.  */
-    unsigned long type;
+    unsigned long long type;
     bfd_sym_file_reference fref; /* File name table.  */
   }
   file;
 
   struct
   {
-    unsigned long mte_index;     /* Which module contains it.  */
-    unsigned long file_delta;    /* Where it is defined.  */
-    unsigned long mte_offset;    /* Where it is in the module.  */
+    unsigned long long mte_index;     /* Which module contains it.  */
+    unsigned long long file_delta;    /* Where it is defined.  */
+    unsigned long long mte_offset;    /* Where it is in the module.  */
   }
   entry;
 };
@@ -377,14 +377,14 @@ union bfd_sym_contained_labels_table_entry
   struct
   {
     /* END_OF_LIST, SOURCE_FILE_CHANGE, index.  */
-    unsigned long type;
+    unsigned long long type;
   }
   generic;
 
   struct
   {
     /* SOURCE_FILE_CHANGE.  */
-    unsigned long type;
+    unsigned long long type;
     bfd_sym_file_reference fref;
   }
   file;
@@ -392,10 +392,10 @@ union bfd_sym_contained_labels_table_entry
   struct
   {
     /* < SOURCE_FILE_CHANGE.  */
-    unsigned long mte_index;   /* Which module contains us.  */
-    unsigned long mte_offset;  /* Where it is in the module.  */
-    unsigned long nte_index;   /* The name of the label.  */
-    unsigned long file_delta;  /* Where it is defined.  */
+    unsigned long long mte_index;   /* Which module contains us.  */
+    unsigned long long mte_offset;  /* Where it is in the module.  */
+    unsigned long long nte_index;   /* The name of the label.  */
+    unsigned long long file_delta;  /* Where it is defined.  */
     unsigned short scope;      /* How visible the label is.  */
   }
   entry;
@@ -413,14 +413,14 @@ union bfd_sym_contained_types_table_entry
   struct
   {
     /* END_OF_LIST, SOURCE_FILE_CHANGE, or type table entry.  */
-    unsigned long type;
+    unsigned long long type;
   }
   generic;
 
   struct
   {
     /* SOURCE_FILE_CHANGE.  */
-    unsigned long type;
+    unsigned long long type;
     bfd_sym_file_reference fref;
   }
   file;
@@ -428,9 +428,9 @@ union bfd_sym_contained_types_table_entry
   struct
   {
     /* < SOURCE_FILE_CHANGE.  */
-    unsigned long tte_index;
-    unsigned long nte_index;
-    unsigned long file_delta; /* From last file definition.  */
+    unsigned long long tte_index;
+    unsigned long long nte_index;
+    unsigned long long file_delta; /* From last file definition.  */
   }
   entry;
 };
@@ -438,16 +438,16 @@ typedef union bfd_sym_contained_types_table_entry bfd_sym_contained_types_table_
 
 /* TYPE TABLE (TTE).  */
 
-typedef unsigned long bfd_sym_type_table_entry;
+typedef unsigned long long bfd_sym_type_table_entry;
 
 /* TYPE INFORMATION TABLE (TINFO).  */
 
 struct bfd_sym_type_information_table_entry
 {
-  unsigned long nte_index;
-  unsigned long physical_size;
-  unsigned long logical_size;
-  unsigned long offset;
+  unsigned long long nte_index;
+  unsigned long long physical_size;
+  unsigned long long logical_size;
+  unsigned long long offset;
 };
 typedef struct bfd_sym_type_information_table_entry bfd_sym_type_information_table_entry;
 
@@ -461,14 +461,14 @@ union bfd_sym_file_references_index_table_entry
 {
   struct
   {
-    unsigned long type;
+    unsigned long long type;
   }
   generic;
 
   struct
   {
-    unsigned long frte_index;  /* Index into the FRTE table.  */
-    unsigned long nte_index;   /* Name table index, gives filename.  */
+    unsigned long long frte_index;  /* Index into the FRTE table.  */
+    unsigned long long nte_index;   /* Name table index, gives filename.  */
   }
   entry;
 };
@@ -505,9 +505,9 @@ typedef short bfd_sym_constant_pool_entry;
 
 struct bfd_sym_table_info
 {
-  unsigned long dti_first_page;   /* First page for this table.  */
-  unsigned long dti_page_count;   /* Number of pages for the table.  */
-  unsigned long dti_object_count; /* Number of objects in the table.  */
+  unsigned long long dti_first_page;   /* First page for this table.  */
+  unsigned long long dti_page_count;   /* Number of pages for the table.  */
+  unsigned long long dti_object_count; /* Number of objects in the table.  */
 };
 typedef struct bfd_sym_table_info bfd_sym_table_info;
 
@@ -515,9 +515,9 @@ struct bfd_sym_header_block
 {
   unsigned char dshb_id[32];      /* Version information.  */
   unsigned short dshb_page_size;  /* Size of the pages/blocks.  */
-  unsigned long dshb_hash_page;   /* Disk page for the hash table.  */
-  unsigned long dshb_root_mte;    /* MTE index of the program root.  */
-  unsigned long dshb_mod_date;    /* modification date of executable.  */
+  unsigned long long dshb_hash_page;   /* Disk page for the hash table.  */
+  unsigned long long dshb_root_mte;    /* MTE index of the program root.  */
+  unsigned long long dshb_mod_date;    /* modification date of executable.  */
   bfd_sym_table_info dshb_frte;   /* Per TABLE information.  */
   bfd_sym_table_info dshb_rte;
   bfd_sym_table_info dshb_mte;
@@ -589,35 +589,35 @@ extern void bfd_sym_parse_contained_labels_table_entry_v32
 extern void bfd_sym_parse_type_table_entry_v32
   (unsigned char *, size_t, bfd_sym_type_table_entry *);
 extern int bfd_sym_fetch_resources_table_entry
-  (bfd *, bfd_sym_resources_table_entry *, unsigned long);
+  (bfd *, bfd_sym_resources_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_modules_table_entry
-  (bfd *, bfd_sym_modules_table_entry *, unsigned long);
+  (bfd *, bfd_sym_modules_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_file_references_table_entry
-  (bfd *, bfd_sym_file_references_table_entry *, unsigned long);
+  (bfd *, bfd_sym_file_references_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_contained_modules_table_entry
-  (bfd *, bfd_sym_contained_modules_table_entry *, unsigned long);
+  (bfd *, bfd_sym_contained_modules_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_contained_variables_table_entry
-  (bfd *, bfd_sym_contained_variables_table_entry *, unsigned long);
+  (bfd *, bfd_sym_contained_variables_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_contained_statements_table_entry
-  (bfd *, bfd_sym_contained_statements_table_entry *, unsigned long);
+  (bfd *, bfd_sym_contained_statements_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_contained_labels_table_entry
-  (bfd *, bfd_sym_contained_labels_table_entry *, unsigned long);
+  (bfd *, bfd_sym_contained_labels_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_contained_types_table_entry
-  (bfd *, bfd_sym_contained_types_table_entry *, unsigned long);
+  (bfd *, bfd_sym_contained_types_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_file_references_index_table_entry
-  (bfd *, bfd_sym_file_references_index_table_entry *, unsigned long);
+  (bfd *, bfd_sym_file_references_index_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_constant_pool_entry
-  (bfd *, bfd_sym_constant_pool_entry *, unsigned long);
+  (bfd *, bfd_sym_constant_pool_entry *, unsigned long long);
 extern int bfd_sym_fetch_type_table_entry
-  (bfd *, bfd_sym_type_table_entry *, unsigned long);
+  (bfd *, bfd_sym_type_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_type_information_table_entry
-  (bfd *, bfd_sym_type_information_table_entry *, unsigned long);
+  (bfd *, bfd_sym_type_information_table_entry *, unsigned long long);
 extern int bfd_sym_fetch_type_table_information
-  (bfd *, bfd_sym_type_information_table_entry *, unsigned long);
+  (bfd *, bfd_sym_type_information_table_entry *, unsigned long long);
 extern const unsigned char * bfd_sym_symbol_name
-  (bfd *, unsigned long);
+  (bfd *, unsigned long long);
 extern const unsigned char * bfd_sym_module_name
-  (bfd *, unsigned long);
+  (bfd *, unsigned long long);
 extern const char * bfd_sym_unparse_storage_kind
   (enum bfd_sym_storage_kind);
 extern const char * bfd_sym_unparse_storage_class
@@ -649,9 +649,9 @@ extern const char * bfd_sym_type_operator_name
 extern const char * bfd_sym_type_basic_name
   (unsigned char);
 extern int bfd_sym_fetch_long
-  (unsigned char *, unsigned long, unsigned long, unsigned long *, long *);
+  (unsigned char *, unsigned long long, unsigned long long, unsigned long long *, long long *);
 extern void bfd_sym_print_type_information
-  (bfd *, FILE *, unsigned char *, unsigned long, unsigned long, unsigned long *);
+  (bfd *, FILE *, unsigned char *, unsigned long long, unsigned long long, unsigned long long *);
 extern void bfd_sym_print_type_information_table_entry
   (bfd *, FILE *, bfd_sym_type_information_table_entry *);
 extern void bfd_sym_print_file_references_index_table_entry
@@ -690,9 +690,9 @@ extern const bfd_target * bfd_sym_object_p
   (bfd *);
 extern void bfd_sym_get_symbol_info
   (bfd *, asymbol *, symbol_info *);
-extern long bfd_sym_get_symtab_upper_bound
+extern long long bfd_sym_get_symtab_upper_bound
   (bfd *);
-extern long bfd_sym_canonicalize_symtab
+extern long long bfd_sym_canonicalize_symtab
   (bfd *, asymbol **);
 extern int bfd_sym_sizeof_headers
   (bfd *, struct bfd_link_info *);
diff --git a/gdb/aarch64-linux-nat.c b/gdb/aarch64-linux-nat.c
index 43af99d..16ecba4 100644
--- a/gdb/aarch64-linux-nat.c
+++ b/gdb/aarch64-linux-nat.c
@@ -695,7 +695,7 @@ aarch64_linux_nat_target::insert_hw_breakpoint (struct gdbarch *gdbarch,
     fprintf_unfiltered
       (gdb_stdlog,
        "insert_hw_breakpoint on entry (addr=0x%08lx, len=%d))\n",
-       (unsigned long) addr, len);
+       (unsigned long long) addr, len);
 
   ret = aarch64_handle_breakpoint (type, addr, len, 1 /* is_insert */, state);
 
@@ -727,7 +727,7 @@ aarch64_linux_nat_target::remove_hw_breakpoint (struct gdbarch *gdbarch,
   if (show_debug_regs)
     fprintf_unfiltered
       (gdb_stdlog, "remove_hw_breakpoint on entry (addr=0x%08lx, len=%d))\n",
-       (unsigned long) addr, len);
+       (unsigned long long) addr, len);
 
   ret = aarch64_handle_breakpoint (type, addr, len, 0 /* is_insert */, state);
 
@@ -758,7 +758,7 @@ aarch64_linux_nat_target::insert_watchpoint (CORE_ADDR addr, int len,
   if (show_debug_regs)
     fprintf_unfiltered (gdb_stdlog,
 			"insert_watchpoint on entry (addr=0x%08lx, len=%d)\n",
-			(unsigned long) addr, len);
+			(unsigned long long) addr, len);
 
   gdb_assert (type != hw_execute);
 
@@ -790,7 +790,7 @@ aarch64_linux_nat_target::remove_watchpoint (CORE_ADDR addr, int len,
   if (show_debug_regs)
     fprintf_unfiltered (gdb_stdlog,
 			"remove_watchpoint on entry (addr=0x%08lx, len=%d)\n",
-			(unsigned long) addr, len);
+			(unsigned long long) addr, len);
 
   gdb_assert (type != hw_execute);
 
diff --git a/gdb/aarch64-linux-tdep.c b/gdb/aarch64-linux-tdep.c
index 99e6a15..a7e1447 100644
--- a/gdb/aarch64-linux-tdep.c
+++ b/gdb/aarch64-linux-tdep.c
@@ -483,7 +483,7 @@ aarch64_stap_parse_special_token (struct gdbarch *gdbarch,
       char *regname;
       int len;
       int got_minus = 0;
-      long displacement;
+      long long displacement;
       struct stoken str;
 
       ++tmp;
@@ -1161,7 +1161,7 @@ aarch64_all_but_pc_registers_record (struct regcache *regcache)
 
 static int
 aarch64_linux_syscall_record (struct regcache *regcache,
-			      unsigned long svc_number)
+			      unsigned long long svc_number)
 {
   int ret = 0;
   enum gdb_syscall syscall_gdb;
diff --git a/gdb/aarch64-tdep.h b/gdb/aarch64-tdep.h
index 7e5031f..055bcce 100644
--- a/gdb/aarch64-tdep.h
+++ b/gdb/aarch64-tdep.h
@@ -77,7 +77,7 @@ struct gdbarch_tdep
   struct type *vnv_type;
 
   /* syscall record.  */
-  int (*aarch64_syscall_record) (struct regcache *regcache, unsigned long svc_number);
+  int (*aarch64_syscall_record) (struct regcache *regcache, unsigned long long svc_number);
 
   /* The VQ value for SVE targets, or zero if SVE is not supported.  */
   uint64_t vq;
diff --git a/gdb/ada-lang.c b/gdb/ada-lang.c
index 3e5bd8a..d7c1451 100644
--- a/gdb/ada-lang.c
+++ b/gdb/ada-lang.c
@@ -175,11 +175,11 @@ static struct type *static_unwrap_type (struct type *type);
 
 static struct value *unwrap_value (struct value *);
 
-static struct type *constrained_packed_array_type (struct type *, long *);
+static struct type *constrained_packed_array_type (struct type *, long long *);
 
 static struct type *decode_constrained_packed_array_type (struct type *);
 
-static long decode_packed_array_bitsize (struct type *);
+static long long decode_packed_array_bitsize (struct type *);
 
 static struct value *decode_constrained_packed_array (struct value *);
 
@@ -697,7 +697,7 @@ coerce_unspec_val_to_type (struct value *val, struct type *type)
 }
 
 static const gdb_byte *
-cond_offset_host (const gdb_byte *valaddr, long offset)
+cond_offset_host (const gdb_byte *valaddr, long long offset)
 {
   if (valaddr == NULL)
     return NULL;
@@ -706,7 +706,7 @@ cond_offset_host (const gdb_byte *valaddr, long offset)
 }
 
 static CORE_ADDR
-cond_offset_target (CORE_ADDR address, long offset)
+cond_offset_target (CORE_ADDR address, long long offset)
 {
   if (address == 0)
     return 0;
@@ -2143,12 +2143,12 @@ ada_is_unconstrained_packed_array_type (struct type *type)
 /* Given that TYPE encodes a packed array type (constrained or unconstrained),
    return the size of its elements in bits.  */
 
-static long
+static long long
 decode_packed_array_bitsize (struct type *type)
 {
   const char *raw_name;
   const char *tail;
-  long bits;
+  long long bits;
 
   /* Access to arrays implemented as fat pointers are encoded as a typedef
      of the fat pointer type.  We need the name of the fat pointer type
@@ -2194,7 +2194,7 @@ decode_packed_array_bitsize (struct type *type)
    the length is arbitrary.  */
 
 static struct type *
-constrained_packed_array_type (struct type *type, long *elt_bits)
+constrained_packed_array_type (struct type *type, long long *elt_bits)
 {
   struct type *new_elt_type;
   struct type *new_type;
@@ -2248,7 +2248,7 @@ decode_constrained_packed_array_type (struct type *type)
   char *name;
   const char *tail;
   struct type *shadow_type;
-  long bits;
+  long long bits;
 
   if (!raw_name)
     raw_name = ada_type_name (desc_base_type (type));
@@ -2349,7 +2349,7 @@ value_subscript_packed (struct value *arr, int arity, struct value **ind)
 {
   int i;
   int bits, elt_off, bit_off;
-  long elt_total_bit_offset;
+  long long elt_total_bit_offset;
   struct type *elt_type;
   struct value *v;
 
@@ -2378,7 +2378,7 @@ value_subscript_packed (struct value *arr, int arity, struct value **ind)
           idx = pos_atr (ind[i]);
           if (idx < lowerbound || idx > upperbound)
             lim_warning (_("packed array index %ld out of bounds"),
-			 (long) idx);
+			 (long long) idx);
           bits = TYPE_FIELD_BITSIZE (elt_type, 0);
           elt_total_bit_offset += (idx - lowerbound) * bits;
           elt_type = ada_check_typedef (TYPE_TARGET_TYPE (elt_type));
@@ -2438,7 +2438,7 @@ ada_unpack_from_contents (const gdb_byte *src, int bit_offset, int bit_size,
   int unpacked_idx;             /* Index into the unpacked buffer */
   int unpacked_bytes_left;      /* Number of bytes left to set in unpacked.  */
 
-  unsigned long accum;          /* Staging area for bits being transferred */
+  unsigned long long accum;          /* Staging area for bits being transferred */
   int accumSize;                /* Number of meaningful bits in accum */
   unsigned char sign;
 
@@ -2547,7 +2547,7 @@ ada_unpack_from_contents (const gdb_byte *src, int bit_offset, int bit_size,
 
 struct value *
 ada_value_primitive_packed_val (struct value *obj, const gdb_byte *valaddr,
-				long offset, int bit_offset, int bit_size,
+				long long offset, int bit_offset, int bit_size,
                                 struct type *type)
 {
   struct value *v;
@@ -2617,7 +2617,7 @@ ada_value_primitive_packed_val (struct value *obj, const gdb_byte *valaddr,
 
   if (obj != NULL)
     {
-      long new_offset = offset;
+      long long new_offset = offset;
 
       set_value_component_location (v, obj);
       set_value_bitpos (v, bit_offset + value_bitpos (obj));
@@ -8292,7 +8292,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,
   struct type *rtype;
   int nfields, bit_len;
   int variant_field;
-  long off;
+  long long off;
   int fld_bit_len;
   int f;
 
@@ -8370,7 +8370,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,
 	     that follow this one.  */
 	  if (ada_is_aligner_type (field_type))
 	    {
-	      long field_offset = TYPE_FIELD_BITPOS (field_type, f);
+	      long long field_offset = TYPE_FIELD_BITPOS (field_type, f);
 
 	      field_valaddr = cond_offset_host (field_valaddr, field_offset);
 	      field_address = cond_offset_target (field_address, field_offset);
@@ -9382,7 +9382,7 @@ value_val_atr (struct type *type, struct value *arg)
 
   if (TYPE_CODE (type) == TYPE_CODE_ENUM)
     {
-      long pos = value_as_long (arg);
+      long long pos = value_as_long (arg);
 
       if (pos < 0 || pos >= TYPE_NFIELDS (type))
         error (_("argument to 'VAL out of range"));
@@ -11858,7 +11858,7 @@ to_fixed_range_type (struct type *raw_type, struct value *dval)
           strcpy (name_buf + prefix_len, "___U");
           if (!get_int_var_value (name_buf, U))
             {
-              lim_warning (_("Unknown upper bound, using %ld."), (long) L);
+              lim_warning (_("Unknown upper bound, using %ld."), (long long) L);
               U = L;
             }
         }
@@ -13935,7 +13935,7 @@ ada_print_subexp (struct expression *exp, int *pos,
       fputs_filtered ("'range", stream);
       if (exp->elts[pc + 1].longconst > 1)
         fprintf_filtered (stream, "(%ld)",
-                          (long) exp->elts[pc + 1].longconst);
+                          (long long) exp->elts[pc + 1].longconst);
       return;
 
     case TERNOP_IN_RANGE:
diff --git a/gdb/ada-lang.h b/gdb/ada-lang.h
index 90bfa0a..f241c7d 100644
--- a/gdb/ada-lang.h
+++ b/gdb/ada-lang.h
@@ -261,7 +261,7 @@ extern int ada_is_constrained_packed_array_type (struct type *);
 
 extern struct value *ada_value_primitive_packed_val (struct value *,
 						     const gdb_byte *,
-                                                     long, int, int,
+                                                     long long, int, int,
                                                      struct type *);
 
 extern struct type *ada_coerce_to_simple_array_type (struct type *);
diff --git a/gdb/ada-tasks.c b/gdb/ada-tasks.c
index bd864c2..24212ae 100644
--- a/gdb/ada-tasks.c
+++ b/gdb/ada-tasks.c
@@ -591,7 +591,7 @@ ada_get_tcb_types_info (void)
 static ptid_t
 ptid_from_atcb_common (struct value *common_value)
 {
-  long thread = 0;
+  long long thread = 0;
   CORE_ADDR lwp = 0;
   struct value *ll_value;
   ptid_t ptid;
@@ -1119,7 +1119,7 @@ print_ada_task_info (struct ui_out *uiout,
       uiout->field_int ("id", taskno);
 
       /* Print the Task ID.  */
-      uiout->field_fmt ("task-id", "%9lx", (long) task_info->task_id);
+      uiout->field_fmt ("task-id", "%9lx", (long long) task_info->task_id);
 
       /* Print the associated Thread ID.  */
       if (uiout->is_mi_like_p ())
diff --git a/gdb/ada-valprint.c b/gdb/ada-valprint.c
index a486919..db97be2 100644
--- a/gdb/ada-valprint.c
+++ b/gdb/ada-valprint.c
@@ -132,7 +132,7 @@ val_print_packed_array_elements (struct type *type, const gdb_byte *valaddr,
   unsigned int things_printed = 0;
   unsigned len;
   struct type *elttype, *index_type;
-  unsigned long bitsize = TYPE_FIELD_BITSIZE (type, 0);
+  unsigned long long bitsize = TYPE_FIELD_BITSIZE (type, 0);
   struct value *mark = value_mark ();
   LONGEST low = 0;
 
@@ -952,7 +952,7 @@ ada_val_print_enum (struct type *type, const gdb_byte *valaddr,
       const char *name = ada_enum_name (TYPE_FIELD_NAME (type, i));
 
       if (name[0] == '\'')
-	fprintf_filtered (stream, "%ld %s", (long) val, name);
+	fprintf_filtered (stream, "%ld %s", (long long) val, name);
       else
 	fputs_filtered (name, stream);
     }
diff --git a/gdb/aix-thread.c b/gdb/aix-thread.c
index 97592e5..285b066 100644
--- a/gdb/aix-thread.c
+++ b/gdb/aix-thread.c
@@ -145,7 +145,7 @@ public:
 
   const char *extra_thread_info (struct thread_info *) override;
 
-  ptid_t get_ada_task_ptid (long lwp, long thread) override;
+  ptid_t get_ada_task_ptid (long long lwp, long long thread) override;
 };
 
 static aix_thread_target aix_thread_ops;
@@ -341,7 +341,7 @@ pdc_symbol_addrs (pthdb_user_t user, pthdb_symbol_t *symbols, int count)
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog,
       "pdc_symbol_addrs (user = %ld, symbols = 0x%lx, count = %d)\n",
-      user, (long) symbols, count);
+      user, (long long) symbols, count);
 
   for (i = 0; i < count; i++)
     {
@@ -406,7 +406,7 @@ pdc_read_regs (pthdb_user_t user,
       if (arch64)
 	{
 	  if (!ptrace64aix (PTT_READ_GPRS, tid, 
-			    (unsigned long) gprs64, 0, NULL))
+			    (unsigned long long) gprs64, 0, NULL))
 	    memset (gprs64, 0, sizeof (gprs64));
 	  memcpy (context->gpr, gprs64, sizeof(gprs64));
 	}
@@ -432,7 +432,7 @@ pdc_read_regs (pthdb_user_t user,
       if (arch64)
 	{
 	  if (!ptrace64aix (PTT_READ_SPRS, tid, 
-			    (unsigned long) &sprs64, 0, NULL))
+			    (unsigned long long) &sprs64, 0, NULL))
 	    memset (&sprs64, 0, sizeof (sprs64));
       	  memcpy (&context->msr, &sprs64, sizeof(sprs64));
 	}
@@ -471,7 +471,7 @@ pdc_write_regs (pthdb_user_t user,
     {
       if (arch64)
 	ptrace64aix (PTT_WRITE_GPRS, tid, 
-		     (unsigned long) context->gpr, 0, NULL);
+		     (unsigned long long) context->gpr, 0, NULL);
       else
 	ptrace32 (PTT_WRITE_GPRS, tid, (uintptr_t) context->gpr, 0, NULL);
     }
@@ -488,7 +488,7 @@ pdc_write_regs (pthdb_user_t user,
       if (arch64)
 	{
 	  ptrace64aix (PTT_WRITE_SPRS, tid, 
-		       (unsigned long) &context->msr, 0, NULL);
+		       (unsigned long long) &context->msr, 0, NULL);
 	}
       else
 	{
@@ -509,7 +509,7 @@ pdc_read_data (pthdb_user_t user, void *buf,
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog,
       "pdc_read_data (user = %ld, buf = 0x%lx, addr = %s, len = %ld)\n",
-      user, (long) buf, hex_string (addr), len);
+      user, (long long) buf, hex_string (addr), len);
 
   status = target_read_memory (addr, (gdb_byte *) buf, len);
   ret = status == 0 ? PDC_SUCCESS : PDC_FAILURE;
@@ -531,7 +531,7 @@ pdc_write_data (pthdb_user_t user, void *buf,
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog,
       "pdc_write_data (user = %ld, buf = 0x%lx, addr = %s, len = %ld)\n",
-      user, (long) buf, hex_string (addr), len);
+      user, (long long) buf, hex_string (addr), len);
 
   status = target_write_memory (addr, (gdb_byte *) buf, len);
   ret = status == 0 ? PDC_SUCCESS : PDC_FAILURE;
@@ -551,11 +551,11 @@ pdc_alloc (pthdb_user_t user, size_t len, void **bufp)
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog,
                         "pdc_alloc (user = %ld, len = %ld, bufp = 0x%lx)\n",
-			user, len, (long) bufp);
+			user, len, (long long) bufp);
   *bufp = xmalloc (len);
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog, 
-			"  malloc returned 0x%lx\n", (long) *bufp);
+			"  malloc returned 0x%lx\n", (long long) *bufp);
 
   /* Note: xmalloc() can't return 0; therefore PDC_FAILURE will never
      be returned.  */
@@ -573,11 +573,11 @@ pdc_realloc (pthdb_user_t user, void *buf, size_t len, void **bufp)
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog,
       "pdc_realloc (user = %ld, buf = 0x%lx, len = %ld, bufp = 0x%lx)\n",
-      user, (long) buf, len, (long) bufp);
+      user, (long long) buf, len, (long long) bufp);
   *bufp = xrealloc (buf, len);
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog, 
-			"  realloc returned 0x%lx\n", (long) *bufp);
+			"  realloc returned 0x%lx\n", (long long) *bufp);
   return *bufp ? PDC_SUCCESS : PDC_FAILURE;
 }
 
@@ -590,7 +590,7 @@ pdc_dealloc (pthdb_user_t user, void *buf)
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog, 
 			"pdc_free (user = %ld, buf = 0x%lx)\n", user,
-                        (long) buf);
+                        (long long) buf);
   xfree (buf);
   return PDC_SUCCESS;
 }
@@ -1223,7 +1223,7 @@ fetch_regs_user_thread (struct regcache *regcache, pthdb_pthread_t pdtid)
 
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog, 
-			"fetch_regs_user_thread %lx\n", (long) pdtid);
+			"fetch_regs_user_thread %lx\n", (long long) pdtid);
   status = pthdb_pthread_context (pd_session, pdtid, &ctx);
   if (status != PTHDB_SUCCESS)
     error (_("aix-thread: fetch_registers: pthdb_pthread_context returned %s"),
@@ -1283,7 +1283,7 @@ fetch_regs_kernel_thread (struct regcache *regcache, int regno,
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog,
 	"fetch_regs_kernel_thread tid=%lx regno=%d arch64=%d\n",
-	(long) tid, regno, arch64);
+	(long long) tid, regno, arch64);
 
   /* General-purpose registers.  */
   if (regno == -1
@@ -1293,7 +1293,7 @@ fetch_regs_kernel_thread (struct regcache *regcache, int regno,
       if (arch64)
 	{
 	  if (!ptrace64aix (PTT_READ_GPRS, tid, 
-			    (unsigned long) gprs64, 0, NULL))
+			    (unsigned long long) gprs64, 0, NULL))
 	    memset (gprs64, 0, sizeof (gprs64));
 	  supply_gprs64 (regcache, gprs64);
 	}
@@ -1325,7 +1325,7 @@ fetch_regs_kernel_thread (struct regcache *regcache, int regno,
       if (arch64)
 	{
 	  if (!ptrace64aix (PTT_READ_SPRS, tid, 
-			    (unsigned long) &sprs64, 0, NULL))
+			    (unsigned long long) &sprs64, 0, NULL))
 	    memset (&sprs64, 0, sizeof (sprs64));
 	  supply_sprs64 (regcache, sprs64.pt_iar, sprs64.pt_msr,
 			 sprs64.pt_cr, sprs64.pt_lr, sprs64.pt_ctr,
@@ -1506,7 +1506,7 @@ store_regs_user_thread (const struct regcache *regcache, pthdb_pthread_t pdtid)
 
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog, 
-			"store_regs_user_thread %lx\n", (long) pdtid);
+			"store_regs_user_thread %lx\n", (long long) pdtid);
 
   /* Retrieve the thread's current context for its non-register
      values.  */
@@ -1599,7 +1599,7 @@ store_regs_kernel_thread (const struct regcache *regcache, int regno,
   if (debug_aix_thread)
     fprintf_unfiltered (gdb_stdlog, 
 			"store_regs_kernel_thread tid=%lx regno=%d\n",
-                        (long) tid, regno);
+                        (long long) tid, regno);
 
   /* General-purpose registers.  */
   if (regno == -1
@@ -1609,9 +1609,9 @@ store_regs_kernel_thread (const struct regcache *regcache, int regno,
       if (arch64)
 	{
 	  /* Pre-fetch: some regs may not be in the cache.  */
-	  ptrace64aix (PTT_READ_GPRS, tid, (unsigned long) gprs64, 0, NULL);
+	  ptrace64aix (PTT_READ_GPRS, tid, (unsigned long long) gprs64, 0, NULL);
 	  fill_gprs64 (regcache, gprs64);
-	  ptrace64aix (PTT_WRITE_GPRS, tid, (unsigned long) gprs64, 0, NULL);
+	  ptrace64aix (PTT_WRITE_GPRS, tid, (unsigned long long) gprs64, 0, NULL);
 	}
       else
 	{
@@ -1643,12 +1643,12 @@ store_regs_kernel_thread (const struct regcache *regcache, int regno,
 	{
 	  /* Pre-fetch: some registers won't be in the cache.  */
 	  ptrace64aix (PTT_READ_SPRS, tid, 
-		       (unsigned long) &sprs64, 0, NULL);
+		       (unsigned long long) &sprs64, 0, NULL);
 	  fill_sprs64 (regcache, &sprs64.pt_iar, &sprs64.pt_msr,
 		       &sprs64.pt_cr, &sprs64.pt_lr, &sprs64.pt_ctr,
 		       &sprs64.pt_xer, &sprs64.pt_fpscr);
 	  ptrace64aix (PTT_WRITE_SPRS, tid, 
-		       (unsigned long) &sprs64, 0, NULL);
+		       (unsigned long long) &sprs64, 0, NULL);
 	}
       else
 	{
@@ -1830,7 +1830,7 @@ aix_thread_target::extra_thread_info (struct thread_info *thread)
 }
 
 ptid_t
-aix_thread_target::get_ada_task_ptid (long lwp, long thread)
+aix_thread_target::get_ada_task_ptid (long long lwp, long long thread)
 {
   return ptid_t (inferior_ptid.pid (), 0, thread);
 }
diff --git a/gdb/alpha-linux-nat.c b/gdb/alpha-linux-nat.c
index e23674a..433a631 100644
--- a/gdb/alpha-linux-nat.c
+++ b/gdb/alpha-linux-nat.c
@@ -48,7 +48,7 @@ static alpha_linux_nat_target the_alpha_linux_nat_target;
 void
 supply_gregset (struct regcache *regcache, const gdb_gregset_t *gregsetp)
 {
-  const long *regp = (const long *)gregsetp;
+  const long long *regp = (const long long *)gregsetp;
 
   /* PC is in slot 32, UNIQUE is in slot 33.  */
   alpha_supply_int_regs (regcache, -1, regp, regp + 31, regp + 32);
@@ -58,7 +58,7 @@ void
 fill_gregset (const struct regcache *regcache,
 	      gdb_gregset_t *gregsetp, int regno)
 {
-  long *regp = (long *)gregsetp;
+  long long *regp = (long long *)gregsetp;
 
   /* PC is in slot 32, UNIQUE is in slot 33.  */
   alpha_fill_int_regs (regcache, regno, regp, regp + 31, regp + 32);
@@ -70,7 +70,7 @@ fill_gregset (const struct regcache *regcache,
 void
 supply_fpregset (struct regcache *regcache, const gdb_fpregset_t *fpregsetp)
 {
-  const long *regp = (const long *)fpregsetp;
+  const long long *regp = (const long long *)fpregsetp;
 
   /* FPCR is in slot 32.  */
   alpha_supply_fp_regs (regcache, -1, regp, regp + 31);
@@ -80,7 +80,7 @@ void
 fill_fpregset (const struct regcache *regcache,
 	       gdb_fpregset_t *fpregsetp, int regno)
 {
-  long *regp = (long *)fpregsetp;
+  long long *regp = (long long *)fpregsetp;
 
   /* FPCR is in slot 32.  */
   alpha_fill_fp_regs (regcache, regno, regp, regp + 31);
diff --git a/gdb/alpha-linux-tdep.c b/gdb/alpha-linux-tdep.c
index 913a420..cb5cae1 100644
--- a/gdb/alpha-linux-tdep.c
+++ b/gdb/alpha-linux-tdep.c
@@ -69,7 +69,7 @@ enum
      (3) there is a "normal" sigreturn and an "rt" sigreturn which
          has a different stack layout.  */
 
-static long
+static long long
 alpha_linux_sigtramp_offset_1 (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
   switch (alpha_read_insn (gdbarch, pc))
@@ -94,7 +94,7 @@ alpha_linux_sigtramp_offset_1 (struct gdbarch *gdbarch, CORE_ADDR pc)
 static LONGEST
 alpha_linux_sigtramp_offset (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
-  long i, off;
+  long long i, off;
 
   if (pc & 3)
     return -1;
@@ -130,7 +130,7 @@ alpha_linux_sigcontext_addr (struct frame_info *this_frame)
   struct gdbarch *gdbarch = get_frame_arch (this_frame);
   CORE_ADDR pc;
   ULONGEST sp;
-  long off;
+  long long off;
 
   pc = get_frame_pc (this_frame);
   sp = get_frame_register_unsigned (this_frame, ALPHA_SP_REGNUM);
diff --git a/gdb/alpha-mdebug-tdep.c b/gdb/alpha-mdebug-tdep.c
index 18dced7..fc212b1 100644
--- a/gdb/alpha-mdebug-tdep.c
+++ b/gdb/alpha-mdebug-tdep.c
@@ -193,7 +193,7 @@ alpha_mdebug_frame_unwind_cache (struct frame_info *this_frame,
   struct mdebug_extra_func_info *proc_desc;
   ULONGEST vfp;
   CORE_ADDR pc, reg_position;
-  unsigned long mask;
+  unsigned long long mask;
   int ireg, returnreg;
 
   if (*this_prologue_cache)
diff --git a/gdb/alpha-tdep.c b/gdb/alpha-tdep.c
index 53943e1..c7f85f5 100644
--- a/gdb/alpha-tdep.c
+++ b/gdb/alpha-tdep.c
@@ -696,7 +696,7 @@ alpha_read_insn (struct gdbarch *gdbarch, CORE_ADDR pc)
 static CORE_ADDR
 alpha_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
-  unsigned long inst;
+  unsigned long long inst;
   int offset;
   CORE_ADDR post_prologue_pc;
   gdb_byte buf[ALPHA_INSN_SIZE];
diff --git a/gdb/amd64-linux-nat.c b/gdb/amd64-linux-nat.c
index bc2412b..d8116a8 100644
--- a/gdb/amd64-linux-nat.c
+++ b/gdb/amd64-linux-nat.c
@@ -156,7 +156,7 @@ amd64_linux_nat_target::fetch_registers (struct regcache *regcache, int regnum)
     {
       elf_gregset_t regs;
 
-      if (ptrace (PTRACE_GETREGS, tid, 0, (long) &regs) < 0)
+      if (ptrace (PTRACE_GETREGS, tid, 0, (long long) &regs) < 0)
 	perror_with_name (_("Couldn't get registers"));
 
       amd64_supply_native_gregset (regcache, &regs, -1);
@@ -176,14 +176,14 @@ amd64_linux_nat_target::fetch_registers (struct regcache *regcache, int regnum)
 	  iov.iov_base = xstateregs;
 	  iov.iov_len = sizeof (xstateregs);
 	  if (ptrace (PTRACE_GETREGSET, tid,
-		      (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
+		      (unsigned int) NT_X86_XSTATE, (long long) &iov) < 0)
 	    perror_with_name (_("Couldn't get extended state status"));
 
 	  amd64_supply_xsave (regcache, -1, xstateregs);
 	}
       else
 	{
-	  if (ptrace (PTRACE_GETFPREGS, tid, 0, (long) &fpregs) < 0)
+	  if (ptrace (PTRACE_GETFPREGS, tid, 0, (long long) &fpregs) < 0)
 	    perror_with_name (_("Couldn't get floating point status"));
 
 	  amd64_supply_fxsave (regcache, -1, &fpregs);
@@ -193,7 +193,7 @@ amd64_linux_nat_target::fetch_registers (struct regcache *regcache, int regnum)
 	/* PTRACE_ARCH_PRCTL is obsolete since 2.6.25, where the
 	   fs_base and gs_base fields of user_regs_struct can be
 	   used directly.  */
-	unsigned long base;
+	unsigned long long base;
 
 	if (regnum == -1 || regnum == AMD64_FSBASE_REGNUM)
 	  {
@@ -234,12 +234,12 @@ amd64_linux_nat_target::store_registers (struct regcache *regcache, int regnum)
     {
       elf_gregset_t regs;
 
-      if (ptrace (PTRACE_GETREGS, tid, 0, (long) &regs) < 0)
+      if (ptrace (PTRACE_GETREGS, tid, 0, (long long) &regs) < 0)
 	perror_with_name (_("Couldn't get registers"));
 
       amd64_collect_native_gregset (regcache, &regs, regnum);
 
-      if (ptrace (PTRACE_SETREGS, tid, 0, (long) &regs) < 0)
+      if (ptrace (PTRACE_SETREGS, tid, 0, (long long) &regs) < 0)
 	perror_with_name (_("Couldn't write registers"));
 
       if (regnum != -1)
@@ -258,23 +258,23 @@ amd64_linux_nat_target::store_registers (struct regcache *regcache, int regnum)
 	  iov.iov_base = xstateregs;
 	  iov.iov_len = sizeof (xstateregs);
 	  if (ptrace (PTRACE_GETREGSET, tid,
-		      (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
+		      (unsigned int) NT_X86_XSTATE, (long long) &iov) < 0)
 	    perror_with_name (_("Couldn't get extended state status"));
 
 	  amd64_collect_xsave (regcache, regnum, xstateregs, 0);
 
 	  if (ptrace (PTRACE_SETREGSET, tid,
-		      (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
+		      (unsigned int) NT_X86_XSTATE, (long long) &iov) < 0)
 	    perror_with_name (_("Couldn't write extended state status"));
 	}
       else
 	{
-	  if (ptrace (PTRACE_GETFPREGS, tid, 0, (long) &fpregs) < 0)
+	  if (ptrace (PTRACE_GETFPREGS, tid, 0, (long long) &fpregs) < 0)
 	    perror_with_name (_("Couldn't get floating point status"));
 
 	  amd64_collect_fxsave (regcache, regnum, &fpregs);
 
-	  if (ptrace (PTRACE_SETFPREGS, tid, 0, (long) &fpregs) < 0)
+	  if (ptrace (PTRACE_SETFPREGS, tid, 0, (long long) &fpregs) < 0)
 	    perror_with_name (_("Couldn't write floating point status"));
 	}
 
@@ -317,13 +317,13 @@ ps_get_thread_area (struct ps_prochandle *ph,
       unsigned int base_addr;
       ps_err_e result;
 
-      result = x86_linux_get_thread_area (lwpid, (void *) (long) idx,
+      result = x86_linux_get_thread_area (lwpid, (void *) (long long) idx,
 					  &base_addr);
       if (result == PS_OK)
 	{
 	  /* Extend the value to 64 bits.  Here it's assumed that
 	     a "long" and a "void *" are the same.  */
-	  (*base) = (void *) (long) base_addr;
+	  (*base) = (void *) (long long) base_addr;
 	}
       return result;
     }
@@ -342,7 +342,7 @@ ps_get_thread_area (struct ps_prochandle *ph,
 	      /* PTRACE_ARCH_PRCTL is obsolete since 2.6.25, where the
 		 fs_base and gs_base fields of user_regs_struct can be
 		 used directly.  */
-	      unsigned long fs;
+	      unsigned long long fs;
 	      errno = 0;
 	      fs = ptrace (PTRACE_PEEKUSER, lwpid,
 			   offsetof (struct user_regs_struct, fs_base), 0);
@@ -359,7 +359,7 @@ ps_get_thread_area (struct ps_prochandle *ph,
 	case GS:
 #ifdef HAVE_STRUCT_USER_REGS_STRUCT_GS_BASE
 	    {
-	      unsigned long gs;
+	      unsigned long long gs;
 	      errno = 0;
 	      gs = ptrace (PTRACE_PEEKUSER, lwpid,
 			   offsetof (struct user_regs_struct, gs_base), 0);
diff --git a/gdb/amd64-windows-tdep.c b/gdb/amd64-windows-tdep.c
index 904875b..08ed3fa 100644
--- a/gdb/amd64-windows-tdep.c
+++ b/gdb/amd64-windows-tdep.c
@@ -941,7 +941,7 @@ amd64_windows_find_unwind_info (struct gdbarch *gdbarch, CORE_ADDR pc,
   pe_data_type *pe;
   IMAGE_DATA_DIRECTORY *dir;
   struct objfile *objfile;
-  unsigned long lo, hi;
+  unsigned long long lo, hi;
   CORE_ADDR base;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
 
@@ -969,7 +969,7 @@ amd64_windows_find_unwind_info (struct gdbarch *gdbarch, CORE_ADDR pc,
   *unwind_info = 0;
   while (lo <= hi)
     {
-      unsigned long mid = lo + (hi - lo) / 2;
+      unsigned long long mid = lo + (hi - lo) / 2;
       struct external_pex64_runtime_function d;
       CORE_ADDR sa, ea;
 
diff --git a/gdb/arch/aarch64.c b/gdb/arch/aarch64.c
index 9b19131..13fc162 100644
--- a/gdb/arch/aarch64.c
+++ b/gdb/arch/aarch64.c
@@ -34,7 +34,7 @@ aarch64_create_target_description (uint64_t vq)
   set_tdesc_architecture (tdesc, "aarch64");
 #endif
 
-  long regnum = 0;
+  long long regnum = 0;
 
   regnum = create_feature_aarch64_core (tdesc, regnum);
 
diff --git a/gdb/arch/amd64.c b/gdb/arch/amd64.c
index 4ad17c3..89d3c68 100644
--- a/gdb/arch/amd64.c
+++ b/gdb/arch/amd64.c
@@ -49,7 +49,7 @@ amd64_create_target_description (uint64_t xcr0, bool is_x32, bool is_linux,
     set_tdesc_osabi (tdesc, "GNU/Linux");
 #endif
 
-  long regnum = 0;
+  long long regnum = 0;
 
   if (is_x32)
     regnum = create_feature_i386_x32_core (tdesc, regnum);
diff --git a/gdb/arch/arm-get-next-pcs.c b/gdb/arch/arm-get-next-pcs.c
index 1e63267..8f62ff9 100644
--- a/gdb/arch/arm-get-next-pcs.c
+++ b/gdb/arch/arm-get-next-pcs.c
@@ -268,10 +268,10 @@ thumb_get_next_pcs_raw (struct arm_get_next_pcs *self)
   int byte_order = self->byte_order;
   int byte_order_for_code = self->byte_order_for_code;
   CORE_ADDR pc = regcache_read_pc (self->regcache);
-  unsigned long pc_val = ((unsigned long) pc) + 4;	/* PC after prefetch */
+  unsigned long long pc_val = ((unsigned long long) pc) + 4;	/* PC after prefetch */
   unsigned short inst1;
   CORE_ADDR nextpc = pc + 2;		/* Default is next instruction.  */
-  unsigned long offset;
+  unsigned long long offset;
   ULONGEST status, itstate;
   struct regcache *regcache = self->regcache;
   std::vector<CORE_ADDR> next_pcs;
@@ -415,7 +415,7 @@ thumb_get_next_pcs_raw (struct arm_get_next_pcs *self)
     }
   else if ((inst1 & 0xf000) == 0xd000)	/* conditional branch */
     {
-      unsigned long cond = bits (inst1, 8, 11);
+      unsigned long long cond = bits (inst1, 8, 11);
       if (cond == 0x0f)  /* 0x0f = SWI */
 	{
 	  nextpc = self->ops->syscall_next_pc (self);
@@ -647,15 +647,15 @@ arm_get_next_pcs_raw (struct arm_get_next_pcs *self)
 {
   int byte_order = self->byte_order;
   int byte_order_for_code = self->byte_order_for_code;
-  unsigned long pc_val;
-  unsigned long this_instr = 0;
-  unsigned long status;
+  unsigned long long pc_val;
+  unsigned long long this_instr = 0;
+  unsigned long long status;
   CORE_ADDR nextpc;
   struct regcache *regcache = self->regcache;
   CORE_ADDR pc = regcache_read_pc (self->regcache);
   std::vector<CORE_ADDR> next_pcs;
 
-  pc_val = (unsigned long) pc;
+  pc_val = (unsigned long long) pc;
   this_instr = self->ops->read_mem_uint (pc, 4, byte_order_for_code);
 
   status = regcache_raw_get_unsigned (regcache, ARM_PS_REGNUM);
@@ -690,8 +690,8 @@ arm_get_next_pcs_raw (struct arm_get_next_pcs *self)
 	case 0x2:
 	case 0x3:
 	  {
-	    unsigned long operand1, operand2, result = 0;
-	    unsigned long rn;
+	    unsigned long long operand1, operand2, result = 0;
+	    unsigned long long rn;
 	    int c;
 
 	    if (bits (this_instr, 12, 15) != 15)
@@ -723,8 +723,8 @@ arm_get_next_pcs_raw (struct arm_get_next_pcs *self)
 
 	    if (bit (this_instr, 25))
 	      {
-		unsigned long immval = bits (this_instr, 0, 7);
-		unsigned long rotate = 2 * bits (this_instr, 8, 11);
+		unsigned long long immval = bits (this_instr, 0, 7);
+		unsigned long long rotate = 2 * bits (this_instr, 8, 11);
 		operand2 = ((immval >> rotate) | (immval << (32 - rotate)))
 		  & 0xffffffff;
 	      }
@@ -770,7 +770,7 @@ arm_get_next_pcs_raw (struct arm_get_next_pcs *self)
 	      case 0x9:
 	      case 0xa:
 	      case 0xb:	/* tst, teq, cmp, cmn */
-		result = (unsigned long) nextpc;
+		result = (unsigned long long) nextpc;
 		break;
 
 	      case 0xc:	/*orr */
@@ -811,8 +811,8 @@ arm_get_next_pcs_raw (struct arm_get_next_pcs *self)
 	      if (bits (this_instr, 12, 15) == 15)
 		{
 		  /* rd == pc */
-		  unsigned long rn;
-		  unsigned long base;
+		  unsigned long long rn;
+		  unsigned long long base;
 
 		  if (bit (this_instr, 22))
 		    error (_("Invalid update to pc in instruction"));
@@ -827,7 +827,7 @@ arm_get_next_pcs_raw (struct arm_get_next_pcs *self)
 		    {
 		      /* pre-indexed */
 		      int c = (status & FLAG_C) ? 1 : 0;
-		      unsigned long offset =
+		      unsigned long long offset =
 		      (bit (this_instr, 25)
 		       ? shifted_reg_val (regcache, this_instr, c,
 					  pc_val, status)
@@ -855,14 +855,14 @@ arm_get_next_pcs_raw (struct arm_get_next_pcs *self)
 		  /* loading pc */
 		  int offset = 0;
 		  CORE_ADDR rn_val_offset = 0;
-		  unsigned long rn_val
+		  unsigned long long rn_val
 		    = regcache_raw_get_unsigned (regcache,
 						 bits (this_instr, 16, 19));
 
 		  if (bit (this_instr, 23))
 		    {
 		      /* up */
-		      unsigned long reglist = bits (this_instr, 0, 14);
+		      unsigned long long reglist = bits (this_instr, 0, 14);
 		      offset = bitcount (reglist) * 4;
 		      if (bit (this_instr, 24))		/* pre */
 			offset += 4;
diff --git a/gdb/arch/arm-linux.c b/gdb/arch/arm-linux.c
index 46402fe..bf8cb2c 100644
--- a/gdb/arch/arm-linux.c
+++ b/gdb/arch/arm-linux.c
@@ -26,9 +26,9 @@
 /* Calculate the offset from stack pointer of the pc register on the stack
    in the case of a sigreturn or sigreturn_rt syscall.  */
 int
-arm_linux_sigreturn_next_pc_offset (unsigned long sp,
-				    unsigned long sp_data,
-				    unsigned long svc_number,
+arm_linux_sigreturn_next_pc_offset (unsigned long long sp,
+				    unsigned long long sp_data,
+				    unsigned long long svc_number,
 				    int is_sigreturn)
 {
   /* Offset of R0 register.  */
diff --git a/gdb/arch/arm-linux.h b/gdb/arch/arm-linux.h
index ecfaba5..5e1ad00 100644
--- a/gdb/arch/arm-linux.h
+++ b/gdb/arch/arm-linux.h
@@ -69,9 +69,9 @@
 #define ARM_NEW_SIGFRAME_MAGIC 0x5ac3c35a
 
 int
-arm_linux_sigreturn_next_pc_offset (unsigned long sp,
-				    unsigned long sp_data,
-				    unsigned long svc_number,
+arm_linux_sigreturn_next_pc_offset (unsigned long long sp,
+				    unsigned long long sp_data,
+				    unsigned long long svc_number,
 				    int is_sigreturn);
 
 struct arm_get_next_pcs;
diff --git a/gdb/arch/arm.c b/gdb/arch/arm.c
index 41c91ba..1dd8597 100644
--- a/gdb/arch/arm.c
+++ b/gdb/arch/arm.c
@@ -35,7 +35,7 @@ thumb_insn_size (unsigned short inst1)
 /* See arm.h.  */
 
 int
-bitcount (unsigned long val)
+bitcount (unsigned long long val)
 {
   int nbits;
   for (nbits = 0; val != 0; nbits++)
@@ -46,7 +46,7 @@ bitcount (unsigned long val)
 /* See arm.h.  */
 
 int
-condition_true (unsigned long cond, unsigned long status_reg)
+condition_true (unsigned long long cond, unsigned long long status_reg)
 {
   if (cond == INST_AL || cond == INST_NV)
     return 1;
@@ -322,13 +322,13 @@ thumb2_instruction_changes_pc (unsigned short inst1, unsigned short inst2)
 
 /* See arm.h.  */
 
-unsigned long
-shifted_reg_val (struct regcache *regcache, unsigned long inst,
-		 int carry, unsigned long pc_val, unsigned long status_reg)
+unsigned long long
+shifted_reg_val (struct regcache *regcache, unsigned long long inst,
+		 int carry, unsigned long long pc_val, unsigned long long status_reg)
 {
-  unsigned long res, shift;
+  unsigned long long res, shift;
   int rm = bits (inst, 0, 3);
-  unsigned long shifttype = bits (inst, 5, 6);
+  unsigned long long shifttype = bits (inst, 5, 6);
 
   if (bit (inst, 4))
     {
diff --git a/gdb/arch/arm.h b/gdb/arch/arm.h
index 4f8098c..421f516 100644
--- a/gdb/arch/arm.h
+++ b/gdb/arch/arm.h
@@ -107,9 +107,9 @@ enum arm_breakpoint_kinds
 #define bits(obj,st,fn) (((obj) >> (st)) & submask ((fn) - (st)))
 #define bit(obj,st) (((obj) >> (st)) & 1)
 #define sbits(obj,st,fn) \
-  ((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))
+  ((long long) (bits(obj,st,fn) | ((long long) bit(obj,fn) * ~ submask (fn - st))))
 #define BranchDest(addr,instr) \
-  ((CORE_ADDR) (((unsigned long) (addr)) + 8 + (sbits (instr, 0, 23) << 2)))
+  ((CORE_ADDR) (((unsigned long long) (addr)) + 8 + (sbits (instr, 0, 23) << 2)))
 
 /* Forward declaration.  */
 struct regcache;
@@ -119,10 +119,10 @@ struct regcache;
 int thumb_insn_size (unsigned short inst1);
 
 /* Returns true if the condition evaluates to true.  */
-int condition_true (unsigned long cond, unsigned long status_reg);
+int condition_true (unsigned long long cond, unsigned long long status_reg);
 
 /* Return number of 1-bits in VAL.  */
-int bitcount (unsigned long val);
+int bitcount (unsigned long long val);
 
 /* Return 1 if THIS_INSTR might change control flow, 0 otherwise.  */
 int arm_instruction_changes_pc (uint32_t this_instr);
@@ -140,10 +140,10 @@ int thumb_advance_itstate (unsigned int itstate);
 
 /* Decode shifted register value.  */
 
-unsigned long shifted_reg_val (struct regcache *regcache,
-			       unsigned long inst,
+unsigned long long shifted_reg_val (struct regcache *regcache,
+			       unsigned long long inst,
 			       int carry,
-			       unsigned long pc_val,
-			       unsigned long status_reg);
+			       unsigned long long pc_val,
+			       unsigned long long status_reg);
 
 #endif
diff --git a/gdb/arch/i386.c b/gdb/arch/i386.c
index 92b6973..f2a8cb7 100644
--- a/gdb/arch/i386.c
+++ b/gdb/arch/i386.c
@@ -42,7 +42,7 @@ i386_create_target_description (uint64_t xcr0, bool is_linux)
     set_tdesc_osabi (tdesc, "GNU/Linux");
 #endif
 
-  long regnum = 0;
+  long long regnum = 0;
 
   if (xcr0 & X86_XSTATE_X87)
     regnum = create_feature_i386_32bit_core (tdesc, regnum);
diff --git a/gdb/arch/tic6x.c b/gdb/arch/tic6x.c
index 6b57baa..25ee1c3 100644
--- a/gdb/arch/tic6x.c
+++ b/gdb/arch/tic6x.c
@@ -33,7 +33,7 @@ tic6x_create_target_description (enum c6x_feature feature)
   set_tdesc_architecture (tdesc, "tic6x");
   set_tdesc_osabi (tdesc, "GNU/Linux");
 
-  long regnum = 0;
+  long long regnum = 0;
 
   regnum = create_feature_tic6x_core (tdesc, regnum);
 
diff --git a/gdb/arm-linux-tdep.c b/gdb/arm-linux-tdep.c
index 4c5a4bc..9ac18a1 100644
--- a/gdb/arm-linux-tdep.c
+++ b/gdb/arm-linux-tdep.c
@@ -757,7 +757,7 @@ arm_linux_core_read_description (struct gdbarch *gdbarch,
    rt_sigreturn/sigreturn syscall.  */
 static int
 arm_linux_sigreturn_return_addr (struct frame_info *frame,
-				 unsigned long svc_number,
+				 unsigned long long svc_number,
 				 CORE_ADDR *pc, int *is_thumb)
 {
   /* Is this a sigreturn or rt_sigreturn syscall?  */
@@ -783,10 +783,10 @@ arm_linux_sigreturn_return_addr (struct frame_info *frame,
 
 static CORE_ADDR
 arm_linux_sigreturn_next_pc (struct regcache *regcache,
-			     unsigned long svc_number, int *is_thumb)
+			     unsigned long long svc_number, int *is_thumb)
 {
   ULONGEST sp;
-  unsigned long sp_data;
+  unsigned long long sp_data;
   CORE_ADDR next_pc = 0;
   struct gdbarch *gdbarch = regcache->arch ();
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
@@ -845,10 +845,10 @@ arm_linux_get_syscall_number (struct gdbarch *gdbarch,
 
       /* PC gets incremented before the syscall-stop, so read the
 	 previous instruction.  */
-      unsigned long this_instr = 
+      unsigned long long this_instr = 
 	read_memory_unsigned_integer (pc - 4, 4, byte_order_for_code);
 
-      unsigned long svc_operand = (0x00ffffff & this_instr);
+      unsigned long long svc_operand = (0x00ffffff & this_instr);
 
       if (svc_operand)
 	{
@@ -883,10 +883,10 @@ arm_linux_get_next_pcs_syscall_next_pc (struct arm_get_next_pcs *self)
       struct gdbarch *gdbarch = self->regcache->arch ();
       enum bfd_endian byte_order_for_code = 
 	gdbarch_byte_order_for_code (gdbarch);
-      unsigned long this_instr = 
+      unsigned long long this_instr = 
 	read_memory_unsigned_integer (pc, 4, byte_order_for_code);
 
-      unsigned long svc_operand = (0x00ffffff & this_instr);
+      unsigned long long svc_operand = (0x00ffffff & this_instr);
       if (svc_operand)  /* OABI.  */
 	{
 	  svc_number = svc_operand - 0x900000;
@@ -962,7 +962,7 @@ arm_linux_cleanup_svc (struct gdbarch *gdbarch,
   if (debug_displaced)
     {
       fprintf_unfiltered (gdb_stdlog, "displaced: PC is apparently %.8lx after "
-			  "SVC step ", (unsigned long) apparent_pc);
+			  "SVC step ", (unsigned long long) apparent_pc);
       if (within_scratch)
         fprintf_unfiltered (gdb_stdlog, "(within scratch space)\n");
       else
@@ -997,12 +997,12 @@ arm_linux_copy_svc (struct gdbarch *gdbarch, struct regcache *regs,
 	fprintf_unfiltered (gdb_stdlog, "displaced: found "
 			    "sigreturn/rt_sigreturn SVC call.  PC in "
 			    "frame = %lx\n",
-			    (unsigned long) get_frame_pc (frame));
+			    (unsigned long long) get_frame_pc (frame));
 
       if (debug_displaced)
 	fprintf_unfiltered (gdb_stdlog, "displaced: unwind pc = %lx.  "
 			    "Setting momentary breakpoint.\n",
-			    (unsigned long) return_to);
+			    (unsigned long long) return_to);
 
       gdb_assert (inferior_thread ()->control.step_resume_breakpoint
 		  == NULL);
@@ -1118,7 +1118,7 @@ arm_linux_displaced_step_copy_insn (struct gdbarch *gdbarch,
     {
       if (debug_displaced)
         fprintf_unfiltered (gdb_stdlog, "displaced: detected kernel helper "
-			    "at %.8lx\n", (unsigned long) from);
+			    "at %.8lx\n", (unsigned long long) from);
 
       arm_catch_kernel_helper_return (gdbarch, from, to, regs, dsc);
     }
@@ -1170,7 +1170,7 @@ arm_stap_parse_special_token (struct gdbarch *gdbarch,
       char *regname;
       int len, offset;
       int got_minus = 0;
-      long displacement;
+      long long displacement;
       struct stoken str;
 
       ++tmp;
@@ -1656,7 +1656,7 @@ arm_all_but_pc_registers_record (struct regcache *regcache)
 /* Handler for arm system call instruction recording.  */
 
 static int
-arm_linux_syscall_record (struct regcache *regcache, unsigned long svc_number)
+arm_linux_syscall_record (struct regcache *regcache, unsigned long long svc_number)
 {
   int ret = 0;
   enum gdb_syscall syscall_gdb;
diff --git a/gdb/arm-symbian-tdep.c b/gdb/arm-symbian-tdep.c
index aa3179d..7245b43 100644
--- a/gdb/arm-symbian-tdep.c
+++ b/gdb/arm-symbian-tdep.c
@@ -88,7 +88,7 @@ static enum gdb_osabi
 arm_symbian_osabi_sniffer (bfd *abfd)
 {
   Elf_Internal_Phdr *phdrs;
-  long phdrs_size;
+  long long phdrs_size;
   int num_phdrs, i;
 
   /* Symbian executables are always shared objects (ET_DYN).  */
diff --git a/gdb/arm-tdep.c b/gdb/arm-tdep.c
index fdfb360..e928d99 100644
--- a/gdb/arm-tdep.c
+++ b/gdb/arm-tdep.c
@@ -410,8 +410,8 @@ arm_pc_is_thumb (struct gdbarch *gdbarch, CORE_ADDR memaddr)
       if (debug_displaced)
 	fprintf_unfiltered (gdb_stdlog,
 			    "displaced: check mode of %.8lx instead of %.8lx\n",
-			    (unsigned long) dsc->insn_addr,
-			    (unsigned long) memaddr);
+			    (unsigned long long) dsc->insn_addr,
+			    (unsigned long long) memaddr);
       memaddr = dsc->insn_addr;
     }
 
@@ -3942,7 +3942,7 @@ static void
 arm_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,
 		      struct frame_info *frame, const char *args)
 {
-  unsigned long status = get_frame_register_unsigned (frame, ARM_FPS_REGNUM);
+  unsigned long long status = get_frame_register_unsigned (frame, ARM_FPS_REGNUM);
   int type;
 
   type = (status >> 24) & 127;
@@ -4425,7 +4425,7 @@ displaced_read_reg (struct regcache *regs, arm_displaced_step_closure *dsc,
 
       if (debug_displaced)
 	fprintf_unfiltered (gdb_stdlog, "displaced: read pc value %.8lx\n",
-			    (unsigned long) from);
+			    (unsigned long long) from);
       return (ULONGEST) from;
     }
   else
@@ -4433,7 +4433,7 @@ displaced_read_reg (struct regcache *regs, arm_displaced_step_closure *dsc,
       regcache_cooked_read_unsigned (regs, regno, &ret);
       if (debug_displaced)
 	fprintf_unfiltered (gdb_stdlog, "displaced: read r%d value %.8lx\n",
-			    regno, (unsigned long) ret);
+			    regno, (unsigned long long) ret);
       return ret;
     }
 }
@@ -4531,7 +4531,7 @@ displaced_write_reg (struct regcache *regs, arm_displaced_step_closure *dsc,
     {
       if (debug_displaced)
 	fprintf_unfiltered (gdb_stdlog, "displaced: writing pc %.8lx\n",
-			    (unsigned long) val);
+			    (unsigned long long) val);
       switch (write_pc)
 	{
 	case BRANCH_WRITE_PC:
@@ -4566,7 +4566,7 @@ displaced_write_reg (struct regcache *regs, arm_displaced_step_closure *dsc,
     {
       if (debug_displaced)
 	fprintf_unfiltered (gdb_stdlog, "displaced: writing r%d value %.8lx\n",
-			    regno, (unsigned long) val);
+			    regno, (unsigned long long) val);
       regcache_cooked_write_unsigned (regs, regno, val);
     }
 }
@@ -4612,7 +4612,7 @@ arm_copy_unmodified (struct gdbarch *gdbarch, uint32_t insn,
 {
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying insn %.8lx, "
-			"opcode/class '%s' unmodified\n", (unsigned long) insn,
+			"opcode/class '%s' unmodified\n", (unsigned long long) insn,
 			iname);
 
   dsc->modinsn[0] = insn;
@@ -4695,7 +4695,7 @@ arm_copy_preload (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying preload insn %.8lx\n",
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   dsc->modinsn[0] = insn & 0xfff0ffff;
 
@@ -4792,7 +4792,7 @@ arm_copy_preload_reg (struct gdbarch *gdbarch, uint32_t insn,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying preload insn %.8lx\n",
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   dsc->modinsn[0] = (insn & 0xfff0fff0) | 0x1;
 
@@ -4854,7 +4854,7 @@ arm_copy_copro_load_store (struct gdbarch *gdbarch, uint32_t insn,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying coprocessor "
-			"load/store insn %.8lx\n", (unsigned long) insn);
+			"load/store insn %.8lx\n", (unsigned long long) insn);
 
   dsc->modinsn[0] = insn & 0xfff0ffff;
 
@@ -4926,7 +4926,7 @@ cleanup_branch (struct gdbarch *gdbarch, struct regcache *regs,
 static void
 install_b_bl_blx (struct gdbarch *gdbarch, struct regcache *regs,
 		  arm_displaced_step_closure *dsc,
-		  unsigned int cond, int exchange, int link, long offset)
+		  unsigned int cond, int exchange, int link, long long offset)
 {
   /* Implement "BL<cond> <label>" as:
 
@@ -4959,12 +4959,12 @@ arm_copy_b_bl_blx (struct gdbarch *gdbarch, uint32_t insn,
   unsigned int cond = bits (insn, 28, 31);
   int exchange = (cond == 0xf);
   int link = exchange || bit (insn, 24);
-  long offset;
+  long long offset;
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying %s immediate insn "
 			"%.8lx\n", (exchange) ? "blx" : (link) ? "bl" : "b",
-			(unsigned long) insn);
+			(unsigned long long) insn);
   if (exchange)
     /* For BLX, set bit 0 of the destination.  The cleanup_branch function will
        then arrange the switch into Thumb mode.  */
@@ -4989,7 +4989,7 @@ thumb2_copy_b_bl_blx (struct gdbarch *gdbarch, uint16_t insn1,
   int link = bit (insn2, 14);
   int exchange = link && !bit (insn2, 12);
   int cond = INST_AL;
-  long offset = 0;
+  long long offset = 0;
   int j1 = bit (insn2, 13);
   int j2 = bit (insn2, 11);
   int s = sbits (insn1, 10, 10);
@@ -5112,7 +5112,7 @@ arm_copy_bx_blx_reg (struct gdbarch *gdbarch, uint32_t insn,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying insn %.8lx",
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   dsc->modinsn[0] = ARM_NOP;
 
@@ -5168,7 +5168,7 @@ arm_copy_alu_imm (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying immediate %s insn "
 			"%.8lx\n", is_mov ? "move" : "ALU",
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   /* Instruction is of form:
 
@@ -5314,7 +5314,7 @@ arm_copy_alu_reg (struct gdbarch *gdbarch, uint32_t insn, struct regcache *regs,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying reg %s insn %.8lx\n",
-			is_mov ? "move" : "ALU", (unsigned long) insn);
+			is_mov ? "move" : "ALU", (unsigned long long) insn);
 
   if (is_mov)
     dsc->modinsn[0] = (insn & 0xfff00ff0) | 0x2;
@@ -5419,7 +5419,7 @@ arm_copy_alu_shifted_reg (struct gdbarch *gdbarch, uint32_t insn,
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying shifted reg %s insn "
 			"%.8lx\n", is_mov ? "move" : "ALU",
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   rn = bits (insn, 16, 19);
   rm = bits (insn, 0, 3);
@@ -5511,7 +5511,7 @@ arm_copy_extra_ld_st (struct gdbarch *gdbarch, uint32_t insn, int unprivileged,
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying %sextra load/store "
 			"insn %.8lx\n", unprivileged ? "unprivileged " : "",
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   opcode = ((op2 << 2) | (op1 & 0x1) | ((op1 & 0x4) >> 1)) - 4;
 
@@ -5745,7 +5745,7 @@ arm_copy_ldr_str_ldrb_strb (struct gdbarch *gdbarch, uint32_t insn,
 			load ? (size == 1 ? "ldrb" : "ldr")
 			     : (size == 1 ? "strb" : "str"), usermode ? "t" : "",
 			rt, rn,
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   install_load_store (gdbarch, regs, dsc, load, immed, writeback, size,
 		      usermode, rt, rm, rn);
@@ -5879,7 +5879,7 @@ cleanup_block_store_pc (struct gdbarch *gdbarch, struct regcache *regs,
   CORE_ADDR pc_stored_at, transferred_regs = bitcount (dsc->u.block.regmask);
   CORE_ADDR stm_insn_addr;
   uint32_t pc_val;
-  long offset;
+  long long offset;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
 
   /* If condition code fails, there's nothing else to do.  */
@@ -6026,7 +6026,7 @@ arm_copy_block_xfer (struct gdbarch *gdbarch, uint32_t insn,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying block transfer insn "
-			"%.8lx\n", (unsigned long) insn);
+			"%.8lx\n", (unsigned long long) insn);
 
   dsc->u.block.xfer_addr = displaced_read_reg (regs, dsc, rn);
   dsc->u.block.rn = rn;
@@ -6269,7 +6269,7 @@ cleanup_svc (struct gdbarch *gdbarch, struct regcache *regs,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: cleanup for svc, resume at "
-			"%.8lx\n", (unsigned long) resume_addr);
+			"%.8lx\n", (unsigned long long) resume_addr);
 
   displaced_write_reg (regs, dsc, ARM_PC_REGNUM, resume_addr, BRANCH_WRITE_PC);
 }
@@ -6306,7 +6306,7 @@ arm_copy_svc (struct gdbarch *gdbarch, uint32_t insn,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying svc insn %.8lx\n",
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   dsc->modinsn[0] = insn;
 
@@ -6336,7 +6336,7 @@ arm_copy_undef (struct gdbarch *gdbarch, uint32_t insn,
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog,
 			"displaced: copying undefined insn %.8lx\n",
-			(unsigned long) insn);
+			(unsigned long long) insn);
 
   dsc->modinsn[0] = insn;
 
@@ -6368,7 +6368,7 @@ arm_copy_unpred (struct gdbarch *gdbarch, uint32_t insn,
 {
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: copying unpredictable insn "
-			"%.8lx\n", (unsigned long) insn);
+			"%.8lx\n", (unsigned long long) insn);
 
   dsc->modinsn[0] = insn;
 
@@ -7529,7 +7529,7 @@ thumb_process_displaced_insn (struct gdbarch *gdbarch, CORE_ADDR from,
 
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: process thumb insn %.4x "
-			"at %.8lx\n", insn1, (unsigned long) from);
+			"at %.8lx\n", insn1, (unsigned long long) from);
 
   dsc->is_thumb = 1;
   dsc->insn_size = thumb_insn_size (insn1);
@@ -7568,8 +7568,8 @@ arm_process_displaced_insn (struct gdbarch *gdbarch, CORE_ADDR from,
   insn = read_memory_unsigned_integer (from, 4, byte_order_for_code);
   if (debug_displaced)
     fprintf_unfiltered (gdb_stdlog, "displaced: stepping insn %.8lx "
-			"at %.8lx\n", (unsigned long) insn,
-			(unsigned long) from);
+			"at %.8lx\n", (unsigned long long) insn,
+			(unsigned long long) from);
 
   if ((insn & 0xf0000000) == 0xf0000000)
     err = arm_decode_unconditional (gdbarch, insn, regs, dsc);
@@ -7628,7 +7628,7 @@ arm_displaced_init_closure (struct gdbarch *gdbarch, CORE_ADDR from,
 				(unsigned short)dsc->modinsn[i]);
 
 	  fprintf_unfiltered (gdb_stdlog, " at %.8lx\n",
-			      (unsigned long) to + offset);
+			      (unsigned long long) to + offset);
 
 	}
       write_memory_unsigned_integer (to + offset, size,
@@ -9519,7 +9519,7 @@ arm_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)
     return;
 
   fprintf_unfiltered (file, _("arm_dump_tdep: Lowest pc = 0x%lx"),
-		      (unsigned long) tdep->lowest_pc);
+		      (unsigned long long) tdep->lowest_pc);
 }
 
 #if GDB_SELF_TEST
@@ -9532,7 +9532,7 @@ static void arm_record_test (void);
 void
 _initialize_arm_tdep (void)
 {
-  long length;
+  long long length;
   int i, j;
   char regdesc[1024], *rdptr = regdesc;
   size_t rest = sizeof (regdesc);
diff --git a/gdb/arm-tdep.h b/gdb/arm-tdep.h
index 8fa8b68..0cc8989 100644
--- a/gdb/arm-tdep.h
+++ b/gdb/arm-tdep.h
@@ -142,7 +142,7 @@ struct gdbarch_tdep
   struct type *neon_quad_type;
 
    /* syscall record.  */
-  int (*arm_syscall_record) (struct regcache *regcache, unsigned long svc_number);
+  int (*arm_syscall_record) (struct regcache *regcache, unsigned long long svc_number);
 };
 
 /* Structures used for displaced stepping.  */
@@ -172,7 +172,7 @@ struct arm_displaced_step_closure : public displaced_step_closure
 
     struct
     {
-      unsigned long dest;
+      unsigned long long dest;
       unsigned int link : 1;
       unsigned int exchange : 1;
       unsigned int cond : 4;
@@ -215,7 +215,7 @@ struct arm_displaced_step_closure : public displaced_step_closure
      - ARM instruction occupies one slot,
      - Thumb 16 bit instruction occupies one slot,
      - Thumb 32-bit instruction occupies *two* slots, one part for each.  */
-  unsigned long modinsn[DISPLACED_MODIFIED_INSNS];
+  unsigned long long modinsn[DISPLACED_MODIFIED_INSNS];
   int numinsns;
   CORE_ADDR insn_addr;
   CORE_ADDR scratch_base;
diff --git a/gdb/arm-wince-tdep.c b/gdb/arm-wince-tdep.c
index 84e4ad7..75b41bc 100644
--- a/gdb/arm-wince-tdep.c
+++ b/gdb/arm-wince-tdep.c
@@ -97,9 +97,9 @@ arm_wince_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
   if ((this_instr & 0xfff00000) == 0xeb000000)
     {
 #define sign_extend(V, N) \
-  (((long) (V) ^ (1L << ((N) - 1))) - (1L << ((N) - 1)))
+  (((long long) (V) ^ (1L << ((N) - 1))) - (1L << ((N) - 1)))
 
-      long offset = sign_extend (this_instr & 0x000fffff, 23) << 2;
+      long long offset = sign_extend (this_instr & 0x000fffff, 23) << 2;
       CORE_ADDR call_dest = (pc + 8 + offset) & 0xffffffffU;
       struct bound_minimal_symbol s = lookup_minimal_symbol_by_pc (call_dest);
 
diff --git a/gdb/bcache.c b/gdb/bcache.c
index a674a85..2ff496b 100644
--- a/gdb/bcache.c
+++ b/gdb/bcache.c
@@ -67,25 +67,25 @@ struct bcache
   struct bstring **bucket;
 
   /* Statistics.  */
-  unsigned long unique_count;	/* number of unique strings */
-  long total_count;	/* total number of strings cached, including dups */
-  long unique_size;	/* size of unique strings, in bytes */
-  long total_size;      /* total number of bytes cached, including dups */
-  long structure_size;	/* total size of bcache, including infrastructure */
+  unsigned long long unique_count;	/* number of unique strings */
+  long long total_count;	/* total number of strings cached, including dups */
+  long long unique_size;	/* size of unique strings, in bytes */
+  long long total_size;      /* total number of bytes cached, including dups */
+  long long structure_size;	/* total size of bcache, including infrastructure */
   /* Number of times that the hash table is expanded and hence
      re-built, and the corresponding number of times that a string is
      [re]hashed as part of entering it into the expanded table.  The
      total number of hashes can be computed by adding TOTAL_COUNT to
      expand_hash_count.  */
-  unsigned long expand_count;
-  unsigned long expand_hash_count;
+  unsigned long long expand_count;
+  unsigned long long expand_hash_count;
   /* Number of times that the half-hash compare hit (compare the upper
      16 bits of hash values) hit, but the corresponding combined
      length/data compare missed.  */
-  unsigned long half_hash_miss_count;
+  unsigned long long half_hash_miss_count;
 
   /* Hash function to be used for this bcache object.  */
-  unsigned long (*hash_function)(const void *addr, int length);
+  unsigned long long (*hash_function)(const void *addr, int length);
 
   /* Compare function to be used for this bcache object.  */
   int (*compare_function)(const void *, const void *, int length);
@@ -94,7 +94,7 @@ struct bcache
 /* The old hash function was stolen from SDBM. This is what DB 3.0
    uses now, and is better than the old one.  */
 
-unsigned long
+unsigned long long
 hash(const void *addr, int length)
 {
   return hash_continue (addr, length, 0);
@@ -102,8 +102,8 @@ hash(const void *addr, int length)
 
 /* Continue the calculation of the hash H at the given address.  */
 
-unsigned long
-hash_continue (const void *addr, int length, unsigned long h)
+unsigned long long
+hash_continue (const void *addr, int length, unsigned long long h)
 {
   const unsigned char *k, *e;
 
@@ -131,7 +131,7 @@ expand_hash_table (struct bcache *bcache)
      so we roughly double the table size each time.  After we fall off 
      the end of this table, we just double.  Don't laugh --- there have
      been executables sighted with a gigabyte of debug info.  */
-  static unsigned long sizes[] = { 
+  static unsigned long long sizes[] = { 
     1021, 2053, 4099, 8191, 16381, 32771,
     65537, 131071, 262144, 524287, 1048573, 2097143,
     4194301, 8388617, 16777213, 33554467, 67108859, 134217757,
@@ -217,7 +217,7 @@ bcache (const void *addr, int length, struct bcache *cache)
 const void *
 bcache_full (const void *addr, int length, struct bcache *bcache, int *added)
 {
-  unsigned long full_hash;
+  unsigned long long full_hash;
   unsigned short half_hash;
   int hash_index;
   struct bstring *s;
@@ -303,7 +303,7 @@ bcache_compare (const void *addr1, const void *addr2, int length)
    COMPARE_FUNCTION is NULL memcmp() is used.  */
 
 struct bcache *
-bcache_xmalloc (unsigned long (*hash_function)(const void *, int length),
+bcache_xmalloc (unsigned long long (*hash_function)(const void *, int length),
                 int (*compare_function)(const void *, 
 					const void *, 
 					int length))
diff --git a/gdb/bcache.h b/gdb/bcache.h
index 41014b7..7dfa771 100644
--- a/gdb/bcache.h
+++ b/gdb/bcache.h
@@ -158,7 +158,7 @@ extern void bcache_xfree (struct bcache *bcache);
 
 /* Create a new bcache object.  */
 extern struct bcache *bcache_xmalloc (
-    unsigned long (*hash_function)(const void *, int length),
+    unsigned long long (*hash_function)(const void *, int length),
     int (*compare_function)(const void *, const void *, int length));
 
 /* Print statistics on BCACHE's memory usage and efficacity at
@@ -169,8 +169,8 @@ extern void print_bcache_statistics (struct bcache *bcache, const char *type);
 extern int bcache_memory_used (struct bcache *bcache);
 
 /* The hash functions */
-extern unsigned long hash(const void *addr, int length);
-extern unsigned long hash_continue (const void *addr, int length,
-                                    unsigned long h);
+extern unsigned long long hash(const void *addr, int length);
+extern unsigned long long hash_continue (const void *addr, int length,
+                                    unsigned long long h);
 
 #endif /* BCACHE_H */
diff --git a/gdb/bfin-tdep.c b/gdb/bfin-tdep.c
index da62130..76db70f 100644
--- a/gdb/bfin-tdep.c
+++ b/gdb/bfin-tdep.c
@@ -257,7 +257,7 @@ struct bfin_frame_cache
   CORE_ADDR saved_sp;
 
   /* Stack space reserved for local variables.  */
-  long locals;
+  long long locals;
 };
 
 /* Allocate and initialize a frame cache.  */
@@ -503,7 +503,7 @@ bfin_push_dummy_call (struct gdbarch *gdbarch,
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int i;
-  long reg_r0, reg_r1, reg_r2;
+  long long reg_r0, reg_r1, reg_r2;
   int total_len = 0;
 
   for (i = nargs - 1; i >= 0; i--)
diff --git a/gdb/breakpoint.c b/gdb/breakpoint.c
index 2c031c0..ef48d42 100644
--- a/gdb/breakpoint.c
+++ b/gdb/breakpoint.c
@@ -6926,8 +6926,8 @@ breakpoint_adjustment_warning (CORE_ADDR from_addr, CORE_ADDR to_addr,
   char astr1[64];
   char astr2[64];
 
-  strcpy (astr1, hex_string_custom ((unsigned long) from_addr, 8));
-  strcpy (astr2, hex_string_custom ((unsigned long) to_addr, 8));
+  strcpy (astr1, hex_string_custom ((unsigned long long) from_addr, 8));
+  strcpy (astr2, hex_string_custom ((unsigned long long) to_addr, 8));
   if (have_bnum)
     warning (_("Breakpoint %d address previously adjusted from %s to %s."),
              bnum, astr1, astr2);
diff --git a/gdb/breakpoint.h b/gdb/breakpoint.h
index 7da9452..20d2c6c 100644
--- a/gdb/breakpoint.h
+++ b/gdb/breakpoint.h
@@ -879,7 +879,7 @@ struct tracepoint : public breakpoint
 {
   /* Number of times this tracepoint should single-step and collect
      additional data.  */
-  long step_count;
+  long long step_count;
 
   /* Number of times this tracepoint should be hit before
      disabling/ending.  */
diff --git a/gdb/bsd-kvm.c b/gdb/bsd-kvm.c
index 078cd30..0178edb 100644
--- a/gdb/bsd-kvm.c
+++ b/gdb/bsd-kvm.c
@@ -216,7 +216,7 @@ bsd_kvm_fetch_pcb (struct regcache *regcache, struct pcb *paddr)
 {
   struct pcb pcb;
 
-  if (kvm_read (core_kd, (unsigned long) paddr, &pcb, sizeof pcb) == -1)
+  if (kvm_read (core_kd, (unsigned long long) paddr, &pcb, sizeof pcb) == -1)
     error (("%s"), kvm_geterr (core_kd));
 
   gdb_assert (bsd_kvm_supply_pcb);
diff --git a/gdb/btrace.c b/gdb/btrace.c
index 35dc90e..1553e03 100644
--- a/gdb/btrace.c
+++ b/gdb/btrace.c
@@ -3183,7 +3183,7 @@ get_uint (const char **arg)
 {
   const char *begin, *pos;
   char *end;
-  unsigned long number;
+  unsigned long long number;
 
   begin = *arg;
   pos = skip_spaces (begin);
@@ -3211,7 +3211,7 @@ get_context_size (const char **arg)
     error (_("Expected positive number, got: %s."), pos);
 
   char *end;
-  long result = strtol (pos, &end, 10);
+  long long result = strtol (pos, &end, 10);
   *arg = end;
   return result;
 }
diff --git a/gdb/c-lang.c b/gdb/c-lang.c
index 5ad5801..0853b6e 100644
--- a/gdb/c-lang.c
+++ b/gdb/c-lang.c
@@ -376,7 +376,7 @@ static char *
 convert_ucn (char *p, char *limit, const char *dest_charset,
 	     struct obstack *output, int length)
 {
-  unsigned long result = 0;
+  unsigned long long result = 0;
   gdb_byte data[4];
   int i;
 
@@ -399,7 +399,7 @@ convert_ucn (char *p, char *limit, const char *dest_charset,
    OUTPUT.  TYPE is the target character type.  */
 
 static void
-emit_numeric_character (struct type *type, unsigned long value,
+emit_numeric_character (struct type *type, unsigned long long value,
 			struct obstack *output)
 {
   gdb_byte *buffer;
@@ -419,7 +419,7 @@ convert_octal (struct type *type, char *p,
 	       char *limit, struct obstack *output)
 {
   int i;
-  unsigned long value = 0;
+  unsigned long long value = 0;
 
   for (i = 0;
        i < 3 && p < limit && ISDIGIT (*p) && *p != '8' && *p != '9';
@@ -443,7 +443,7 @@ static char *
 convert_hex (struct type *type, char *p,
 	     char *limit, struct obstack *output)
 {
-  unsigned long value = 0;
+  unsigned long long value = 0;
 
   while (p < limit && ISXDIGIT (*p))
     {
diff --git a/gdb/charset.c b/gdb/charset.c
index fcb24a4..a90c332 100644
--- a/gdb/charset.c
+++ b/gdb/charset.c
@@ -138,7 +138,7 @@ phony_iconv (iconv_t utf_flag, const char **inbuf, size_t *inbytesleft,
 	= utf_flag == 1 ? BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;
       while (*inbytesleft >= 4)
 	{
-	  unsigned long c
+	  unsigned long long c
 	    = extract_unsigned_integer ((const gdb_byte *)*inbuf, 4, endian);
 
 	  if (c >= 256)
diff --git a/gdb/cli/cli-dump.c b/gdb/cli/cli-dump.c
index e9e393c..1864f0f 100644
--- a/gdb/cli/cli-dump.c
+++ b/gdb/cli/cli-dump.c
@@ -441,16 +441,16 @@ restore_section_callback (bfd *ibfd, asection *isec, void *args)
 
   printf_filtered ("Restoring section %s (0x%lx to 0x%lx)",
 		   bfd_section_name (ibfd, isec), 
-		   (unsigned long) sec_start, 
-		   (unsigned long) sec_end);
+		   (unsigned long long) sec_start, 
+		   (unsigned long long) sec_end);
 
   if (data->load_offset != 0 || data->load_start != 0 || data->load_end != 0)
     printf_filtered (" into memory (%s to %s)\n",
 		     paddress (target_gdbarch (),
-			       (unsigned long) sec_start
+			       (unsigned long long) sec_start
 			       + sec_offset + data->load_offset), 
 		     paddress (target_gdbarch (),
-			       (unsigned long) sec_start + sec_offset
+			       (unsigned long long) sec_start + sec_offset
 				+ data->load_offset + sec_load_count));
   else
     puts_filtered ("\n");
@@ -466,7 +466,7 @@ static void
 restore_binary_file (const char *filename, struct callback_data *data)
 {
   gdb_file_up file = gdb_fopen_cloexec (filename, FOPEN_RB);
-  long len;
+  long long len;
 
   /* Get the file size for reading.  */
   if (fseek (file.get (), 0, SEEK_END) == 0)
@@ -492,8 +492,8 @@ restore_binary_file (const char *filename, struct callback_data *data)
   printf_filtered 
     ("Restoring binary file %s into memory (0x%lx to 0x%lx)\n", 
      filename, 
-     (unsigned long) (data->load_start + data->load_offset),
-     (unsigned long) (data->load_start + data->load_offset + len));
+     (unsigned long long) (data->load_start + data->load_offset),
+     (unsigned long long) (data->load_start + data->load_offset + len));
 
   /* Now set the file pos to the requested load start pos.  */
   if (fseek (file.get (), data->load_start, SEEK_SET) != 0)
@@ -559,9 +559,9 @@ restore_command (const char *args, int from_tty)
 
   if (info_verbose)
     printf_filtered ("Restore file %s offset 0x%lx start 0x%lx end 0x%lx\n",
-		     filename.get (), (unsigned long) data.load_offset,
-		     (unsigned long) data.load_start, 
-		     (unsigned long) data.load_end);
+		     filename.get (), (unsigned long long) data.load_offset,
+		     (unsigned long long) data.load_start, 
+		     (unsigned long long) data.load_end);
 
   if (binary_flag)
     {
diff --git a/gdb/cli/cli-script.c b/gdb/cli/cli-script.c
index fef03d3..41bafc8 100644
--- a/gdb/cli/cli-script.c
+++ b/gdb/cli/cli-script.c
@@ -853,7 +853,7 @@ user_args::insert_args (const char *line) const
       else
 	{
 	  char *tmp;
-	  unsigned long i;
+	  unsigned long long i;
 
 	  errno = 0;
 	  i = strtoul (p + 4, &tmp, 10);
diff --git a/gdb/coff-pe-read.c b/gdb/coff-pe-read.c
index 97b646a..b2dd376 100644
--- a/gdb/coff-pe-read.c
+++ b/gdb/coff-pe-read.c
@@ -49,8 +49,8 @@ static unsigned int debug_coff_pe_read;
 struct read_pe_section_data
 {
   CORE_ADDR vma_offset;		/* Offset to loaded address of section.  */
-  unsigned long rva_start;	/* Start offset within the pe.  */
-  unsigned long rva_end;	/* End offset within the pe.  */
+  unsigned long long rva_start;	/* Start offset within the pe.  */
+  unsigned long long rva_end;	/* End offset within the pe.  */
   enum minimal_symbol_type ms_type;	/* Type to assign symbols in
 					   section.  */
   unsigned int index;		/* BFD section number.  */
@@ -152,7 +152,7 @@ get_section_vmas (bfd *abfd, asection *sectp, void *context)
 static void
 add_pe_exported_sym (minimal_symbol_reader &reader,
 		     const char *sym_name,
-		     unsigned long func_rva,
+		     unsigned long long func_rva,
 		     int ordinal,
 		     const struct read_pe_section_data *section_data,
 		     const char *dll_name, struct objfile *objfile)
@@ -335,13 +335,13 @@ read_pe_exported_syms (minimal_symbol_reader &reader,
 		       struct objfile *objfile)
 {
   bfd *dll = objfile->obfd;
-  unsigned long nbnormal, nbforward;
-  unsigned long pe_header_offset, opthdr_ofs, num_entries, i;
-  unsigned long export_opthdrrva, export_opthdrsize;
-  unsigned long export_rva, export_size, nsections, secptr, expptr;
-  unsigned long exp_funcbase;
+  unsigned long long nbnormal, nbforward;
+  unsigned long long pe_header_offset, opthdr_ofs, num_entries, i;
+  unsigned long long export_opthdrrva, export_opthdrsize;
+  unsigned long long export_rva, export_size, nsections, secptr, expptr;
+  unsigned long long exp_funcbase;
   unsigned char *expdata, *erva;
-  unsigned long name_rvas, ordinals, nexp, ordbase;
+  unsigned long long name_rvas, ordinals, nexp, ordbase;
   char *dll_name = (char *) dll->filename;
   int otherix = PE_SECTION_TABLE_SIZE;
   int is_pe64 = 0;
@@ -414,10 +414,10 @@ read_pe_exported_syms (minimal_symbol_reader &reader,
   for (i = 0; i < nsections; i++)
     {
       char sname[8];
-      unsigned long secptr1 = secptr + 40 * i;
-      unsigned long vaddr = pe_get32 (dll, secptr1 + 12);
-      unsigned long vsize = pe_get32 (dll, secptr1 + 16);
-      unsigned long fptr = pe_get32 (dll, secptr1 + 20);
+      unsigned long long secptr1 = secptr + 40 * i;
+      unsigned long long vaddr = pe_get32 (dll, secptr1 + 12);
+      unsigned long long vsize = pe_get32 (dll, secptr1 + 16);
+      unsigned long long fptr = pe_get32 (dll, secptr1 + 20);
 
       bfd_seek (dll, (file_ptr) secptr1, SEEK_SET);
       bfd_bread (sname, (bfd_size_type) sizeof (sname), dll);
@@ -454,10 +454,10 @@ read_pe_exported_syms (minimal_symbol_reader &reader,
      sections.  */
   for (i = 0; i < nsections; i++)
     {
-      unsigned long secptr1 = secptr + 40 * i;
-      unsigned long vsize = pe_get32 (dll, secptr1 + 8);
-      unsigned long vaddr = pe_get32 (dll, secptr1 + 12);
-      unsigned long characteristics = pe_get32 (dll, secptr1 + 36);
+      unsigned long long secptr1 = secptr + 40 * i;
+      unsigned long long vsize = pe_get32 (dll, secptr1 + 8);
+      unsigned long long vaddr = pe_get32 (dll, secptr1 + 12);
+      unsigned long long characteristics = pe_get32 (dll, secptr1 + 36);
       char sec_name[SCNNMLEN + 1];
       int sectix;
       unsigned int bfd_section_index;
@@ -534,15 +534,15 @@ read_pe_exported_syms (minimal_symbol_reader &reader,
   for (i = 0; i < nexp; i++)
     {
       /* Pointer to the names vector.  */
-      unsigned long name_rva = pe_as32 (erva + name_rvas + i * 4);
+      unsigned long long name_rva = pe_as32 (erva + name_rvas + i * 4);
       /* Retrieve ordinal value.  */
 
-      unsigned long ordinal = pe_as16 (erva + ordinals + i * 2);
+      unsigned long long ordinal = pe_as16 (erva + ordinals + i * 2);
 
 
       /* Pointer to the function address vector.  */
       /* This is relatived to ordinal value. */
-      unsigned long func_rva = pe_as32 (erva + exp_funcbase +
+      unsigned long long func_rva = pe_as32 (erva + exp_funcbase +
                                         ordinal * 4);
 
       /* Find this symbol's section in our own array.  */
@@ -625,8 +625,8 @@ CORE_ADDR
 pe_text_section_offset (struct bfd *abfd)
 
 {
-  unsigned long pe_header_offset, i;
-  unsigned long nsections, secptr;
+  unsigned long long pe_header_offset, i;
+  unsigned long long nsections, secptr;
   int is_pe64 = 0;
   int is_pe32 = 0;
   char const *target;
@@ -661,8 +661,8 @@ pe_text_section_offset (struct bfd *abfd)
   for (i = 0; i < nsections; i++)
     {
       char sname[SCNNMLEN + 1];
-      unsigned long secptr1 = secptr + 40 * i;
-      unsigned long vaddr = pe_get32 (abfd, secptr1 + 12);
+      unsigned long long secptr1 = secptr + 40 * i;
+      unsigned long long vaddr = pe_get32 (abfd, secptr1 + 12);
 
       bfd_seek (abfd, (file_ptr) secptr1, SEEK_SET);
       bfd_bread (sname, (bfd_size_type) SCNNMLEN, abfd);
diff --git a/gdb/coffread.c b/gdb/coffread.c
index 9e2edde..2aae2f0 100644
--- a/gdb/coffread.c
+++ b/gdb/coffread.c
@@ -183,13 +183,13 @@ static struct symbol *process_coff_symbol (struct coff_symbol *,
 
 static void patch_opaque_types (struct symtab *);
 
-static void enter_linenos (long, int, int, struct objfile *);
+static void enter_linenos (long long, int, int, struct objfile *);
 
 static void free_linetab (void);
 
 static void free_linetab_cleanup (void *ignore);
 
-static int init_lineno (bfd *, long, int);
+static int init_lineno (bfd *, long long, int);
 
 static char *getsymname (struct internal_syment *);
 
@@ -199,14 +199,14 @@ static void free_stringtab (void);
 
 static void free_stringtab_cleanup (void *ignore);
 
-static int init_stringtab (bfd *, long);
+static int init_stringtab (bfd *, long long);
 
 static void read_one_sym (struct coff_symbol *,
 			  struct internal_syment *,
 			  union internal_auxent *);
 
 static void coff_symtab_read (minimal_symbol_reader &,
-			      long, unsigned int, struct objfile *);
+			      long long, unsigned int, struct objfile *);
 
 /* We are called once per section from coff_symfile_read.  We
    need to examine each section we are passed, check to see
@@ -651,7 +651,7 @@ coff_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)
   /* Now that the executable file is positioned at symbol table,
      process it and define symbols accordingly.  */
 
-  coff_symtab_read (reader, (long) symtab_offset, num_symbols, objfile);
+  coff_symtab_read (reader, (long long) symtab_offset, num_symbols, objfile);
 
   /* Install any minimal symbols that have been collected as the
      current minimal symbols for this objfile.  */
@@ -776,7 +776,7 @@ coff_symfile_finish (struct objfile *objfile)
 
 static void
 coff_symtab_read (minimal_symbol_reader &reader,
-		  long symtab_offset, unsigned int nsyms,
+		  long long symtab_offset, unsigned int nsyms,
 		  struct objfile *objfile)
 {
   struct gdbarch *gdbarch = get_objfile_arch (objfile);
@@ -798,7 +798,7 @@ coff_symtab_read (minimal_symbol_reader &reader,
   CORE_ADDR fcn_first_line_addr = 0;
   int fcn_last_line = 0;
   int fcn_start_addr = 0;
-  long fcn_line_ptr = 0;
+  long long fcn_line_ptr = 0;
   int val;
   CORE_ADDR tmpaddr;
   struct minimal_symbol *msym;
@@ -823,7 +823,7 @@ coff_symtab_read (minimal_symbol_reader &reader,
   bfd_seek (objfile->obfd, 0, 0);
 
   /* Position to read the symbol table.  */
-  val = bfd_seek (objfile->obfd, (long) symtab_offset, 0);
+  val = bfd_seek (objfile->obfd, (long long) symtab_offset, 0);
   if (val < 0)
     perror_with_name (objfile_name (objfile));
 
@@ -1301,9 +1301,9 @@ read_one_sym (struct coff_symbol *cs,
 static char *stringtab = NULL;
 
 static int
-init_stringtab (bfd *abfd, long offset)
+init_stringtab (bfd *abfd, long long offset)
 {
-  long length;
+  long long length;
   int val;
   unsigned char lengthbuf[4];
 
@@ -1408,15 +1408,15 @@ coff_getfilename (union internal_auxent *aux_entry)
 /* Support for line number handling.  */
 
 static char *linetab = NULL;
-static long linetab_offset;
-static unsigned long linetab_size;
+static long long linetab_offset;
+static unsigned long long linetab_size;
 
 /* Read in all the line numbers for fast lookups later.  Leave them in
    external (unswapped) format in memory; we'll swap them as we enter
    them into GDB's data structures.  */
 
 static int
-init_lineno (bfd *abfd, long offset, int size)
+init_lineno (bfd *abfd, long long offset, int size)
 {
   int val;
 
@@ -1463,7 +1463,7 @@ free_linetab_cleanup (void *ignore)
 #endif
 
 static void
-enter_linenos (long file_offset, int first_line,
+enter_linenos (long long file_offset, int first_line,
 	       int last_line, struct objfile *objfile)
 {
   struct gdbarch *gdbarch = get_objfile_arch (objfile);
diff --git a/gdb/common/buffer.c b/gdb/common/buffer.c
index 4a0e2c9..5bce459 100644
--- a/gdb/common/buffer.c
+++ b/gdb/common/buffer.c
@@ -113,16 +113,16 @@ buffer_xml_printf (struct buffer *buffer, const char *format, ...)
 	      switch (*f)
 		{
 		case 'd':
-		  sprintf (str, "%ld", va_arg (ap, long));
+		  sprintf (str, "%ld", va_arg (ap, long long));
 		  break;
 		case 'u':
-		  sprintf (str, "%lu", va_arg (ap, unsigned long));
+		  sprintf (str, "%lu", va_arg (ap, unsigned long long));
 		  break;
 		case 'x':
-		  sprintf (str, "%lx", va_arg (ap, unsigned long));
+		  sprintf (str, "%lx", va_arg (ap, unsigned long long));
 		  break;
 		case 'o':
-		  sprintf (str, "%lo", va_arg (ap, unsigned long));
+		  sprintf (str, "%lo", va_arg (ap, unsigned long long));
 		  break;
 		case 'l':
 		  f++;
diff --git a/gdb/common/errors.h b/gdb/common/errors.h
index 647152c..0c66e6f 100644
--- a/gdb/common/errors.h
+++ b/gdb/common/errors.h
@@ -85,6 +85,6 @@ extern void perror_with_name (const char *string) ATTRIBUTE_NORETURN;
    function does not return.  This function must be provided by the
    client.  */
 
-extern void malloc_failure (long size) ATTRIBUTE_NORETURN;
+extern void malloc_failure (long long size) ATTRIBUTE_NORETURN;
 
 #endif /* COMMON_ERRORS_H */
diff --git a/gdb/common/fileio.c b/gdb/common/fileio.c
index 912a7ed..d401a6f 100644
--- a/gdb/common/fileio.c
+++ b/gdb/common/fileio.c
@@ -225,13 +225,13 @@ host_to_fileio_stat (struct stat *st, struct fio_stat *fst)
 {
   LONGEST blksize;
 
-  host_to_fileio_uint ((long) st->st_dev, fst->fst_dev);
-  host_to_fileio_uint ((long) st->st_ino, fst->fst_ino);
+  host_to_fileio_uint ((long long) st->st_dev, fst->fst_dev);
+  host_to_fileio_uint ((long long) st->st_ino, fst->fst_ino);
   host_to_fileio_mode (st->st_mode, fst->fst_mode);
-  host_to_fileio_uint ((long) st->st_nlink, fst->fst_nlink);
-  host_to_fileio_uint ((long) st->st_uid, fst->fst_uid);
-  host_to_fileio_uint ((long) st->st_gid, fst->fst_gid);
-  host_to_fileio_uint ((long) st->st_rdev, fst->fst_rdev);
+  host_to_fileio_uint ((long long) st->st_nlink, fst->fst_nlink);
+  host_to_fileio_uint ((long long) st->st_uid, fst->fst_uid);
+  host_to_fileio_uint ((long long) st->st_gid, fst->fst_gid);
+  host_to_fileio_uint ((long long) st->st_rdev, fst->fst_rdev);
   host_to_fileio_ulong ((LONGEST) st->st_size, fst->fst_size);
 #ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
   blksize = st->st_blksize;
diff --git a/gdb/common/fileio.h b/gdb/common/fileio.h
index 92d2674..dcfcaf4 100644
--- a/gdb/common/fileio.h
+++ b/gdb/common/fileio.h
@@ -53,7 +53,7 @@ host_to_bigendian (LONGEST num, char *buf, int bytes)
 /* Pack a host-format integer into an fio_uint_t.  */
 
 static inline void
-host_to_fileio_uint (long num, fio_uint_t fnum)
+host_to_fileio_uint (long long num, fio_uint_t fnum)
 {
   host_to_bigendian ((LONGEST) num, (char *) fnum, 4);
 }
diff --git a/gdb/common/filestuff.c b/gdb/common/filestuff.c
index f5a754f..63ca06d 100644
--- a/gdb/common/filestuff.c
+++ b/gdb/common/filestuff.c
@@ -78,7 +78,7 @@ fdwalk (int (*func) (void *, int), void *arg)
 
       for (entry = readdir (dir); entry != NULL; entry = readdir (dir))
 	{
-	  long fd;
+	  long long fd;
 	  char *tail;
 	  int result;
 
@@ -280,7 +280,7 @@ socket_mark_cloexec (int fd)
 /* See filestuff.h.  */
 
 int
-gdb_open_cloexec (const char *filename, int flags, unsigned long mode)
+gdb_open_cloexec (const char *filename, int flags, unsigned long long mode)
 {
   int fd = open (filename, flags | O_CLOEXEC, mode);
 
diff --git a/gdb/common/filestuff.h b/gdb/common/filestuff.h
index 0e46eb5..88deb67 100644
--- a/gdb/common/filestuff.h
+++ b/gdb/common/filestuff.h
@@ -46,7 +46,7 @@ extern void close_most_fds (void);
    close-on-exec flag set.  */
 
 extern int gdb_open_cloexec (const char *filename, int flags,
-			     /* mode_t */ unsigned long mode);
+			     /* mode_t */ unsigned long long mode);
 
 struct gdb_file_deleter
 {
diff --git a/gdb/common/print-utils.c b/gdb/common/print-utils.c
index 7eccec7..3141ce7 100644
--- a/gdb/common/print-utils.c
+++ b/gdb/common/print-utils.c
@@ -42,7 +42,7 @@ decimal2str (const char *sign, ULONGEST addr, int width)
 {
   /* Steal code from valprint.c:print_decimal().  Should this worry
      about the real size of addr as the above does?  */
-  unsigned long temp[3];
+  unsigned long long temp[3];
   char *str = get_print_cell ();
   int i = 0;
 
@@ -83,7 +83,7 @@ decimal2str (const char *sign, ULONGEST addr, int width)
 static char *
 octal2str (ULONGEST addr, int width)
 {
-  unsigned long temp[3];
+  unsigned long long temp[3];
   char *str = get_print_cell ();
   int i = 0;
 
@@ -157,12 +157,12 @@ phex (ULONGEST l, int sizeof_l)
     case 8:
       str = get_print_cell ();
       xsnprintf (str, PRINT_CELL_SIZE, "%08lx%08lx",
-		 (unsigned long) (l >> thirty_two),
-		 (unsigned long) (l & 0xffffffff));
+		 (unsigned long long) (l >> thirty_two),
+		 (unsigned long long) (l & 0xffffffff));
       break;
     case 4:
       str = get_print_cell ();
-      xsnprintf (str, PRINT_CELL_SIZE, "%08lx", (unsigned long) l);
+      xsnprintf (str, PRINT_CELL_SIZE, "%08lx", (unsigned long long) l);
       break;
     case 2:
       str = get_print_cell ();
@@ -187,20 +187,20 @@ phex_nz (ULONGEST l, int sizeof_l)
     {
     case 8:
       {
-	unsigned long high = (unsigned long) (l >> thirty_two);
+	unsigned long long high = (unsigned long long) (l >> thirty_two);
 
 	str = get_print_cell ();
 	if (high == 0)
 	  xsnprintf (str, PRINT_CELL_SIZE, "%lx",
-		     (unsigned long) (l & 0xffffffff));
+		     (unsigned long long) (l & 0xffffffff));
 	else
 	  xsnprintf (str, PRINT_CELL_SIZE, "%lx%08lx", high,
-		     (unsigned long) (l & 0xffffffff));
+		     (unsigned long long) (l & 0xffffffff));
 	break;
       }
     case 4:
       str = get_print_cell ();
-      xsnprintf (str, PRINT_CELL_SIZE, "%lx", (unsigned long) l);
+      xsnprintf (str, PRINT_CELL_SIZE, "%lx", (unsigned long long) l);
       break;
     case 2:
       str = get_print_cell ();
diff --git a/gdb/common/ptid.h b/gdb/common/ptid.h
index 03f5321..5a0d752 100644
--- a/gdb/common/ptid.h
+++ b/gdb/common/ptid.h
@@ -44,7 +44,7 @@ public:
      A ptid with only a PID (LWP and TID equal to zero) is usually used to
      represent a whole process, including all its lwps/threads.  */
 
-  explicit constexpr ptid_t (int pid, long lwp = 0, long tid = 0)
+  explicit constexpr ptid_t (int pid, long long lwp = 0, long long tid = 0)
     : m_pid (pid), m_lwp (lwp), m_tid (tid)
   {}
 
@@ -60,7 +60,7 @@ public:
 
   /* Fetch the lwp (lightweight process) component from the ptid.  */
 
-  constexpr long lwp () const
+  constexpr long long lwp () const
   { return m_lwp; }
 
   /* Return true if the ptid's tid member is non-zero.  */
@@ -70,7 +70,7 @@ public:
 
   /* Fetch the tid (thread id) component from a ptid.  */
 
-  constexpr long tid () const
+  constexpr long long tid () const
   { return m_tid; }
 
   /* Return true if the ptid represents a whole process, including all its
@@ -137,10 +137,10 @@ private:
   int m_pid;
 
   /* Lightweight process id.  */
-  long m_lwp;
+  long long m_lwp;
 
   /* Thread id.  */
-  long m_tid;
+  long long m_tid;
 };
 
 /* The null or zero ptid, often used to indicate no process. */
diff --git a/gdb/common/tdesc.h b/gdb/common/tdesc.h
index d13143e..4a8df4c 100644
--- a/gdb/common/tdesc.h
+++ b/gdb/common/tdesc.h
@@ -82,7 +82,7 @@ struct tdesc_reg : tdesc_element
   /* The register number used by this target to refer to this
      register.  This is used for remote p/P packets and to determine
      the ordering of registers in the remote g/G packets.  */
-  long target_regnum;
+  long long target_regnum;
 
   /* If this flag is set, GDB should save and restore this register
      around calls to an inferior function.  */
diff --git a/gdb/compile/compile-c-types.c b/gdb/compile/compile-c-types.c
index 212cfe6..0370928 100644
--- a/gdb/compile/compile-c-types.c
+++ b/gdb/compile/compile-c-types.c
@@ -181,7 +181,7 @@ convert_struct_or_union (struct compile_c_instance *context, struct type *type)
   for (i = 0; i < TYPE_NFIELDS (type); ++i)
     {
       gcc_type field_type;
-      unsigned long bitsize = TYPE_FIELD_BITSIZE (type, i);
+      unsigned long long bitsize = TYPE_FIELD_BITSIZE (type, i);
 
       field_type = convert_type (context, TYPE_FIELD_TYPE (type, i));
       if (bitsize == 0)
diff --git a/gdb/compile/compile-loc2c.c b/gdb/compile/compile-loc2c.c
index aba791a..ba0213d 100644
--- a/gdb/compile/compile-loc2c.c
+++ b/gdb/compile/compile-loc2c.c
@@ -886,7 +886,7 @@ do_compile_dwarf_expr_to_c (int indent, string_file &stream,
 	    /* Generate a unique-enough name, in case the frame base
 	       is computed multiple times in this expression.  */
 	    xsnprintf (fb_name, sizeof (fb_name), "__frame_base_%ld",
-		       (long) (op_ptr - base));
+		       (long long) (op_ptr - base));
 
 	    do_compile_dwarf_expr_to_c (indent, stream,
 					GCC_UINTPTR, fb_name,
@@ -1067,7 +1067,7 @@ do_compile_dwarf_expr_to_c (int indent, string_file &stream,
 		/* Generate a unique-enough name, in case the CFA is
 		   computed multiple times in this expression.  */
 		xsnprintf (cfa_name, sizeof (cfa_name),
-			   "__cfa_%ld", (long) (op_ptr - base));
+			   "__cfa_%ld", (long long) (op_ptr - base));
 
 		do_compile_dwarf_expr_to_c (indent, stream,
 					    GCC_UINTPTR, cfa_name,
diff --git a/gdb/compile/compile-object-load.c b/gdb/compile/compile-object-load.c
index 9b3c51f..835c371 100644
--- a/gdb/compile/compile-object-load.c
+++ b/gdb/compile/compile-object-load.c
@@ -618,9 +618,9 @@ compile_object_load (const compile_file_names &file_names,
   struct symbol *func_sym;
   struct type *func_type;
   struct bound_minimal_symbol bmsym;
-  long storage_needed;
+  long long storage_needed;
   asymbol **symbol_table, **symp;
-  long number_of_symbols, missing_symbols;
+  long long number_of_symbols, missing_symbols;
   struct compile_module *retval;
   struct type *regs_type, *out_value_type = NULL;
   char **matching;
diff --git a/gdb/cp-support.c b/gdb/cp-support.c
index 3ce5f60..c28d956 100644
--- a/gdb/cp-support.c
+++ b/gdb/cp-support.c
@@ -85,7 +85,7 @@ static void
 
 static char *
 copy_string_to_obstack (struct obstack *obstack, const char *string,
-			long *len)
+			long long *len)
 {
   *len = strlen (string);
   return (char *) obstack_copy (obstack, string, *len);
@@ -184,7 +184,7 @@ inspect_type (struct demangle_parse_info *info,
       if (TYPE_CODE (otype) == TYPE_CODE_TYPEDEF
 	  || TYPE_CODE (otype) == TYPE_CODE_NAMESPACE)
 	{
-	  long len;
+	  long long len;
 	  int is_anon;
 	  struct type *type;
 	  std::unique_ptr<demangle_parse_info> i;
@@ -315,7 +315,7 @@ replace_typedefs_qualified_name (struct demangle_parse_info *info,
 	  if (inspect_type (info, &newobj, finder, data))
 	    {
 	      char *s;
-	      long slen;
+	      long long slen;
 
 	      /* A typedef was substituted in NEW.  Convert it to a
 		 string and replace the top DEMANGLE_COMPONENT_QUAL_NAME
diff --git a/gdb/cp-valprint.c b/gdb/cp-valprint.c
index f67eaed..8cf0bd4 100644
--- a/gdb/cp-valprint.c
+++ b/gdb/cp-valprint.c
@@ -796,7 +796,7 @@ cp_print_class_member (const gdb_byte *valaddr, struct type *type,
       fputs_filtered (TYPE_FIELD_NAME (self_type, fieldno), stream);
     }
   else
-    fprintf_filtered (stream, "%ld", (long) val);
+    fprintf_filtered (stream, "%ld", (long long) val);
 }
 
 
diff --git a/gdb/cris-tdep.c b/gdb/cris-tdep.c
index e0371a2..67553dd 100644
--- a/gdb/cris-tdep.c
+++ b/gdb/cris-tdep.c
@@ -473,11 +473,11 @@ crisv32_single_step_through_delay (struct gdbarch *gdbarch,
 typedef 
 struct instruction_environment
 {
-  unsigned long reg[NUM_GENREGS];
-  unsigned long preg[NUM_SPECREGS];
-  unsigned long branch_break_address;
-  unsigned long delay_slot_pc;
-  unsigned long prefix_value;
+  unsigned long long reg[NUM_GENREGS];
+  unsigned long long preg[NUM_SPECREGS];
+  unsigned long long branch_break_address;
+  unsigned long long delay_slot_pc;
+  unsigned long long prefix_value;
   int   branch_found;
   int   prefix_found;
   int   invalid;
@@ -588,7 +588,7 @@ cris_get_branch_short_offset (unsigned short insn)
 }
 
 static int
-cris_get_asr_shift_steps (unsigned long value)
+cris_get_asr_shift_steps (unsigned long long value)
 {
   return (value & 0x3F);
 }
@@ -2001,13 +2001,13 @@ find_step_target (struct regcache *regcache, inst_env_type *inst_env)
   for (i = 0; i < NUM_GENREGS; i++)
     {
       inst_env->reg[i] = 
-	(unsigned long) regcache_raw_get_unsigned (regcache, i);
+	(unsigned long long) regcache_raw_get_unsigned (regcache, i);
     }
   offset = NUM_GENREGS;
   for (i = 0; i < NUM_SPECREGS; i++)
     {
       inst_env->preg[i] = 
-	(unsigned long) regcache_raw_get_unsigned (regcache, offset + i);
+	(unsigned long long) regcache_raw_get_unsigned (regcache, offset + i);
     }
   inst_env->branch_found = 0;
   inst_env->slot_needed = 0;
@@ -2154,7 +2154,7 @@ process_autoincrement (int size, unsigned short inst, inst_env_type *inst_env)
 
 /* Just a forward declaration.  */
 
-static unsigned long get_data_from_address (unsigned short *inst,
+static unsigned long long get_data_from_address (unsigned short *inst,
 					    CORE_ADDR address,
 					    enum bfd_endian byte_order);
 
@@ -2337,7 +2337,7 @@ static void
 abs_op (unsigned short inst, inst_env_type *inst_env)
 {
 
-  long value;
+  long long value;
   
   /* ABS can't have a prefix, so it's bad if it does.  */
   if (inst_env->prefix_found)
@@ -2357,13 +2357,13 @@ abs_op (unsigned short inst, inst_env_type *inst_env)
           return;
         }
 
-      value = (long) inst_env->reg[REG_PC];
+      value = (long long) inst_env->reg[REG_PC];
 
       /* The value of abs (SIGNED_DWORD_MASK) is SIGNED_DWORD_MASK.  */
       if (value != SIGNED_DWORD_MASK)
         {
           value = -value;
-          inst_env->reg[REG_PC] = (long) value;
+          inst_env->reg[REG_PC] = (long long) value;
         }
     }
 
@@ -2398,8 +2398,8 @@ static void
 asr_op (unsigned short inst, inst_env_type *inst_env)
 {
   int shift_steps;
-  unsigned long value;
-  unsigned long signed_extend_mask = 0;
+  unsigned long long value;
+  unsigned long long signed_extend_mask = 0;
 
   /* ASR can't have a prefix, so check that it doesn't.  */
   if (inst_env->prefix_found)
@@ -2477,8 +2477,8 @@ asrq_op (unsigned short inst, inst_env_type *inst_env)
 {
 
   int shift_steps;
-  unsigned long value;
-  unsigned long signed_extend_mask = 0;
+  unsigned long long value;
+  unsigned long long signed_extend_mask = 0;
   
   /* ASRQ can't have a prefix, so check that it doesn't.  */
   if (inst_env->prefix_found)
@@ -2807,7 +2807,7 @@ reg_mode_jump_op (unsigned short inst, inst_env_type *inst_env)
 static void
 none_reg_mode_jump_op (unsigned short inst, inst_env_type *inst_env)
 {
-  unsigned long newpc;
+  unsigned long long newpc;
   CORE_ADDR address;
 
   /* It's invalid to do a JUMP in a delay slot.  */
@@ -3184,10 +3184,10 @@ mulu_op (unsigned short inst, inst_env_type *inst_env)
 
 static void 
 add_sub_cmp_and_or_move_action (unsigned short inst, inst_env_type *inst_env, 
-                                unsigned long source1, unsigned long source2)
+                                unsigned long long source1, unsigned long long source2)
 {
-  unsigned long pc_mask;
-  unsigned long operation_mask;
+  unsigned long long pc_mask;
+  unsigned long long operation_mask;
   
   /* Find out how many bits the operation should apply to.  */
   if (cris_get_size (inst) == INST_BYTE_SIZE)
@@ -3264,8 +3264,8 @@ add_sub_cmp_and_or_move_action (unsigned short inst, inst_env_type *inst_env,
    is zero extend then the value is extended with zero.  If instead the mode
    is signed extend the sign bit of the value is taken into consideration.  */
 
-static unsigned long 
-do_sign_or_zero_extend (unsigned long value, unsigned short *inst)
+static unsigned long long 
+do_sign_or_zero_extend (unsigned long long value, unsigned short *inst)
 {
   /* The size can be either byte or word, check which one it is. 
      Don't check the highest bit, it's indicating if it's a zero
@@ -3306,8 +3306,8 @@ static void
 reg_mode_add_sub_cmp_and_or_move_op (unsigned short inst,
                                      inst_env_type *inst_env)
 {
-  unsigned long operand1;
-  unsigned long operand2;
+  unsigned long long operand1;
+  unsigned long long operand2;
 
   /* It's invalid to have a prefix to the instruction.  This is a register 
      mode instruction and can't have a prefix.  */
@@ -3347,12 +3347,12 @@ reg_mode_add_sub_cmp_and_or_move_op (unsigned short inst,
    the size of the operation.  If the instruction is a zero or signed
    extend instruction, the size field is changed in instruction.  */
 
-static unsigned long 
+static unsigned long long 
 get_data_from_address (unsigned short *inst, CORE_ADDR address,
 		       enum bfd_endian byte_order)
 {
   int size = cris_get_size (*inst);
-  unsigned long value;
+  unsigned long long value;
 
   /* If it's an extend instruction we don't want the signed extend bit,
      because it influences the size.  */
@@ -3380,8 +3380,8 @@ static void
 handle_prefix_assign_mode_for_aritm_op (unsigned short inst, 
                                         inst_env_type *inst_env)
 {
-  unsigned long operand2;
-  unsigned long operand3;
+  unsigned long long operand2;
+  unsigned long long operand3;
 
   check_assign (inst, inst_env);
   if (cris_get_operand2 (inst) == REG_PC)
@@ -3410,8 +3410,8 @@ static void
 three_operand_add_sub_cmp_and_or_op (unsigned short inst, 
                                      inst_env_type *inst_env)
 {
-  unsigned long operand2;
-  unsigned long operand3;
+  unsigned long long operand2;
+  unsigned long long operand3;
 
   if (cris_get_operand1 (inst) == REG_PC)
     {
@@ -3467,9 +3467,9 @@ static void
 handle_inc_and_index_mode_for_aritm_op (unsigned short inst, 
                                         inst_env_type *inst_env)
 {
-  unsigned long operand1;
-  unsigned long operand2;
-  unsigned long operand3;
+  unsigned long long operand1;
+  unsigned long long operand2;
+  unsigned long long operand3;
   int size;
 
   /* The instruction is either an indirect or autoincrement addressing mode.
@@ -3546,8 +3546,8 @@ none_reg_mode_add_sub_cmp_and_or_move_op (unsigned short inst,
 static void 
 quick_mode_add_sub_op (unsigned short inst, inst_env_type *inst_env)
 {
-  unsigned long operand1;
-  unsigned long operand2;
+  unsigned long long operand1;
+  unsigned long long operand2;
 
   /* It's a bad idea to be in a prefix instruction now.  This is a quick mode
      instruction and can't have a prefix.  */
@@ -3586,8 +3586,8 @@ quick_mode_add_sub_op (unsigned short inst, inst_env_type *inst_env)
 static void 
 quick_mode_and_cmp_move_or_op (unsigned short inst, inst_env_type *inst_env)
 {
-  unsigned long operand1;
-  unsigned long operand2;
+  unsigned long long operand1;
+  unsigned long long operand2;
 
   /* It's a bad idea to be in a prefix instruction now.  This is a quick mode
      instruction and can't have a prefix.  */
diff --git a/gdb/ctf.c b/gdb/ctf.c
index a156b1f..7bb5047 100644
--- a/gdb/ctf.c
+++ b/gdb/ctf.c
@@ -124,7 +124,7 @@ struct trace_write_handler
   size_t content_size;
 
   /* This is the start offset of current packet.  */
-  long packet_start;
+  long long packet_start;
 };
 
 /* Write metadata in FORMAT.  */
@@ -179,7 +179,7 @@ ctf_save_write (struct trace_write_handler *handler,
    if WHENCE is SEEK_CUR.  */
 
 static int
-ctf_save_fseek (struct trace_write_handler *handler, long offset,
+ctf_save_fseek (struct trace_write_handler *handler, long long offset,
 		int whence)
 {
   gdb_assert (whence != SEEK_END);
@@ -204,7 +204,7 @@ ctf_save_align_write (struct trace_write_handler *handler,
 		      const gdb_byte *buf,
 		      size_t size, size_t align_size)
 {
-  long offset
+  long long offset
     = (align_up (handler->content_size, align_size)
        - handler->content_size);
 
diff --git a/gdb/darwin-nat-info.c b/gdb/darwin-nat-info.c
index f3c8de2..542cce3 100644
--- a/gdb/darwin-nat-info.c
+++ b/gdb/darwin-nat-info.c
@@ -53,7 +53,7 @@
 } while (0)
 
 #define PRINT_FIELD(structure, field) \
-  printf_unfiltered(_(#field":\t%#lx\n"), (unsigned long) (structure)->field)
+  printf_unfiltered(_(#field":\t%#lx\n"), (unsigned long long) (structure)->field)
 
 #define PRINT_TV_FIELD(structure, field) \
   printf_unfiltered(_(#field":\t%u.%06u sec\n"),	\
@@ -309,8 +309,8 @@ darwin_debug_port_info (task_t task, mach_port_t port)
     (task, port, MACH_PORT_RECEIVE_STATUS, (mach_port_info_t)&status, &len);
   MACH_CHECK_ERROR (kret);
 
-  printf_unfiltered (_("Port 0x%lx in task 0x%lx:\n"), (unsigned long) port,
-                     (unsigned long) task);
+  printf_unfiltered (_("Port 0x%lx in task 0x%lx:\n"), (unsigned long long) port,
+                     (unsigned long long) task);
   printf_unfiltered (_("  port set: 0x%x\n"), status.mps_pset);
   printf_unfiltered (_("     seqno: 0x%x\n"), status.mps_seqno);
   printf_unfiltered (_("   mscount: 0x%x\n"), status.mps_mscount);
diff --git a/gdb/darwin-nat.c b/gdb/darwin-nat.c
index 8104de5..b0eaee9 100644
--- a/gdb/darwin-nat.c
+++ b/gdb/darwin-nat.c
@@ -178,7 +178,7 @@ mach_check_error (kern_return_t ret, const char *file,
     func = _("[UNKNOWN]");
 
   warning (_("Mach error at \"%s:%u\" in function \"%s\": %s (0x%lx)"),
-	   file, line, func, mach_error_string (ret), (unsigned long) ret);
+	   file, line, func, mach_error_string (ret), (unsigned long long) ret);
 }
 
 static const char *
@@ -235,7 +235,7 @@ darwin_ptrace (const char *name,
     ret = 0;
 
   inferior_debug (4, _("ptrace (%s, %d, 0x%lx, %d): %d (%s)\n"),
-                  name, pid, (unsigned long) arg3, arg4, ret,
+                  name, pid, (unsigned long long) arg3, arg4, ret,
                   (ret != 0) ? safe_strerror (errno) : _("no error"));
   return ret;
 }
@@ -957,7 +957,7 @@ darwin_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signal)
   else
     {
       struct inferior *inf = find_inferior_ptid (ptid);
-      long tid = ptid.tid ();
+      long long tid = ptid.tid ();
 
       /* Stop the inferior (should be useless).  */
       darwin_suspend_inferior (inf);
@@ -1172,7 +1172,7 @@ cancel_breakpoint (ptid_t ptid)
   if (breakpoint_inserted_here_p (regcache->aspace (), pc))
     {
       inferior_debug (4, "cancel_breakpoint for thread 0x%lx\n",
-		      (unsigned long) ptid.tid ());
+		      (unsigned long long) ptid.tid ());
 
       /* Back up the PC if necessary.  */
       if (gdbarch_decr_pc_after_break (gdbarch))
@@ -1599,7 +1599,7 @@ darwin_attach_pid (struct inferior *inf)
 	  error
 	    (_("Unable to find Mach task port for process-id %d: %s (0x%lx).\n"
 	       " (please check gdb is codesigned - see taskgated(8))"),
-	     inf->pid, mach_error_string (kret), (unsigned long) kret);
+	     inf->pid, mach_error_string (kret), (unsigned long long) kret);
 	}
 
       inferior_debug (2, _("inferior task: 0x%x, pid: %d\n"),
@@ -1962,7 +1962,7 @@ const char *
 darwin_nat_target::pid_to_str (ptid_t ptid)
 {
   static char buf[80];
-  long tid = ptid.tid ();
+  long long tid = ptid.tid ();
 
   if (tid != 0)
     {
@@ -2094,7 +2094,7 @@ darwin_read_write_inferior (task_t task, CORE_ADDR addr,
 			 "mach_vm_protect failed at %s "
 			 "(len=0x%lx, prot=0x%x): %s"),
 		       core_addr_to_string (region_address),
-		       (unsigned long) region_length, (unsigned) prot,
+		       (unsigned long long) region_length, (unsigned) prot,
 		       mach_error_string (kret));
 	      return res_length;
 	    }
@@ -2125,7 +2125,7 @@ darwin_read_write_inferior (task_t task, CORE_ADDR addr,
 			 "mach_vm_protect restore failed at %s "
 			 "(len=0x%lx): %s"),
 		       core_addr_to_string (region_address),
-		       (unsigned long) region_length,
+		       (unsigned long long) region_length,
 		       mach_error_string (kret));
 	    }
 	}
@@ -2257,7 +2257,7 @@ darwin_nat_target::pid_to_exec_file (int pid)
 }
 
 ptid_t
-darwin_nat_target::get_ada_task_ptid (long lwp, long thread)
+darwin_nat_target::get_ada_task_ptid (long long lwp, long long thread)
 {
   struct inferior *inf = current_inferior ();
   darwin_inferior *priv = get_darwin_inferior (inf);
@@ -2266,7 +2266,7 @@ darwin_nat_target::get_ada_task_ptid (long lwp, long thread)
   mach_msg_type_number_t names_count;
   mach_port_type_array_t types;
   mach_msg_type_number_t types_count;
-  long res = 0;
+  long long res = 0;
 
   /* First linear search.  */
   for (darwin_thread_t *t : priv->threads)
@@ -2344,7 +2344,7 @@ _initialize_darwin_nat ()
     }
 
   inferior_debug (2, _("GDB task: 0x%lx, pid: %d\n"),
-		  (unsigned long) mach_task_self (), getpid ());
+		  (unsigned long long) mach_task_self (), getpid ());
 
   add_setshow_zuinteger_cmd ("darwin", class_obscure,
 			     &darwin_debug_flag, _("\
diff --git a/gdb/darwin-nat.h b/gdb/darwin-nat.h
index 5965df0..a3057c0 100644
--- a/gdb/darwin-nat.h
+++ b/gdb/darwin-nat.h
@@ -58,7 +58,7 @@ class darwin_nat_target : public inf_child_target
 
   bool supports_multi_process () override;
 
-  ptid_t get_ada_task_ptid (long lwp, long thread) override;
+  ptid_t get_ada_task_ptid (long long lwp, long long thread) override;
 };
 
 /* Describe the mach exception handling state for a task.  This state is saved
diff --git a/gdb/dbxread.c b/gdb/dbxread.c
index 1b524ec..4119b98 100644
--- a/gdb/dbxread.c
+++ b/gdb/dbxread.c
@@ -578,7 +578,7 @@ dbx_new_init (struct objfile *ignore)
    be called unless this is an a.out (or very similar) file.
    FIXME, there should be a cleaner peephole into the BFD environment here.  */
 
-#define DBX_STRINGTAB_SIZE_SIZE sizeof(long)	/* FIXME */
+#define DBX_STRINGTAB_SIZE_SIZE sizeof(long long)	/* FIXME */
 
 static void
 dbx_symfile_init (struct objfile *objfile)
diff --git a/gdb/defs.h b/gdb/defs.h
index fc42170..7271f56 100644
--- a/gdb/defs.h
+++ b/gdb/defs.h
@@ -338,7 +338,7 @@ extern const char *pc_prefix (CORE_ADDR);
    its original file based copy if MODIFIED is non-zero.  DATA is
    passed without changes from a caller.  */
 
-typedef int (*find_memory_region_ftype) (CORE_ADDR addr, unsigned long size,
+typedef int (*find_memory_region_ftype) (CORE_ADDR addr, unsigned long long size,
 					 int read, int write, int exec,
 					 int modified, void *data);
 
@@ -448,11 +448,11 @@ enum val_prettyformat
 #endif
 
 #if !defined (ULONG_MAX)
-#define	ULONG_MAX ((unsigned long)(~0L))    /* 0xFFFFFFFF for 32-bits */
+#define	ULONG_MAX ((unsigned long long)(~0L))    /* 0xFFFFFFFF for 32-bits */
 #endif
 
 #if !defined (LONG_MAX)
-#define	LONG_MAX ((long)(ULONG_MAX >> 1))   /* 0x7FFFFFFF for 32-bits */
+#define	LONG_MAX ((long long)(ULONG_MAX >> 1))   /* 0x7FFFFFFF for 32-bits */
 #endif
 
 #if !defined (ULONGEST_MAX)
@@ -595,10 +595,10 @@ extern void (*deprecated_post_add_symbol_hook) (void);
 extern void (*selected_frame_level_changed_hook) (int);
 extern int (*deprecated_ui_loop_hook) (int signo);
 extern void (*deprecated_show_load_progress) (const char *section,
-					      unsigned long section_sent, 
-					      unsigned long section_size, 
-					      unsigned long total_sent, 
-					      unsigned long total_size);
+					      unsigned long long section_sent, 
+					      unsigned long long section_size, 
+					      unsigned long long total_sent, 
+					      unsigned long long total_size);
 extern void (*deprecated_print_frame_info_listing_hook) (struct symtab * s,
 							 int line,
 							 int stopline,
@@ -623,7 +623,7 @@ extern void (*deprecated_call_command_hook) (struct cmd_list_element * c,
 					     const char *cmd, int from_tty);
 
 extern int (*deprecated_ui_load_progress_hook) (const char *section,
-						unsigned long num);
+						unsigned long long num);
 
 /* If this definition isn't overridden by the header files, assume
    that isatty and fileno exist on this system.  */
diff --git a/gdb/dicos-tdep.c b/gdb/dicos-tdep.c
index 951b951..73ba4bb 100644
--- a/gdb/dicos-tdep.c
+++ b/gdb/dicos-tdep.c
@@ -53,7 +53,7 @@ dicos_init_abi (struct gdbarch *gdbarch)
 int
 dicos_load_module_p (bfd *abfd, int header_size)
 {
-  long storage_needed;
+  long long storage_needed;
   int ret = 0;
   asymbol **symbol_table = NULL;
   const char *symname = "Dicos_loadModuleInfo";
@@ -86,7 +86,7 @@ dicos_load_module_p (bfd *abfd, int header_size)
 
   if (storage_needed > 0)
     {
-      long i, symcount;
+      long long i, symcount;
 
       symbol_table = (asymbol **) xmalloc (storage_needed);
       symcount = bfd_canonicalize_symtab (abfd, symbol_table);
diff --git a/gdb/dwarf2loc.c b/gdb/dwarf2loc.c
index 2da088e..f2f121a 100644
--- a/gdb/dwarf2loc.c
+++ b/gdb/dwarf2loc.c
@@ -934,7 +934,7 @@ chain_candidate (struct gdbarch *gdbarch,
 		 gdb::unique_xmalloc_ptr<struct call_site_chain> *resultp,
 		 std::vector<struct call_site *> *chain)
 {
-  long length = chain->size ();
+  long long length = chain->size ();
   int callers, callees, idx;
 
   if (*resultp == NULL)
@@ -973,7 +973,7 @@ chain_candidate (struct gdbarch *gdbarch,
 
   /* Intersect callers.  */
 
-  callers = std::min ((long) (*resultp)->callers, length);
+  callers = std::min ((long long) (*resultp)->callers, length);
   for (idx = 0; idx < callers; idx++)
     if ((*resultp)->call_site[idx] != chain->at (idx))
       {
@@ -983,7 +983,7 @@ chain_candidate (struct gdbarch *gdbarch,
 
   /* Intersect callees.  */
 
-  callees = std::min ((long) (*resultp)->callees, length);
+  callees = std::min ((long long) (*resultp)->callees, length);
   for (idx = 0; idx < callees; idx++)
     if ((*resultp)->call_site[(*resultp)->length - 1 - idx]
 	!= chain->at (length - 1 - idx))
@@ -3924,9 +3924,9 @@ disassemble_dwarf_expression (struct ui_file *stream,
 
       if (!name)
 	error (_("Unrecognized DWARF opcode 0x%02x at %ld"),
-	       op, (long) (data - 1 - start));
+	       op, (long long) (data - 1 - start));
       fprintf_filtered (stream, "  %*ld: %s", indent + 4,
-			(long) (data - 1 - start), name);
+			(long long) (data - 1 - start), name);
 
       switch (op)
 	{
@@ -4101,14 +4101,14 @@ disassemble_dwarf_expression (struct ui_file *stream,
 	  l = extract_signed_integer (data, 2, gdbarch_byte_order (arch));
 	  data += 2;
 	  fprintf_filtered (stream, " to %ld",
-			    (long) (data + l - start));
+			    (long long) (data + l - start));
 	  break;
 
 	case DW_OP_bra:
 	  l = extract_signed_integer (data, 2, gdbarch_byte_order (arch));
 	  data += 2;
 	  fprintf_filtered (stream, " %ld",
-			    (long) (data + l - start));
+			    (long long) (data + l - start));
 	  break;
 
 	case DW_OP_call2:
diff --git a/gdb/dwarf2read.c b/gdb/dwarf2read.c
index b0c7d98..b388a77 100644
--- a/gdb/dwarf2read.c
+++ b/gdb/dwarf2read.c
@@ -5430,7 +5430,7 @@ read_debug_names_from_section (struct objfile *objfile,
     {
       warning (_("Section .debug_names in %s has unsupported %lu foreign TUs, "
 		 "ignoring .debug_names."),
-	       filename, static_cast<unsigned long> (foreign_tu_count));
+	       filename, static_cast<unsigned long long> (foreign_tu_count));
       return false;
     }
 
@@ -9878,7 +9878,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)
       while (name[0] >= '0' && name[0] <= '9')
 	{
 	  char *tail;
-	  unsigned long index = strtoul (name, &tail, 10);
+	  unsigned long long index = strtoul (name, &tail, 10);
 	  name = tail;
 	  if (*name != '$'
 	      || index >= TYPE_NFIELDS (field_type)
@@ -12544,10 +12544,10 @@ create_dwo_unit_in_dwp_v2 (struct dwarf2_per_objfile *dwarf2_per_objfile,
 
   std::string virtual_dwo_name =
     string_printf ("virtual-dwo/%ld-%ld-%ld-%ld",
-		   (long) (sections.abbrev_size ? sections.abbrev_offset : 0),
-		   (long) (sections.line_size ? sections.line_offset : 0),
-		   (long) (sections.loc_size ? sections.loc_offset : 0),
-		   (long) (sections.str_offsets_size
+		   (long long) (sections.abbrev_size ? sections.abbrev_offset : 0),
+		   (long long) (sections.line_size ? sections.line_offset : 0),
+		   (long long) (sections.loc_size ? sections.loc_offset : 0),
+		   (long long) (sections.str_offsets_size
 			   ? sections.str_offsets_offset : 0));
   /* Can we use an existing virtual DWO file?  */
   dwo_file_slot = lookup_dwo_file_slot (dwarf2_per_objfile,
@@ -14734,7 +14734,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,
 
       /* The value of the DW_AT_ranges attribute is the offset of the
          address range list in the .debug_ranges section.  */
-      unsigned long offset = (DW_UNSND (attr)
+      unsigned long long offset = (DW_UNSND (attr)
 			      + (need_ranges_base ? cu->ranges_base : 0));
 
       std::vector<blockrange> blockvec;
@@ -20697,7 +20697,7 @@ lnp_state_machine::check_line_address (struct dwarf2_cu *cu,
 	 GCd by the linker.  Ignore it.  PR gdb/12528 */
 
       struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;
-      long line_offset = line_ptr - get_debug_line_section (cu)->buffer;
+      long long line_offset = line_ptr - get_debug_line_section (cu)->buffer;
 
       complaint (_(".debug_line address at offset 0x%lx is 0 [in module %s]"),
 		 line_offset, objfile_name (objfile));
@@ -22590,7 +22590,7 @@ dump_die_shallow (struct ui_file *f, int indent, struct die_info *die)
 	case DW_FORM_ref8:
 	case DW_FORM_ref_udata:
 	  fprintf_unfiltered (f, "constant ref: 0x%lx (adjusted)",
-			      (long) (DW_UNSND (&die->attrs[i])));
+			      (long long) (DW_UNSND (&die->attrs[i])));
 	  break;
 	case DW_FORM_data1:
 	case DW_FORM_data2:
@@ -24008,7 +24008,7 @@ skip_unknown_opcode (unsigned int opcode,
 		     struct dwarf2_section_info *section)
 {
   unsigned int bytes_read, i;
-  unsigned long arg;
+  unsigned long long arg;
   const gdb_byte *defn;
 
   if (opcode_definitions[opcode] == NULL)
@@ -24082,7 +24082,7 @@ dwarf_parse_macro_header (const gdb_byte **opcode_definitions,
 	  for (i = 0; i < count; ++i)
 	    {
 	      unsigned int opcode, bytes_read;
-	      unsigned long arg;
+	      unsigned long long arg;
 
 	      opcode = read_1_byte (abfd, mac_ptr);
 	      ++mac_ptr;
diff --git a/gdb/elfread.c b/gdb/elfread.c
index feca5ea..80926f0 100644
--- a/gdb/elfread.c
+++ b/gdb/elfread.c
@@ -81,7 +81,7 @@ static struct symfile_segment_data *
 elf_symfile_segments (bfd *abfd)
 {
   Elf_Internal_Phdr *phdrs, **segments;
-  long phdrs_size;
+  long long phdrs_size;
   int num_phdrs, num_segments, num_sections, i;
   asection *sect;
   struct symfile_segment_data *data;
@@ -225,12 +225,12 @@ record_minimal_symbol (minimal_symbol_reader &reader,
 static void
 elf_symtab_read (minimal_symbol_reader &reader,
 		 struct objfile *objfile, int type,
-		 long number_of_symbols, asymbol **symbol_table,
+		 long long number_of_symbols, asymbol **symbol_table,
 		 bool copy_names)
 {
   struct gdbarch *gdbarch = get_objfile_arch (objfile);
   asymbol *sym;
-  long i;
+  long long i;
   CORE_ADDR symaddr;
   enum minimal_symbol_type ms_type;
   /* Name of the last file symbol.  This is either a constant string or is
@@ -1036,7 +1036,7 @@ elf_read_minimal_symbols (struct objfile *objfile, int symfile_flags,
 			  const struct elfinfo *ei)
 {
   bfd *synth_abfd, *abfd = objfile->obfd;
-  long symcount = 0, dynsymcount = 0, synthcount, storage_needed;
+  long long symcount = 0, dynsymcount = 0, synthcount, storage_needed;
   asymbol **symbol_table = NULL, **dyn_symbol_table = NULL;
   asymbol *synthsyms;
   struct dbx_symfile_info *dbx;
@@ -1146,7 +1146,7 @@ elf_read_minimal_symbols (struct objfile *objfile, int symfile_flags,
 					 &synthsyms);
   if (synthcount > 0)
     {
-      long i;
+      long long i;
 
       std::unique_ptr<asymbol *[]>
 	synth_symbol_table (new asymbol *[synthcount]);
diff --git a/gdb/eval.c b/gdb/eval.c
index 9db6e7c..62279fc 100644
--- a/gdb/eval.c
+++ b/gdb/eval.c
@@ -901,7 +901,7 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,
 	  /* Now, convert these values to an address.  */
 	  arg2 = value_cast (type_ptr, arg2);
 
-	  long mem_offset = value_as_long (arg1);
+	  long long mem_offset = value_as_long (arg1);
 
 	  arg1 = value_from_pointer (target_type_ptr,
 				     value_as_long (arg2) + mem_offset);
@@ -1250,7 +1250,7 @@ evaluate_subexp_standard (struct type *expect_type,
   struct value **argvec;
   int code;
   int ix;
-  long mem_offset;
+  long long mem_offset;
   struct type **arg_types;
 
   pc = (*pos)++;
diff --git a/gdb/event-loop.c b/gdb/event-loop.c
index 9ca473e..e745044 100644
--- a/gdb/event-loop.c
+++ b/gdb/event-loop.c
@@ -769,7 +769,7 @@ gdb_wait_for_event (int block)
 	timeout = 0;
 
       num_found = poll (gdb_notifier.poll_fds,
-			(unsigned long) gdb_notifier.num_fds, timeout);
+			(unsigned long long) gdb_notifier.num_fds, timeout);
 
       /* Don't print anything if we get out of poll because of a
 	 signal.  */
diff --git a/gdb/exec.c b/gdb/exec.c
index 3023ff7..60e0b64 100644
--- a/gdb/exec.c
+++ b/gdb/exec.c
@@ -969,9 +969,9 @@ set_section_command (const char *args, int from_tty)
   struct target_section *p;
   const char *secname;
   unsigned seclen;
-  unsigned long secaddr;
+  unsigned long long secaddr;
   char secprint[100];
-  long offset;
+  long long offset;
   struct target_section_table *table;
 
   if (args == 0)
diff --git a/gdb/expprint.c b/gdb/expprint.c
index d6ed412..aa1767b 100644
--- a/gdb/expprint.c
+++ b/gdb/expprint.c
@@ -730,7 +730,7 @@ dump_raw_expression (struct expression *exp, struct ui_file *stream,
     fprintf_filtered (stream, ", %s:", note);
   fprintf_filtered (stream, "\n\tLanguage %s, %d elements, %ld bytes each.\n",
 		    exp->language_defn->la_name, exp->nelts,
-		    (long) sizeof (union exp_element));
+		    (long long) sizeof (union exp_element));
   fprintf_filtered (stream, "\t%5s  %20s  %16s  %s\n", "Index", "Opcode",
 		    "Hex Value", "String Value");
   for (elt = 0; elt < exp->nelts; elt++)
@@ -870,8 +870,8 @@ dump_subexp_body_standard (struct expression *exp,
       fprintf_filtered (stream, " (");
       type_print (exp->elts[elt].type, NULL, stream, 0);
       fprintf_filtered (stream, "), value %ld (0x%lx)",
-			(long) exp->elts[elt + 1].longconst,
-			(long) exp->elts[elt + 1].longconst);
+			(long long) exp->elts[elt + 1].longconst,
+			(long long) exp->elts[elt + 1].longconst);
       elt += 3;
       break;
     case OP_FLOAT:
@@ -911,7 +911,7 @@ dump_subexp_body_standard (struct expression *exp,
       break;
     case OP_LAST:
       fprintf_filtered (stream, "History element %ld",
-			(long) exp->elts[elt].longconst);
+			(long long) exp->elts[elt].longconst);
       elt += 2;
       break;
     case OP_REGISTER:
@@ -1155,7 +1155,7 @@ dump_prefix_expression (struct expression *exp, struct ui_file *stream)
   print_expression (exp, stream);
   fprintf_filtered (stream, "'\n\tLanguage %s, %d elements, %ld bytes each.\n",
 		    exp->language_defn->la_name, exp->nelts,
-		    (long) sizeof (union exp_element));
+		    (long long) sizeof (union exp_element));
   fputs_filtered ("\n", stream);
 
   for (elt = 0; elt < exp->nelts;)
diff --git a/gdb/fbsd-nat.c b/gdb/fbsd-nat.c
index 115deac..ff3f994 100644
--- a/gdb/fbsd-nat.c
+++ b/gdb/fbsd-nat.c
@@ -121,7 +121,7 @@ fbsd_nat_target::find_memory_regions (find_memory_region_ftype func,
 	{
 	  fprintf_filtered (gdb_stdout, 
 			    "Save segment, %ld bytes at %s (%c%c%c)\n",
-			    (long) size,
+			    (long long) size,
 			    paddress (target_gdbarch (), kve->kve_start),
 			    kve->kve_protection & KVME_PROT_READ ? 'r' : '-',
 			    kve->kve_protection & KVME_PROT_WRITE ? 'w' : '-',
@@ -138,13 +138,13 @@ fbsd_nat_target::find_memory_regions (find_memory_region_ftype func,
 }
 #else
 static int
-fbsd_read_mapping (FILE *mapfile, unsigned long *start, unsigned long *end,
+fbsd_read_mapping (FILE *mapfile, unsigned long long *start, unsigned long long *end,
 		   char *protection)
 {
   /* FreeBSD 5.1-RELEASE uses a 256-byte buffer.  */
   char buf[256];
   int resident, privateresident;
-  unsigned long obj;
+  unsigned long long obj;
   int ret = EOF;
 
   /* As of FreeBSD 5.0-RELEASE, the layout is described in
@@ -167,11 +167,11 @@ fbsd_nat_target::find_memory_regions (find_memory_region_ftype func,
 				      void *obfd)
 {
   pid_t pid = inferior_ptid.pid ();
-  unsigned long start, end, size;
+  unsigned long long start, end, size;
   char protection[4];
   int read, write, exec;
 
-  std::string mapfilename = string_printf ("/proc/%ld/map", (long) pid);
+  std::string mapfilename = string_printf ("/proc/%ld/map", (long long) pid);
   gdb_file_up mapfile (fopen (mapfilename.c_str (), "r"));
   if (mapfile == NULL)
     error (_("Couldn't open %s."), mapfilename.c_str ());
@@ -857,7 +857,7 @@ fbsd_nat_target::thread_name (struct thread_info *thr)
   struct ptrace_lwpinfo pl;
   struct kinfo_proc kp;
   int pid = thr->ptid.pid ();
-  long lwp = thr->ptid.lwp ();
+  long long lwp = thr->ptid.lwp ();
   static char buf[sizeof pl.pl_tdname + 1];
 
   /* Note that ptrace_lwpinfo returns the process command in pl_tdname
diff --git a/gdb/fbsd-tdep.c b/gdb/fbsd-tdep.c
index 47a52d3..8d21fde 100644
--- a/gdb/fbsd-tdep.c
+++ b/gdb/fbsd-tdep.c
@@ -422,7 +422,7 @@ struct fbsd_collect_regset_section_cb_data
   bfd *obfd;
   char *note_data;
   int *note_size;
-  unsigned long lwp;
+  unsigned long long lwp;
   enum gdb_signal stop_signal;
   int abort_iteration;
 };
diff --git a/gdb/features/aarch64-core.c b/gdb/features/aarch64-core.c
index cd3de02..a355dfc 100644
--- a/gdb/features/aarch64-core.c
+++ b/gdb/features/aarch64-core.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_aarch64_core (struct target_desc *result, long regnum)
+create_feature_aarch64_core (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/aarch64-fpu.c b/gdb/features/aarch64-fpu.c
index 47962d1..e1eef26 100644
--- a/gdb/features/aarch64-fpu.c
+++ b/gdb/features/aarch64-fpu.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_aarch64_fpu (struct target_desc *result, long regnum)
+create_feature_aarch64_fpu (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/aarch64-sve.c b/gdb/features/aarch64-sve.c
index 71be67c..acc1815 100644
--- a/gdb/features/aarch64-sve.c
+++ b/gdb/features/aarch64-sve.c
@@ -22,7 +22,7 @@
    register.  */
 
 static int
-create_feature_aarch64_sve (struct target_desc *result, long regnum,
+create_feature_aarch64_sve (struct target_desc *result, long long regnum,
 			    uint64_t scale)
 {
   struct tdesc_feature *feature;
diff --git a/gdb/features/i386/32bit-avx.c b/gdb/features/i386/32bit-avx.c
index b9feac3..4780393 100644
--- a/gdb/features/i386/32bit-avx.c
+++ b/gdb/features/i386/32bit-avx.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_32bit_avx (struct target_desc *result, long regnum)
+create_feature_i386_32bit_avx (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/32bit-avx512.c b/gdb/features/i386/32bit-avx512.c
index 51a4032..348f92f 100644
--- a/gdb/features/i386/32bit-avx512.c
+++ b/gdb/features/i386/32bit-avx512.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_32bit_avx512 (struct target_desc *result, long regnum)
+create_feature_i386_32bit_avx512 (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/32bit-core.c b/gdb/features/i386/32bit-core.c
index 098c2ca..6e8a7eb 100644
--- a/gdb/features/i386/32bit-core.c
+++ b/gdb/features/i386/32bit-core.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_32bit_core (struct target_desc *result, long regnum)
+create_feature_i386_32bit_core (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/32bit-linux.c b/gdb/features/i386/32bit-linux.c
index 3bc5937..93b9531 100644
--- a/gdb/features/i386/32bit-linux.c
+++ b/gdb/features/i386/32bit-linux.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_32bit_linux (struct target_desc *result, long regnum)
+create_feature_i386_32bit_linux (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/32bit-mpx.c b/gdb/features/i386/32bit-mpx.c
index 8288e9d..e223a87 100644
--- a/gdb/features/i386/32bit-mpx.c
+++ b/gdb/features/i386/32bit-mpx.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_32bit_mpx (struct target_desc *result, long regnum)
+create_feature_i386_32bit_mpx (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/32bit-pkeys.c b/gdb/features/i386/32bit-pkeys.c
index a2a72f4..f66262d 100644
--- a/gdb/features/i386/32bit-pkeys.c
+++ b/gdb/features/i386/32bit-pkeys.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_32bit_pkeys (struct target_desc *result, long regnum)
+create_feature_i386_32bit_pkeys (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/32bit-sse.c b/gdb/features/i386/32bit-sse.c
index 68fbab0..2686ca6 100644
--- a/gdb/features/i386/32bit-sse.c
+++ b/gdb/features/i386/32bit-sse.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_32bit_sse (struct target_desc *result, long regnum)
+create_feature_i386_32bit_sse (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/64bit-avx.c b/gdb/features/i386/64bit-avx.c
index 7e45c98..a1ee222 100644
--- a/gdb/features/i386/64bit-avx.c
+++ b/gdb/features/i386/64bit-avx.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_64bit_avx (struct target_desc *result, long regnum)
+create_feature_i386_64bit_avx (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/64bit-avx512.c b/gdb/features/i386/64bit-avx512.c
index acc07a3..ffa7a4b 100644
--- a/gdb/features/i386/64bit-avx512.c
+++ b/gdb/features/i386/64bit-avx512.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_64bit_avx512 (struct target_desc *result, long regnum)
+create_feature_i386_64bit_avx512 (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/64bit-core.c b/gdb/features/i386/64bit-core.c
index 617425d..e18ec48 100644
--- a/gdb/features/i386/64bit-core.c
+++ b/gdb/features/i386/64bit-core.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_64bit_core (struct target_desc *result, long regnum)
+create_feature_i386_64bit_core (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/64bit-linux.c b/gdb/features/i386/64bit-linux.c
index 68de9d2..b290cc1 100644
--- a/gdb/features/i386/64bit-linux.c
+++ b/gdb/features/i386/64bit-linux.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_64bit_linux (struct target_desc *result, long regnum)
+create_feature_i386_64bit_linux (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/64bit-mpx.c b/gdb/features/i386/64bit-mpx.c
index ce4d611..392ae54 100644
--- a/gdb/features/i386/64bit-mpx.c
+++ b/gdb/features/i386/64bit-mpx.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_64bit_mpx (struct target_desc *result, long regnum)
+create_feature_i386_64bit_mpx (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/64bit-pkeys.c b/gdb/features/i386/64bit-pkeys.c
index 70b88cf..2570038 100644
--- a/gdb/features/i386/64bit-pkeys.c
+++ b/gdb/features/i386/64bit-pkeys.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_64bit_pkeys (struct target_desc *result, long regnum)
+create_feature_i386_64bit_pkeys (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/64bit-segments.c b/gdb/features/i386/64bit-segments.c
index b06d40f..3475a44 100644
--- a/gdb/features/i386/64bit-segments.c
+++ b/gdb/features/i386/64bit-segments.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_64bit_segments (struct target_desc *result, long regnum)
+create_feature_i386_64bit_segments (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/64bit-sse.c b/gdb/features/i386/64bit-sse.c
index e083093..01cdf27 100644
--- a/gdb/features/i386/64bit-sse.c
+++ b/gdb/features/i386/64bit-sse.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_64bit_sse (struct target_desc *result, long regnum)
+create_feature_i386_64bit_sse (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/i386/x32-core.c b/gdb/features/i386/x32-core.c
index dd6e1a2..e36210c 100644
--- a/gdb/features/i386/x32-core.c
+++ b/gdb/features/i386/x32-core.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_i386_x32_core (struct target_desc *result, long regnum)
+create_feature_i386_x32_core (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/tic6x-c6xp.c b/gdb/features/tic6x-c6xp.c
index bfd69d7..475db58 100644
--- a/gdb/features/tic6x-c6xp.c
+++ b/gdb/features/tic6x-c6xp.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_tic6x_c6xp (struct target_desc *result, long regnum)
+create_feature_tic6x_c6xp (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/tic6x-core.c b/gdb/features/tic6x-core.c
index 0415209..c9e485c 100644
--- a/gdb/features/tic6x-core.c
+++ b/gdb/features/tic6x-core.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_tic6x_core (struct target_desc *result, long regnum)
+create_feature_tic6x_core (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/features/tic6x-gp.c b/gdb/features/tic6x-gp.c
index 4a0734c..95e11b9 100644
--- a/gdb/features/tic6x-gp.c
+++ b/gdb/features/tic6x-gp.c
@@ -4,7 +4,7 @@
 #include "common/tdesc.h"
 
 static int
-create_feature_tic6x_gp (struct target_desc *result, long regnum)
+create_feature_tic6x_gp (struct target_desc *result, long long regnum)
 {
   struct tdesc_feature *feature;
 
diff --git a/gdb/frame.c b/gdb/frame.c
index 1fe882c..63172c3 100644
--- a/gdb/frame.c
+++ b/gdb/frame.c
@@ -1556,7 +1556,7 @@ create_sentinel_frame (struct program_space *pspace, struct regcache *regcache)
 static struct obstack frame_cache_obstack;
 
 void *
-frame_obstack_zalloc (unsigned long size)
+frame_obstack_zalloc (unsigned long long size)
 {
   void *data = obstack_alloc (&frame_cache_obstack, size);
 
diff --git a/gdb/frame.h b/gdb/frame.h
index a6f7fd8..cf5adac 100644
--- a/gdb/frame.h
+++ b/gdb/frame.h
@@ -693,7 +693,7 @@ enum print_what
    Appendices to the frame info (such as the unwind cache) should
    allocate memory using this method.  */
 
-extern void *frame_obstack_zalloc (unsigned long size);
+extern void *frame_obstack_zalloc (unsigned long long size);
 #define FRAME_OBSTACK_ZALLOC(TYPE) \
   ((TYPE *) frame_obstack_zalloc (sizeof (TYPE)))
 #define FRAME_OBSTACK_CALLOC(NUMBER,TYPE) \
diff --git a/gdb/frv-tdep.c b/gdb/frv-tdep.c
index 1eed441..250167b 100644
--- a/gdb/frv-tdep.c
+++ b/gdb/frv-tdep.c
@@ -1014,7 +1014,7 @@ frv_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   gdb_byte buf[4];
-  unsigned long op;
+  unsigned long long op;
   CORE_ADDR orig_pc = pc;
 
   if (target_read_memory (pc, buf, 4))
diff --git a/gdb/gcore.c b/gdb/gcore.c
index fbebb6a..981021d 100644
--- a/gdb/gcore.c
+++ b/gdb/gcore.c
@@ -45,7 +45,7 @@
 
 static const char *default_gcore_target (void);
 static enum bfd_architecture default_gcore_arch (void);
-static unsigned long default_gcore_mach (void);
+static unsigned long long default_gcore_mach (void);
 static int gcore_memory_sections (bfd *);
 
 /* create_gcore_bfd -- helper for gcore_command (exported).
@@ -174,7 +174,7 @@ gcore_command (const char *args, int from_tty)
   fprintf_filtered (gdb_stdout, "Saved corefile %s\n", corefilename.get ());
 }
 
-static unsigned long
+static unsigned long long
 default_gcore_mach (void)
 {
 #if 1	/* See if this even matters...  */
@@ -399,7 +399,7 @@ make_output_phdrs (bfd *obfd, asection *osec, void *ignored)
    GDB is creating.  */
 
 static int
-gcore_create_callback (CORE_ADDR vaddr, unsigned long size, int read,
+gcore_create_callback (CORE_ADDR vaddr, unsigned long long size, int read,
 		       int write, int exec, int modified, void *data)
 {
   bfd *obfd = (bfd *) data;
diff --git a/gdb/gdb_bfd.c b/gdb/gdb_bfd.c
index 8fedeb4..5f7b284 100644
--- a/gdb/gdb_bfd.c
+++ b/gdb/gdb_bfd.c
@@ -112,7 +112,7 @@ struct gdb_bfd_data
   unsigned int crc_computed : 1;
 
   /* The file's CRC.  */
-  unsigned long crc = 0;
+  unsigned long long crc = 0;
 
   /* If the BFD comes from an archive, this points to the archive's
      BFD.  Otherwise, this is NULL.  */
@@ -724,9 +724,9 @@ gdb_bfd_map_section (asection *sectp, bfd_size_type *size)
    not preserved.  */
 
 static int
-get_file_crc (bfd *abfd, unsigned long *file_crc_return)
+get_file_crc (bfd *abfd, unsigned long long *file_crc_return)
 {
-  unsigned long file_crc = 0;
+  unsigned long long file_crc = 0;
 
   if (bfd_seek (abfd, 0, SEEK_SET) != 0)
     {
@@ -759,7 +759,7 @@ get_file_crc (bfd *abfd, unsigned long *file_crc_return)
 /* See gdb_bfd.h.  */
 
 int
-gdb_bfd_crc (struct bfd *abfd, unsigned long *crc_out)
+gdb_bfd_crc (struct bfd *abfd, unsigned long long *crc_out)
 {
   struct gdb_bfd_data *gdata = (struct gdb_bfd_data *) bfd_usrdata (abfd);
 
diff --git a/gdb/gdb_bfd.h b/gdb/gdb_bfd.h
index 85300b9..9468c18 100644
--- a/gdb/gdb_bfd.h
+++ b/gdb/gdb_bfd.h
@@ -119,7 +119,7 @@ const gdb_byte *gdb_bfd_map_section (asection *section, bfd_size_type *size);
    separate debug files.  When successful, this fills in *CRC_OUT and
    returns 1.  Otherwise, this issues a warning and returns 0.  */
 
-int gdb_bfd_crc (struct bfd *abfd, unsigned long *crc_out);
+int gdb_bfd_crc (struct bfd *abfd, unsigned long long *crc_out);
 
 
 
diff --git a/gdb/gdbserver/ax.c b/gdb/gdbserver/ax.c
index c754383..d61aacf 100644
--- a/gdb/gdbserver/ax.c
+++ b/gdb/gdbserver/ax.c
@@ -894,7 +894,7 @@ ax_printf (CORE_ADDR fn, CORE_ADDR chan, const char *format,
 
 	case long_arg:
 	  {
-	    long val = args[i];
+	    long long val = args[i];
 
 	    printf (current_substring, val);
 	    break;
diff --git a/gdb/gdbserver/debug.c b/gdb/gdbserver/debug.c
index fe1e45f..d32984f 100644
--- a/gdb/gdbserver/debug.c
+++ b/gdb/gdbserver/debug.c
@@ -46,7 +46,7 @@ debug_vprintf (const char *format, va_list ap)
       seconds s = duration_cast<seconds> (now.time_since_epoch ());
       microseconds us = duration_cast<microseconds> (now.time_since_epoch ()) - s;
 
-      fprintf (stderr, "%ld.%06ld ", (long) s.count (), (long) us.count ());
+      fprintf (stderr, "%ld.%06ld ", (long long) s.count (), (long long) us.count ());
     }
 #endif
 
diff --git a/gdb/gdbserver/gdbthread.h b/gdb/gdbserver/gdbthread.h
index 0edf870..0707de1 100644
--- a/gdb/gdbserver/gdbthread.h
+++ b/gdb/gdbserver/gdbthread.h
@@ -218,7 +218,7 @@ pid_of (const thread_info *thread)
 
 /* Get the lwp of THREAD.  */
 
-static inline long
+static inline long long
 lwpid_of (const thread_info *thread)
 {
   return thread->id.lwp ();
diff --git a/gdb/gdbserver/i387-fp.c b/gdb/gdbserver/i387-fp.c
index b06079a..6efe4bb 100644
--- a/gdb/gdbserver/i387-fp.c
+++ b/gdb/gdbserver/i387-fp.c
@@ -149,7 +149,7 @@ i387_cache_to_fsave (struct regcache *regcache, void *buf)
   struct i387_fsave *fp = (struct i387_fsave *) buf;
   int i;
   int st0_regnum = find_regno (regcache->tdesc, "st0");
-  unsigned long val2;
+  unsigned long long val2;
 
   for (i = 0; i < 8; i++)
     collect_register (regcache, i + st0_regnum,
@@ -176,7 +176,7 @@ i387_fsave_to_cache (struct regcache *regcache, const void *buf)
   struct i387_fsave *fp = (struct i387_fsave *) buf;
   int i;
   int st0_regnum = find_regno (regcache->tdesc, "st0");
-  unsigned long val;
+  unsigned long long val;
 
   for (i = 0; i < 8; i++)
     supply_register (regcache, i + st0_regnum,
@@ -213,7 +213,7 @@ i387_cache_to_fxsave (struct regcache *regcache, void *buf)
   int i;
   int st0_regnum = find_regno (regcache->tdesc, "st0");
   int xmm0_regnum = find_regno (regcache->tdesc, "xmm0");
-  unsigned long val, val2;
+  unsigned long long val, val2;
   /* Amd64 has 16 xmm regs; I386 has 8 xmm regs.  */
   int num_xmm_registers = register_size (regcache->tdesc, 0) == 8 ? 16 : 8;
 
@@ -257,7 +257,7 @@ i387_cache_to_xsave (struct regcache *regcache, void *buf)
 {
   struct i387_xsave *fp = (struct i387_xsave *) buf;
   int i;
-  unsigned long val, val2;
+  unsigned long long val, val2;
   unsigned long long xstate_bv = 0;
   unsigned long long clear_bv = 0;
   char raw[64];
@@ -610,7 +610,7 @@ i387_ftag (struct i387_fxsave *fp, int regno)
 {
   unsigned char *raw = &fp->st_space[regno * 16];
   unsigned int exponent;
-  unsigned long fraction[2];
+  unsigned long long fraction[2];
   int integer;
 
   integer = raw[7] & 0x80;
@@ -659,7 +659,7 @@ i387_fxsave_to_cache (struct regcache *regcache, const void *buf)
   int i, top;
   int st0_regnum = find_regno (regcache->tdesc, "st0");
   int xmm0_regnum = find_regno (regcache->tdesc, "xmm0");
-  unsigned long val;
+  unsigned long long val;
   /* Amd64 has 16 xmm regs; I386 has 8 xmm regs.  */
   int num_xmm_registers = register_size (regcache->tdesc, 0) == 8 ? 16 : 8;
 
@@ -711,7 +711,7 @@ i387_xsave_to_cache (struct regcache *regcache, const void *buf)
   struct i387_xsave *fp = (struct i387_xsave *) buf;
   struct i387_fxsave *fxp = (struct i387_fxsave *) buf;
   int i, top;
-  unsigned long val;
+  unsigned long long val;
   unsigned long long clear_bv;
   gdb_byte *p;
   /* Amd64 has 16 xmm regs; I386 has 8 xmm regs.  */
diff --git a/gdb/gdbserver/linux-aarch32-low.c b/gdb/gdbserver/linux-aarch32-low.c
index 12c11a4..7c7c7d8 100644
--- a/gdb/gdbserver/linux-aarch32-low.c
+++ b/gdb/gdbserver/linux-aarch32-low.c
@@ -38,9 +38,9 @@
 #define arm_eabi_breakpoint 0xe7f001f0UL
 
 #if (defined __ARM_EABI__ || defined __aarch64__)
-static const unsigned long arm_breakpoint = arm_eabi_breakpoint;
+static const unsigned long long arm_breakpoint = arm_eabi_breakpoint;
 #else
-static const unsigned long arm_breakpoint = arm_abi_breakpoint;
+static const unsigned long long arm_breakpoint = arm_abi_breakpoint;
 #endif
 
 #define arm_breakpoint_len 4
@@ -172,7 +172,7 @@ int
 arm_is_thumb_mode (void)
 {
   struct regcache *regcache = get_thread_regcache (current_thread, 1);
-  unsigned long cpsr;
+  unsigned long long cpsr;
 
   collect_register_by_name (regcache, "cpsr", &cpsr);
 
@@ -206,7 +206,7 @@ arm_breakpoint_at (CORE_ADDR where)
   else
     {
       /* ARM mode.  */
-      unsigned long insn;
+      unsigned long long insn;
 
       (*the_target->read_memory) (where, (unsigned char *) &insn, 4);
       if (insn == arm_abi_breakpoint)
diff --git a/gdb/gdbserver/linux-aarch64-low.c b/gdb/gdbserver/linux-aarch64-low.c
index 1d34e31..140026e 100644
--- a/gdb/gdbserver/linux-aarch64-low.c
+++ b/gdb/gdbserver/linux-aarch64-low.c
@@ -269,7 +269,7 @@ aarch64_insert_point (enum raw_bkpt_type type, CORE_ADDR addr,
 
   if (show_debug_regs)
     fprintf (stderr, "insert_point on entry (addr=0x%08lx, len=%d)\n",
-	     (unsigned long) addr, len);
+	     (unsigned long long) addr, len);
 
   /* Determine the type from the raw breakpoint type.  */
   targ_type = raw_bkpt_type_to_target_hw_bp_type (type);
@@ -318,7 +318,7 @@ aarch64_remove_point (enum raw_bkpt_type type, CORE_ADDR addr,
 
   if (show_debug_regs)
     fprintf (stderr, "remove_point on entry (addr=0x%08lx, len=%d)\n",
-	     (unsigned long) addr, len);
+	     (unsigned long long) addr, len);
 
   /* Determine the type from the raw breakpoint type.  */
   targ_type = raw_bkpt_type_to_target_hw_bp_type (type);
@@ -649,7 +649,7 @@ aarch64_get_syscall_trapinfo (struct regcache *regcache, int *sysno)
 
   if (use_64bit)
     {
-      long l_sysno;
+      long long l_sysno;
 
       collect_register_by_name (regcache, "x8", &l_sysno);
       *sysno = (int) l_sysno;
diff --git a/gdb/gdbserver/linux-amd64-ipa.c b/gdb/gdbserver/linux-amd64-ipa.c
index d99a3db..546a15c 100644
--- a/gdb/gdbserver/linux-amd64-ipa.c
+++ b/gdb/gdbserver/linux-amd64-ipa.c
@@ -135,7 +135,7 @@ supply_static_tracepoint_registers (struct regcache *regcache,
 				    CORE_ADDR pc)
 {
   int i;
-  unsigned long newpc = pc;
+  unsigned long long newpc = pc;
 
   supply_register (regcache, AMD64_RIP_REGNUM, &newpc);
 
@@ -151,7 +151,7 @@ supply_static_tracepoint_registers (struct regcache *regcache,
 	    break;
 	  case 2:
 	    {
-	      unsigned long reg
+	      unsigned long long reg
 		= * (short *) (((char *) buf)
 			       + x86_64_st_collect_regmap[i].offset);
 	      reg &= 0xffff;
diff --git a/gdb/gdbserver/linux-arm-low.c b/gdb/gdbserver/linux-arm-low.c
index 6c2dcea..b42667d 100644
--- a/gdb/gdbserver/linux-arm-low.c
+++ b/gdb/gdbserver/linux-arm-low.c
@@ -772,8 +772,8 @@ static CORE_ADDR
 arm_sigreturn_next_pc (struct regcache *regcache, int svc_number,
 		       int *is_thumb)
 {
-  unsigned long sp;
-  unsigned long sp_data;
+  unsigned long long sp;
+  unsigned long long sp_data;
   /* Offset of PC register.  */
   int pc_offset = 0;
   CORE_ADDR next_pc = 0;
@@ -814,8 +814,8 @@ get_next_pcs_syscall_next_pc (struct arm_get_next_pcs *self)
     }
   else
     {
-      unsigned long this_instr;
-      unsigned long svc_operand;
+      unsigned long long this_instr;
+      unsigned long long svc_operand;
 
       target_read_memory (pc, (unsigned char *) &this_instr, 4);
       svc_operand = (0x00ffffff & this_instr);
@@ -848,7 +848,7 @@ get_next_pcs_syscall_next_pc (struct arm_get_next_pcs *self)
 }
 
 static int
-arm_get_hwcap (unsigned long *valp)
+arm_get_hwcap (unsigned long long *valp)
 {
   unsigned char *data = (unsigned char *) alloca (8);
   int offset = 0;
@@ -873,7 +873,7 @@ static const struct target_desc *
 arm_read_description (void)
 {
   int pid = lwpid_of (current_thread);
-  unsigned long arm_hwcap = 0;
+  unsigned long long arm_hwcap = 0;
 
   /* Query hardware watchpoint/breakpoint capabilities.  */
   arm_linux_init_hwbp_cap (pid);
@@ -970,8 +970,8 @@ arm_get_syscall_trapinfo (struct regcache *regcache, int *sysno)
     collect_register_by_name (regcache, "r7", sysno);
   else
     {
-      unsigned long pc;
-      unsigned long insn;
+      unsigned long long pc;
+      unsigned long long insn;
 
       collect_register_by_name (regcache, "pc", &pc);
 
@@ -979,7 +979,7 @@ arm_get_syscall_trapinfo (struct regcache *regcache, int *sysno)
 	*sysno = UNKNOWN_SYSCALL;
       else
 	{
-	  unsigned long svc_operand = (0x00ffffff & insn);
+	  unsigned long long svc_operand = (0x00ffffff & insn);
 
 	  if (svc_operand)
 	    {
diff --git a/gdb/gdbserver/linux-crisv32-low.c b/gdb/gdbserver/linux-crisv32-low.c
index 6eb8217..af9f582 100644
--- a/gdb/gdbserver/linux-crisv32-low.c
+++ b/gdb/gdbserver/linux-crisv32-low.c
@@ -84,7 +84,7 @@ cris_breakpoint_at (CORE_ADDR where)
 
 static void
 cris_write_data_breakpoint (struct regcache *regcache,
-			    int bp, unsigned long start, unsigned long end)
+			    int bp, unsigned long long start, unsigned long long end)
 {
   switch (bp)
     {
@@ -134,9 +134,9 @@ cris_insert_point (enum raw_bkpt_type type, CORE_ADDR addr,
 		   int len, struct raw_breakpoint *bp)
 {
   int bp;
-  unsigned long bp_ctrl;
-  unsigned long start, end;
-  unsigned long ccs;
+  unsigned long long bp_ctrl;
+  unsigned long long start, end;
+  unsigned long long ccs;
   struct regcache *regcache;
 
   regcache = get_thread_regcache (current_thread, 1);
@@ -207,10 +207,10 @@ cris_remove_point (enum raw_bkpt_type type, CORE_ADDR addr, int len,
 		   struct raw_breakpoint *bp)
 {
   int bp;
-  unsigned long bp_ctrl;
-  unsigned long start, end;
+  unsigned long long bp_ctrl;
+  unsigned long long start, end;
   struct regcache *regcache;
-  unsigned long bp_d_regs[12];
+  unsigned long long bp_d_regs[12];
 
   regcache = get_thread_regcache (current_thread, 1);
 
@@ -288,7 +288,7 @@ cris_remove_point (enum raw_bkpt_type type, CORE_ADDR addr, int len,
 static int
 cris_stopped_by_watchpoint (void)
 {
-  unsigned long exs;
+  unsigned long long exs;
   struct regcache *regcache = get_thread_regcache (current_thread, 1);
 
   collect_register_by_name (regcache, "exs", &exs);
@@ -299,7 +299,7 @@ cris_stopped_by_watchpoint (void)
 static CORE_ADDR
 cris_stopped_data_address (void)
 {
-  unsigned long eda;
+  unsigned long long eda;
   struct regcache *regcache = get_thread_regcache (current_thread, 1);
 
   collect_register_by_name (regcache, "eda", &eda);
diff --git a/gdb/gdbserver/linux-i386-ipa.c b/gdb/gdbserver/linux-i386-ipa.c
index 39afcaf..c028494 100644
--- a/gdb/gdbserver/linux-i386-ipa.c
+++ b/gdb/gdbserver/linux-i386-ipa.c
@@ -171,7 +171,7 @@ supply_static_tracepoint_registers (struct regcache *regcache,
 	    break;
 	  case 2:
 	    {
-	      unsigned long reg
+	      unsigned long long reg
 		= * (short *) (((char *) buf)
 			       + i386_st_collect_regmap[i].offset);
 	      reg &= 0xffff;
diff --git a/gdb/gdbserver/linux-low.c b/gdb/gdbserver/linux-low.c
index 7c396ae..5662d7f 100644
--- a/gdb/gdbserver/linux-low.c
+++ b/gdb/gdbserver/linux-low.c
@@ -275,7 +275,7 @@ static void mark_lwp_dead (struct lwp_info *lwp, int wstat);
 static int lwp_is_marked_dead (struct lwp_info *lwp);
 static void proceed_all_lwps (void);
 static int finish_step_over (struct lwp_info *lwp);
-static int kill_lwp (unsigned long lwpid, int signo);
+static int kill_lwp (unsigned long long lwpid, int signo);
 static void enqueue_pending_signal (struct lwp_info *lwp, int signal, siginfo_t *info);
 static void complete_ongoing_step_over (void);
 static int linux_low_ptrace_options (int attached);
@@ -492,7 +492,7 @@ handle_extended_wait (struct lwp_info **orig_event_lwp, int wstat)
       || (event == PTRACE_EVENT_CLONE))
     {
       ptid_t ptid;
-      unsigned long new_pid;
+      unsigned long long new_pid;
       int ret, status;
 
       /* Get the pid of the new lwp.  */
@@ -764,7 +764,7 @@ get_pc (struct lwp_info *lwp)
   pc = (*the_low_target.get_pc) (regcache);
 
   if (debug_threads)
-    debug_printf ("pc is 0x%lx\n", (long) pc);
+    debug_printf ("pc is 0x%lx\n", (long long) pc);
 
   current_thread = saved_thread;
   return pc;
@@ -1181,7 +1181,7 @@ static void async_file_mark (void);
    of its threads.  */
 
 static int
-linux_attach (unsigned long pid)
+linux_attach (unsigned long long pid)
 {
   struct process_info *proc;
   struct thread_info *initial_thread;
@@ -1549,7 +1549,7 @@ linux_detach_one_lwp (struct lwp_info *lwp)
 
   lwpid = lwpid_of (thread);
   if (ptrace (PTRACE_DETACH, lwpid, (PTRACE_TYPE_ARG3) 0,
-	      (PTRACE_TYPE_ARG4) (long) sig) < 0)
+	      (PTRACE_TYPE_ARG4) (long long) sig) < 0)
     {
       int save_errno = errno;
 
@@ -2733,7 +2733,7 @@ linux_wait_for_event_filtered (ptid_t wait_ptid, ptid_t filter_ptid,
 	  if (debug_threads)
 	    {
 	      debug_printf ("LLW: waitpid %ld received %s\n",
-			    (long) ret, status_to_str (*wstatp));
+			    (long long) ret, status_to_str (*wstatp));
 	    }
 
 	  /* Filter all events.  IOW, leave all events pending.  We'll
@@ -3902,7 +3902,7 @@ linux_wait (ptid_t ptid,
 /* Send a signal to an LWP.  */
 
 static int
-kill_lwp (unsigned long lwpid, int signo)
+kill_lwp (unsigned long long lwpid, int signo)
 {
   int ret;
 
@@ -4413,7 +4413,7 @@ linux_resume_one_lwp_throw (struct lwp_info *lwp,
       if (debug_threads)
 	{
 	  debug_printf ("  %s from pc 0x%lx\n", step ? "step" : "continue",
-			(long) lwp->stop_pc);
+			(long long) lwp->stop_pc);
 	}
     }
 
@@ -5362,7 +5362,7 @@ regsets_fetch_inferior_registers (struct regsets_info *regsets_info,
 
 #ifndef __sparc__
       res = ptrace (regset->get_request, pid,
-		    (PTRACE_TYPE_ARG3) (long) nt_type, data);
+		    (PTRACE_TYPE_ARG3) (long long) nt_type, data);
 #else
       res = ptrace (regset->get_request, pid, data, nt_type);
 #endif
@@ -5445,7 +5445,7 @@ regsets_store_inferior_registers (struct regsets_info *regsets_info,
 
 #ifndef __sparc__
       res = ptrace (regset->get_request, pid,
-		    (PTRACE_TYPE_ARG3) (long) nt_type, data);
+		    (PTRACE_TYPE_ARG3) (long long) nt_type, data);
 #else
       res = ptrace (regset->get_request, pid, data, nt_type);
 #endif
@@ -5458,7 +5458,7 @@ regsets_store_inferior_registers (struct regsets_info *regsets_info,
 	  /* Only now do we write the register set.  */
 #ifndef __sparc__
 	  res = ptrace (regset->set_request, pid,
-			(PTRACE_TYPE_ARG3) (long) nt_type, data);
+			(PTRACE_TYPE_ARG3) (long long) nt_type, data);
 #else
 	  res = ptrace (regset->set_request, pid, data, nt_type);
 #endif
@@ -5761,7 +5761,7 @@ linux_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
   int fd;
 
   /* Try using /proc.  Don't bother for one word.  */
-  if (len >= 3 * sizeof (long))
+  if (len >= 3 * sizeof (long long))
     {
       int bytes;
 
@@ -5874,7 +5874,7 @@ linux_write_memory (CORE_ADDR memaddr, const unsigned char *myaddr, int len)
       *p = '\0';
 
       debug_printf ("Writing %s to 0x%08lx in process %d\n",
-		    str, (long) memaddr, pid);
+		    str, (long long) memaddr, pid);
     }
 
   /* Fill start and end extra bytes of buffer with existing memory data.  */
@@ -6094,7 +6094,7 @@ linux_stopped_data_address (void)
 static int
 linux_read_offsets (CORE_ADDR *text_p, CORE_ADDR *data_p)
 {
-  unsigned long text, text_end, data;
+  unsigned long long text, text_end, data;
   int pid = lwpid_of (current_thread);
 
   errno = 0;
@@ -6394,7 +6394,7 @@ linux_supports_range_stepping (void)
 
 /* Enumerate spufs IDs for process PID.  */
 static int
-spu_enumerate_spu_ids (long pid, unsigned char *buf, CORE_ADDR offset, int len)
+spu_enumerate_spu_ids (long long pid, unsigned char *buf, CORE_ADDR offset, int len)
 {
   int pos = 0;
   int written = 0;
@@ -6448,7 +6448,7 @@ linux_qxfer_spu (const char *annex, unsigned char *readbuf,
 		 unsigned const char *writebuf,
 		 CORE_ADDR offset, int len)
 {
-  long pid = lwpid_of (current_thread);
+  long long pid = lwpid_of (current_thread);
   char buf[128];
   int fd = 0;
   int ret = 0;
@@ -6750,7 +6750,7 @@ get_phdr_phnum_from_proc_auxv (const int pid, const int is_elf64,
     {
       warning ("Unexpected missing AT_PHDR and/or AT_PHNUM: "
 	       "phdr_memaddr = %ld, phdr_num = %d",
-	       (long) *phdr_memaddr, *num_phdr);
+	       (long long) *phdr_memaddr, *num_phdr);
       return 2;
     }
 
@@ -7091,7 +7091,7 @@ linux_qxfer_libraries_svr4 (const char *annex, unsigned char *readbuf,
 				 &lm_addr, ptr_size) != 0)
 	    {
 	      warning ("unable to read r_map from 0x%lx",
-		       (long) priv->r_debug + lmo->r_map_offset);
+		       (long long) priv->r_debug + lmo->r_map_offset);
 	    }
 	}
     }
@@ -7115,7 +7115,7 @@ linux_qxfer_libraries_svr4 (const char *annex, unsigned char *readbuf,
       if (lm_prev != l_prev)
 	{
 	  warning ("Corrupted shared library list: 0x%lx != 0x%lx",
-		   (long) lm_prev, (long) l_prev);
+		   (long long) lm_prev, (long long) l_prev);
 	  break;
 	}
 
@@ -7126,7 +7126,7 @@ linux_qxfer_libraries_svr4 (const char *annex, unsigned char *readbuf,
 	 executable does not have PT_DYNAMIC present and this function already
 	 exited above due to failed get_r_debug.  */
       if (lm_prev == 0)
-	string_appendf (document, " main-lm=\"0x%lx\"", (unsigned long) lm_addr);
+	string_appendf (document, " main-lm=\"0x%lx\"", (unsigned long long) lm_addr);
       else
 	{
 	  /* Not checking for error because reading may stop before
@@ -7147,8 +7147,8 @@ linux_qxfer_libraries_svr4 (const char *annex, unsigned char *readbuf,
 	      xml_escape_text_append (&document, (char *) libname);
 	      string_appendf (document, "\" lm=\"0x%lx\" "
 			      "l_addr=\"0x%lx\" l_ld=\"0x%lx\"/>",
-			      (unsigned long) lm_addr, (unsigned long) l_addr,
-			      (unsigned long) l_ld);
+			      (unsigned long long) lm_addr, (unsigned long long) l_addr,
+			      (unsigned long long) l_ld);
 	    }
 	}
 
diff --git a/gdb/gdbserver/linux-low.h b/gdb/gdbserver/linux-low.h
index 79b3311..a19d626 100644
--- a/gdb/gdbserver/linux-low.h
+++ b/gdb/gdbserver/linux-low.h
@@ -28,7 +28,7 @@
 #include "target/waitstatus.h" /* For enum target_stop_reason.  */
 #include "tracepoint.h"
 
-#define PTRACE_XFER_TYPE long
+#define PTRACE_XFER_TYPE long long
 
 #ifdef HAVE_LINUX_REGSETS
 typedef void (*regset_fill_func) (struct regcache *, void *);
diff --git a/gdb/gdbserver/linux-mips-low.c b/gdb/gdbserver/linux-mips-low.c
index 2194af6..8e49a40 100644
--- a/gdb/gdbserver/linux-mips-low.c
+++ b/gdb/gdbserver/linux-mips-low.c
@@ -485,7 +485,7 @@ mips_insert_point (enum raw_bkpt_type type, CORE_ADDR addr,
   struct process_info *proc = current_process ();
   struct arch_process_info *priv = proc->priv->arch_private;
   struct pt_watch_regs regs;
-  long lwpid;
+  long long lwpid;
   enum target_hw_bp_type watch_type;
   uint32_t irw;
 
@@ -580,7 +580,7 @@ mips_stopped_by_watchpoint (void)
   struct arch_process_info *priv = proc->priv->arch_private;
   int n;
   int num_valid;
-  long lwpid = lwpid_of (current_thread);
+  long long lwpid = lwpid_of (current_thread);
 
   if (!mips_linux_read_watch_registers (lwpid,
 					&priv->watch_readback,
@@ -608,7 +608,7 @@ mips_stopped_data_address (void)
   struct arch_process_info *priv = proc->priv->arch_private;
   int n;
   int num_valid;
-  long lwpid = lwpid_of (current_thread);
+  long long lwpid = lwpid_of (current_thread);
 
   /* On MIPS we don't know the low order 3 bits of the data address.
      GDB does not support remote targets that can't report the
diff --git a/gdb/gdbserver/linux-ppc-ipa.c b/gdb/gdbserver/linux-ppc-ipa.c
index f6861f0..2844bf1 100644
--- a/gdb/gdbserver/linux-ppc-ipa.c
+++ b/gdb/gdbserver/linux-ppc-ipa.c
@@ -83,7 +83,7 @@ supply_fast_tracepoint_registers (struct regcache *regcache,
 	continue;
       supply_register (regcache, i,
 		       ((char *) buf)
-			+ ppc_ft_collect_regmap[i] * sizeof (long));
+			+ ppc_ft_collect_regmap[i] * sizeof (long long));
     }
 }
 
@@ -98,8 +98,8 @@ get_raw_reg (const unsigned char *raw_regs, int regnum)
   if (ppc_ft_collect_regmap[regnum] == -1)
     return 0;
 
-  return *(unsigned long *) (raw_regs
-			     + ppc_ft_collect_regmap[regnum] * sizeof (long));
+  return *(unsigned long long *) (raw_regs
+			     + ppc_ft_collect_regmap[regnum] * sizeof (long long));
 }
 
 /* Allocate buffer for the jump pads.  The branch instruction has a reach
diff --git a/gdb/gdbserver/linux-ppc-low.c b/gdb/gdbserver/linux-ppc-low.c
index 47428c1..e60763d 100644
--- a/gdb/gdbserver/linux-ppc-low.c
+++ b/gdb/gdbserver/linux-ppc-low.c
@@ -41,7 +41,7 @@
 #define PPC_LI(insn)	(PPC_SEXT (PPC_FIELD (insn, 6, 24), 24) << 2)
 #define PPC_BD(insn)	(PPC_SEXT (PPC_FIELD (insn, 16, 14), 14) << 2)
 
-static unsigned long ppc_hwcap;
+static unsigned long long ppc_hwcap;
 
 
 #define ppc_num_regs 73
@@ -145,7 +145,7 @@ ppc_cannot_fetch_register (int regno)
 static void
 ppc_collect_ptrace_register (struct regcache *regcache, int regno, char *buf)
 {
-  memset (buf, 0, sizeof (long));
+  memset (buf, 0, sizeof (long long));
 
   if (__BYTE_ORDER == __LITTLE_ENDIAN)
     {
@@ -159,8 +159,8 @@ ppc_collect_ptrace_register (struct regcache *regcache, int regno, char *buf)
          padding to access them correctly.  */
       int size = register_size (regcache->tdesc, regno);
 
-      if (size < sizeof (long))
-	collect_register (regcache, regno, buf + sizeof (long) - size);
+      if (size < sizeof (long long))
+	collect_register (regcache, regno, buf + sizeof (long long) - size);
       else
 	collect_register (regcache, regno, buf);
     }
@@ -184,8 +184,8 @@ ppc_supply_ptrace_register (struct regcache *regcache,
          padding to access them correctly.  */
       int size = register_size (regcache->tdesc, regno);
 
-      if (size < sizeof (long))
-	supply_register (regcache, regno, buf + sizeof (long) - size);
+      if (size < sizeof (long long))
+	supply_register (regcache, regno, buf + sizeof (long long) - size);
       else
 	supply_register (regcache, regno, buf);
     }
@@ -221,7 +221,7 @@ parse_spufs_run (struct regcache *regcache, int *fd, CORE_ADDR *addr)
     }
   else
     {
-      unsigned long pc, r0, r3, r4;
+      unsigned long long pc, r0, r3, r4;
       collect_register_by_name (regcache, "pc", &pc);
       collect_register_by_name (regcache, "r0", &r0);
       collect_register_by_name (regcache, "orig_r3", &r3);
@@ -267,7 +267,7 @@ ppc_get_pc (struct regcache *regcache)
     }
   else
     {
-      unsigned long pc;
+      unsigned long long pc;
       collect_register_by_name (regcache, "pc", &pc);
       return (CORE_ADDR) pc;
     }
@@ -291,14 +291,14 @@ ppc_set_pc (struct regcache *regcache, CORE_ADDR pc)
     }
   else
     {
-      unsigned long newpc = pc;
+      unsigned long long newpc = pc;
       supply_register_by_name (regcache, "pc", &newpc);
     }
 }
 
 
 static int
-ppc_get_auxv (unsigned long type, unsigned long *valp)
+ppc_get_auxv (unsigned long long type, unsigned long long *valp)
 {
   const struct target_desc *tdesc = current_process ()->tdesc;
   int wordsize = register_size (tdesc, 0);
@@ -318,7 +318,7 @@ ppc_get_auxv (unsigned long type, unsigned long *valp)
 	}
       else
 	{
-	  unsigned long *data_p = (unsigned long *)data;
+	  unsigned long long *data_p = (unsigned long long *)data;
 	  if (data_p[0] == type)
 	    {
 	      *valp = data_p[1];
@@ -526,9 +526,9 @@ ppc_store_vrregset (struct regcache *regcache, const void *buf)
 
 struct gdb_evrregset_t
 {
-  unsigned long evr[32];
+  unsigned long long evr[32];
   unsigned long long acc;
-  unsigned long spefscr;
+  unsigned long long spefscr;
 };
 
 static void
@@ -659,7 +659,7 @@ ppc_arch_setup (void)
 	 supplied in a 32-bit GDB compilation doesn't reflect
 	 this.  */
       if (register_size (tdesc, 70) == 8)
-	ppc_regmap[70] = (48 + 2*32) * sizeof (long);
+	ppc_regmap[70] = (48 + 2*32) * sizeof (long long);
 
       ppc_regmap_adjusted = 1;
    }
@@ -741,7 +741,7 @@ is_elfv2_inferior (void)
 #else
   const int def_res = 0;
 #endif
-  unsigned long phdr;
+  unsigned long long phdr;
   Elf64_Ehdr ehdr;
 
   if (!ppc_get_auxv (AT_PHDR, &phdr))
@@ -1088,7 +1088,7 @@ static void
 ppc_relocate_instruction (CORE_ADDR *to, CORE_ADDR oldloc)
 {
   uint32_t insn, op6;
-  long rel, newrel;
+  long long rel, newrel;
 
   read_inferior_memory (oldloc, (unsigned char *) &insn, 4);
   op6 = PPC_OP6 (insn);
@@ -2209,7 +2209,7 @@ ppc_emit_ge_goto (int *offset_p, int *size_p)
 static void
 ppc_write_goto_address (CORE_ADDR from, CORE_ADDR to, int size)
 {
-  long rel = to - from;
+  long long rel = to - from;
   uint32_t insn;
   int opcd;
 
diff --git a/gdb/gdbserver/linux-s390-low.c b/gdb/gdbserver/linux-s390-low.c
index fff839b..753868b 100644
--- a/gdb/gdbserver/linux-s390-low.c
+++ b/gdb/gdbserver/linux-s390-low.c
@@ -160,16 +160,16 @@ s390_collect_ptrace_register (struct regcache *regcache, int regno, char *buf)
   struct usrregs_info *usr = regs_info->usrregs;
   int regaddr = usr->regmap[regno];
 
-  if (size < sizeof (long))
+  if (size < sizeof (long long))
     {
-      memset (buf, 0, sizeof (long));
+      memset (buf, 0, sizeof (long long));
 
       if ((regno ^ 1) < usr->num_regs
 	  && usr->regmap[regno ^ 1] == regaddr)
 	{
 	  collect_register (regcache, regno & ~1, buf);
 	  collect_register (regcache, (regno & ~1) + 1,
-			    buf + sizeof (long) - size);
+			    buf + sizeof (long long) - size);
 	}
       else if (regaddr == PT_PSWMASK)
 	{
@@ -185,12 +185,12 @@ s390_collect_ptrace_register (struct regcache *regcache, int regno, char *buf)
 	{
 	  /* Convert 4-byte PSW address to 8 bytes by clearing the addressing
 	     mode bit (which gets copied to the PSW mask instead).  */
-	  collect_register (regcache, regno, buf + sizeof (long) - size);
-	  buf[sizeof (long) - size] &= ~0x80;
+	  collect_register (regcache, regno, buf + sizeof (long long) - size);
+	  buf[sizeof (long long) - size] &= ~0x80;
 	}
       else if ((regaddr >= PT_GPR0 && regaddr <= PT_GPR15)
 	       || regaddr == PT_ORIGGPR2)
-	collect_register (regcache, regno, buf + sizeof (long) - size);
+	collect_register (regcache, regno, buf + sizeof (long long) - size);
       else
 	collect_register (regcache, regno, buf);
     }
@@ -207,14 +207,14 @@ s390_supply_ptrace_register (struct regcache *regcache,
   struct usrregs_info *usr = regs_info->usrregs;
   int regaddr = usr->regmap[regno];
 
-  if (size < sizeof (long))
+  if (size < sizeof (long long))
     {
       if ((regno ^ 1) < usr->num_regs
 	  && usr->regmap[regno ^ 1] == regaddr)
 	{
 	  supply_register (regcache, regno & ~1, buf);
 	  supply_register (regcache, (regno & ~1) + 1,
-			   buf + sizeof (long) - size);
+			   buf + sizeof (long long) - size);
 	}
       else if (regaddr == PT_PSWMASK)
 	{
@@ -239,14 +239,14 @@ s390_supply_ptrace_register (struct regcache *regcache,
 	  char amode;
 	  collect_register (regcache, regno, addr);
 	  amode = addr[0] & 0x80;
-	  memcpy (addr, buf + sizeof (long) - size, size);
+	  memcpy (addr, buf + sizeof (long long) - size, size);
 	  addr[0] &= ~0x80;
 	  addr[0] |= amode;
 	  supply_register (regcache, regno, addr);
 	}
       else if ((regaddr >= PT_GPR0 && regaddr <= PT_GPR15)
 	       || regaddr == PT_ORIGGPR2)
-	supply_register (regcache, regno, buf + sizeof (long) - size);
+	supply_register (regcache, regno, buf + sizeof (long long) - size);
       else
 	supply_register (regcache, regno, buf);
     }
@@ -444,7 +444,7 @@ s390_get_pc (struct regcache *regcache)
     }
   else
     {
-      unsigned long pc;
+      unsigned long long pc;
       collect_register_by_name (regcache, "pswa", &pc);
       return pc;
     }
@@ -462,7 +462,7 @@ s390_set_pc (struct regcache *regcache, CORE_ADDR newpc)
     }
   else
     {
-      unsigned long pc = newpc;
+      unsigned long long pc = newpc;
       supply_register_by_name (regcache, "pswa", &pc);
     }
 }
@@ -470,7 +470,7 @@ s390_set_pc (struct regcache *regcache, CORE_ADDR newpc)
 /* Get HWCAP from AUXV, using the given WORDSIZE.  Return the HWCAP, or
    zero if not found.  */
 
-static unsigned long
+static unsigned long long
 s390_get_hwcap (int wordsize)
 {
   gdb_byte *data = (gdb_byte *) alloca (2 * wordsize);
@@ -486,7 +486,7 @@ s390_get_hwcap (int wordsize)
         }
       else
         {
-          unsigned long *data_p = (unsigned long *)data;
+          unsigned long long *data_p = (unsigned long long *)data;
           if (data_p[0] == AT_HWCAP)
 	    return data_p[1];
         }
@@ -528,7 +528,7 @@ s390_check_regset (int pid, int regset, int regsize)
   iov.iov_base = buf;
   iov.iov_len = regsize;
 
-  if (ptrace (PTRACE_GETREGSET, pid, (long) regset, (long) &iov) >= 0
+  if (ptrace (PTRACE_GETREGSET, pid, (long long) regset, (long long) &iov) >= 0
       || errno == ENODATA)
     return 1;
   return 0;
@@ -548,7 +548,7 @@ s390_arch_setup (void)
   /* Determine word size and HWCAP.  */
   int pid = pid_of (current_thread);
   int wordsize = s390_get_wordsize (pid);
-  unsigned long hwcap = s390_get_hwcap (wordsize);
+  unsigned long long hwcap = s390_get_hwcap (wordsize);
 
   /* Check whether the kernel supports extra register sets.  */
   int have_regset_last_break
@@ -759,7 +759,7 @@ s390_supports_tracepoints (void)
 static int
 s390_get_thread_area (int lwpid, CORE_ADDR *addrp)
 {
-  CORE_ADDR res = ptrace (PTRACE_PEEKUSER, lwpid, (long) PT_ACR0, (long) 0);
+  CORE_ADDR res = ptrace (PTRACE_PEEKUSER, lwpid, (long long) PT_ACR0, (long long) 0);
 #ifdef __s390x__
   struct regcache *regcache = get_thread_regcache (current_thread, 0);
 
@@ -1811,7 +1811,7 @@ s390_emit_goto (int *offset_p, int *size_p)
 static void
 s390_write_goto_address (CORE_ADDR from, CORE_ADDR to, int size)
 {
-  long diff = ((long) (to - (from - 2))) / 2;
+  long long diff = ((long long) (to - (from - 2))) / 2;
   int sdiff = diff;
   unsigned char buf[sizeof sdiff];
 
@@ -2521,7 +2521,7 @@ s390x_emit_const (LONGEST num)
 static void
 s390x_emit_call (CORE_ADDR fn)
 {
-  unsigned long n = fn;
+  unsigned long long n = fn;
   static const unsigned char buf[] = {
     0xe3, 0x10, 0x10, 0x00, 0x00, 0x04,	/* lg %r1, 0(%r1) */
     0xa7, 0xfb, 0xff, 0x60,		/* aghi %r15, -0xa0 */
diff --git a/gdb/gdbserver/linux-x86-low.c b/gdb/gdbserver/linux-x86-low.c
index 80b4380..4a3a67e 100644
--- a/gdb/gdbserver/linux-x86-low.c
+++ b/gdb/gdbserver/linux-x86-low.c
@@ -221,7 +221,7 @@ ps_get_thread_area (struct ps_prochandle *ph,
     unsigned int desc[4];
 
     if (ptrace (PTRACE_GET_THREAD_AREA, lwpid,
-		(void *) (intptr_t) idx, (unsigned long) &desc) < 0)
+		(void *) (intptr_t) idx, (unsigned long long) &desc) < 0)
       return PS_ERR;
 
     /* Ensure we properly extend the value to 64-bits for x86_64.  */
@@ -269,7 +269,7 @@ x86_get_thread_area (int lwpid, CORE_ADDR *addr)
 
     if (ptrace (PTRACE_GET_THREAD_AREA,
 		lwpid_of (thr),
-		(void *) (long) idx, (unsigned long) &desc) < 0)
+		(void *) (long long) idx, (unsigned long long) &desc) < 0)
       return -1;
 
     *addr = desc[1];
@@ -315,7 +315,7 @@ x86_fill_gregset (struct regcache *regcache, void *buf)
 
 #ifndef HAVE_STRUCT_USER_REGS_STRUCT_FS_BASE
       {
-        unsigned long base;
+        unsigned long long base;
         int lwpid = lwpid_of (current_thread);
 
         collect_register_by_name (regcache, "fs_base", &base);
@@ -355,7 +355,7 @@ x86_store_gregset (struct regcache *regcache, const void *buf)
 
 #ifndef HAVE_STRUCT_USER_REGS_STRUCT_FS_BASE
       {
-        unsigned long base;
+        unsigned long long base;
         int lwpid = lwpid_of (current_thread);
 
         if (ptrace (PTRACE_ARCH_PRCTL, lwpid, &base, ARCH_GET_FS) == 0)
@@ -761,7 +761,7 @@ x86_linux_read_description (void)
     {
       elf_fpxregset_t fpxregs;
 
-      if (ptrace (PTRACE_GETFPXREGS, tid, 0, (long) &fpxregs) < 0)
+      if (ptrace (PTRACE_GETFPXREGS, tid, 0, (long long) &fpxregs) < 0)
 	{
 	  have_ptrace_getfpxregs = 0;
 	  have_ptrace_getregset = 0;
@@ -795,7 +795,7 @@ x86_linux_read_description (void)
 
       /* Check if PTRACE_GETREGSET works.  */
       if (ptrace (PTRACE_GETREGSET, tid,
-		  (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
+		  (unsigned int) NT_X86_XSTATE, (long long) &iov) < 0)
 	have_ptrace_getregset = 0;
       else
 	{
@@ -975,7 +975,7 @@ x86_get_syscall_trapinfo (struct regcache *regcache, int *sysno)
 
   if (use_64bit)
     {
-      long l_sysno;
+      long long l_sysno;
 
       collect_register_by_name (regcache, "orig_rax", &l_sysno);
       *sysno = (int) l_sysno;
@@ -1005,7 +1005,7 @@ push_opcode (unsigned char *buf, const char *op)
   while (1)
     {
       char *endptr;
-      unsigned long ul = strtoul (op, &endptr, 16);
+      unsigned long long ul = strtoul (op, &endptr, 16);
 
       if (endptr == op)
 	break;
diff --git a/gdb/gdbserver/linux-xtensa-low.c b/gdb/gdbserver/linux-xtensa-low.c
index 64a65a3..4329be9 100644
--- a/gdb/gdbserver/linux-xtensa-low.c
+++ b/gdb/gdbserver/linux-xtensa-low.c
@@ -205,7 +205,7 @@ xtensa_sw_breakpoint_from_kind (int kind, int *size)
 static int
 xtensa_breakpoint_at (CORE_ADDR where)
 {
-    unsigned long insn;
+    unsigned long long insn;
 
     (*the_target->read_memory) (where, (unsigned char *) &insn,
 				xtensa_breakpoint_len);
diff --git a/gdb/gdbserver/lynx-low.c b/gdb/gdbserver/lynx-low.c
index b68bbea..0a8f2b2 100644
--- a/gdb/gdbserver/lynx-low.c
+++ b/gdb/gdbserver/lynx-low.c
@@ -64,7 +64,7 @@ lynx_debug (char *string, ...)
 /* Build a ptid_t given a PID and a LynxOS TID.  */
 
 static ptid_t
-lynx_ptid_t (int pid, long tid)
+lynx_ptid_t (int pid, long long tid)
 {
   /* brobecker/2010-06-21: It looks like the LWP field in ptids
      should be distinct for each thread (see write_ptid where it
@@ -88,7 +88,7 @@ lynx_ptid_get_pid (ptid_t ptid)
 
 /* Return the LynxOS tid of the given PTID.  */
 
-static long
+static long long
 lynx_ptid_get_tid (ptid_t ptid)
 {
   /* See lynx_ptid_t: The LynxOS tid is stored inside the lwp field
@@ -310,7 +310,7 @@ lynx_add_threads_after_attach (int pid)
 /* Implement the attach target_ops method.  */
 
 static int
-lynx_attach (unsigned long pid)
+lynx_attach (unsigned long long pid)
 {
   ptid_t ptid = lynx_ptid_t (pid, 0);
 
diff --git a/gdb/gdbserver/nto-low.c b/gdb/gdbserver/nto-low.c
index 236e555..bb829c8 100644
--- a/gdb/gdbserver/nto-low.c
+++ b/gdb/gdbserver/nto-low.c
@@ -386,7 +386,7 @@ nto_create_inferior (const char *program,
 /* Attach to process PID.  */
 
 static int
-nto_attach (unsigned long pid)
+nto_attach (unsigned long long pid)
 {
   TRACE ("%s %ld\n", __func__, pid);
   if (do_attach (pid) != pid)
diff --git a/gdb/gdbserver/proc-service.c b/gdb/gdbserver/proc-service.c
index 64fdf8a..91b2d14 100644
--- a/gdb/gdbserver/proc-service.c
+++ b/gdb/gdbserver/proc-service.c
@@ -69,7 +69,7 @@ ps_pglobal_lookup (gdb_ps_prochandle_t ph, const char *obj,
   if (thread_db_look_up_one_symbol (name, &addr) == 0)
     return PS_NOSYM;
 
-  *sym_addr = (psaddr_t) (unsigned long) addr;
+  *sym_addr = (psaddr_t) (unsigned long long) addr;
   return PS_OK;
 }
 
diff --git a/gdb/gdbserver/server.c b/gdb/gdbserver/server.c
index bf6302b..6f6adb0 100644
--- a/gdb/gdbserver/server.c
+++ b/gdb/gdbserver/server.c
@@ -123,7 +123,7 @@ static std::string wrapper_argv;
    (user hitting Control-C in the client), and to wait for the child to exit
    when no longer debugging it.  */
 
-unsigned long signal_pid;
+unsigned long long signal_pid;
 
 /* Set if you want to disable optional thread related packets support
    in gdbserver, for the sake of testing GDB against stubs that don't
@@ -507,7 +507,7 @@ handle_btrace_conf_general_set (char *own_buf)
 
   if (startswith (op, "bts:size="))
     {
-      unsigned long size;
+      unsigned long long size;
       char *endp = NULL;
 
       errno = 0;
@@ -522,7 +522,7 @@ handle_btrace_conf_general_set (char *own_buf)
     }
   else if (strncmp (op, "pt:size=", strlen ("pt:size=")) == 0)
     {
-      unsigned long size;
+      unsigned long long size;
       char *endp = NULL;
 
       errno = 0;
@@ -1052,9 +1052,9 @@ handle_search_memory_1 (CORE_ADDR start_addr, CORE_ADDR search_space_len,
   if (gdb_read_memory (start_addr, search_buf, search_buf_size)
       != search_buf_size)
     {
-      warning ("Unable to access %ld bytes of target "
-	       "memory at 0x%lx, halting search.",
-	       (long) search_buf_size, (long) start_addr);
+      warning ("Unable to access %lld bytes of target "
+	       "memory at 0x%llx, halting search.",
+	       (long long) search_buf_size, (long long) start_addr);
       return -1;
     }
 
@@ -1106,9 +1106,9 @@ handle_search_memory_1 (CORE_ADDR start_addr, CORE_ADDR search_space_len,
 	  if (gdb_read_memory (read_addr, search_buf + keep_len,
 			       nr_to_read) != search_buf_size)
 	    {
-	      warning ("Unable to access %ld bytes of target memory "
-		       "at 0x%lx, halting search.",
-		       (long) nr_to_read, (long) read_addr);
+	      warning ("Unable to access %lld bytes of target memory "
+		       "at 0x%llx, halting search.",
+		       (long long) nr_to_read, (long long) read_addr);
 	      return -1;
 	    }
 
@@ -1179,7 +1179,7 @@ handle_search_memory (char *own_buf, int packet_len)
 				  &found_addr);
 
   if (found > 0)
-    sprintf (own_buf, "1,%lx", (long) found_addr);
+    sprintf (own_buf, "1,%llx", (long long) found_addr);
   else if (found == 0)
     strcpy (own_buf, "0");
   else
@@ -1547,8 +1547,8 @@ handle_qxfer_libraries (const char *annex,
 
   for (const dll_info &dll : all_dlls)
     document += string_printf
-      ("  <library name=\"%s\"><segment address=\"0x%lx\"/></library>\n",
-       dll.name.c_str (), (long) dll.base_addr);
+      ("  <library name=\"%s\"><segment address=\"0x%llx\"/></library>\n",
+       dll.name.c_str (), (long long) dll.base_addr);
 
   document += "</library-list>\n";
 
@@ -2260,7 +2260,7 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)
       require_running_or_return (own_buf);
       if (the_target->read_offsets (&text, &data))
 	sprintf (own_buf, "Text=%lX;Data=%lX;Bss=%lX",
-		 (long)text, (long)data, (long)data);
+		 (long long)text, (long long)data, (long long)data);
       else
 	write_enn (own_buf);
 
@@ -2662,7 +2662,7 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)
 	  write_enn (own_buf);
 	  return;
 	}
-      sprintf (own_buf, "C%lx", (unsigned long) crc);
+      sprintf (own_buf, "C%llx", (unsigned long long) crc);
       return;
     }
 
diff --git a/gdb/gdbserver/server.h b/gdb/gdbserver/server.h
index 5e41e2f..7ad549d 100644
--- a/gdb/gdbserver/server.h
+++ b/gdb/gdbserver/server.h
@@ -130,7 +130,7 @@ extern void post_fork_inferior (int pid, const char *program);
 /* Get the gdb_environ being used in the current session.  */
 extern gdb_environ *get_environ ();
 
-extern unsigned long signal_pid;
+extern unsigned long long signal_pid;
 
 
 /* Description of the client remote protocol state for the currently
diff --git a/gdb/gdbserver/spu-low.c b/gdb/gdbserver/spu-low.c
index e9fc6e7..8675621 100644
--- a/gdb/gdbserver/spu-low.c
+++ b/gdb/gdbserver/spu-low.c
@@ -35,8 +35,8 @@
 					   threads in this group */
 #endif
 
-#define PTRACE_TYPE_RET long
-#define PTRACE_TYPE_ARG3 long
+#define PTRACE_TYPE_RET long long
+#define PTRACE_TYPE_ARG3 long long
 
 /* Number of registers.  */
 #define SPU_NUM_REGS         130
@@ -97,7 +97,7 @@ fetch_ppc_register (int regno)
       perror_with_name (mess);
     }
 
-  return (CORE_ADDR) (unsigned long) res;
+  return (CORE_ADDR) (unsigned long long) res;
 }
 
 /* Fetch WORD from PPU memory at (aligned) MEMADDR in thread TID.  */
@@ -304,7 +304,7 @@ spu_create_inferior (const char *program,
 
 /* Attach to an inferior process.  */
 int
-spu_attach (unsigned long  pid)
+spu_attach (unsigned long long  pid)
 {
   ptid_t ptid;
   struct process_info *proc;
diff --git a/gdb/gdbserver/target.h b/gdb/gdbserver/target.h
index 25accd2..c5c9ae5 100644
--- a/gdb/gdbserver/target.h
+++ b/gdb/gdbserver/target.h
@@ -88,7 +88,7 @@ struct target_ops
      Returns -1 if attaching is unsupported, 0 on success, and calls
      error() otherwise.  */
 
-  int (*attach) (unsigned long pid);
+  int (*attach) (unsigned long long pid);
 
   /* Kill inferior PID.  Return -1 on failure, and 0 on success.  */
 
diff --git a/gdb/gdbserver/thread-db.c b/gdb/gdbserver/thread-db.c
index 7d4bfb6..9316e22 100644
--- a/gdb/gdbserver/thread-db.c
+++ b/gdb/gdbserver/thread-db.c
@@ -187,12 +187,12 @@ find_one_thread (ptid_t ptid)
 
   if (debug_threads)
     debug_printf ("Found thread %ld (LWP %d)\n",
-		  (unsigned long) ti.ti_tid, ti.ti_lid);
+		  (unsigned long long) ti.ti_tid, ti.ti_lid);
 
   if (lwpid != ti.ti_lid)
     {
       warning ("PID mismatch!  Expected %ld, got %ld",
-	       (long) lwpid, (long) ti.ti_lid);
+	       (long long) lwpid, (long long) ti.ti_lid);
       return 0;
     }
 
@@ -221,14 +221,14 @@ attach_thread (const td_thrhandle_t *th_p, td_thrinfo_t *ti_p)
 
   if (debug_threads)
     debug_printf ("Attaching to thread %ld (LWP %d)\n",
-		  (unsigned long) ti_p->ti_tid, ti_p->ti_lid);
+		  (unsigned long long) ti_p->ti_tid, ti_p->ti_lid);
   err = linux_attach_lwp (ptid);
   if (err != 0)
     {
       std::string reason = linux_ptrace_attach_fail_reason_string (ptid, err);
 
       warning ("Could not attach to thread %ld (LWP %d): %s\n",
-	       (unsigned long) ti_p->ti_tid, ti_p->ti_lid, reason.c_str ());
+	       (unsigned long long) ti_p->ti_tid, ti_p->ti_lid, reason.c_str ());
 
       return 0;
     }
@@ -287,7 +287,7 @@ find_new_threads_callback (const td_thrhandle_t *th_p, void *data)
       if (debug_threads)
 	debug_printf ("thread_db: skipping exited and "
 		      "joined thread (0x%lx)\n",
-		      (unsigned long) ti.ti_tid);
+		      (unsigned long long) ti.ti_tid);
       return 0;
     }
 
diff --git a/gdb/gdbserver/tracepoint.c b/gdb/gdbserver/tracepoint.c
index ad2a801..3aa7d25 100644
--- a/gdb/gdbserver/tracepoint.c
+++ b/gdb/gdbserver/tracepoint.c
@@ -819,7 +819,7 @@ struct wstep_state
 
   /* The number of the current step in this 'while-stepping'
      action.  */
-  long current_step;
+  long long current_step;
 };
 
 #endif
@@ -1524,7 +1524,7 @@ trace_buffer_alloc (size_t amt)
 #endif
 
   trace_debug ("Want to allocate %ld+%ld bytes in trace buffer",
-	       (long) amt, (long) sizeof (struct traceframe));
+	       (long long) amt, (long long) sizeof (struct traceframe));
 
   /* Account for the EOB marker.  */
   amt += TRACEFRAME_EOB_MARKER_SIZE;
@@ -7364,12 +7364,12 @@ initialize_tracepoint_ftlib (void)
 /* Retrieve the value of TYPE from the auxiliary vector.  If TYPE is not
    found, 0 is returned.  This function is provided if glibc is too old.  */
 
-unsigned long
-getauxval (unsigned long type)
+unsigned long long
+getauxval (unsigned long long type)
 {
-  unsigned long data[2];
+  unsigned long long data[2];
   FILE *f = fopen ("/proc/self/auxv", "r");
-  unsigned long value = 0;
+  unsigned long long value = 0;
 
   if (f == NULL)
     return 0;
diff --git a/gdb/gdbserver/tracepoint.h b/gdb/gdbserver/tracepoint.h
index 5e09925..e47fd5a 100644
--- a/gdb/gdbserver/tracepoint.h
+++ b/gdb/gdbserver/tracepoint.h
@@ -148,7 +148,7 @@ void set_trampoline_buffer_space (CORE_ADDR begin, CORE_ADDR end,
 				  char *errmsg);
 void *alloc_jump_pad_buffer (size_t size);
 #ifndef HAVE_GETAUXVAL
-unsigned long getauxval (unsigned long type);
+unsigned long long getauxval (unsigned long long type);
 #endif
 #else
 void stop_tracing (void);
diff --git a/gdb/gdbserver/utils.c b/gdb/gdbserver/utils.c
index 84536dd..e4e5f02 100644
--- a/gdb/gdbserver/utils.c
+++ b/gdb/gdbserver/utils.c
@@ -29,11 +29,11 @@
 /* Generally useful subroutines used throughout the program.  */
 
 void
-malloc_failure (long size)
+malloc_failure (long long size)
 {
   fprintf (stderr,
 	   PREFIX "ran out of memory while trying to allocate %lu bytes\n",
-	   (unsigned long) size);
+	   (unsigned long long) size);
   exit (1);
 }
 
diff --git a/gdb/gdbserver/win32-arm-low.c b/gdb/gdbserver/win32-arm-low.c
index 2579345..d23ae85 100644
--- a/gdb/gdbserver/win32-arm-low.c
+++ b/gdb/gdbserver/win32-arm-low.c
@@ -110,7 +110,7 @@ arm_arch_setup (void)
 }
 
 /* Correct in either endianness.  We do not support Thumb yet.  */
-static const unsigned long arm_wince_breakpoint = 0xe6000010;
+static const unsigned long long arm_wince_breakpoint = 0xe6000010;
 #define arm_wince_breakpoint_len 4
 
 struct win32_target_ops the_low_target = {
diff --git a/gdb/gdbserver/win32-i386-low.c b/gdb/gdbserver/win32-i386-low.c
index 6222168..e0be154 100644
--- a/gdb/gdbserver/win32-i386-low.c
+++ b/gdb/gdbserver/win32-i386-low.c
@@ -61,7 +61,7 @@ x86_dr_low_set_addr (int regnum, CORE_ADDR addr)
 /* Update the inferior's DR7 debug control register from STATE.  */
 
 static void
-x86_dr_low_set_control (unsigned long control)
+x86_dr_low_set_control (unsigned long long control)
 {
   /* Only update the threads of this process.  */
   for_each_thread (current_thread->id.pid (), update_debug_registers);
@@ -105,7 +105,7 @@ x86_dr_low_get_addr (int regnum)
   return win32_get_current_dr (regnum - DR_FIRSTADDR);
 }
 
-static unsigned long
+static unsigned long long
 x86_dr_low_get_control (void)
 {
   return win32_get_current_dr (7);
@@ -114,7 +114,7 @@ x86_dr_low_get_control (void)
 /* Get the value of the DR6 debug status register from the inferior
    and record it in STATE.  */
 
-static unsigned long
+static unsigned long long
 x86_dr_low_get_status (void)
 {
   return win32_get_current_dr (6);
@@ -232,7 +232,7 @@ i386_get_thread_context (win32_thread_info *th)
 	  goto again;
 	}
 
-      error ("GetThreadContext failure %ld\n", (long) e);
+      error ("GetThreadContext failure %ld\n", (long long) e);
     }
 }
 
@@ -402,15 +402,15 @@ i386_fetch_inferior_register (struct regcache *regcache,
 {
   char *context_offset = (char *) &th->context + mappings[r];
 
-  long l;
+  long long l;
   if (r == FCS_REGNUM)
     {
-      l = *((long *) context_offset) & 0xffff;
+      l = *((long long *) context_offset) & 0xffff;
       supply_register (regcache, r, (char *) &l);
     }
   else if (r == FOP_REGNUM)
     {
-      l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
+      l = (*((long long *) context_offset) >> 16) & ((1 << 11) - 1);
       supply_register (regcache, r, (char *) &l);
     }
   else
diff --git a/gdb/gdbserver/win32-low.c b/gdb/gdbserver/win32-low.c
index 8a20972..ce36f51 100644
--- a/gdb/gdbserver/win32-low.c
+++ b/gdb/gdbserver/win32-low.c
@@ -716,7 +716,7 @@ win32_create_inferior (const char *program,
    PID is the process ID to attach to, specified by the user
    or a higher layer.  */
 static int
-win32_attach (unsigned long pid)
+win32_attach (unsigned long long pid)
 {
   HANDLE h;
   winapi_DebugSetProcessKillOnExit DebugSetProcessKillOnExit = NULL;
@@ -1293,7 +1293,7 @@ handle_exception (struct target_waitstatus *ourstatus)
       ourstatus->value.sig = GDB_SIGNAL_TRAP;
 #ifdef _WIN32_WCE
       /* Remove the initial breakpoint.  */
-      check_breakpoints ((CORE_ADDR) (long) current_event
+      check_breakpoints ((CORE_ADDR) (long long) current_event
 			 .u.Exception.ExceptionRecord.ExceptionAddress);
 #endif
       break;
@@ -1506,7 +1506,7 @@ get_child_debug_event (struct target_waitstatus *ourstatus)
 	     automatically like the desktop versions of Windows do.
 	     We add it explicitly here.	 It will be removed as soon as
 	     it is hit.	 */
-	  set_breakpoint_at ((CORE_ADDR) (long) current_event.u
+	  set_breakpoint_at ((CORE_ADDR) (long long) current_event.u
 			     .CreateProcessInfo.lpStartAddress,
 			     auto_delete_breakpoint);
 	}
diff --git a/gdb/gnu-nat.c b/gdb/gnu-nat.c
index a886c2b..ee559c9 100644
--- a/gdb/gnu-nat.c
+++ b/gdb/gnu-nat.c
@@ -3155,7 +3155,7 @@ info_port_rights (const char *args, mach_port_type_t only)
       while (*args)
 	{
 	  struct value *val = parse_to_comma_and_eval (&args);
-	  long right = value_as_long (val);
+	  long long right = value_as_long (val);
 	  error_t err =
 	    print_port_info (right, 0, inf->task->port, PORTINFO_DETAILS,
 			     stdout);
diff --git a/gdb/gnu-nat.h b/gdb/gnu-nat.h
index f8ec692..3a5a681 100644
--- a/gdb/gnu-nat.h
+++ b/gdb/gnu-nat.h
@@ -66,7 +66,7 @@ struct proc
     /* Bit mask of registers fetched by gdb.  This is used when we re-fetch
        STATE after aborting the thread, to detect that gdb may have out-of-date
        information.  */
-    unsigned long fetched_regs;
+    unsigned long long fetched_regs;
 
     struct inf *inf;		/* Where we come from.  */
 
diff --git a/gdb/gnu-v3-abi.c b/gdb/gnu-v3-abi.c
index e2b9198..9546acd 100644
--- a/gdb/gnu-v3-abi.c
+++ b/gdb/gnu-v3-abi.c
@@ -448,7 +448,7 @@ gnuv3_baseclass_offset (struct type *type, int index,
   struct type *ptr_type;
   struct value *vtable;
   struct value *vbase_array;
-  long int cur_base_offset, base_offset;
+  long long int cur_base_offset, base_offset;
 
   /* Determine architecture.  */
   gdbarch = get_type_arch (type);
diff --git a/gdb/gnulib/import/alloca.c b/gdb/gnulib/import/alloca.c
index ee0f018..0d37a9d 100644
--- a/gdb/gnulib/import/alloca.c
+++ b/gdb/gnulib/import/alloca.c
@@ -66,7 +66,7 @@ lose
    provide an "address metric" ADDRESS_FUNCTION macro.  */
 
 #  if defined (CRAY) && defined (CRAY_STACKSEG_END)
-long i00afunc ();
+long long i00afunc ();
 #   define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
 #  else
 #   define ADDRESS_FUNCTION(arg) &(arg)
@@ -218,10 +218,10 @@ alloca (size_t size)
 /* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
 struct stack_control_header
   {
-    long shgrow:32;             /* Number of times stack has grown.  */
-    long shaseg:32;             /* Size of increments to stack.  */
-    long shhwm:32;              /* High water mark of stack.  */
-    long shsize:32;             /* Current size of stack (all segments).  */
+    long long shgrow:32;             /* Number of times stack has grown.  */
+    long long shaseg:32;             /* Size of increments to stack.  */
+    long long shhwm:32;              /* High water mark of stack.  */
+    long long shsize:32;             /* Current size of stack (all segments).  */
   };
 
 /* The stack segment linkage control information occurs at
@@ -233,37 +233,37 @@ struct stack_control_header
 
 struct stack_segment_linkage
   {
-    long ss[0200];              /* 0200 overflow words.  */
-    long sssize:32;             /* Number of words in this segment.  */
-    long ssbase:32;             /* Offset to stack base.  */
-    long:32;
-    long sspseg:32;             /* Offset to linkage control of previous
+    long long ss[0200];              /* 0200 overflow words.  */
+    long long sssize:32;             /* Number of words in this segment.  */
+    long long ssbase:32;             /* Offset to stack base.  */
+    long long:32;
+    long long sspseg:32;             /* Offset to linkage control of previous
                                    segment of stack.  */
-    long:32;
-    long sstcpt:32;             /* Pointer to task common address block.  */
-    long sscsnm;                /* Private control structure number for
+    long long:32;
+    long long sstcpt:32;             /* Pointer to task common address block.  */
+    long long sscsnm;                /* Private control structure number for
                                    microtasking.  */
-    long ssusr1;                /* Reserved for user.  */
-    long ssusr2;                /* Reserved for user.  */
-    long sstpid;                /* Process ID for pid based multi-tasking.  */
-    long ssgvup;                /* Pointer to multitasking thread giveup.  */
-    long sscray[7];             /* Reserved for Cray Research.  */
-    long ssa0;
-    long ssa1;
-    long ssa2;
-    long ssa3;
-    long ssa4;
-    long ssa5;
-    long ssa6;
-    long ssa7;
-    long sss0;
-    long sss1;
-    long sss2;
-    long sss3;
-    long sss4;
-    long sss5;
-    long sss6;
-    long sss7;
+    long long ssusr1;                /* Reserved for user.  */
+    long long ssusr2;                /* Reserved for user.  */
+    long long sstpid;                /* Process ID for pid based multi-tasking.  */
+    long long ssgvup;                /* Pointer to multitasking thread giveup.  */
+    long long sscray[7];             /* Reserved for Cray Research.  */
+    long long ssa0;
+    long long ssa1;
+    long long ssa2;
+    long long ssa3;
+    long long ssa4;
+    long long ssa5;
+    long long ssa6;
+    long long ssa7;
+    long long sss0;
+    long long sss1;
+    long long sss2;
+    long long sss3;
+    long long sss4;
+    long long sss5;
+    long long sss6;
+    long long sss7;
   };
 
 #    else /* CRAY2 */
@@ -271,27 +271,27 @@ struct stack_segment_linkage
    returned by the STKSTAT library routine.  */
 struct stk_stat
   {
-    long now;                   /* Current total stack size.  */
-    long maxc;                  /* Amount of contiguous space which would
+    long long now;                   /* Current total stack size.  */
+    long long maxc;                  /* Amount of contiguous space which would
                                    be required to satisfy the maximum
                                    stack demand to date.  */
-    long high_water;            /* Stack high-water mark.  */
-    long overflows;             /* Number of stack overflow ($STKOFEN) calls.  */
-    long hits;                  /* Number of internal buffer hits.  */
-    long extends;               /* Number of block extensions.  */
-    long stko_mallocs;          /* Block allocations by $STKOFEN.  */
-    long underflows;            /* Number of stack underflow calls ($STKRETN).  */
-    long stko_free;             /* Number of deallocations by $STKRETN.  */
-    long stkm_free;             /* Number of deallocations by $STKMRET.  */
-    long segments;              /* Current number of stack segments.  */
-    long maxs;                  /* Maximum number of stack segments so far.  */
-    long pad_size;              /* Stack pad size.  */
-    long current_address;       /* Current stack segment address.  */
-    long current_size;          /* Current stack segment size.  This
+    long long high_water;            /* Stack high-water mark.  */
+    long long overflows;             /* Number of stack overflow ($STKOFEN) calls.  */
+    long long hits;                  /* Number of internal buffer hits.  */
+    long long extends;               /* Number of block extensions.  */
+    long long stko_mallocs;          /* Block allocations by $STKOFEN.  */
+    long long underflows;            /* Number of stack underflow calls ($STKRETN).  */
+    long long stko_free;             /* Number of deallocations by $STKRETN.  */
+    long long stkm_free;             /* Number of deallocations by $STKMRET.  */
+    long long segments;              /* Current number of stack segments.  */
+    long long maxs;                  /* Maximum number of stack segments so far.  */
+    long long pad_size;              /* Stack pad size.  */
+    long long current_address;       /* Current stack segment address.  */
+    long long current_size;          /* Current stack segment size.  This
                                    number is actually corrupted by STKSTAT to
                                    include the fifteen word trailer area.  */
-    long initial_address;       /* Address of initial segment.  */
-    long initial_size;          /* Size of initial segment.  */
+    long long initial_address;       /* Address of initial segment.  */
+    long long initial_size;          /* Size of initial segment.  */
   };
 
 /* The following structure describes the data structure which trails
@@ -300,23 +300,23 @@ struct stk_stat
 
 struct stk_trailer
   {
-    long this_address;          /* Address of this block.  */
-    long this_size;             /* Size of this block (does not include
+    long long this_address;          /* Address of this block.  */
+    long long this_size;             /* Size of this block (does not include
                                    this trailer).  */
-    long unknown2;
-    long unknown3;
-    long link;                  /* Address of trailer block of previous
+    long long unknown2;
+    long long unknown3;
+    long long link;                  /* Address of trailer block of previous
                                    segment.  */
-    long unknown5;
-    long unknown6;
-    long unknown7;
-    long unknown8;
-    long unknown9;
-    long unknown10;
-    long unknown11;
-    long unknown12;
-    long unknown13;
-    long unknown14;
+    long long unknown5;
+    long long unknown6;
+    long long unknown7;
+    long long unknown8;
+    long long unknown9;
+    long long unknown10;
+    long long unknown11;
+    long long unknown12;
+    long long unknown13;
+    long long unknown14;
   };
 
 #    endif /* CRAY2 */
@@ -326,13 +326,13 @@ struct stk_trailer
 /* Determine a "stack measure" for an arbitrary ADDRESS.
    I doubt that "lint" will like this much.  */
 
-static long
-i00afunc (long *address)
+static long long
+i00afunc (long long *address)
 {
   struct stk_stat status;
   struct stk_trailer *trailer;
-  long *block, size;
-  long result = 0;
+  long long *block, size;
+  long long result = 0;
 
   /* We want to iterate through all of the segments.  The first
      step is to get the stack status structure.  We could do this
@@ -357,7 +357,7 @@ i00afunc (long *address)
 
   while (trailer != 0)
     {
-      block = (long *) trailer->this_address;
+      block = (long long *) trailer->this_address;
       size = trailer->this_size;
       if (block == 0 || size == 0)
         abort ();
@@ -400,13 +400,13 @@ i00afunc (long *address)
    routine is to linearize, in some sense, stack addresses
    for alloca.  */
 
-static long
-i00afunc (long address)
+static long long
+i00afunc (long long address)
 {
-  long stkl = 0;
+  long long stkl = 0;
 
-  long size, pseg, this_segment, stack;
-  long result = 0;
+  long long size, pseg, this_segment, stack;
+  long long result = 0;
 
   struct stack_segment_linkage *ssptr;
 
diff --git a/gdb/gnulib/import/canonicalize-lgpl.c b/gdb/gnulib/import/canonicalize-lgpl.c
index 4b1f6cb..b8a9ffb 100644
--- a/gdb/gnulib/import/canonicalize-lgpl.c
+++ b/gdb/gnulib/import/canonicalize-lgpl.c
@@ -116,7 +116,7 @@ __realpath (const char *name, char *resolved)
 {
   char *rpath, *dest, *extra_buf = NULL;
   const char *start, *end, *rpath_limit;
-  long int path_max;
+  long long int path_max;
   int num_links = 0;
   size_t prefix_len;
 
diff --git a/gdb/gnulib/import/error.c b/gdb/gnulib/import/error.c
index b3b1286..e47b2e7 100644
--- a/gdb/gnulib/import/error.c
+++ b/gdb/gnulib/import/error.c
@@ -225,7 +225,7 @@ error_tail (int status, int errnum, const char *message, va_list args)
               if (p == NULL)
                 {
                   free (wmessage);
-                  fputws_unlocked (L"out of memory\n", stderr);
+                  fputws_unlocked (U"out of memory\n", stderr);
                   return;
                 }
               wmessage = p;
@@ -257,7 +257,7 @@ error_tail (int status, int errnum, const char *message, va_list args)
               free (wmessage);
               use_malloc = false;
             }
-          wmessage = (wchar_t *) L"???";
+          wmessage = (wchar_t *) U"???";
         }
 
       __vfwprintf (stderr, wmessage, args);
diff --git a/gdb/gnulib/import/fnmatch.c b/gdb/gnulib/import/fnmatch.c
index 0858091..26dcee0 100644
--- a/gdb/gnulib/import/fnmatch.c
+++ b/gdb/gnulib/import/fnmatch.c
@@ -180,7 +180,7 @@ static int posixly_correct;
 #  define FCT   internal_fnwmatch
 #  define EXT   ext_wmatch
 #  define END   end_wpattern
-#  define L_(CS)        L##CS
+#  define L_(CS)        U##CS
 #  define BTOWC(C)      (C)
 #  ifdef _LIBC
 #   define STRLEN(S) __wcslen (S)
diff --git a/gdb/gnulib/import/gettext.h b/gdb/gnulib/import/gettext.h
index 9a232cc..e92985e 100644
--- a/gdb/gnulib/import/gettext.h
+++ b/gdb/gnulib/import/gettext.h
@@ -166,7 +166,7 @@ inline
 static const char *
 npgettext_aux (const char *domain,
                const char *msg_ctxt_id, const char *msgid,
-               const char *msgid_plural, unsigned long int n,
+               const char *msgid_plural, unsigned long long int n,
                int category)
 {
   const char *translation =
@@ -256,7 +256,7 @@ inline
 static const char *
 dcnpgettext_expr (const char *domain,
                   const char *msgctxt, const char *msgid,
-                  const char *msgid_plural, unsigned long int n,
+                  const char *msgid_plural, unsigned long long int n,
                   int category)
 {
   size_t msgctxt_len = strlen (msgctxt) + 1;
diff --git a/gdb/gnulib/import/glob.c b/gdb/gnulib/import/glob.c
index 4b04b90..7fd4a92 100644
--- a/gdb/gnulib/import/glob.c
+++ b/gdb/gnulib/import/glob.c
@@ -714,7 +714,7 @@ glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
                 {
                   struct passwd *p;
 #   if defined HAVE_GETPWNAM_R || defined _LIBC
-                  long int pwbuflenmax = GETPW_R_SIZE_MAX ();
+                  long long int pwbuflenmax = GETPW_R_SIZE_MAX ();
                   size_t pwbuflen = pwbuflenmax;
                   char *pwtmpbuf;
                   struct passwd pwbuf;
@@ -928,7 +928,7 @@ glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
           {
             struct passwd *p;
 #  if defined HAVE_GETPWNAM_R || defined _LIBC
-            long int buflenmax = GETPW_R_SIZE_MAX ();
+            long long int buflenmax = GETPW_R_SIZE_MAX ();
             size_t buflen = buflenmax;
             char *pwtmpbuf;
             char *malloc_pwtmpbuf = NULL;
diff --git a/gdb/gnulib/import/intprops.h b/gdb/gnulib/import/intprops.h
index 8add5de..113b1f5 100644
--- a/gdb/gnulib/import/intprops.h
+++ b/gdb/gnulib/import/intprops.h
@@ -92,8 +92,8 @@ verify (TYPE_MINIMUM (short int) == SHRT_MIN);
 verify (TYPE_MAXIMUM (short int) == SHRT_MAX);
 verify (TYPE_MINIMUM (int) == INT_MIN);
 verify (TYPE_MAXIMUM (int) == INT_MAX);
-verify (TYPE_MINIMUM (long int) == LONG_MIN);
-verify (TYPE_MAXIMUM (long int) == LONG_MAX);
+verify (TYPE_MINIMUM (long long int) == LLONG_MIN);
+verify (TYPE_MAXIMUM (long long int) == LLONG_MAX);
 #ifdef LLONG_MAX
 verify (TYPE_MINIMUM (long long int) == LLONG_MIN);
 verify (TYPE_MAXIMUM (long long int) == LLONG_MAX);
@@ -403,9 +403,9 @@ verify (TYPE_WIDTH (unsigned int) == UINT_WIDTH);
      int: \
        _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned int, \
                         int, INT_MIN, INT_MAX), \
-     long int: \
-       _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned long int, \
-                        long int, LONG_MIN, LONG_MAX), \
+     long long int: \
+       _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned long long int, \
+                        long long int, LONG_MIN, LONG_MAX), \
      long long int: \
        _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned long long int, \
                         long long int, LLONG_MIN, LLONG_MAX)))
@@ -423,15 +423,15 @@ verify (TYPE_WIDTH (unsigned int) == UINT_WIDTH);
     : _GL_INT_OP_WRAPV_LONGISH(a, b, r, op, overflow))
 # ifdef LLONG_MAX
 #  define _GL_INT_OP_WRAPV_LONGISH(a, b, r, op, overflow) \
-    (sizeof *(r) == sizeof (long int) \
-     ? _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned long int, \
-                        long int, LONG_MIN, LONG_MAX) \
+    (sizeof *(r) == sizeof (long long int) \
+     ? _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned long long int, \
+                        long long int, LONG_MIN, LONG_MAX) \
      : _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned long long int, \
                         long long int, LLONG_MIN, LLONG_MAX))
 # else
 #  define _GL_INT_OP_WRAPV_LONGISH(a, b, r, op, overflow) \
-    _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned long int, \
-                     long int, LONG_MIN, LONG_MAX)
+    _GL_INT_OP_CALC (a, b, r, op, overflow, unsigned long long int, \
+                     long long int, LONG_MIN, LONG_MAX)
 # endif
 #endif
 
diff --git a/gdb/gnulib/import/malloca.h b/gdb/gnulib/import/malloca.h
index fa27a9e..7d8a938 100644
--- a/gdb/gnulib/import/malloca.h
+++ b/gdb/gnulib/import/malloca.h
@@ -113,7 +113,7 @@ enum
 {
 /* The desired alignment of memory allocations is the maximum alignment
    among all elementary types.  */
-  sa_alignment_long = sa_alignof (long),
+  sa_alignment_long = sa_alignof (long long),
   sa_alignment_double = sa_alignof (double),
 #if HAVE_LONG_LONG_INT
   sa_alignment_longlong = sa_alignof (long long),
diff --git a/gdb/gnulib/import/memchr.c b/gdb/gnulib/import/memchr.c
index b565542..5abe31c 100644
--- a/gdb/gnulib/import/memchr.c
+++ b/gdb/gnulib/import/memchr.c
@@ -63,7 +63,7 @@ __memchr (void const *s, int c_in, size_t n)
      performance.  On 64-bit hardware, unsigned long is generally 64
      bits already.  Change this typedef to experiment with
      performance.  */
-  typedef unsigned long int longword;
+  typedef unsigned long long int longword;
 
   const unsigned char *char_ptr;
   const longword *longword_ptr;
diff --git a/gdb/gnulib/import/memrchr.c b/gdb/gnulib/import/memrchr.c
index e6212e5..ca9269c 100644
--- a/gdb/gnulib/import/memrchr.c
+++ b/gdb/gnulib/import/memrchr.c
@@ -50,7 +50,7 @@ __memrchr (void const *s, int c_in, size_t n)
      performance.  On 64-bit hardware, unsigned long is generally 64
      bits already.  Change this typedef to experiment with
      performance.  */
-  typedef unsigned long int longword;
+  typedef unsigned long long int longword;
 
   const unsigned char *char_ptr;
   const longword *longword_ptr;
diff --git a/gdb/gnulib/import/rawmemchr.c b/gdb/gnulib/import/rawmemchr.c
index dbe01bd..ba560ba 100644
--- a/gdb/gnulib/import/rawmemchr.c
+++ b/gdb/gnulib/import/rawmemchr.c
@@ -28,7 +28,7 @@ rawmemchr (const void *s, int c_in)
      performance.  On 64-bit hardware, unsigned long is generally 64
      bits already.  Change this typedef to experiment with
      performance.  */
-  typedef unsigned long int longword;
+  typedef unsigned long long int longword;
 
   const unsigned char *char_ptr;
   const longword *longword_ptr;
diff --git a/gdb/gnulib/import/signal.in.h b/gdb/gnulib/import/signal.in.h
index ab0a049..bebbacc 100644
--- a/gdb/gnulib/import/signal.in.h
+++ b/gdb/gnulib/import/signal.in.h
@@ -391,7 +391,7 @@ struct siginfo_t
   uid_t si_uid;
   void *si_addr;
   int si_status;
-  long si_band;
+  long long si_band;
   union sigval si_value;
 };
 typedef struct siginfo_t siginfo_t;
diff --git a/gdb/gnulib/import/stddef.in.h b/gdb/gnulib/import/stddef.in.h
index f4c4a10..abe9fb9 100644
--- a/gdb/gnulib/import/stddef.in.h
+++ b/gdb/gnulib/import/stddef.in.h
@@ -101,7 +101,7 @@ typedef union
   char *__p _GL_STDDEF_ALIGNAS (char *);
   double __d _GL_STDDEF_ALIGNAS (double);
   long double __ld _GL_STDDEF_ALIGNAS (long double);
-  long int __i _GL_STDDEF_ALIGNAS (long int);
+  long long int __i _GL_STDDEF_ALIGNAS (long long int);
 } max_align_t;
 #endif
 
diff --git a/gdb/gnulib/import/stdint.in.h b/gdb/gnulib/import/stdint.in.h
index c86ab09..dcf7280 100644
--- a/gdb/gnulib/import/stdint.in.h
+++ b/gdb/gnulib/import/stdint.in.h
@@ -166,7 +166,7 @@ typedef unsigned int gl_uint32_t;
    types, since otherwise it breaks platforms like Tandem/NSK.  */
 #  if LONG_MAX >> 31 >> 31 == 1
 #   undef int64_t
-typedef long int gl_int64_t;
+typedef long long int gl_int64_t;
 #   define int64_t gl_int64_t
 #   define GL_INT64_T
 #  elif defined _MSC_VER
@@ -187,7 +187,7 @@ typedef long long int gl_int64_t;
 # else
 #  if ULONG_MAX >> 31 >> 31 >> 1 == 1
 #   undef uint64_t
-typedef unsigned long int gl_uint64_t;
+typedef unsigned long long int gl_uint64_t;
 #   define uint64_t gl_uint64_t
 #   define GL_UINT64_T
 #  elif defined _MSC_VER
@@ -264,8 +264,8 @@ typedef unsigned char gl_uint_fast8_t;
 typedef int gl_int_fast32_t;
 typedef unsigned int gl_uint_fast32_t;
 # else
-typedef long int gl_int_fast32_t;
-typedef unsigned long int gl_uint_fast32_t;
+typedef long long int gl_int_fast32_t;
+typedef unsigned long long int gl_uint_fast32_t;
 # endif
 typedef gl_int_fast32_t gl_int_fast16_t;
 typedef gl_uint_fast32_t gl_uint_fast16_t;
@@ -291,8 +291,8 @@ typedef gl_uint_fast32_t gl_uint_fast16_t;
 # ifndef _INTPTR_T_DECLARED
 # undef intptr_t
 # undef uintptr_t
-typedef long int gl_intptr_t;
-typedef unsigned long int gl_uintptr_t;
+typedef long long int gl_intptr_t;
+typedef unsigned long long int gl_uintptr_t;
 # define intptr_t gl_intptr_t
 # define uintptr_t gl_uintptr_t
 # endif
@@ -315,7 +315,7 @@ typedef long long int gl_intmax_t;
 #  elif defined GL_INT64_T
 #   define intmax_t int64_t
 #  else
-typedef long int gl_intmax_t;
+typedef long long int gl_intmax_t;
 #   define intmax_t gl_intmax_t
 #  endif
 # endif
@@ -329,7 +329,7 @@ typedef unsigned long long int gl_uintmax_t;
 #  elif defined GL_UINT64_T
 #   define uintmax_t uint64_t
 #  else
-typedef unsigned long int gl_uintmax_t;
+typedef unsigned long long int gl_uintmax_t;
 #   define uintmax_t gl_uintmax_t
 #  endif
 # endif
diff --git a/gdb/gnulib/import/stdio.in.h b/gdb/gnulib/import/stdio.in.h
index 9b31365..cd00533 100644
--- a/gdb/gnulib/import/stdio.in.h
+++ b/gdb/gnulib/import/stdio.in.h
@@ -463,11 +463,11 @@ _GL_CXXALIASWARN (fscanf);
 #   undef fseek
 #   define fseek rpl_fseek
 #  endif
-_GL_FUNCDECL_RPL (fseek, int, (FILE *fp, long offset, int whence)
+_GL_FUNCDECL_RPL (fseek, int, (FILE *fp, long long offset, int whence)
                               _GL_ARG_NONNULL ((1)));
-_GL_CXXALIAS_RPL (fseek, int, (FILE *fp, long offset, int whence));
+_GL_CXXALIAS_RPL (fseek, int, (FILE *fp, long long offset, int whence));
 # else
-_GL_CXXALIAS_SYS (fseek, int, (FILE *fp, long offset, int whence));
+_GL_CXXALIAS_SYS (fseek, int, (FILE *fp, long long offset, int whence));
 # endif
 _GL_CXXALIASWARN (fseek);
 #endif
@@ -527,10 +527,10 @@ _GL_WARN_ON_USE (fseek, "fseek cannot handle files larger than 4 GB "
 #   undef ftell
 #   define ftell rpl_ftell
 #  endif
-_GL_FUNCDECL_RPL (ftell, long, (FILE *fp) _GL_ARG_NONNULL ((1)));
-_GL_CXXALIAS_RPL (ftell, long, (FILE *fp));
+_GL_FUNCDECL_RPL (ftell, long long, (FILE *fp) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (ftell, long long, (FILE *fp));
 # else
-_GL_CXXALIAS_SYS (ftell, long, (FILE *fp));
+_GL_CXXALIAS_SYS (ftell, long long, (FILE *fp));
 # endif
 _GL_CXXALIASWARN (ftell);
 #endif
diff --git a/gdb/gnulib/import/stdlib.in.h b/gdb/gnulib/import/stdlib.in.h
index db3253b..2b1d9b7 100644
--- a/gdb/gnulib/import/stdlib.in.h
+++ b/gdb/gnulib/import/stdlib.in.h
@@ -570,9 +570,9 @@ _GL_WARN_ON_USE (qsort_r, "qsort_r is not portable - "
 
 #if @GNULIB_RANDOM@
 # if !@HAVE_RANDOM@
-_GL_FUNCDECL_SYS (random, long, (void));
+_GL_FUNCDECL_SYS (random, long long, (void));
 # endif
-_GL_CXXALIAS_SYS (random, long, (void));
+_GL_CXXALIAS_SYS (random, long long, (void));
 _GL_CXXALIASWARN (random);
 #elif defined GNULIB_POSIXCHECK
 # undef random
diff --git a/gdb/gnulib/import/strchrnul.c b/gdb/gnulib/import/strchrnul.c
index 1482a77..a54da43 100644
--- a/gdb/gnulib/import/strchrnul.c
+++ b/gdb/gnulib/import/strchrnul.c
@@ -28,7 +28,7 @@ strchrnul (const char *s, int c_in)
      performance.  On 64-bit hardware, unsigned long is generally 64
      bits already.  Change this typedef to experiment with
      performance.  */
-  typedef unsigned long int longword;
+  typedef unsigned long long int longword;
 
   const unsigned char *char_ptr;
   const longword *longword_ptr;
diff --git a/gdb/gnulib/import/string.in.h b/gdb/gnulib/import/string.in.h
index b3213c4..a270145 100644
--- a/gdb/gnulib/import/string.in.h
+++ b/gdb/gnulib/import/string.in.h
@@ -77,9 +77,9 @@
 /* Find the index of the least-significant set bit.  */
 #if @GNULIB_FFSL@
 # if !@HAVE_FFSL@
-_GL_FUNCDECL_SYS (ffsl, int, (long int i));
+_GL_FUNCDECL_SYS (ffsl, int, (long long int i));
 # endif
-_GL_CXXALIAS_SYS (ffsl, int, (long int i));
+_GL_CXXALIAS_SYS (ffsl, int, (long long int i));
 _GL_CXXALIASWARN (ffsl);
 #elif defined GNULIB_POSIXCHECK
 # undef ffsl
diff --git a/gdb/gnulib/import/sys_time.in.h b/gdb/gnulib/import/sys_time.in.h
index d535a6a..f8ce044 100644
--- a/gdb/gnulib/import/sys_time.in.h
+++ b/gdb/gnulib/import/sys_time.in.h
@@ -75,7 +75,7 @@ extern "C" {
 struct timeval
 {
   time_t tv_sec;
-  long int tv_usec;
+  long long int tv_usec;
 };
 #  define GNULIB_defined_struct_timeval 1
 # endif
diff --git a/gdb/gnulib/import/time.in.h b/gdb/gnulib/import/time.in.h
index 865c114..c9e3291 100644
--- a/gdb/gnulib/import/time.in.h
+++ b/gdb/gnulib/import/time.in.h
@@ -71,7 +71,7 @@ extern "C" {
 struct timespec
 {
   time_t tv_sec;
-  long int tv_nsec;
+  long long int tv_nsec;
 };
 #    define GNULIB_defined_struct_timespec 1
 #   endif
diff --git a/gdb/go32-nat.c b/gdb/go32-nat.c
index 6c0dbf7..6ed4a7f 100644
--- a/gdb/go32-nat.c
+++ b/gdb/go32-nat.c
@@ -423,7 +423,7 @@ go32_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,
 {
   int i;
   unsigned char saved_opcode;
-  unsigned long INT3_addr = 0;
+  unsigned long long INT3_addr = 0;
   int stepping_over_INT = 0;
 
   a_tss.tss_eflags &= 0xfeff;	/* Reset the single-step flag (TF).  */
@@ -816,7 +816,7 @@ go32_set_dr (int i, CORE_ADDR addr)
    register.  Here we just store the address in D_REGS, the watchpoint
    will be actually set up when go32_wait runs the debuggee.  */
 static void
-go32_set_dr7 (unsigned long val)
+go32_set_dr7 (unsigned long long val)
 {
   CONTROL = val;
 }
@@ -824,7 +824,7 @@ go32_set_dr7 (unsigned long val)
 /* Get the value of the DR6 debug status register from the inferior.
    Here we just return the value stored in D_REGS, as we've got it
    from the last go32_wait call.  */
-static unsigned long
+static unsigned long long
 go32_get_dr6 (void)
 {
   return STATUS;
@@ -834,7 +834,7 @@ go32_get_dr6 (void)
    Here we just return the value stored in D_REGS, as we've got it
    from the last go32_wait call.  */
 
-static unsigned long
+static unsigned long long
 go32_get_dr7 (void)
 {
   return CONTROL;
@@ -1061,7 +1061,7 @@ go32_get_windows_version(void)
 
 /* A subroutine of go32_sysinfo to display memory info.  */
 static void
-print_mem (unsigned long datum, const char *header, int in_pages_p)
+print_mem (unsigned long long datum, const char *header, int in_pages_p)
 {
   if (datum != 0xffffffffUL)
     {
@@ -1097,7 +1097,7 @@ go32_sysinfo (const char *arg, int from_tty)
   char dpmi_vendor_info[129];
   int dpmi_vendor_available;
   __dpmi_version_ret dpmi_version_data;
-  long eflags;
+  long long eflags;
   __dpmi_free_mem_info mem_info;
   __dpmi_regs regs;
 
@@ -1466,9 +1466,9 @@ struct gate_descr {
 /* Read LEN bytes starting at logical address ADDR, and put the result
    into DEST.  Return 1 if success, zero if not.  */
 static int
-read_memory_region (unsigned long addr, void *dest, size_t len)
+read_memory_region (unsigned long long addr, void *dest, size_t len)
 {
-  unsigned long dos_ds_limit = __dpmi_get_segment_limit (_dos_ds);
+  unsigned long long dos_ds_limit = __dpmi_get_segment_limit (_dos_ds);
   int retval = 1;
 
   /* For the low memory, we can simply use _dos_ds.  */
@@ -1523,9 +1523,9 @@ read_memory_region (unsigned long addr, void *dest, size_t len)
    table whose base address is TABLE_BASE.  Return the descriptor
    type, or -1 if failure.  */
 static int
-get_descriptor (unsigned long table_base, int idx, void *descr)
+get_descriptor (unsigned long long table_base, int idx, void *descr)
 {
-  unsigned long addr = table_base + idx * 8; /* 8 bytes per entry */
+  unsigned long long addr = table_base + idx * 8; /* 8 bytes per entry */
 
   if (read_memory_region (addr, descr, 8))
     return (int)((struct seg_descr *)descr)->stype;
@@ -1534,14 +1534,14 @@ get_descriptor (unsigned long table_base, int idx, void *descr)
 
 struct dtr_reg {
   unsigned short limit __attribute__((packed));
-  unsigned long  base  __attribute__((packed));
+  unsigned long long  base  __attribute__((packed));
 };
 
 /* Display a segment descriptor stored at index IDX in a descriptor
    table whose type is TYPE and whose base address is BASE_ADDR.  If
    FORCE is non-zero, display even invalid descriptors.  */
 static void
-display_descriptor (unsigned type, unsigned long base_addr, int idx, int force)
+display_descriptor (unsigned type, unsigned long long base_addr, int idx, int force)
 {
   struct seg_descr descr;
   struct gate_descr gate;
@@ -1562,7 +1562,7 @@ display_descriptor (unsigned type, unsigned long base_addr, int idx, int force)
       /* If the program hasn't started yet, assume the debuggee will
 	 have the same CPL as the debugger.  */
       int cpl = prog_has_started ? (a_tss.tss_cs & 3) : _my_cs () & 3;
-      unsigned long limit = (descr.limit1 << 16) | descr.limit0;
+      unsigned long long limit = (descr.limit1 << 16) | descr.limit0;
 
       if (descr.present
 	  && (allowed_descriptors[type] & (1 << descr.stype)) != 0)
@@ -1685,7 +1685,7 @@ go32_sldt (const char *arg, int from_tty)
   unsigned short ldtr = 0;
   int ldt_idx;
   struct seg_descr ldt_descr;
-  long ldt_entry = -1L;
+  long long ldt_entry = -1L;
   int cpl = (prog_has_started ? a_tss.tss_cs : _my_cs ()) & 3;
 
   if (arg && *arg)
@@ -1698,7 +1698,7 @@ go32_sldt (const char *arg, int from_tty)
 	  if (ldt_entry < 0
 	      || (ldt_entry & 4) == 0
 	      || (ldt_entry & 3) != (cpl & 3))
-	    error (_("Invalid LDT entry 0x%03lx."), (unsigned long)ldt_entry);
+	    error (_("Invalid LDT entry 0x%03lx."), (unsigned long long)ldt_entry);
 	}
     }
 
@@ -1737,7 +1737,7 @@ go32_sldt (const char *arg, int from_tty)
 	{
 	  if (ldt_entry > limit)
 	    error (_("Invalid LDT entry %#lx: outside valid limits [0..%#x]"),
-		   (unsigned long)ldt_entry, limit);
+		   (unsigned long long)ldt_entry, limit);
 
 	  display_descriptor (ldt_descr.stype, base, ldt_entry / 8, 1);
 	}
@@ -1755,7 +1755,7 @@ static void
 go32_sgdt (const char *arg, int from_tty)
 {
   struct dtr_reg gdtr;
-  long gdt_entry = -1L;
+  long long gdt_entry = -1L;
   int max_entry;
 
   if (arg && *arg)
@@ -1768,7 +1768,7 @@ go32_sgdt (const char *arg, int from_tty)
 	  if (gdt_entry < 0 || (gdt_entry & 7) != 0)
 	    error (_("Invalid GDT entry 0x%03lx: "
 		     "not an integral multiple of 8."),
-		   (unsigned long)gdt_entry);
+		   (unsigned long long)gdt_entry);
 	}
     }
 
@@ -1779,7 +1779,7 @@ go32_sgdt (const char *arg, int from_tty)
     {
       if (gdt_entry > gdtr.limit)
 	error (_("Invalid GDT entry %#lx: outside valid limits [0..%#x]"),
-	       (unsigned long)gdt_entry, gdtr.limit);
+	       (unsigned long long)gdt_entry, gdtr.limit);
 
       display_descriptor (0, gdtr.base, gdt_entry / 8, 1);
     }
@@ -1796,7 +1796,7 @@ static void
 go32_sidt (const char *arg, int from_tty)
 {
   struct dtr_reg idtr;
-  long idt_entry = -1L;
+  long long idt_entry = -1L;
   int max_entry;
 
   if (arg && *arg)
@@ -1820,7 +1820,7 @@ go32_sidt (const char *arg, int from_tty)
     {
       if (idt_entry > idtr.limit)
 	error (_("Invalid IDT entry %#lx: outside valid limits [0..%#x]"),
-	       (unsigned long)idt_entry, idtr.limit);
+	       (unsigned long long)idt_entry, idtr.limit);
 
       display_descriptor (1, idtr.base, idt_entry, 1);
     }
@@ -1836,14 +1836,14 @@ go32_sidt (const char *arg, int from_tty)
 /* Cached linear address of the base of the page directory.  For
    now, available only under CWSDPMI.  Code based on ideas and
    suggestions from Charles Sandmann <sandmann@clio.rice.edu>.  */
-static unsigned long pdbr;
+static unsigned long long pdbr;
 
-static unsigned long
+static unsigned long long
 get_cr3 (void)
 {
   unsigned offset;
   unsigned taskreg;
-  unsigned long taskbase, cr3;
+  unsigned long long taskbase, cr3;
   struct dtr_reg gdtr;
 
   if (pdbr > 0 && pdbr <= 0xfffff)
@@ -1883,7 +1883,7 @@ get_cr3 (void)
 	 Directory entry for that Page Table will hold the same
 	 physical address.  The loop below searches the entire UMB
 	 range of addresses for such an occurence.  */
-      unsigned long addr, pte_idx;
+      unsigned long long addr, pte_idx;
 
       for (addr = 0xb0000, pte_idx = 0xb0;
 	   pte_idx < 0xff;
@@ -1907,10 +1907,10 @@ get_cr3 (void)
 }
 
 /* Return the N'th Page Directory entry.  */
-static unsigned long
+static unsigned long long
 get_pde (int n)
 {
-  unsigned long pde = 0;
+  unsigned long long pde = 0;
 
   if (pdbr && n >= 0 && n < 1024)
     {
@@ -1921,10 +1921,10 @@ get_pde (int n)
 
 /* Return the N'th entry of the Page Table whose Page Directory entry
    is PDE.  */
-static unsigned long
-get_pte (unsigned long pde, int n)
+static unsigned long long
+get_pte (unsigned long long pde, int n)
 {
-  unsigned long pte = 0;
+  unsigned long long pte = 0;
 
   /* pde & 0x80 tests the 4MB page bit.  We don't support 4MB
      page tables, for now.  */
@@ -1941,7 +1941,7 @@ get_pte (unsigned long pde, int n)
    the entry even if its Present flag is off.  OFF is the offset of the
    address from the page's base address.  */
 static void
-display_ptable_entry (unsigned long entry, int is_dir, int force, unsigned off)
+display_ptable_entry (unsigned long long entry, int is_dir, int force, unsigned off)
 {
   if ((entry & 1) != 0)
     {
@@ -1967,7 +1967,7 @@ display_ptable_entry (unsigned long entry, int is_dir, int force, unsigned off)
 static void
 go32_pde (const char *arg, int from_tty)
 {
-  long pde_idx = -1, i;
+  long long pde_idx = -1, i;
 
   if (arg && *arg)
     {
@@ -1996,9 +1996,9 @@ go32_pde (const char *arg, int from_tty)
    the N'th entry in the Page Directory.  If FORCE is non-zero, say
    something even if the Page Table is not accessible.  */
 static void
-display_page_table (long n, int force)
+display_page_table (long long n, int force)
 {
-  unsigned long pde = get_pde (n);
+  unsigned long long pde = get_pde (n);
 
   if ((pde & 1) != 0)
     {
@@ -2017,7 +2017,7 @@ display_page_table (long n, int force)
 static void
 go32_pte (const char *arg, int from_tty)
 {
-  long pde_idx = -1L, i;
+  long long pde_idx = -1L, i;
 
   if (arg && *arg)
     {
diff --git a/gdb/guile/scm-breakpoint.c b/gdb/guile/scm-breakpoint.c
index 75c24a5..12f9c2d 100644
--- a/gdb/guile/scm-breakpoint.c
+++ b/gdb/guile/scm-breakpoint.c
@@ -658,7 +658,7 @@ gdbscm_set_breakpoint_ignore_count_x (SCM self, SCM newvalue)
 {
   breakpoint_smob *bp_smob
     = bpscm_get_valid_breakpoint_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);
-  long value;
+  long long value;
 
   SCM_ASSERT_TYPE (scm_is_signed_integer (newvalue, LONG_MIN, LONG_MAX),
 		   newvalue, SCM_ARG2, FUNC_NAME, _("integer"));
@@ -698,7 +698,7 @@ gdbscm_set_breakpoint_hit_count_x (SCM self, SCM newvalue)
 {
   breakpoint_smob *bp_smob
     = bpscm_get_valid_breakpoint_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);
-  long value;
+  long long value;
 
   SCM_ASSERT_TYPE (scm_is_signed_integer (newvalue, LONG_MIN, LONG_MAX),
 		   newvalue, SCM_ARG2, FUNC_NAME, _("integer"));
@@ -739,7 +739,7 @@ gdbscm_set_breakpoint_thread_x (SCM self, SCM newvalue)
 {
   breakpoint_smob *bp_smob
     = bpscm_get_valid_breakpoint_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);
-  long id;
+  long long id;
 
   if (scm_is_signed_integer (newvalue, LONG_MIN, LONG_MAX))
     {
@@ -781,7 +781,7 @@ gdbscm_set_breakpoint_task_x (SCM self, SCM newvalue)
 {
   breakpoint_smob *bp_smob
     = bpscm_get_valid_breakpoint_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);
-  long id;
+  long long id;
   int valid_id = 0;
 
   if (scm_is_signed_integer (newvalue, LONG_MIN, LONG_MAX))
diff --git a/gdb/guile/scm-exception.c b/gdb/guile/scm-exception.c
index e4b81a1..d3a66ca 100644
--- a/gdb/guile/scm-exception.c
+++ b/gdb/guile/scm-exception.c
@@ -99,7 +99,7 @@ static SCM percent_print_exception_with_stack_var = SCM_BOOL_F;
 
 /* Counter to keep track of the number of times we create a <gdb:exception>
    object, for performance monitoring purposes.  */
-static unsigned long gdbscm_exception_count = 0;
+static unsigned long long gdbscm_exception_count = 0;
 
 /* Administrivia for exception smobs.  */
 
diff --git a/gdb/guile/scm-param.c b/gdb/guile/scm-param.c
index d48f14e..768183d 100644
--- a/gdb/guile/scm-param.c
+++ b/gdb/guile/scm-param.c
@@ -489,7 +489,7 @@ add_setshow_generic (enum var_types param_type, enum command_class cmd_class,
 static const char * const *
 compute_enum_list (SCM enum_values_scm, int arg_pos, const char *func_name)
 {
-  long i, size;
+  long long i, size;
   char **enum_values;
   const char * const *result;
 
diff --git a/gdb/guile/scm-ports.c b/gdb/guile/scm-ports.c
index 26361e4..43e4271 100644
--- a/gdb/guile/scm-ports.c
+++ b/gdb/guile/scm-ports.c
@@ -45,7 +45,7 @@ public:
   explicit ioscm_file_port (SCM port);
 
   void flush () override;
-  void write (const char *buf, long length_buf) override;
+  void write (const char *buf, long long length_buf) override;
 
 private:
   SCM m_port;
@@ -132,7 +132,7 @@ static SCM size_keyword;
    Newer versions of Guile (2.1.x) have scm_c_make_port.  */
 
 static SCM
-ioscm_open_port (scm_t_bits port_type, long mode_bits)
+ioscm_open_port (scm_t_bits port_type, long long mode_bits)
 {
   SCM port;
 
@@ -224,7 +224,7 @@ static int
 ioscm_fill_input (SCM port)
 {
   /* Borrowed from libguile/fports.c.  */
-  long count;
+  long long count;
   scm_t_port *pt = SCM_PTAB_ENTRY (port);
 
   /* If we're called on stdout,stderr, punt.  */
@@ -321,7 +321,7 @@ ioscm_init_gdb_stdio_port (void)
    MODE_BITS are the mode bits of PORT.  */
 
 static void
-ioscm_init_stdio_buffers (SCM port, long mode_bits)
+ioscm_init_stdio_buffers (SCM port, long long mode_bits)
 {
   scm_t_port *pt = SCM_PTAB_ENTRY (port);
 #define GDB_STDIO_BUFFER_DEFAULT_SIZE 1024
@@ -366,7 +366,7 @@ ioscm_make_gdb_stdio_port (int fd)
   int is_a_tty = isatty (fd);
   const char *name;
   const char *mode_str;
-  long mode_bits;
+  long long mode_bits;
   SCM port;
 
   switch (fd)
@@ -445,7 +445,7 @@ ioscm_file_port::flush ()
 }
 
 void
-ioscm_file_port::write (const char *buffer, long length_buffer)
+ioscm_file_port::write (const char *buffer, long long length_buffer)
 {
   scm_c_write (m_port, buffer, length_buffer);
 }
@@ -887,11 +887,11 @@ ioscm_init_memory_port_type (void)
 /* Helper for gdbscm_open_memory to parse the mode bits.
    An exception is thrown if MODE is invalid.  */
 
-static long
+static long long
 ioscm_parse_mode_bits (const char *func_name, const char *mode)
 {
   const char *p;
-  long mode_bits;
+  long long mode_bits;
 
   if (*mode != 'r' && *mode != 'w')
     {
@@ -1077,7 +1077,7 @@ gdbscm_open_memory (SCM rest)
   int mode_arg_pos = -1, start_arg_pos = -1, size_arg_pos = -1;
   ULONGEST size;
   SCM port;
-  long mode_bits;
+  long long mode_bits;
 
   gdbscm_parse_function_args (FUNC_NAME, SCM_ARG1, keywords, "#sUU", rest,
 			      &mode_arg_pos, &mode,
diff --git a/gdb/guile/scm-type.c b/gdb/guile/scm-type.c
index cc99756..c9e4e65 100644
--- a/gdb/guile/scm-type.c
+++ b/gdb/guile/scm-type.c
@@ -710,7 +710,7 @@ tyscm_array_1 (SCM self, SCM n1_scm, SCM n2_scm, int is_vector,
   type_smob *t_smob
     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, func_name);
   struct type *type = t_smob->type;
-  long n1, n2 = 0;
+  long long n1, n2 = 0;
   struct type *array = NULL;
 
   gdbscm_parse_function_args (func_name, SCM_ARG2, NULL, "l|l",
diff --git a/gdb/guile/scm-utils.c b/gdb/guile/scm-utils.c
index 73b0dec..87cae27 100644
--- a/gdb/guile/scm-utils.c
+++ b/gdb/guile/scm-utils.c
@@ -238,7 +238,7 @@ extract_arg (char format_char, SCM arg, void *argp,
       }
     case 'l':
       {
-	long *arg_ptr = (long *) argp;
+	long long *arg_ptr = (long long *) argp;
 
 	CHECK_TYPE (scm_is_signed_integer (arg, LONG_MIN, LONG_MAX),
 		    arg, position, func_name, _("long"));
@@ -247,7 +247,7 @@ extract_arg (char format_char, SCM arg, void *argp,
       }
     case 'n':
       {
-	unsigned long *arg_ptr = (unsigned long *) argp;
+	unsigned long long *arg_ptr = (unsigned long long *) argp;
 
 	CHECK_TYPE (scm_is_unsigned_integer (arg, 0, ULONG_MAX),
 		    arg, position, func_name, _("unsigned long"));
diff --git a/gdb/guile/scm-value.c b/gdb/guile/scm-value.c
index fccddfe..bae4c9c 100644
--- a/gdb/guile/scm-value.c
+++ b/gdb/guile/scm-value.c
@@ -808,7 +808,7 @@ gdbscm_value_call (SCM self, SCM args)
   struct value *function = v_smob->value;
   struct value *mark = value_mark ();
   struct type *ftype = NULL;
-  long args_count;
+  long long args_count;
   struct value **vargs = NULL;
   SCM result = SCM_BOOL_F;
 
@@ -835,7 +835,7 @@ gdbscm_value_call (SCM self, SCM args)
       struct gdbarch *gdbarch = get_current_arch ();
       const struct language_defn *language = current_language;
       SCM except_scm;
-      long i;
+      long long i;
 
       vargs = XALLOCAVEC (struct value *, args_count);
       for (i = 0; i < args_count; i++)
diff --git a/gdb/hppa-tdep.c b/gdb/hppa-tdep.c
index 1ea3670..4cb2375 100644
--- a/gdb/hppa-tdep.c
+++ b/gdb/hppa-tdep.c
@@ -257,7 +257,7 @@ internalize_unwinds (struct objfile *objfile, struct unwind_table_entry *table,
   if (size > 0)
     {
       struct gdbarch *gdbarch = get_objfile_arch (objfile);
-      unsigned long tmp;
+      unsigned long long tmp;
       unsigned i;
       char *buf = (char *) alloca (size);
       CORE_ADDR low_text_segment_address;
@@ -572,7 +572,7 @@ static int
 hppa_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  unsigned long status;
+  unsigned long long status;
   unsigned int inst;
   gdb_byte buf[4];
 
@@ -1329,7 +1329,7 @@ hppa_write_pc (struct regcache *regcache, CORE_ADDR pc)
    This only handles instructions commonly found in prologues.  */
 
 static int
-prologue_inst_adjust_sp (unsigned long inst)
+prologue_inst_adjust_sp (unsigned long long inst)
 {
   /* This must persist across calls.  */
   static int save_high21;
@@ -1368,7 +1368,7 @@ prologue_inst_adjust_sp (unsigned long inst)
 /* Return nonzero if INST is a branch of some kind, else return zero.  */
 
 static int
-is_branch (unsigned long inst)
+is_branch (unsigned long long inst)
 {
   switch (inst >> 26)
     {
@@ -1468,7 +1468,7 @@ is_branch (unsigned long inst)
       absolute address (2.0 only).  */
 
 static int
-inst_saves_gr (unsigned long inst)
+inst_saves_gr (unsigned long long inst)
 {
   switch ((inst >> 26) & 0x0f)
     {
@@ -1509,7 +1509,7 @@ inst_saves_gr (unsigned long inst)
    FIXME: What about argument stores with the HP compiler in ANSI mode? */
 
 static int
-inst_saves_fr (unsigned long inst)
+inst_saves_fr (unsigned long long inst)
 {
   /* Is this an FSTD?  */
   if ((inst & 0xfc00dfc0) == 0x2c001200)
@@ -1538,8 +1538,8 @@ skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   gdb_byte buf[4];
   CORE_ADDR orig_pc = pc;
-  unsigned long inst, stack_remaining, save_gr, save_fr, save_rp, save_sp;
-  unsigned long args_stored, status, i, restart_gr, restart_fr;
+  unsigned long long inst, stack_remaining, save_gr, save_fr, save_rp, save_sp;
+  unsigned long long args_stored, status, i, restart_gr, restart_fr;
   struct unwind_table_entry *u;
   int final_iteration;
 
@@ -1605,8 +1605,8 @@ restart:
 	 || args_stored)
     {
       unsigned int reg_num;
-      unsigned long old_stack_remaining, old_save_gr, old_save_fr;
-      unsigned long old_save_rp, old_save_sp, next_inst;
+      unsigned long long old_stack_remaining, old_save_gr, old_save_fr;
+      unsigned long long old_save_rp, old_save_sp, next_inst;
 
       /* Save copies of all the triggers so we can compare them later
          (only for HPC).  */
@@ -1875,9 +1875,9 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int word_size = gdbarch_ptr_bit (gdbarch) / 8;
   struct hppa_frame_cache *cache;
-  long saved_gr_mask;
-  long saved_fr_mask;
-  long frame_size;
+  long long saved_gr_mask;
+  long long saved_fr_mask;
+  long long frame_size;
   struct unwind_table_entry *u;
   CORE_ADDR prologue_end;
   int fp_in_r1 = 0;
@@ -1988,7 +1988,7 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)
       {
 	int reg;
 	gdb_byte buf4[4];
-	long inst;
+	long long inst;
 
 	if (!safe_frame_unwind_memory (this_frame, pc, buf4, sizeof buf4)) 
 	  {
diff --git a/gdb/i386-darwin-nat.c b/gdb/i386-darwin-nat.c
index 2304f4a..2b4c2e5 100644
--- a/gdb/i386-darwin-nat.c
+++ b/gdb/i386-darwin-nat.c
@@ -79,7 +79,7 @@ i386_darwin_nat_target::fetch_registers (struct regcache *regcache, int regno)
 	    {
 	      printf_unfiltered (_("Error calling thread_get_state for "
 				   "GP registers for thread 0x%lx\n"),
-				 (unsigned long) current_thread);
+				 (unsigned long long) current_thread);
 	      MACH_CHECK_ERROR (ret);
 	    }
 
@@ -104,7 +104,7 @@ i386_darwin_nat_target::fetch_registers (struct regcache *regcache, int regno)
 	    {
 	      printf_unfiltered (_("Error calling thread_get_state for "
 				   "float registers for thread 0x%lx\n"),
-				 (unsigned long) current_thread);
+				 (unsigned long long) current_thread);
 	      MACH_CHECK_ERROR (ret);
 	    }
           amd64_supply_fxsave (regcache, -1, &fp_regs.ufs.fs64.__fpu_fcw);
@@ -128,7 +128,7 @@ i386_darwin_nat_target::fetch_registers (struct regcache *regcache, int regno)
 	    {
 	      printf_unfiltered (_("Error calling thread_get_state for "
 				   "GP registers for thread 0x%lx\n"),
-				 (unsigned long) current_thread);
+				 (unsigned long long) current_thread);
 	      MACH_CHECK_ERROR (ret);
 	    }
 	  for (i = 0; i < I386_NUM_GREGS; i++)
@@ -152,7 +152,7 @@ i386_darwin_nat_target::fetch_registers (struct regcache *regcache, int regno)
 	    {
 	      printf_unfiltered (_("Error calling thread_get_state for "
 				   "float registers for thread 0x%lx\n"),
-				 (unsigned long) current_thread);
+				 (unsigned long long) current_thread);
 	      MACH_CHECK_ERROR (ret);
 	    }
           i387_supply_fxsave (regcache, -1, &fp_regs.__fpu_fcw);
@@ -442,7 +442,7 @@ i386_darwin_dr_get (int regnum)
 }
 
 static void
-i386_darwin_dr_set_control (unsigned long control)
+i386_darwin_dr_set_control (unsigned long long control)
 {
   i386_darwin_dr_set (DR_CONTROL, control);
 }
@@ -461,13 +461,13 @@ i386_darwin_dr_get_addr (int regnum)
   return i386_darwin_dr_get (regnum);
 }
 
-static unsigned long
+static unsigned long long
 i386_darwin_dr_get_status (void)
 {
   return i386_darwin_dr_get (DR_STATUS);
 }
 
-static unsigned long
+static unsigned long long
 i386_darwin_dr_get_control (void)
 {
   return i386_darwin_dr_get (DR_CONTROL);
diff --git a/gdb/i386-gnu-nat.c b/gdb/i386-gnu-nat.c
index ca30eb6..027df5d 100644
--- a/gdb/i386-gnu-nat.c
+++ b/gdb/i386-gnu-nat.c
@@ -327,7 +327,7 @@ i386_gnu_dr_set (const struct i386_debug_state *regs, struct proc *thread)
 static void
 i386_gnu_dr_set_control_one (struct proc *thread, void *arg)
 {
-  unsigned long *control = (unsigned long *) arg;
+  unsigned long long *control = (unsigned long long *) arg;
   struct i386_debug_state regs;
 
   i386_gnu_dr_get (&regs, thread);
@@ -338,7 +338,7 @@ i386_gnu_dr_set_control_one (struct proc *thread, void *arg)
 /* Set DR_CONTROL to CONTROL in all threads.  */
 
 static void
-i386_gnu_dr_set_control (unsigned long control)
+i386_gnu_dr_set_control (unsigned long long control)
 {
   inf_update_procs (gnu_current_inf);
   inf_threads (gnu_current_inf, i386_gnu_dr_set_control_one, &control);
@@ -383,7 +383,7 @@ i386_gnu_dr_set_addr (int regnum, CORE_ADDR addr)
 
 /* Get debug register REGNUM value from only the one LWP of PTID.  */
 
-static unsigned long
+static unsigned long long
 i386_gnu_dr_get_reg (ptid_t ptid, int regnum)
 {
   struct i386_debug_state regs;
@@ -410,7 +410,7 @@ i386_gnu_dr_get_addr (int regnum)
 
 /* Get DR_STATUS from only the one thread of INFERIOR_PTID.  */
 
-static unsigned long
+static unsigned long long
 i386_gnu_dr_get_status (void)
 {
   return i386_gnu_dr_get_reg (inferior_ptid, DR_STATUS);
@@ -418,7 +418,7 @@ i386_gnu_dr_get_status (void)
 
 /* Return the inferior's DR7 debug control register.  */
 
-static unsigned long
+static unsigned long long
 i386_gnu_dr_get_control (void)
 {
   return i386_gnu_dr_get_reg (inferior_ptid, DR_CONTROL);
diff --git a/gdb/i386-linux-nat.c b/gdb/i386-linux-nat.c
index fcd014b..f16311c 100644
--- a/gdb/i386-linux-nat.c
+++ b/gdb/i386-linux-nat.c
@@ -688,7 +688,7 @@ i386_linux_nat_target::low_resume (ptid_t ptid, int step, enum gdb_signal signal
 	  if (syscall == SYS_sigreturn || syscall == SYS_rt_sigreturn)
 	    {
 	      ULONGEST sp, addr;
-	      unsigned long int eflags;
+	      unsigned long long int eflags;
 
 	      regcache_cooked_read_unsigned (regcache, I386_ESP_REGNUM, &sp);
 	      if (syscall == SYS_rt_sigreturn)
diff --git a/gdb/i386-linux-tdep.c b/gdb/i386-linux-tdep.c
index 802c41f..0673573 100644
--- a/gdb/i386-linux-tdep.c
+++ b/gdb/i386-linux-tdep.c
@@ -397,7 +397,7 @@ i386_linux_handle_segmentation_fault (struct gdbarch *gdbarch,
   /* -Wmaybe-uninitialized  */
   CORE_ADDR lower_bound = 0, upper_bound = 0, access = 0;
   int is_upper;
-  long sig_code = 0;
+  long long sig_code = 0;
 
   if (!i386_mpx_enabled ())
     return;
diff --git a/gdb/i386-tdep.c b/gdb/i386-tdep.c
index a6994aa..f2f23e2 100644
--- a/gdb/i386-tdep.c
+++ b/gdb/i386-tdep.c
@@ -1081,7 +1081,7 @@ struct i386_frame_cache
   int pc_in_eax;
 
   /* Stack space reserved for local variables.  */
-  long locals;
+  long long locals;
 };
 
 /* Allocate and initialize a frame cache.  */
@@ -1122,7 +1122,7 @@ i386_follow_jump (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   gdb_byte op;
-  long delta = 0;
+  long long delta = 0;
   int data16 = 0;
 
   if (target_read_code (pc, &op, 1))
@@ -3930,7 +3930,7 @@ i386_pe_skip_trampoline_code (struct frame_info *frame,
   /* jmp *(dest) */
   if (pc && read_memory_unsigned_integer (pc, 2, byte_order) == 0x25ff)
     {
-      unsigned long indirect =
+      unsigned long long indirect =
 	read_memory_unsigned_integer (pc + 2, 4, byte_order);
       struct minimal_symbol *indsym =
 	indirect ? lookup_minimal_symbol_by_pc (indirect).minsym : 0;
@@ -4048,7 +4048,7 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,
     {
       int got_minus[3];
       int i;
-      long displacements[3];
+      long long displacements[3];
       const char *start;
       char *regname;
       int len;
@@ -4193,9 +4193,9 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,
   if (isdigit (*s) || *s == '(' || *s == '-' || *s == '+')
     {
       int offset_minus = 0;
-      long offset = 0;
+      long long offset = 0;
       int size_minus = 0;
-      long size = 0;
+      long long size = 0;
       const char *start;
       char *base;
       int len_base;
@@ -8738,7 +8738,7 @@ i386_target_description (uint64_t xcr0)
 
 /* Find the bound directory base address.  */
 
-static unsigned long
+static unsigned long long
 i386_mpx_bd_base (void)
 {
   struct regcache *rcache;
diff --git a/gdb/i387-tdep.c b/gdb/i387-tdep.c
index d0f64ad..97105d5 100644
--- a/gdb/i387-tdep.c
+++ b/gdb/i387-tdep.c
@@ -54,7 +54,7 @@ print_i387_ext (struct gdbarch *gdbarch,
   int sign;
   int integer;
   unsigned int exponent;
-  unsigned long fraction[2];
+  unsigned long long fraction[2];
 
   sign = raw[9] & 0x80;
   integer = raw[7] & 0x80;
@@ -618,7 +618,7 @@ i387_supply_fxsave (struct regcache *regcache, int regnum, const void *fxsave)
 		   the tag word.  We have to look at the actual 80-bit
 		   FP data to recreate the traditional i387 tag word.  */
 
-		unsigned long ftag = 0;
+		unsigned long long ftag = 0;
 		int fpreg;
 		int top;
 
@@ -1278,7 +1278,7 @@ i387_supply_xsave (struct regcache *regcache, int regnum,
 		   the tag word.  We have to look at the actual 80-bit
 		   FP data to recreate the traditional i387 tag word.  */
 
-		unsigned long ftag = 0;
+		unsigned long long ftag = 0;
 		int fpreg;
 		int top;
 
@@ -1871,7 +1871,7 @@ i387_tag (const gdb_byte *raw)
 {
   int integer;
   unsigned int exponent;
-  unsigned long fraction[2];
+  unsigned long long fraction[2];
 
   integer = raw[7] & 0x80;
   exponent = (((raw[9] & 0x7f) << 8) | raw[8]);
diff --git a/gdb/ia64-libunwind-tdep.c b/gdb/ia64-libunwind-tdep.c
index 99782b2..b4bb219 100644
--- a/gdb/ia64-libunwind-tdep.c
+++ b/gdb/ia64-libunwind-tdep.c
@@ -392,7 +392,7 @@ libunwind_frame_prev_register (struct frame_info *this_frame,
 /* The following is a glue routine to call the libunwind unwind table
    search function to get unwind information for a specified ip address.  */ 
 int
-libunwind_search_unwind_table (void *as, long ip, void *di,
+libunwind_search_unwind_table (void *as, long long ip, void *di,
 			       void *pi, int need_unwind_info, void *args)
 {
   return unw_search_unwind_table_p (*(unw_addr_space_t *) as, (unw_word_t) ip,
diff --git a/gdb/ia64-libunwind-tdep.h b/gdb/ia64-libunwind-tdep.h
index dc7ec9c..cf48136 100644
--- a/gdb/ia64-libunwind-tdep.h
+++ b/gdb/ia64-libunwind-tdep.h
@@ -64,7 +64,7 @@ void libunwind_frame_dealloc_cache (struct frame_info *self, void *cache);
 
 int libunwind_is_initialized (void);
 
-int libunwind_search_unwind_table (void *as, long ip, void *di,
+int libunwind_search_unwind_table (void *as, long long ip, void *di,
 				   void *pi, int need_unwind_info, void *args);
 
 unw_word_t libunwind_find_dyn_list (unw_addr_space_t, unw_dyn_info_t *,
diff --git a/gdb/ia64-linux-nat.c b/gdb/ia64-linux-nat.c
index 1d39ec5..ec04132 100644
--- a/gdb/ia64-linux-nat.c
+++ b/gdb/ia64-linux-nat.c
@@ -546,10 +546,10 @@ enable_watchpoints_in_psr (ptid_t ptid)
     }
 }
 
-static long debug_registers[8];
+static long long debug_registers[8];
 
 static void
-store_debug_register (ptid_t ptid, int idx, long val)
+store_debug_register (ptid_t ptid, int idx, long long val)
 {
   int tid;
 
@@ -561,8 +561,8 @@ store_debug_register (ptid_t ptid, int idx, long val)
 }
 
 static void
-store_debug_register_pair (ptid_t ptid, int idx, long *dbr_addr,
-			   long *dbr_mask)
+store_debug_register_pair (ptid_t ptid, int idx, long long *dbr_addr,
+			   long long *dbr_mask)
 {
   if (dbr_addr)
     store_debug_register (ptid, 2 * idx, *dbr_addr);
@@ -590,7 +590,7 @@ ia64_linux_nat_target::insert_watchpoint (CORE_ADDR addr, int len,
 {
   struct lwp_info *lp;
   int idx;
-  long dbr_addr, dbr_mask;
+  long long dbr_addr, dbr_mask;
   int max_watchpoints = 4;
 
   if (len <= 0 || !is_power_of_2 (len))
@@ -609,7 +609,7 @@ ia64_linux_nat_target::insert_watchpoint (CORE_ADDR addr, int len,
   if (idx == max_watchpoints)
     return -1;
 
-  dbr_addr = (long) addr;
+  dbr_addr = (long long) addr;
   dbr_mask = (~(len - 1) & 0x00ffffffffffffffL);  /* construct mask to match */
   dbr_mask |= 0x0800000000000000L;           /* Only match privilege level 3 */
   switch (type)
@@ -644,7 +644,7 @@ ia64_linux_nat_target::remove_watchpoint (CORE_ADDR addr, int len,
 					  struct expression *cond)
 {
   int idx;
-  long dbr_addr, dbr_mask;
+  long long dbr_addr, dbr_mask;
   int max_watchpoints = 4;
 
   if (len <= 0 || !is_power_of_2 (len))
@@ -881,9 +881,9 @@ ia64_linux_nat_target::xfer_partial (enum target_object object,
 {
   if (object == TARGET_OBJECT_UNWIND_TABLE && readbuf != NULL)
     {
-      static long gate_table_size;
+      static long long gate_table_size;
       gdb_byte *tmp_buf;
-      long res;
+      long long res;
 
       /* Probe for the table size once.  */
       if (gate_table_size == 0)
diff --git a/gdb/ia64-tdep.c b/gdb/ia64-tdep.c
index 0df62e2..3ccd6a9 100644
--- a/gdb/ia64-tdep.c
+++ b/gdb/ia64-tdep.c
@@ -2393,9 +2393,9 @@ ia64_rse_slot_num (uint64_t addr)
 /* Skip over a designated number of registers in the backing
    store, remembering every 64th position is for NAT.  */
 static __inline__ uint64_t
-ia64_rse_skip_regs (uint64_t addr, long num_regs)
+ia64_rse_skip_regs (uint64_t addr, long long num_regs)
 {
-  long delta = ia64_rse_slot_num(addr) + num_regs;
+  long long delta = ia64_rse_slot_num(addr) + num_regs;
 
   if (num_regs < 0)
     delta -= 0x3e;
@@ -2484,7 +2484,7 @@ ia64_access_reg (unw_addr_space_t as, unw_regnum_t uw_regnum, unw_word_t *val,
   struct frame_info *this_frame = (struct frame_info *) arg;
   struct gdbarch *gdbarch = get_frame_arch (this_frame);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  long new_sof, old_sof;
+  long long new_sof, old_sof;
   
   /* We never call any libunwind routines that need to write registers.  */
   gdb_assert (!write);
@@ -2557,7 +2557,7 @@ ia64_access_rse_reg (unw_addr_space_t as, unw_regnum_t uw_regnum,
   struct regcache *regcache = (struct regcache *) arg;
   struct gdbarch *gdbarch = regcache->arch ();
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  long new_sof, old_sof;
+  long long new_sof, old_sof;
   
   /* We never call any libunwind routines that need to write registers.  */
   gdb_assert (!write);
diff --git a/gdb/inf-child.c b/gdb/inf-child.c
index 2f5babe..d8f5191 100644
--- a/gdb/inf-child.c
+++ b/gdb/inf-child.c
@@ -301,14 +301,14 @@ inf_child_target::fileio_pwrite (int fd, const gdb_byte *write_buf, int len,
   int ret;
 
 #ifdef HAVE_PWRITE
-  ret = pwrite (fd, write_buf, len, (long) offset);
+  ret = pwrite (fd, write_buf, len, (long long) offset);
 #else
   ret = -1;
 #endif
   /* If we have no pwrite or it failed for this file, use lseek/write.  */
   if (ret == -1)
     {
-      ret = lseek (fd, (long) offset, SEEK_SET);
+      ret = lseek (fd, (long long) offset, SEEK_SET);
       if (ret != -1)
 	ret = write (fd, write_buf, len);
     }
@@ -328,14 +328,14 @@ inf_child_target::fileio_pread (int fd, gdb_byte *read_buf, int len,
   int ret;
 
 #ifdef HAVE_PREAD
-  ret = pread (fd, read_buf, len, (long) offset);
+  ret = pread (fd, read_buf, len, (long long) offset);
 #else
   ret = -1;
 #endif
   /* If we have no pread or it failed for this file, use lseek/read.  */
   if (ret == -1)
     {
-      ret = lseek (fd, (long) offset, SEEK_SET);
+      ret = lseek (fd, (long long) offset, SEEK_SET);
       if (ret != -1)
 	ret = read (fd, read_buf, len);
     }
diff --git a/gdb/inf-ptrace.c b/gdb/inf-ptrace.c
index 90ea679..08be1d6 100644
--- a/gdb/inf-ptrace.c
+++ b/gdb/inf-ptrace.c
@@ -550,7 +550,7 @@ inf_ptrace_target::xfer_partial (enum target_object object,
 	   inserting breakpoints, so we use PIOD_WRITE_I instead.  */
 	piod.piod_op = writebuf ? PIOD_WRITE_I : PIOD_READ_D;
 	piod.piod_addr = writebuf ? (void *) writebuf : readbuf;
-	piod.piod_offs = (void *) (long) offset;
+	piod.piod_offs = (void *) (long long) offset;
 	piod.piod_len = len;
 
 	errno = 0;
@@ -586,7 +586,7 @@ inf_ptrace_target::xfer_partial (enum target_object object,
 	  return TARGET_XFER_E_IO;
 	piod.piod_op = PIOD_READ_AUXV;
 	piod.piod_addr = readbuf;
-	piod.piod_offs = (void *) (long) offset;
+	piod.piod_offs = (void *) (long long) offset;
 	piod.piod_len = len;
 
 	errno = 0;
diff --git a/gdb/infrun.c b/gdb/infrun.c
index ba91a03..d1570d9 100644
--- a/gdb/infrun.c
+++ b/gdb/infrun.c
@@ -7534,7 +7534,7 @@ insert_exception_resume_breakpoint (struct thread_info *tp,
 	  if (debug_infrun)
 	    fprintf_unfiltered (gdb_stdlog,
 				"infrun: exception resume at %lx\n",
-				(unsigned long) handler);
+				(unsigned long long) handler);
 
 	  bp = set_momentary_breakpoint_at_pc (get_frame_arch (frame),
 					       handler,
diff --git a/gdb/iq2000-tdep.c b/gdb/iq2000-tdep.c
index 9f7f35d..6b5df5d 100644
--- a/gdb/iq2000-tdep.c
+++ b/gdb/iq2000-tdep.c
@@ -474,7 +474,7 @@ iq2000_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)
 {
   if ((*pcptr & 3) != 0)
     error (_("breakpoint_from_pc: invalid breakpoint address 0x%lx"),
-	   (long) *pcptr);
+	   (long long) *pcptr);
 
   return 4;
 }
diff --git a/gdb/jit.c b/gdb/jit.c
index e6b3cc2..be58a55 100644
--- a/gdb/jit.c
+++ b/gdb/jit.c
@@ -1341,7 +1341,7 @@ jit_inferior_init (struct gdbarch *gdbarch)
     {
       printf_unfiltered (_("Unsupported JIT protocol version %ld "
 			   "in descriptor (expected 1)\n"),
-			 (long) descriptor.version);
+			 (long long) descriptor.version);
       return;
     }
 
diff --git a/gdb/language.h b/gdb/language.h
index c4b7619..5b2c43e 100644
--- a/gdb/language.h
+++ b/gdb/language.h
@@ -449,7 +449,7 @@ struct language_defn
     /* Add fields above this point, so the magic number is always last.  */
     /* Magic number for compat checking.  */
 
-    long la_magic;
+    long long la_magic;
 
   };
 
diff --git a/gdb/linux-fork.c b/gdb/linux-fork.c
index 74d5c19..08609cb 100644
--- a/gdb/linux-fork.c
+++ b/gdb/linux-fork.c
@@ -247,7 +247,7 @@ call_lseek (int fd, off_t offset, int whence)
   char exp[80];
 
   snprintf (&exp[0], sizeof (exp), "(long) lseek (%d, %ld, %d)",
-	    fd, (long) offset, whence);
+	    fd, (long long) offset, whence);
   return (off_t) parse_and_eval_long (&exp[0]);
 }
 
@@ -305,10 +305,10 @@ fork_save_infrun_state (struct fork_info *fp, int clobber_regs)
       /* Now save the 'state' (file position) of all open file descriptors.
 	 Unfortunately fork does not take care of that for us...  */
       snprintf (path, PATH_MAX, "/proc/%ld/fd",
-		(long) fp->ptid.pid ());
+		(long long) fp->ptid.pid ());
       if ((d = opendir (path)) != NULL)
 	{
-	  long tmp;
+	  long long tmp;
 
 	  fp->maxfd = 0;
 	  while ((de = readdir (d)) != NULL)
@@ -720,14 +720,14 @@ checkpoint_command (const char *args, int from_tty)
       int parent_pid;
 
       printf_filtered (_("checkpoint %d: fork returned pid %ld.\n"),
-		       fp != NULL ? fp->num : -1, (long) retpid);
+		       fp != NULL ? fp->num : -1, (long long) retpid);
       if (info_verbose)
 	{
 	  parent_pid = last_target_ptid.lwp ();
 	  if (parent_pid == 0)
 	    parent_pid = last_target_ptid.pid ();
 	  printf_filtered (_("   gdb says parent = %ld.\n"),
-			   (long) parent_pid);
+			   (long long) parent_pid);
 	}
     }
 
diff --git a/gdb/linux-nat.c b/gdb/linux-nat.c
index 18d9a38..b0e3cba 100644
--- a/gdb/linux-nat.c
+++ b/gdb/linux-nat.c
@@ -1236,7 +1236,7 @@ linux_nat_target::attach (const char *args, int from_tty)
 
       internal_error (__FILE__, __LINE__,
 		      _("unexpected status %d for PID %ld"),
-		      status, (long) ptid.lwp ());
+		      status, (long long) ptid.lwp ());
     }
 
   lp->stopped = 1;
@@ -1246,7 +1246,7 @@ linux_nat_target::attach (const char *args, int from_tty)
   if (debug_linux_nat)
     fprintf_unfiltered (gdb_stdlog,
 			"LNA: waitpid %ld, saving status %s\n",
-			(long) lp->ptid.pid (), status_to_str (status));
+			(long long) lp->ptid.pid (), status_to_str (status));
 
   lp->status = status;
 
@@ -1938,7 +1938,7 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)
   if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK
       || event == PTRACE_EVENT_CLONE)
     {
-      unsigned long new_pid;
+      unsigned long long new_pid;
       int ret;
 
       ptrace (PTRACE_GETEVENTMSG, pid, 0, &new_pid);
@@ -2050,7 +2050,7 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)
 		fprintf_unfiltered (gdb_stdlog,
 				    "LHEW: waitpid of new LWP %ld, "
 				    "saving status %s\n",
-				    (long) new_lp->ptid.lwp (),
+				    (long long) new_lp->ptid.lwp (),
 				    status_to_str (status));
 	      new_lp->status = status;
 	    }
@@ -2956,7 +2956,7 @@ linux_nat_filter_event (int lwpid, int status)
       if (debug_linux_nat)
 	fprintf_unfiltered (gdb_stdlog,
 			    "LHEW: saving LWP %ld status %s in stopped_pids list\n",
-			    (long) lwpid, status_to_str (status));
+			    (long long) lwpid, status_to_str (status));
       add_to_pid_list (&stopped_pids, lwpid, status);
       return NULL;
     }
@@ -3316,7 +3316,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,
 	    {
 	      fprintf_unfiltered (gdb_stdlog,
 				  "LLW: waitpid %ld received %s\n",
-				  (long) lwpid, status_to_str (status));
+				  (long long) lwpid, status_to_str (status));
 	    }
 
 	  linux_nat_filter_event (lwpid, status);
@@ -3604,7 +3604,7 @@ kill_one_lwp (pid_t pid)
       int save_errno = errno;
 
       fprintf_unfiltered (gdb_stdlog,
-			  "KC:  kill (SIGKILL) %ld, 0, 0 (%s)\n", (long) pid,
+			  "KC:  kill (SIGKILL) %ld, 0, 0 (%s)\n", (long long) pid,
 			  save_errno ? safe_strerror (save_errno) : "OK");
     }
 
@@ -3617,7 +3617,7 @@ kill_one_lwp (pid_t pid)
       int save_errno = errno;
 
       fprintf_unfiltered (gdb_stdlog,
-			  "KC:  PTRACE_KILL %ld, 0, 0 (%s)\n", (long) pid,
+			  "KC:  PTRACE_KILL %ld, 0, 0 (%s)\n", (long long) pid,
 			  save_errno ? safe_strerror (save_errno) : "OK");
     }
 }
@@ -3641,7 +3641,7 @@ kill_wait_one_lwp (pid_t pid)
 	  if (debug_linux_nat)
 	    fprintf_unfiltered (gdb_stdlog,
 				"KWC: wait %ld received unknown.\n",
-				(long) pid);
+				(long long) pid);
 	  /* The Linux kernel sometimes fails to kill a thread
 	     completely after PTRACE_KILL; that goes from the stop
 	     point in do_fork out to the one in get_signal_to_deliver
@@ -3978,7 +3978,7 @@ linux_proc_xfer_partial (enum target_object object,
     return TARGET_XFER_EOF;
 
   /* Don't bother for one word.  */
-  if (len < 3 * sizeof (long))
+  if (len < 3 * sizeof (long long))
     return TARGET_XFER_EOF;
 
   /* We could keep this file open and cache it - possibly one per
diff --git a/gdb/linux-record.c b/gdb/linux-record.c
index 1d0735e..971b40b 100644
--- a/gdb/linux-record.c
+++ b/gdb/linux-record.c
@@ -602,7 +602,7 @@ record_linux_system_call (enum gdb_syscall syscall,
 
     case gdb_old_select:
       {
-	unsigned long sz_sel_arg = tdep->size_long + tdep->size_pointer * 4;
+	unsigned long long sz_sel_arg = tdep->size_long + tdep->size_pointer * 4;
 	gdb_byte *a = (gdb_byte *) alloca (sz_sel_arg);
 	CORE_ADDR inp, outp, exp, tvp;
 
diff --git a/gdb/linux-tdep.c b/gdb/linux-tdep.c
index fd2bc15..a7f1518 100644
--- a/gdb/linux-tdep.c
+++ b/gdb/linux-tdep.c
@@ -718,7 +718,7 @@ linux_info_proc (struct gdbarch *gdbarch, const char *args,
 {
   /* A long is used for pid instead of an int to avoid a loss of precision
      compiler warning from the output of strtoul.  */
-  long pid;
+  long long pid;
   int cmdline_f = (what == IP_MINIMAL || what == IP_CMDLINE || what == IP_ALL);
   int cwd_f = (what == IP_MINIMAL || what == IP_CWD || what == IP_ALL);
   int exe_f = (what == IP_MINIMAL || what == IP_EXE || what == IP_ALL);
@@ -1278,7 +1278,7 @@ linux_find_memory_regions_full (struct gdbarch *gdbarch,
 	      if (strcmp (keyword, "AnonHugePages:") == 0
 		  || strcmp (keyword, "Anonymous:") == 0)
 		{
-		  unsigned long number;
+		  unsigned long long number;
 
 		  if (sscanf (line, "%*s%lu", &number) != 1)
 		    {
@@ -1571,7 +1571,7 @@ struct linux_collect_regset_section_cb_data
   bfd *obfd;
   char *note_data;
   int *note_size;
-  unsigned long lwp;
+  unsigned long long lwp;
   enum gdb_signal stop_signal;
   int abort_iteration;
 };
@@ -1743,7 +1743,7 @@ linux_fill_prpsinfo (struct elf_internal_linux_prpsinfo *p)
   /* Process flags.  */
   unsigned int pr_flag;
   /* Process nice value.  */
-  long pr_nice;
+  long long pr_nice;
   /* The number of fields read by `sscanf'.  */
   int n_fields = 0;
 
@@ -2257,7 +2257,7 @@ static int
 linux_vsyscall_range_raw (struct gdbarch *gdbarch, struct mem_range *range)
 {
   char filename[100];
-  long pid;
+  long long pid;
 
   if (target_auxv_search (current_top_target (), AT_SYSINFO_EHDR, &range->start) <= 0)
     return 0;
@@ -2268,7 +2268,7 @@ linux_vsyscall_range_raw (struct gdbarch *gdbarch, struct mem_range *range)
   if (!target_has_execution)
     {
       Elf_Internal_Phdr *phdrs;
-      long phdrs_size;
+      long long phdrs_size;
       int num_phdrs, i;
 
       phdrs_size = bfd_get_elf_phdr_upper_bound (core_bfd);
diff --git a/gdb/linux-thread-db.c b/gdb/linux-thread-db.c
index ad193d6..3e8311b 100644
--- a/gdb/linux-thread-db.c
+++ b/gdb/linux-thread-db.c
@@ -100,7 +100,7 @@ public:
 				      CORE_ADDR load_module_addr,
 				      CORE_ADDR offset) override;
   const char *extra_thread_info (struct thread_info *) override;
-  ptid_t get_ada_task_ptid (long lwp, long thread) override;
+  ptid_t get_ada_task_ptid (long long lwp, long long thread) override;
 
   thread_info *thread_handle_to_thread_info (const gdb_byte *thread_handle,
 					     int handle_len,
@@ -1451,7 +1451,7 @@ find_new_threads_callback (const td_thrhandle_t *th_p, void *data)
 	fprintf_unfiltered (gdb_stdlog,
 			    "thread_db: skipping exited and "
 			    "joined thread (0x%lx)\n",
-			    (unsigned long) ti.ti_tid);
+			    (unsigned long long) ti.ti_tid);
       return 0;
     }
 
@@ -1638,7 +1638,7 @@ thread_db_target::pid_to_str (ptid_t ptid)
       thread_db_thread_info *priv = get_thread_db_thread_info (thread_info);
 
       snprintf (buf, sizeof (buf), "Thread 0x%lx (LWP %ld)",
-		(unsigned long) priv->tid, ptid.lwp ());
+		(unsigned long long) priv->tid, ptid.lwp ());
 
       return buf;
     }
@@ -1781,7 +1781,7 @@ thread_db_target::get_thread_local_address (ptid_t ptid,
 /* Implement the to_get_ada_task_ptid target method for this target.  */
 
 ptid_t
-thread_db_target::get_ada_task_ptid (long lwp, long thread)
+thread_db_target::get_ada_task_ptid (long long lwp, long long thread)
 {
   /* NPTL uses a 1:1 model, so the LWP id suffices.  */
   return ptid_t (inferior_ptid.pid (), lwp, 0);
diff --git a/gdb/lm32-tdep.c b/gdb/lm32-tdep.c
index 9428521..83218a3 100644
--- a/gdb/lm32-tdep.c
+++ b/gdb/lm32-tdep.c
@@ -43,7 +43,7 @@
 #define LM32_REG0(insn)         ((insn >> 21) & 0x1f)
 #define LM32_REG1(insn)         ((insn >> 16) & 0x1f)
 #define LM32_REG2(insn)         ((insn >> 11) & 0x1f)
-#define LM32_IMM16(insn)        ((((long)insn & 0xffff) << 16) >> 16)
+#define LM32_IMM16(insn)        ((((long long)insn & 0xffff) << 16) >> 16)
 
 struct gdbarch_tdep
 {
@@ -129,7 +129,7 @@ lm32_analyze_prologue (struct gdbarch *gdbarch,
 		       struct lm32_frame_cache *info)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  unsigned long instruction;
+  unsigned long long instruction;
 
   /* Keep reading though instructions, until we come across an instruction 
      that isn't likely to be part of the prologue.  */
diff --git a/gdb/m32c-tdep.c b/gdb/m32c-tdep.c
index f696568..fdf416d 100644
--- a/gdb/m32c-tdep.c
+++ b/gdb/m32c-tdep.c
@@ -148,7 +148,7 @@ static void
 make_types (struct gdbarch *arch)
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
-  unsigned long mach = gdbarch_bfd_arch_info (arch)->mach;
+  unsigned long long mach = gdbarch_bfd_arch_info (arch)->mach;
   int data_addr_reg_bits, code_addr_reg_bits;
   char type_name[50];
 
@@ -1544,7 +1544,7 @@ m32c_analyze_prologue (struct gdbarch *arch,
 		       struct m32c_prologue *prologue)
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
-  unsigned long mach = gdbarch_bfd_arch_info (arch)->mach;
+  unsigned long long mach = gdbarch_bfd_arch_info (arch)->mach;
   CORE_ADDR after_last_frame_related_insn;
   struct m32c_pv_state st;
 
@@ -2022,7 +2022,7 @@ m32c_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
+  unsigned long long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
   CORE_ADDR cfa;
   int i;
 
@@ -2611,7 +2611,7 @@ m32c_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
 {
   struct gdbarch *gdbarch;
   struct gdbarch_tdep *tdep;
-  unsigned long mach = info.bfd_arch_info->mach;
+  unsigned long long mach = info.bfd_arch_info->mach;
 
   /* Find a candidate among the list of architectures we've created
      already.  */
diff --git a/gdb/m32r-linux-nat.c b/gdb/m32r-linux-nat.c
index 8740af5..699b2d4 100644
--- a/gdb/m32r-linux-nat.c
+++ b/gdb/m32r-linux-nat.c
@@ -78,7 +78,7 @@ supply_gregset (struct regcache *regcache, const elf_gregset_t * gregsetp)
 {
   const elf_greg_t *regp = (const elf_greg_t *) gregsetp;
   int i;
-  unsigned long psw, bbpsw;
+  unsigned long long psw, bbpsw;
 
   psw = *(regp + PSW_REGMAP);
   bbpsw = *(regp + BBPSW_REGMAP);
@@ -133,7 +133,7 @@ fill_gregset (const struct regcache *regcache,
 {
   elf_greg_t *regp = (elf_greg_t *) gregsetp;
   int i;
-  unsigned long psw, bbpsw, tmp;
+  unsigned long long psw, bbpsw, tmp;
 
   psw = *(regp + PSW_REGMAP);
   bbpsw = *(regp + BBPSW_REGMAP);
diff --git a/gdb/m32r-tdep.c b/gdb/m32r-tdep.c
index fd79f3f..16931f4 100644
--- a/gdb/m32r-tdep.c
+++ b/gdb/m32r-tdep.c
@@ -267,10 +267,10 @@ m32r_store_return_value (struct type *type, struct regcache *regcache,
 static int
 decode_prologue (struct gdbarch *gdbarch,
 		 CORE_ADDR start_pc, CORE_ADDR scan_limit,
-		 CORE_ADDR *pl_endptr, unsigned long *framelength)
+		 CORE_ADDR *pl_endptr, unsigned long long *framelength)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  unsigned long framesize;
+  unsigned long long framesize;
   int insn;
   int op1;
   CORE_ADDR after_prologue = 0;
@@ -526,7 +526,7 @@ m32r_frame_unwind_cache (struct frame_info *this_frame,
   CORE_ADDR pc, scan_limit;
   ULONGEST prev_sp;
   ULONGEST this_base;
-  unsigned long op;
+  unsigned long long op;
   int i;
   struct m32r_unwind_cache *info;
 
@@ -563,7 +563,7 @@ m32r_frame_unwind_cache (struct frame_info *this_frame,
 						     2) == 0x0f24)
 		{
 		  /* ld24 r4, xxxxxx; sub sp, r4 */
-		  unsigned long n = op & 0xffffff;
+		  unsigned long long n = op & 0xffffff;
 		  info->sp_offset += n;
 		  pc += 2;	/* skip sub instruction */
 		}
diff --git a/gdb/m68k-linux-nat.c b/gdb/m68k-linux-nat.c
index d66a630..108c602 100644
--- a/gdb/m68k-linux-nat.c
+++ b/gdb/m68k-linux-nat.c
@@ -116,18 +116,18 @@ static void
 fetch_register (struct regcache *regcache, int regno)
 {
   struct gdbarch *gdbarch = regcache->arch ();
-  long regaddr, val;
+  long long regaddr, val;
   int i;
   gdb_byte buf[M68K_MAX_REGISTER_SIZE];
   pid_t tid = get_ptrace_pid (regcache->ptid ());
 
   regaddr = 4 * regmap[regno];
-  for (i = 0; i < register_size (gdbarch, regno); i += sizeof (long))
+  for (i = 0; i < register_size (gdbarch, regno); i += sizeof (long long))
     {
       errno = 0;
       val = ptrace (PTRACE_PEEKUSER, tid, regaddr, 0);
-      memcpy (&buf[i], &val, sizeof (long));
-      regaddr += sizeof (long);
+      memcpy (&buf[i], &val, sizeof (long long));
+      regaddr += sizeof (long long);
       if (errno != 0)
 	error (_("Couldn't read register %s (#%d): %s."), 
 	       gdbarch_register_name (gdbarch, regno),
@@ -164,7 +164,7 @@ static void
 store_register (const struct regcache *regcache, int regno)
 {
   struct gdbarch *gdbarch = regcache->arch ();
-  long regaddr, val;
+  long long regaddr, val;
   int i;
   gdb_byte buf[M68K_MAX_REGISTER_SIZE];
   pid_t tid = get_ptrace_pid (regcache->ptid ());
@@ -175,12 +175,12 @@ store_register (const struct regcache *regcache, int regno)
   regcache->raw_collect (regno, buf);
 
   /* Store the local buffer into the inferior a chunk at the time.  */
-  for (i = 0; i < register_size (gdbarch, regno); i += sizeof (long))
+  for (i = 0; i < register_size (gdbarch, regno); i += sizeof (long long))
     {
       errno = 0;
-      memcpy (&val, &buf[i], sizeof (long));
+      memcpy (&val, &buf[i], sizeof (long long));
       ptrace (PTRACE_POKEUSER, tid, regaddr, val);
-      regaddr += sizeof (long);
+      regaddr += sizeof (long long);
       if (errno != 0)
 	error (_("Couldn't write register %s (#%d): %s."),
 	       gdbarch_register_name (gdbarch, regno),
diff --git a/gdb/m68k-linux-tdep.c b/gdb/m68k-linux-tdep.c
index 8ebf791..a2ecbe1 100644
--- a/gdb/m68k-linux-tdep.c
+++ b/gdb/m68k-linux-tdep.c
@@ -66,7 +66,7 @@ m68k_linux_pc_in_sigtramp (struct frame_info *this_frame)
   struct gdbarch *gdbarch = get_frame_arch (this_frame);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   gdb_byte buf[12];
-  unsigned long insn0, insn1, insn2;
+  unsigned long long insn0, insn1, insn2;
   CORE_ADDR pc = get_frame_pc (this_frame);
 
   if (!safe_frame_unwind_memory (this_frame, pc - 4, buf, sizeof (buf)))
diff --git a/gdb/m68k-tdep.c b/gdb/m68k-tdep.c
index a6e9b58..00271ed 100644
--- a/gdb/m68k-tdep.c
+++ b/gdb/m68k-tdep.c
@@ -579,7 +579,7 @@ struct m68k_frame_cache
   CORE_ADDR saved_sp;
 
   /* Stack space reserved for local variables.  */
-  long locals;
+  long long locals;
 };
 
 /* Allocate and initialize a frame cache.  */
diff --git a/gdb/machoread.c b/gdb/machoread.c
index 62d0fb9..c36bb29 100644
--- a/gdb/machoread.c
+++ b/gdb/machoread.c
@@ -61,7 +61,7 @@ struct oso_el
   const char *name;
 
   /* Associated time stamp.  */
-  unsigned long mtime;
+  unsigned long long mtime;
 
   /* Stab symbols range for this OSO.  */
   asymbol **oso_sym;
@@ -148,10 +148,10 @@ macho_symtab_add_minsym (minimal_symbol_reader &reader,
 static void
 macho_symtab_read (minimal_symbol_reader &reader,
 		   struct objfile *objfile,
-		   long number_of_symbols, asymbol **symbol_table,
+		   long long number_of_symbols, asymbol **symbol_table,
 		   std::vector<oso_el> *oso_vector_ptr)
 {
-  long i;
+  long long i;
   const asymbol *file_so = NULL;
   asymbol **oso_file = NULL;
   unsigned int nbr_syms = 0;
@@ -791,7 +791,7 @@ static void
 macho_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)
 {
   bfd *abfd = objfile->obfd;
-  long storage_needed;
+  long long storage_needed;
   std::vector<oso_el> oso_vector;
   /* We have to hold on to the symbol table until the call to
      macho_symfile_read_all_oso at the end of this function.  */
@@ -813,7 +813,7 @@ macho_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)
 
       if (storage_needed > 0)
 	{
-	  long symcount;
+	  long long symcount;
 
 	  symbol_table.resize (storage_needed / sizeof (asymbol *));
 
diff --git a/gdb/maint.c b/gdb/maint.c
index a8a1fcb..462544b 100644
--- a/gdb/maint.c
+++ b/gdb/maint.c
@@ -278,12 +278,12 @@ print_bfd_flags (flagword flags)
 static void
 maint_print_section_info (const char *name, flagword flags, 
 			  CORE_ADDR addr, CORE_ADDR endaddr, 
-			  unsigned long filepos, int addr_size)
+			  unsigned long long filepos, int addr_size)
 {
   printf_filtered ("    %s", hex_string_custom (addr, addr_size));
   printf_filtered ("->%s", hex_string_custom (endaddr, addr_size));
   printf_filtered (" at %s",
-		   hex_string_custom ((unsigned long) filepos, 8));
+		   hex_string_custom ((unsigned long long) filepos, 8));
   printf_filtered (": %s", name);
   print_bfd_flags (flags);
   printf_filtered ("\n");
@@ -680,7 +680,7 @@ mcleanup_wrapper (void)
     _mcleanup ();
 }
 
-EXTERN_C void monstartup (unsigned long, unsigned long);
+EXTERN_C void monstartup (unsigned long long, unsigned long long);
 extern int main ();
 
 static void
@@ -704,7 +704,7 @@ maintenance_set_profile_cmd (const char *args, int from_tty,
 
       /* "main" is now always the first function in the text segment, so use
 	 its address for monstartup.  */
-      monstartup ((unsigned long) &main, (unsigned long) TEXTEND);
+      monstartup ((unsigned long long) &main, (unsigned long long) TEXTEND);
     }
   else
     {
@@ -831,8 +831,8 @@ scoped_command_stats::~scoped_command_stats ()
 #ifdef HAVE_SBRK
       char *lim = (char *) sbrk (0);
 
-      long space_now = lim - lim_at_start;
-      long space_diff = space_now - m_start_space;
+      long long space_now = lim - lim_at_start;
+      long long space_diff = space_now - m_start_space;
 
       printf_unfiltered (!m_msg_type
 			 ? _("Space used: %ld (%s%ld during startup)\n")
diff --git a/gdb/maint.h b/gdb/maint.h
index 20e78e4..31db3fc 100644
--- a/gdb/maint.h
+++ b/gdb/maint.h
@@ -53,7 +53,7 @@ class scoped_command_stats
   int m_symtab_enabled : 1;
   run_time_clock::time_point m_start_cpu_time;
   std::chrono::steady_clock::time_point m_start_wall_time;
-  long m_start_space;
+  long long m_start_space;
   /* Total number of symtabs (over all objfiles).  */
   int m_start_nr_symtabs;
   /* A count of the compunits.  */
diff --git a/gdb/mdebugread.c b/gdb/mdebugread.c
index 98f10b4..d4097e5 100644
--- a/gdb/mdebugread.c
+++ b/gdb/mdebugread.c
@@ -390,8 +390,8 @@ mdebug_build_psymtabs (minimal_symbol_reader &reader,
 struct pst_map
 {
   struct partial_symtab *pst;	/* the psymtab proper */
-  long n_globals;		/* exported globals (external symbols) */
-  long globals_offset;		/* cumulative */
+  long long n_globals;		/* exported globals (external symbols) */
+  long long globals_offset;		/* cumulative */
 };
 
 
@@ -597,7 +597,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,
   struct field *f;
   int count = 1;
   TIR tir;
-  long svalue = sh->value;
+  long long svalue = sh->value;
   int bitsize;
 
   if (ext_sh == (char *) NULL)
@@ -829,7 +829,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,
 	enum type_code type_code;
 	char *ext_tsym;
 	int nfields;
-	long max_value;
+	long long max_value;
 	struct field *f;
 
     case stStruct:		/* Start a block defining a struct type.  */
@@ -1931,7 +1931,7 @@ parse_procedure (PDR *pr, struct compunit_symtab *search_symtab,
 	  /* Static procedure at address pr->adr.  Sigh.  */
 	  /* FIXME-32x64.  assuming pr->adr fits in long.  */
 	  complaint (_("can't handle PDR for static proc at 0x%lx"),
-		     (unsigned long) pr->adr);
+		     (unsigned long long) pr->adr);
 	  return;
 	}
       else
@@ -2709,7 +2709,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,
 		  if (sh.st == stProc || sh.st == stStaticProc)
 		    {
 		      CORE_ADDR procaddr;
-		      long isym;
+		      long long isym;
 
 		      if (sh.st == stStaticProc)
 			{
diff --git a/gdb/mdebugread.h b/gdb/mdebugread.h
index a3a0c57..061ec88 100644
--- a/gdb/mdebugread.h
+++ b/gdb/mdebugread.h
@@ -28,7 +28,7 @@
 
 struct mdebug_extra_func_info
 {
-  long numargs;		/* Number of args to procedure (was iopt).  */
+  long long numargs;		/* Number of args to procedure (was iopt).  */
   PDR pdr;		/* Procedure descriptor record.  */
 };
 
diff --git a/gdb/mep-tdep.c b/gdb/mep-tdep.c
index c8a5ecf..0427be7 100644
--- a/gdb/mep-tdep.c
+++ b/gdb/mep-tdep.c
@@ -1400,7 +1400,7 @@ mep_pc_in_vliw_section (CORE_ADDR pc)
    anyway.  */
 
 static CORE_ADDR 
-mep_get_insn (struct gdbarch *gdbarch, CORE_ADDR pc, unsigned long *insn)
+mep_get_insn (struct gdbarch *gdbarch, CORE_ADDR pc, unsigned long long *insn)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int pc_in_vliw_section;
@@ -1660,7 +1660,7 @@ mep_analyze_prologue (struct gdbarch *gdbarch,
                       struct mep_prologue *result)
 {
   CORE_ADDR pc;
-  unsigned long insn;
+  unsigned long long insn;
   int rn;
   pv_t reg[MEP_NUM_REGS];
   CORE_ADDR after_last_frame_setup_insn = start_pc;
diff --git a/gdb/mi/mi-console.c b/gdb/mi/mi-console.c
index 248d070..12bcdb0 100644
--- a/gdb/mi/mi-console.c
+++ b/gdb/mi/mi-console.c
@@ -37,7 +37,7 @@ mi_console_file::mi_console_file (ui_file *raw, const char *prefix, char quote)
 {}
 
 void
-mi_console_file::write (const char *buf, long length_buf)
+mi_console_file::write (const char *buf, long long length_buf)
 {
   size_t prev_size = m_buffer.size ();
   /* Append the text to our internal buffer.  */
@@ -59,7 +59,7 @@ do_fputc_async_safe (int c, ui_file *stream)
 }
 
 void
-mi_console_file::write_async_safe (const char *buf, long length_buf)
+mi_console_file::write_async_safe (const char *buf, long long length_buf)
 {
   m_raw->write_async_safe (m_prefix, strlen (m_prefix));
   if (m_quote)
diff --git a/gdb/mi/mi-console.h b/gdb/mi/mi-console.h
index d98a0c8..c33b13e 100644
--- a/gdb/mi/mi-console.h
+++ b/gdb/mi/mi-console.h
@@ -37,9 +37,9 @@ public:
 
   void flush () override;
 
-  void write (const char *buf, long length_buf) override;
+  void write (const char *buf, long long length_buf) override;
 
-  void write_async_safe (const char *buf, long length_buf) override;
+  void write_async_safe (const char *buf, long long length_buf) override;
 
 private:
   /* The wrapped raw output stream.  */
diff --git a/gdb/mi/mi-main.c b/gdb/mi/mi-main.c
index 18ce4e6..478db7c 100644
--- a/gdb/mi/mi-main.c
+++ b/gdb/mi/mi-main.c
@@ -1255,14 +1255,14 @@ mi_cmd_data_read_memory (const char *command, char **argv, int argc)
   struct gdbarch *gdbarch = get_current_arch ();
   struct ui_out *uiout = current_uiout;
   CORE_ADDR addr;
-  long total_bytes, nr_cols, nr_rows;
+  long long total_bytes, nr_cols, nr_rows;
   char word_format;
   struct type *word_type;
-  long word_size;
+  long long word_size;
   char word_asize;
   char aschar;
   int nr_bytes;
-  long offset = 0;
+  long long offset = 0;
   int oind = 0;
   char *oarg;
   enum opt
@@ -1431,7 +1431,7 @@ mi_cmd_data_read_memory_bytes (const char *command, char **argv, int argc)
   struct ui_out *uiout = current_uiout;
   CORE_ADDR addr;
   LONGEST length;
-  long offset = 0;
+  long long offset = 0;
   int unit_size = gdbarch_addressable_memory_unit_size (gdbarch);
   int oind = 0;
   char *oarg;
@@ -1512,11 +1512,11 @@ mi_cmd_data_write_memory (const char *command, char **argv, int argc)
   struct gdbarch *gdbarch = get_current_arch ();
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR addr;
-  long word_size;
+  long long word_size;
   /* FIXME: ezannoni 2000-02-17 LONGEST could possibly not be big
      enough when using a compiler other than GCC.  */
   LONGEST value;
-  long offset = 0;
+  long long offset = 0;
   int oind = 0;
   char *oarg;
   enum opt
@@ -1580,7 +1580,7 @@ mi_cmd_data_write_memory_bytes (const char *command, char **argv, int argc)
   CORE_ADDR addr;
   char *cdata;
   size_t len_hex, len_bytes, len_units, i, steps, remaining_units;
-  long int count_units;
+  long long int count_units;
   int unit_size;
 
   if (argc != 2 && argc != 3)
@@ -2160,10 +2160,10 @@ mi_execute_async_cli_command (const char *cli_command, char **argv, int argc)
 
 void
 mi_load_progress (const char *section_name,
-		  unsigned long sent_so_far,
-		  unsigned long total_section,
-		  unsigned long total_sent,
-		  unsigned long grand_total)
+		  unsigned long long sent_so_far,
+		  unsigned long long total_section,
+		  unsigned long long total_sent,
+		  unsigned long long grand_total)
 {
   using namespace std::chrono;
   static steady_clock::time_point last_update;
diff --git a/gdb/mi/mi-main.h b/gdb/mi/mi-main.h
index c927f46..5fb76c0 100644
--- a/gdb/mi/mi-main.h
+++ b/gdb/mi/mi-main.h
@@ -23,10 +23,10 @@
 struct ui_file;
 
 extern void mi_load_progress (const char *section_name,
-			      unsigned long sent_so_far,
-			      unsigned long total_section,
-			      unsigned long total_sent,
-			      unsigned long grand_total);
+			      unsigned long long sent_so_far,
+			      unsigned long long total_section,
+			      unsigned long long total_sent,
+			      unsigned long long grand_total);
 
 extern void mi_print_timing_maybe (struct ui_file *file);
 
diff --git a/gdb/microblaze-tdep.c b/gdb/microblaze-tdep.c
index 9bac864..3597c2d 100644
--- a/gdb/microblaze-tdep.c
+++ b/gdb/microblaze-tdep.c
@@ -121,7 +121,7 @@ microblaze_register_type (struct gdbarch *gdbarch, int regnum)
 
 /* Fetch the instruction at PC.  */
 
-static unsigned long
+static unsigned long long
 microblaze_fetch_instruction (CORE_ADDR pc)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
@@ -201,7 +201,7 @@ microblaze_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,
 {
   const char *name;
   CORE_ADDR func_addr, func_end, addr, stop, prologue_end_addr = 0;
-  unsigned long insn;
+  unsigned long long insn;
   int rd, ra, rb, imm;
   enum microblaze_instr op;
   int flags = 0;
diff --git a/gdb/mips-linux-nat.c b/gdb/mips-linux-nat.c
index 21b1f58..a6b9118 100644
--- a/gdb/mips-linux-nat.c
+++ b/gdb/mips-linux-nat.c
@@ -654,7 +654,7 @@ write_watchpoint_regs (void)
 void
 mips_linux_nat_target::low_new_thread (struct lwp_info *lp)
 {
-  long tid = lp->ptid.lwp ();
+  long long tid = lp->ptid.lwp ();
 
   if (!mips_linux_read_watch_registers (tid,
 					&watch_readback,
diff --git a/gdb/mips-tdep.c b/gdb/mips-tdep.c
index 36fae02..ca1a52a 100644
--- a/gdb/mips-tdep.c
+++ b/gdb/mips-tdep.c
@@ -1617,7 +1617,7 @@ static CORE_ADDR
 mips32_next_pc (struct regcache *regcache, CORE_ADDR pc)
 {
   struct gdbarch *gdbarch = regcache->arch ();
-  unsigned long inst;
+  unsigned long long inst;
   int op;
   inst = mips_fetch_instruction (gdbarch, ISA_MIPS, pc, NULL);
   op = itype_op (inst);
@@ -1656,7 +1656,7 @@ mips32_next_pc (struct regcache *regcache, CORE_ADDR pc)
 	/* JALX: 011101 */
 	/* The new PC will be alternate mode.  */
 	{
-	  unsigned long reg;
+	  unsigned long long reg;
 
 	  reg = jtype_target (inst) << 2;
 	  /* Add 1 to indicate 16-bit mode -- invert ISA mode.  */
@@ -1767,7 +1767,7 @@ mips32_next_pc (struct regcache *regcache, CORE_ADDR pc)
 	case 2:		/* J */
 	case 3:		/* JAL */
 	  {
-	    unsigned long reg;
+	    unsigned long long reg;
 	    reg = jtype_target (inst) << 2;
 	    /* Upper four bits get never changed...  */
 	    pc = reg + ((pc + 4) & ~(CORE_ADDR) 0x0fffffff);
@@ -2203,7 +2203,7 @@ unpack_mips16 (struct gdbarch *gdbarch, CORE_ADDR pc,
       }
     case jalxtype:
       {
-	unsigned long value;
+	unsigned long long value;
 	unsigned int nexthalf;
 	value = ((inst & 0x1f) << 5) | ((inst >> 5) & 0x1f);
 	value = value << 16;
@@ -2490,8 +2490,8 @@ mips16_scan_prologue (struct gdbarch *gdbarch,
   CORE_ADDR cur_pc;
   CORE_ADDR frame_addr = 0;	/* Value of $r17, used as frame pointer.  */
   CORE_ADDR sp;
-  long frame_offset = 0;        /* Size of stack frame.  */
-  long frame_adjust = 0;        /* Offset of FP from SP.  */
+  long long frame_offset = 0;        /* Size of stack frame.  */
+  long long frame_adjust = 0;        /* Offset of FP from SP.  */
   int frame_reg = MIPS_SP_REGNUM;
   unsigned short prev_inst = 0;	/* saved copy of previous instruction.  */
   unsigned inst = 0;		/* current instruction */
@@ -2712,7 +2712,7 @@ mips16_scan_prologue (struct gdbarch *gdbarch,
       int xsregs = (save_inst >> 24) & 0x7;
       int args = args_table[aregs];
       int astatic = astatic_table[aregs];
-      long frame_size;
+      long long frame_size;
 
       if (args < 0)
 	{
@@ -2949,17 +2949,17 @@ micromips_scan_prologue (struct gdbarch *gdbarch,
   int frame_reg = MIPS_SP_REGNUM;
   int this_non_prologue_insn;
   int non_prologue_insns = 0;
-  long frame_offset = 0;	/* Size of stack frame.  */
-  long frame_adjust = 0;	/* Offset of FP from SP.  */
+  long long frame_offset = 0;	/* Size of stack frame.  */
+  long long frame_adjust = 0;	/* Offset of FP from SP.  */
   int prev_delay_slot = 0;
   int in_delay_slot;
   CORE_ADDR prev_pc;
   CORE_ADDR cur_pc;
   ULONGEST insn;		/* current instruction */
   CORE_ADDR sp;
-  long offset;
-  long sp_adj;
-  long v1_off = 0;		/* The assumption is LUI will replace it.  */
+  long long offset;
+  long long sp_adj;
+  long long v1_off = 0;		/* The assumption is LUI will replace it.  */
   int reglist;
   int breg;
   int dreg;
@@ -3398,7 +3398,7 @@ mips32_scan_prologue (struct gdbarch *gdbarch,
   CORE_ADDR prev_pc;
   CORE_ADDR cur_pc;
   CORE_ADDR sp;
-  long frame_offset;
+  long long frame_offset;
   int  frame_reg = MIPS_SP_REGNUM;
 
   CORE_ADDR end_prologue_addr;
@@ -3431,15 +3431,15 @@ restart:
   frame_offset = 0;
   for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS_INSN32_SIZE)
     {
-      unsigned long inst, high_word;
-      long offset;
+      unsigned long long inst, high_word;
+      long long offset;
       int reg;
 
       this_non_prologue_insn = 0;
       in_delay_slot = 0;
 
       /* Fetch the instruction.  */
-      inst = (unsigned long) mips_fetch_instruction (gdbarch, ISA_MIPS,
+      inst = (unsigned long long) mips_fetch_instruction (gdbarch, ISA_MIPS,
 						     cur_pc, NULL);
 
       /* Save some code by pre-extracting some useful fields.  */
@@ -4304,7 +4304,7 @@ heuristic-fence-post' command.\n",
       {
 	ULONGEST insn;
 	int stop = 0;
-	long offset;
+	long long offset;
 	int dreg;
 	int sreg;
 
@@ -4515,7 +4515,7 @@ mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
   if (mips_debug)
     fprintf_unfiltered (gdb_stdlog,
 			"mips_eabi_push_dummy_call: sp=%s allocated %ld\n",
-			paddress (gdbarch, sp), (long) align_up (len, 16));
+			paddress (gdbarch, sp), (long long) align_up (len, 16));
 
   /* Initialize the integer and float register pointers.  */
   argreg = MIPS_A0_REGNUM;
@@ -4603,7 +4603,7 @@ mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
 	    {
 	      int low_offset = gdbarch_byte_order (gdbarch)
 			       == BFD_ENDIAN_BIG ? 4 : 0;
-	      long regval;
+	      long long regval;
 
 	      /* Write the low word of the double to the even register(s).  */
 	      regval = extract_signed_integer (val + low_offset,
@@ -4906,7 +4906,7 @@ mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
   if (mips_debug)
     fprintf_unfiltered (gdb_stdlog,
 			"mips_n32n64_push_dummy_call: sp=%s allocated %ld\n",
-			paddress (gdbarch, sp), (long) align_up (len, 16));
+			paddress (gdbarch, sp), (long long) align_up (len, 16));
 
   /* Initialize the integer and float register pointers.  */
   argreg = MIPS_A0_REGNUM;
@@ -5370,7 +5370,7 @@ mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
   if (mips_debug)
     fprintf_unfiltered (gdb_stdlog,
 			"mips_o32_push_dummy_call: sp=%s allocated %ld\n",
-			paddress (gdbarch, sp), (long) align_up (len, 16));
+			paddress (gdbarch, sp), (long long) align_up (len, 16));
 
   /* Initialize the integer and float register pointers.  */
   argreg = MIPS_A0_REGNUM;
@@ -5435,7 +5435,7 @@ mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
 	    {
 	      int freg_offset = gdbarch_byte_order (gdbarch)
 				== BFD_ENDIAN_BIG ? 1 : 0;
-	      unsigned long regval;
+	      unsigned long long regval;
 
 	      /* First word.  */
 	      regval = extract_unsigned_integer (val, 4, byte_order);
@@ -5891,7 +5891,7 @@ mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
   if (mips_debug)
     fprintf_unfiltered (gdb_stdlog,
 			"mips_o64_push_dummy_call: sp=%s allocated %ld\n",
-			paddress (gdbarch, sp), (long) align_up (len, 16));
+			paddress (gdbarch, sp), (long long) align_up (len, 16));
 
   /* Initialize the integer and float register pointers.  */
   argreg = MIPS_A0_REGNUM;
@@ -6688,8 +6688,8 @@ mips32_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR pc)
 
       for (; pc < func_end; pc += MIPS_INSN32_SIZE)
 	{
-	  unsigned long high_word;
-	  unsigned long inst;
+	  unsigned long long high_word;
+	  unsigned long long inst;
 
 	  inst = mips_fetch_instruction (gdbarch, ISA_MIPS, pc, NULL);
 	  high_word = (inst >> 16) & 0xffff;
@@ -6717,7 +6717,7 @@ micromips_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR pc)
   CORE_ADDR func_end = 0;
   CORE_ADDR addr;
   ULONGEST insn;
-  long offset;
+  long long offset;
   int dreg;
   int sreg;
   int loc;
diff --git a/gdb/mipsread.c b/gdb/mipsread.c
index 7b6ec2e..fe3bca8 100644
--- a/gdb/mipsread.c
+++ b/gdb/mipsread.c
@@ -227,7 +227,7 @@ read_alphacoff_dynamic_symtab (minimal_symbol_reader &reader,
        dyninfo_p += sizeof (Elfalpha_External_Dyn))
     {
       Elfalpha_External_Dyn *x_dynp = (Elfalpha_External_Dyn *) dyninfo_p;
-      long dyn_tag;
+      long long dyn_tag;
 
       dyn_tag = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp->d_tag);
       if (dyn_tag == DT_NULL)
@@ -258,7 +258,7 @@ read_alphacoff_dynamic_symtab (minimal_symbol_reader &reader,
        i < sym_count;
        i++, x_symp++)
     {
-      unsigned long strx;
+      unsigned long long strx;
       char *name;
       bfd_vma sym_value;
       unsigned char sym_info;
diff --git a/gdb/mn10300-tdep.c b/gdb/mn10300-tdep.c
index edc99a2..989ab0a 100644
--- a/gdb/mn10300-tdep.c
+++ b/gdb/mn10300-tdep.c
@@ -250,7 +250,7 @@ mn10300_return_value (struct gdbarch *gdbarch, struct value *function,
 }
 
 static const char *
-register_name (int reg, const char **regs, long sizeof_regs)
+register_name (int reg, const char **regs, long long sizeof_regs)
 {
   if (reg < 0 || reg >= sizeof_regs / sizeof (regs[0]))
     return NULL;
diff --git a/gdb/nat/aarch64-linux-hw-point.c b/gdb/nat/aarch64-linux-hw-point.c
index 18b5af2..1c6a26e 100644
--- a/gdb/nat/aarch64-linux-hw-point.c
+++ b/gdb/nat/aarch64-linux-hw-point.c
@@ -729,7 +729,7 @@ aarch64_show_debug_reg_state (struct aarch64_debug_reg_state *state,
   debug_printf ("%s", func);
   if (addr || len)
     debug_printf (" (addr=0x%08lx, len=%d, type=%s)",
-		  (unsigned long) addr, len,
+		  (unsigned long long) addr, len,
 		  type == hw_write ? "hw-write-watchpoint"
 		  : (type == hw_read ? "hw-read-watchpoint"
 		     : (type == hw_access ? "hw-access-watchpoint"
diff --git a/gdb/nat/amd64-linux-siginfo.c b/gdb/nat/amd64-linux-siginfo.c
index 0e61f35..08354a6 100644
--- a/gdb/nat/amd64-linux-siginfo.c
+++ b/gdb/nat/amd64-linux-siginfo.c
@@ -37,13 +37,13 @@
 #ifndef __ILP32__
 
 typedef int nat_int_t;
-typedef unsigned long nat_uptr_t;
+typedef unsigned long long nat_uptr_t;
 
 typedef int nat_time_t;
 typedef int nat_timer_t;
 
 /* For native 64-bit, clock_t in _sigchld is 64-bit.  */
-typedef long nat_clock_t;
+typedef long long nat_clock_t;
 
 typedef union nat_sigval
 {
@@ -204,7 +204,7 @@ typedef struct compat_siginfo
 } compat_siginfo_t;
 
 /* For x32, clock_t in _sigchld is 64bit aligned at 4 bytes.  */
-typedef long __attribute__ ((__aligned__ (4))) compat_x32_clock_t;
+typedef long long __attribute__ ((__aligned__ (4))) compat_x32_clock_t;
 
 typedef struct compat_x32_siginfo
 {
diff --git a/gdb/nat/gdb_thread_db.h b/gdb/nat/gdb_thread_db.h
index b8259c3..9853411 100644
--- a/gdb/nat/gdb_thread_db.h
+++ b/gdb/nat/gdb_thread_db.h
@@ -66,7 +66,7 @@ typedef td_err_e (td_thr_tls_get_addr_ftype) (const td_thrhandle_t *th,
 					      psaddr_t map_address,
 					      size_t offset, psaddr_t *address);
 typedef td_err_e (td_thr_tlsbase_ftype) (const td_thrhandle_t *th,
-					 unsigned long int modid,
+					 unsigned long long int modid,
 					 psaddr_t *base);
 
 typedef const char ** (td_symbol_list_ftype) (void);
diff --git a/gdb/nat/glibc_thread_db.h b/gdb/nat/glibc_thread_db.h
index 97423a4..a8c93b4 100644
--- a/gdb/nat/glibc_thread_db.h
+++ b/gdb/nat/glibc_thread_db.h
@@ -266,7 +266,7 @@ typedef struct td_thrinfo
   psaddr_t ti_startfunc;		/* Start function passed to
 					   pthread_create().  */
   psaddr_t ti_stkbase;			/* Base of thread's stack.  */
-  long int ti_stksize;			/* Size of thread's stack.  */
+  long long int ti_stksize;			/* Size of thread's stack.  */
   psaddr_t ti_ro_area;			/* Unused.  */
   int ti_ro_size;			/* Unused.  */
   td_thr_state_e ti_state;		/* Thread state.  */
@@ -406,7 +406,7 @@ extern td_err_e td_thr_setxregs (const td_thrhandle_t *__th,
 
 /* Get address of the given module's TLS storage area for the given thread.  */
 extern td_err_e td_thr_tlsbase (const td_thrhandle_t *__th,
-				unsigned long int __modid,
+				unsigned long long int __modid,
 				psaddr_t *__base);
 
 /* Get address of thread local variable.  */
diff --git a/gdb/nat/linux-procfs.c b/gdb/nat/linux-procfs.c
index 6c15ea5..51b88eb 100644
--- a/gdb/nat/linux-procfs.c
+++ b/gdb/nat/linux-procfs.c
@@ -243,7 +243,7 @@ linux_proc_tid_get_name (ptid_t ptid)
   pid_t tid = ptid.lwp_p () ? ptid.lwp () : ptid.pid ();
 
   xsnprintf (comm_path, sizeof (comm_path),
-	     "/proc/%ld/task/%ld/comm", (long) pid, (long) tid);
+	     "/proc/%ld/task/%ld/comm", (long long) pid, (long long) tid);
 
   gdb_file_up comm_file = gdb_fopen_cloexec (comm_path, "r");
   if (comm_file == NULL)
@@ -283,11 +283,11 @@ linux_proc_attach_tgid_threads (pid_t pid,
   if (linux_proc_get_tgid (pid) != pid)
     return;
 
-  xsnprintf (pathname, sizeof (pathname), "/proc/%ld/task", (long) pid);
+  xsnprintf (pathname, sizeof (pathname), "/proc/%ld/task", (long long) pid);
   dir = opendir (pathname);
   if (dir == NULL)
     {
-      warning (_("Could not open /proc/%ld/task."), (long) pid);
+      warning (_("Could not open /proc/%ld/task."), (long long) pid);
       return;
     }
 
@@ -302,7 +302,7 @@ linux_proc_attach_tgid_threads (pid_t pid,
       new_threads_found = 0;
       while ((dp = readdir (dir)) != NULL)
 	{
-	  unsigned long lwp;
+	  unsigned long long lwp;
 
 	  /* Fetch one lwp.  */
 	  lwp = strtoul (dp->d_name, NULL, 10);
@@ -335,7 +335,7 @@ linux_proc_task_list_dir_exists (pid_t pid)
   char pathname[128];
   struct stat buf;
 
-  xsnprintf (pathname, sizeof (pathname), "/proc/%ld/task", (long) pid);
+  xsnprintf (pathname, sizeof (pathname), "/proc/%ld/task", (long long) pid);
   return (stat (pathname, &buf) == 0);
 }
 
diff --git a/gdb/nat/linux-ptrace.c b/gdb/nat/linux-ptrace.c
index 1f21ef0..fb9146d 100644
--- a/gdb/nat/linux-ptrace.c
+++ b/gdb/nat/linux-ptrace.c
@@ -58,7 +58,7 @@ linux_ptrace_attach_fail_reason (pid_t pid)
 std::string
 linux_ptrace_attach_fail_reason_string (ptid_t ptid, int err)
 {
-  long lwpid = ptid.lwp ();
+  long long lwpid = ptid.lwp ();
   std::string reason = linux_ptrace_attach_fail_reason (lwpid);
 
   if (!reason.empty ())
@@ -90,7 +90,7 @@ linux_ptrace_test_ret_to_nx (void)
 #if defined __i386__ || defined __x86_64__
   pid_t child, got_pid;
   gdb_byte *return_address, *pc;
-  long l;
+  long long l;
   int status, kill_status;
   elf_gregset_t regs;
 
@@ -150,7 +150,7 @@ linux_ptrace_test_ret_to_nx (void)
   if (got_pid != child)
     {
       warning (_("linux_ptrace_test_ret_to_nx: waitpid returned %ld: %s"),
-	       (long) got_pid, safe_strerror (errno));
+	       (long long) got_pid, safe_strerror (errno));
       return;
     }
 
@@ -205,7 +205,7 @@ linux_ptrace_test_ret_to_nx (void)
     {
       warning (_("linux_ptrace_test_ret_to_nx: "
 		 "PTRACE_KILL waitpid returned %ld: %s"),
-	       (long) got_pid, safe_strerror (errno));
+	       (long long) got_pid, safe_strerror (errno));
       return;
     }
   if (!WIFSIGNALED (kill_status))
@@ -386,7 +386,7 @@ static void
 linux_test_for_tracefork (int child_pid)
 {
   int ret, status;
-  long second_pid;
+  long long second_pid;
 
   /* First, set the PTRACE_O_TRACEFORK option.  If this fails, we
      know for sure that it is not supported.  */
diff --git a/gdb/nat/mips-linux-watch.c b/gdb/nat/mips-linux-watch.c
index 34afb35..3807beb 100644
--- a/gdb/nat/mips-linux-watch.c
+++ b/gdb/nat/mips-linux-watch.c
@@ -158,7 +158,7 @@ mips_linux_watch_set_watchhi (struct pt_watch_regs *regs, int n,
    Cached information is used unless FORCE is true.  */
 
 int
-mips_linux_read_watch_registers (long lwpid,
+mips_linux_read_watch_registers (long long lwpid,
 				 struct pt_watch_regs *watch_readback,
 				 int *watch_readback_valid, int force)
 {
diff --git a/gdb/nat/mips-linux-watch.h b/gdb/nat/mips-linux-watch.h
index d9141ed..f3afbe3 100644
--- a/gdb/nat/mips-linux-watch.h
+++ b/gdb/nat/mips-linux-watch.h
@@ -112,7 +112,7 @@ void mips_linux_watch_populate_regs (struct mips_watchpoint *current_watches,
 				     struct pt_watch_regs *regs);
 uint32_t mips_linux_watch_type_to_irw (enum target_hw_bp_type type);
 
-int mips_linux_read_watch_registers (long lwpid,
+int mips_linux_read_watch_registers (long long lwpid,
 				     struct pt_watch_regs *watch_readback,
 				     int *watch_readback_valid, int force);
 #endif
diff --git a/gdb/nat/ppc-linux.c b/gdb/nat/ppc-linux.c
index 1796ceb..29bc4cf 100644
--- a/gdb/nat/ppc-linux.c
+++ b/gdb/nat/ppc-linux.c
@@ -30,12 +30,12 @@
    save it in *VALP.   */
 
 static void
-ppc64_host_hwcap (unsigned long *valp)
+ppc64_host_hwcap (unsigned long long *valp)
 {
 #ifdef HAVE_GETAUXVAL
   *valp = getauxval (AT_HWCAP);
 #else
-  unsigned long data[2];
+  unsigned long long data[2];
   FILE *f = fopen ("/proc/self/auxv", "r");
 
   if (f == NULL)
@@ -55,9 +55,9 @@ ppc64_host_hwcap (unsigned long *valp)
 }
 
 static inline int
-ppc64_64bit_inferior_p (long msr)
+ppc64_64bit_inferior_p (long long msr)
 {
-  unsigned long ppc_host_hwcap = 0;
+  unsigned long long ppc_host_hwcap = 0;
 
   /* Get host's HWCAP to check whether the machine is Book E.  */
   ppc64_host_hwcap (&ppc_host_hwcap);
@@ -83,10 +83,10 @@ ppc_linux_target_wordsize (int tid)
   /* Check for 64-bit inferior process.  This is the case when the host is
      64-bit, and in addition the top bit of the MSR register is set.  */
 #ifdef __powerpc64__
-  long msr;
+  long long msr;
 
   errno = 0;
-  msr = (long) ptrace (PTRACE_PEEKUSER, tid, PT_MSR * 8, 0);
+  msr = (long long) ptrace (PTRACE_PEEKUSER, tid, PT_MSR * 8, 0);
   if (errno == 0 && ppc64_64bit_inferior_p (msr))
     wordsize = 8;
 #endif
diff --git a/gdb/nat/x86-dregs.h b/gdb/nat/x86-dregs.h
index e86e83a..321ffa5 100644
--- a/gdb/nat/x86-dregs.h
+++ b/gdb/nat/x86-dregs.h
@@ -41,7 +41,7 @@ struct x86_dr_low_type
     /* Set the debug control (DR7) register to a given value for
        all LWPs.  May be NULL if the debug control register cannot
        be set.  */
-    void (*set_control) (unsigned long);
+    void (*set_control) (unsigned long long);
 
     /* Put an address into one debug register for all LWPs.  May
        be NULL if debug registers cannot be set*/
@@ -53,11 +53,11 @@ struct x86_dr_low_type
 
     /* Return the value of the debug status (DR6) register for
        current LWP.  */
-    unsigned long (*get_status) (void);
+    unsigned long long (*get_status) (void);
 
     /* Return the value of the debug control (DR7) register for
        current LWP.  */
-    unsigned long (*get_control) (void);
+    unsigned long long (*get_control) (void);
 
     /* Number of bytes used for debug registers (4 or 8).  */
     int debug_register_length;
diff --git a/gdb/nat/x86-linux-dregs.c b/gdb/nat/x86-linux-dregs.c
index 5437fb4..adfabdf 100644
--- a/gdb/nat/x86-linux-dregs.c
+++ b/gdb/nat/x86-linux-dregs.c
@@ -37,11 +37,11 @@ u_debugreg_offset (int regnum)
 
 /* Get debug register REGNUM value from the LWP specified by PTID.  */
 
-static unsigned long
+static unsigned long long
 x86_linux_dr_get (ptid_t ptid, int regnum)
 {
   int tid;
-  unsigned long value;
+  unsigned long long value;
 
   gdb_assert (ptid.lwp_p ());
   tid = ptid.lwp ();
@@ -57,7 +57,7 @@ x86_linux_dr_get (ptid_t ptid, int regnum)
 /* Set debug register REGNUM to VALUE in the LWP specified by PTID.  */
 
 static void
-x86_linux_dr_set (ptid_t ptid, int regnum, unsigned long value)
+x86_linux_dr_set (ptid_t ptid, int regnum, unsigned long long value)
 {
   int tid;
 
@@ -111,7 +111,7 @@ x86_linux_dr_set_addr (int regnum, CORE_ADDR addr)
 
 /* See nat/x86-linux-dregs.h.  */
 
-unsigned long
+unsigned long long
 x86_linux_dr_get_control (void)
 {
   return x86_linux_dr_get (current_lwp_ptid (), DR_CONTROL);
@@ -120,7 +120,7 @@ x86_linux_dr_get_control (void)
 /* See nat/x86-linux-dregs.h.  */
 
 void
-x86_linux_dr_set_control (unsigned long control)
+x86_linux_dr_set_control (unsigned long long control)
 {
   ptid_t pid_ptid = ptid_t (current_lwp_ptid ().pid ());
 
@@ -129,7 +129,7 @@ x86_linux_dr_set_control (unsigned long control)
 
 /* See nat/x86-linux-dregs.h.  */
 
-unsigned long
+unsigned long long
 x86_linux_dr_get_status (void)
 {
   return x86_linux_dr_get (current_lwp_ptid (), DR_STATUS);
diff --git a/gdb/nat/x86-linux-dregs.h b/gdb/nat/x86-linux-dregs.h
index 4fd00cb..6dd703a 100644
--- a/gdb/nat/x86-linux-dregs.h
+++ b/gdb/nat/x86-linux-dregs.h
@@ -33,17 +33,17 @@ extern void x86_linux_dr_set_addr (int regnum, CORE_ADDR addr);
 /* Return the value stored in the current inferior's debug control
    register.  */
 
-extern unsigned long x86_linux_dr_get_control (void);
+extern unsigned long long x86_linux_dr_get_control (void);
 
 /* Store CONTROL in the debug control registers of all LWPs of the
    current inferior.  */
 
-extern void x86_linux_dr_set_control (unsigned long control);
+extern void x86_linux_dr_set_control (unsigned long long control);
 
 /* Return the value stored in the current inferior's debug status
    register.  */
 
-extern unsigned long x86_linux_dr_get_status (void);
+extern unsigned long long x86_linux_dr_get_status (void);
 
 /* Update the thread's debug registers if the values in our local
    mirror have been changed.  */
diff --git a/gdb/nios2-tdep.c b/gdb/nios2-tdep.c
index 91b4381..810051b 100644
--- a/gdb/nios2-tdep.c
+++ b/gdb/nios2-tdep.c
@@ -279,7 +279,7 @@ nios2_fetch_insn (struct gdbarch *gdbarch, CORE_ADDR pc,
 		  unsigned int *insnp)
 {
   LONGEST memword;
-  unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
+  unsigned long long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
   unsigned int insn;
 
   if (mach == bfd_mach_nios2r2)
@@ -306,7 +306,7 @@ nios2_fetch_insn (struct gdbarch *gdbarch, CORE_ADDR pc,
 
 static int
 nios2_match_add (uint32_t insn, const struct nios2_opcode *op,
-		 unsigned long mach, int *ra, int *rb, int *rc)
+		 unsigned long long mach, int *ra, int *rb, int *rc)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -348,7 +348,7 @@ nios2_match_add (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_sub (uint32_t insn, const struct nios2_opcode *op,
-		 unsigned long mach, int *ra, int *rb, int *rc)
+		 unsigned long long mach, int *ra, int *rb, int *rc)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -384,7 +384,7 @@ nios2_match_sub (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_addi (uint32_t insn, const struct nios2_opcode *op,
-		  unsigned long mach, int *ra, int *rb, int *imm)
+		  unsigned long long mach, int *ra, int *rb, int *imm)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -438,7 +438,7 @@ nios2_match_addi (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_orhi (uint32_t insn, const struct nios2_opcode *op,
-		  unsigned long mach, int *ra, int *rb, unsigned int *uimm)
+		  unsigned long long mach, int *ra, int *rb, unsigned int *uimm)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -467,7 +467,7 @@ nios2_match_orhi (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_stw (uint32_t insn, const struct nios2_opcode *op,
-		 unsigned long mach, int *ra, int *rb, int *imm)
+		 unsigned long long mach, int *ra, int *rb, int *imm)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -524,7 +524,7 @@ nios2_match_stw (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_ldw (uint32_t insn, const struct nios2_opcode *op,
-		 unsigned long mach, int *ra, int *rb, int *imm)
+		 unsigned long long mach, int *ra, int *rb, int *imm)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -573,7 +573,7 @@ nios2_match_ldw (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_rdctl (uint32_t insn, const struct nios2_opcode *op,
-		   unsigned long mach, int *ra, int *rc)
+		   unsigned long long mach, int *ra, int *rc)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -599,7 +599,7 @@ nios2_match_rdctl (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_stwm (uint32_t insn, const struct nios2_opcode *op,
-		  unsigned long mach, unsigned int *reglist,
+		  unsigned long long mach, unsigned int *reglist,
 		  int *ra, int *imm, int *wb, int *id)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
@@ -649,7 +649,7 @@ nios2_match_stwm (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_ldwm (uint32_t insn, const struct nios2_opcode *op,
-		  unsigned long mach, unsigned int *reglist,
+		  unsigned long long mach, unsigned int *reglist,
 		  int *ra, int *imm, int *wb, int *id, int *ret)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
@@ -712,7 +712,7 @@ enum branch_condition {
   
 static int
 nios2_match_branch (uint32_t insn, const struct nios2_opcode *op,
-		    unsigned long mach, int *ra, int *rb, int *imm,
+		    unsigned long long mach, int *ra, int *rb, int *imm,
 		    enum branch_condition *cond)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
@@ -810,7 +810,7 @@ nios2_match_branch (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_jmpi (uint32_t insn, const struct nios2_opcode *op,
-		  unsigned long mach, unsigned int *uimm)
+		  unsigned long long mach, unsigned int *uimm)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -835,7 +835,7 @@ nios2_match_jmpi (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_calli (uint32_t insn, const struct nios2_opcode *op,
-		   unsigned long mach, unsigned int *uimm)
+		   unsigned long long mach, unsigned int *uimm)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -860,7 +860,7 @@ nios2_match_calli (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_jmpr (uint32_t insn, const struct nios2_opcode *op,
-		  unsigned long mach, int *ra)
+		  unsigned long long mach, int *ra)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -912,7 +912,7 @@ nios2_match_jmpr (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_callr (uint32_t insn, const struct nios2_opcode *op,
-		   unsigned long mach, int *ra)
+		   unsigned long long mach, int *ra)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -941,7 +941,7 @@ nios2_match_callr (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_break (uint32_t insn, const struct nios2_opcode *op,
-		  unsigned long mach, unsigned int *uimm)
+		  unsigned long long mach, unsigned int *uimm)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -970,7 +970,7 @@ nios2_match_break (uint32_t insn, const struct nios2_opcode *op,
 
 static int
 nios2_match_trap (uint32_t insn, const struct nios2_opcode *op,
-		  unsigned long mach, unsigned int *uimm)
+		  unsigned long long mach, unsigned int *uimm)
 {
   int is_r2 = (mach == bfd_mach_nios2r2);
 
@@ -1006,7 +1006,7 @@ nios2_in_epilogue_p (struct gdbarch *gdbarch,
 		     CORE_ADDR current_pc,
 		     CORE_ADDR start_pc)
 {
-  unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
+  unsigned long long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
   int is_r2 = (mach == bfd_mach_nios2r2);
   /* Maximum number of possibly-epilogue instructions to check.
      Note that this number should not be too large, else we can
@@ -1194,7 +1194,7 @@ nios2_analyze_prologue (struct gdbarch *gdbarch, const CORE_ADDR start_pc,
      potentially end up iterating through unmapped memory.  */
   int ninsns, max_insns = 50;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
+  unsigned long long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
 
   /* Does the frame set up the FP register?  */
   int base_reg = 0;
@@ -1698,7 +1698,7 @@ nios2_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
 static int
 nios2_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)
 {
-  unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
+  unsigned long long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
 
   if (mach == bfd_mach_nios2r2)
     {
@@ -1745,7 +1745,7 @@ nios2_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)
     }
   else
     {
-      unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
+      unsigned long long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
 
       if (mach == bfd_mach_nios2r2)
 	{
@@ -2116,7 +2116,7 @@ nios2_get_next_pc (struct regcache *regcache, CORE_ADDR pc)
 {
   struct gdbarch *gdbarch = regcache->arch ();
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
-  unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
+  unsigned long long mach = gdbarch_bfd_arch_info (gdbarch)->mach;
   unsigned int insn;
   const struct nios2_opcode *op = nios2_fetch_insn (gdbarch, pc, &insn);
   int ra;
diff --git a/gdb/objc-lang.c b/gdb/objc-lang.c
index 6da8af1..73592af 100644
--- a/gdb/objc-lang.c
+++ b/gdb/objc-lang.c
@@ -55,9 +55,9 @@ struct objc_class {
   CORE_ADDR isa; 
   CORE_ADDR super_class; 
   CORE_ADDR name;               
-  long version;
-  long info;
-  long instance_size;
+  long long version;
+  long long info;
+  long long instance_size;
   CORE_ADDR ivars;
   CORE_ADDR methods;
   CORE_ADDR cache;
@@ -1356,7 +1356,7 @@ read_objc_method (struct gdbarch *gdbarch, CORE_ADDR addr,
   method->imp   = read_memory_unsigned_integer (addr + 8, 4, byte_order);
 }
 
-static unsigned long
+static unsigned long long
 read_objc_methlist_nmethods (struct gdbarch *gdbarch, CORE_ADDR addr)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
@@ -1366,7 +1366,7 @@ read_objc_methlist_nmethods (struct gdbarch *gdbarch, CORE_ADDR addr)
 
 static void 
 read_objc_methlist_method (struct gdbarch *gdbarch, CORE_ADDR addr,
-			   unsigned long num, struct objc_method *method)
+			   unsigned long long num, struct objc_method *method)
 {
   gdb_assert (num < read_objc_methlist_nmethods (gdbarch, addr));
   read_objc_method (gdbarch, addr + 8 + (12 * num), method);
@@ -1428,8 +1428,8 @@ find_implementation_from_class (struct gdbarch *gdbarch,
       for (;;) 
 	{
 	  CORE_ADDR mlist;
-	  unsigned long nmethods;
-	  unsigned long i;
+	  unsigned long long nmethods;
+	  unsigned long long i;
       
 	  mlist = read_memory_unsigned_integer (class_str.methods + 
 						(4 * mlistnum),
diff --git a/gdb/objfiles.h b/gdb/objfiles.h
index 7a9087b..0a0bd68 100644
--- a/gdb/objfiles.h
+++ b/gdb/objfiles.h
@@ -349,7 +349,7 @@ struct objfile
   /* The modification timestamp of the object file, as of the last time
      we read its symbols.  */
 
-  long mtime = 0;
+  long long mtime = 0;
 
   /* Obstack to hold objects that should be freed when we load a new symbol
      table from this object file.  */
diff --git a/gdb/osabi.c b/gdb/osabi.c
index 7d0540b..0aece47 100644
--- a/gdb/osabi.c
+++ b/gdb/osabi.c
@@ -141,7 +141,7 @@ struct gdb_osabi_handler
 static struct gdb_osabi_handler *gdb_osabi_handler_list;
 
 void
-gdbarch_register_osabi (enum bfd_architecture arch, unsigned long machine,
+gdbarch_register_osabi (enum bfd_architecture arch, unsigned long long machine,
 			enum gdb_osabi osabi,
 			void (*init_osabi)(struct gdbarch_info,
 					   struct gdbarch *))
@@ -394,9 +394,9 @@ gdbarch_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)
 
 static int
 check_note (bfd *abfd, asection *sect, char *note, unsigned int *sectsize,
-	    const char *name, unsigned long descsz, unsigned long type)
+	    const char *name, unsigned long long descsz, unsigned long long type)
 {
-  unsigned long notesz;
+  unsigned long long notesz;
 
   if (*sectsize)
     {
diff --git a/gdb/osabi.h b/gdb/osabi.h
index 9f53ba4..8930f84 100644
--- a/gdb/osabi.h
+++ b/gdb/osabi.h
@@ -31,7 +31,7 @@ void gdbarch_register_osabi_sniffer (enum bfd_architecture,
 /* Register a handler for an OS ABI variant for a given architecture
    and machine type.  There should be only one handler for a given OS
    ABI for each architecture and machine type combination.  */
-void gdbarch_register_osabi (enum bfd_architecture, unsigned long,
+void gdbarch_register_osabi (enum bfd_architecture, unsigned long long,
 			     enum gdb_osabi,
                              void (*)(struct gdbarch_info,
 				      struct gdbarch *));
diff --git a/gdb/p-lang.c b/gdb/p-lang.c
index 56dfa19..17981e3 100644
--- a/gdb/p-lang.c
+++ b/gdb/p-lang.c
@@ -250,7 +250,7 @@ pascal_printstr (struct ui_file *stream, struct type *type,
       unsigned int rep1;
       /* Number of repetitions we have detected so far.  */
       unsigned int reps;
-      unsigned long int current_char;
+      unsigned long long int current_char;
 
       QUIT;
 
diff --git a/gdb/ppc-fbsd-nat.c b/gdb/ppc-fbsd-nat.c
index 5d2d391..0bfeba6 100644
--- a/gdb/ppc-fbsd-nat.c
+++ b/gdb/ppc-fbsd-nat.c
@@ -51,7 +51,7 @@ static ppc_fbsd_nat_target the_ppc_fbsd_nat_target;
 void
 supply_gregset (struct regcache *regcache, const gdb_gregset_t *gregsetp)
 {
-  const struct regset *regset = ppc_fbsd_gregset (sizeof (long));
+  const struct regset *regset = ppc_fbsd_gregset (sizeof (long long));
 
   ppc_supply_gregset (regset, regcache, -1, gregsetp, sizeof (*gregsetp));
 }
@@ -63,7 +63,7 @@ void
 fill_gregset (const struct regcache *regcache,
 	      gdb_gregset_t *gregsetp, int regno)
 {
-  const struct regset *regset = ppc_fbsd_gregset (sizeof (long));
+  const struct regset *regset = ppc_fbsd_gregset (sizeof (long long));
 
   if (regno == -1)
     memset (gregsetp, 0, sizeof (*gregsetp));
diff --git a/gdb/ppc-fbsd-tdep.c b/gdb/ppc-fbsd-tdep.c
index e709c36..837379a 100644
--- a/gdb/ppc-fbsd-tdep.c
+++ b/gdb/ppc-fbsd-tdep.c
@@ -172,7 +172,7 @@ ppcfbsd_sigtramp_frame_sniffer (const struct frame_unwind *self,
   for (offset = ppcfbsd_sigreturn_offset; *offset != -1; offset++)
     {
       gdb_byte buf[2 * PPC_INSN_SIZE];
-      unsigned long insn;
+      unsigned long long insn;
 
       if (!safe_frame_unwind_memory (this_frame, start_pc + *offset,
 				     buf, sizeof buf))
diff --git a/gdb/ppc-linux-nat.c b/gdb/ppc-linux-nat.c
index 9719a0e..bf207eb 100644
--- a/gdb/ppc-linux-nat.c
+++ b/gdb/ppc-linux-nat.c
@@ -231,9 +231,9 @@ typedef char gdb_vsxregset_t[PPC_LINUX_SIZEOF_VSXREGSET];
    the inferior's registers by PTRACE_SETEVRREGS.  */
 struct gdb_evrregset_t
 {
-  unsigned long evr[32];
+  unsigned long long evr[32];
   unsigned long long acc;
-  unsigned long spefscr;
+  unsigned long long spefscr;
 };
 
 /* Non-zero if our kernel may support the PTRACE_GETVSXREGS and
@@ -345,7 +345,7 @@ ppc_register_u_addr (struct gdbarch *gdbarch, int regno)
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
      interface, and not the wordsize of the program's ABI.  */
-  int wordsize = sizeof (long);
+  int wordsize = sizeof (long long);
 
   /* General purpose registers occupy 1 slot each in the buffer.  */
   if (regno >= tdep->ppc_gp0_regnum 
@@ -580,13 +580,13 @@ fetch_register (struct regcache *regcache, int tid, int regno)
      transfers.  */
   for (bytes_transferred = 0;
        bytes_transferred < register_size (gdbarch, regno);
-       bytes_transferred += sizeof (long))
+       bytes_transferred += sizeof (long long))
     {
-      long l;
+      long long l;
 
       errno = 0;
       l = ptrace (PTRACE_PEEKUSER, tid, (PTRACE_TYPE_ARG3) regaddr, 0);
-      regaddr += sizeof (long);
+      regaddr += sizeof (long long);
       if (errno != 0)
 	{
           char message[128];
@@ -951,7 +951,7 @@ store_register (const struct regcache *regcache, int tid, int regno)
      idea of the register's size may not be a multiple of sizeof
      (long).  */
   memset (buf, 0, sizeof buf);
-  bytes_to_transfer = align_up (register_size (gdbarch, regno), sizeof (long));
+  bytes_to_transfer = align_up (register_size (gdbarch, regno), sizeof (long long));
   if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
     {
       /* Little-endian values always sit at the left end of the buffer.  */
@@ -964,14 +964,14 @@ store_register (const struct regcache *regcache, int tid, int regno)
       regcache->raw_collect (regno, buf + padding);
     }
 
-  for (i = 0; i < bytes_to_transfer; i += sizeof (long))
+  for (i = 0; i < bytes_to_transfer; i += sizeof (long long))
     {
-      long l;
+      long long l;
 
       memcpy (&l, &buf[i], sizeof (l));
       errno = 0;
       ptrace (PTRACE_POKEUSER, tid, (PTRACE_TYPE_ARG3) regaddr, l);
-      regaddr += sizeof (long);
+      regaddr += sizeof (long long);
 
       if (errno == EIO 
           && (regno == tdep->ppc_fpscr_regnum
@@ -1174,7 +1174,7 @@ ppc_linux_get_hwcap (void)
 /* The cached DABR value, to install in new threads.
    This variable is used when the PowerPC HWDEBUG ptrace
    interface is not available.  */
-static long saved_dabr_value;
+static long long saved_dabr_value;
 
 /* Global structure that will store information about the available
    features provided by the PowerPC HWDEBUG ptrace interface.  */
@@ -1187,7 +1187,7 @@ static size_t max_slots_number = 0;
 
 struct hw_break_tuple
 {
-  long slot;
+  long long slot;
   struct ppc_hw_breakpoint *hw_break;
 };
 
@@ -1403,7 +1403,7 @@ static void
 hwdebug_insert_point (struct ppc_hw_breakpoint *b, int tid)
 {
   int i;
-  long slot;
+  long long slot;
   gdb::unique_xmalloc_ptr<ppc_hw_breakpoint> p (XDUP (ppc_hw_breakpoint, b));
   struct hw_break_tuple *hw_breaks;
   struct thread_points *t;
@@ -1885,8 +1885,8 @@ ppc_linux_nat_target::insert_watchpoint (CORE_ADDR addr, int len,
     }
   else
     {
-      long dabr_value;
-      long read_mode, write_mode;
+      long long dabr_value;
+      long long read_mode, write_mode;
 
       if (ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
 	{
@@ -2143,7 +2143,7 @@ ppc_linux_nat_target::store_registers (struct regcache *regcache, int regno)
 void
 supply_gregset (struct regcache *regcache, const gdb_gregset_t *gregsetp)
 {
-  const struct regset *regset = ppc_linux_gregset (sizeof (long));
+  const struct regset *regset = ppc_linux_gregset (sizeof (long long));
 
   ppc_supply_gregset (regset, regcache, -1, gregsetp, sizeof (*gregsetp));
 }
@@ -2152,7 +2152,7 @@ void
 fill_gregset (const struct regcache *regcache,
 	      gdb_gregset_t *gregsetp, int regno)
 {
-  const struct regset *regset = ppc_linux_gregset (sizeof (long));
+  const struct regset *regset = ppc_linux_gregset (sizeof (long long));
 
   if (regno == -1)
     memset (gregsetp, 0, sizeof (*gregsetp));
diff --git a/gdb/ppc-obsd-tdep.c b/gdb/ppc-obsd-tdep.c
index c478324..f490d0e 100644
--- a/gdb/ppc-obsd-tdep.c
+++ b/gdb/ppc-obsd-tdep.c
@@ -134,7 +134,7 @@ ppcobsd_sigtramp_frame_sniffer (const struct frame_unwind *self,
   for (offset = ppcobsd_sigreturn_offset; *offset != -1; offset++)
     {
       gdb_byte buf[2 * PPC_INSN_SIZE];
-      unsigned long insn;
+      unsigned long long insn;
 
       if (!safe_frame_unwind_memory (this_frame, start_pc + *offset,
 				     buf, sizeof buf))
@@ -166,7 +166,7 @@ ppcobsd_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)
   struct trad_frame_cache *cache;
   CORE_ADDR addr, base, func;
   gdb_byte buf[PPC_INSN_SIZE];
-  unsigned long insn, sigcontext_offset;
+  unsigned long long insn, sigcontext_offset;
   int i;
 
   if (*this_cache)
diff --git a/gdb/printcmd.c b/gdb/printcmd.c
index 3c6e4be..b6f890a 100644
--- a/gdb/printcmd.c
+++ b/gdb/printcmd.c
@@ -1365,7 +1365,7 @@ info_address_command (const char *exp, int from_tty)
   int regno;
   struct symbol *sym;
   struct bound_minimal_symbol msymbol;
-  long val;
+  long long val;
   struct obj_section *section;
   CORE_ADDR load_addr, context_pc = 0;
   struct field_of_this_result is_a_field_of_this;
@@ -2363,7 +2363,7 @@ printf_pointer (struct ui_file *stream, const char *format,
 #ifdef PRINTF_HAS_LONG_LONG
   long long val = value_as_long (value);
 #else
-  long val = value_as_long (value);
+  long long val = value_as_long (value);
 #endif
 
   fmt = (char *) alloca (strlen (format) + 5);
@@ -2533,7 +2533,7 @@ ui_printf (const char *arg, struct ui_file *stream)
 	    }
 	  case long_arg:
 	    {
-	      long val = value_as_long (val_args[i]);
+	      long long val = value_as_long (val_args[i]);
 
               fprintf_filtered (stream, current_substring, val);
 	      break;
diff --git a/gdb/proc-api.c b/gdb/proc-api.c
index 75e8055..3840ec8 100644
--- a/gdb/proc-api.c
+++ b/gdb/proc-api.c
@@ -45,7 +45,7 @@
     their symbolic names and to a string that describes their specific use.  */
 
 struct trans {
-  long value;                   /* The numeric value */
+  long long value;                   /* The numeric value */
   const char *name;             /* The equivalent symbolic value */
   const char *desc;             /* Short description of value */
 };
@@ -228,11 +228,11 @@ write_with_trace (int fd, void *varg, size_t len, char *file, int line)
 	      if (lseek_offset != -1)
 		fprintf (procfs_file ? procfs_file : stdout, 
 			 "write (<unknown>, %lud bytes at 0x%08lx) \n", 
-			 (unsigned long) len, (unsigned long) lseek_offset);
+			 (unsigned long long) len, (unsigned long long) lseek_offset);
 	      else
 		fprintf (procfs_file ? procfs_file : stdout, 
 			 "write (<unknown>, %lud bytes) \n", 
-			 (unsigned long) len);
+			 (unsigned long long) len);
 	    }
 	  break;
 	}
@@ -270,7 +270,7 @@ lseek_with_trace (int fd, off_t offset, int whence, char *file, int line)
     {
       fprintf (procfs_file ? procfs_file : stdout, 
 	       "[lseek (0x%08lx) FAILED! (%s)]\n", 
-	       (unsigned long) offset, safe_strerror (errno));
+	       (unsigned long long) offset, safe_strerror (errno));
       if (procfs_file)
 	fflush (procfs_file);
     }
@@ -396,7 +396,7 @@ procfs_note (const char *msg, const char *file, int line)
 }
 
 void
-proc_prettyfprint_status (long flags, int why, int what, int thread)
+proc_prettyfprint_status (long long flags, int why, int what, int thread)
 {
   prepare_to_trace ();
   if (procfs_trace)
diff --git a/gdb/proc-flags.c b/gdb/proc-flags.c
index 7a64c08..203a5d2 100644
--- a/gdb/proc-flags.c
+++ b/gdb/proc-flags.c
@@ -91,7 +91,7 @@ static struct trans pr_flag_table[] =
 };
 
 void
-proc_prettyfprint_flags (FILE *file, unsigned long flags, int verbose)
+proc_prettyfprint_flags (FILE *file, unsigned long long flags, int verbose)
 {
   int i;
 
@@ -107,7 +107,7 @@ proc_prettyfprint_flags (FILE *file, unsigned long flags, int verbose)
 }
 
 void
-proc_prettyprint_flags (unsigned long flags, int verbose)
+proc_prettyprint_flags (unsigned long long flags, int verbose)
 {
   proc_prettyfprint_flags (stdout, flags, verbose);
 }
diff --git a/gdb/proc-utils.h b/gdb/proc-utils.h
index aa83677..e589bcd 100644
--- a/gdb/proc-utils.h
+++ b/gdb/proc-utils.h
@@ -22,7 +22,7 @@
  * Pretty-print functions for /proc data 
  */
 
-extern void proc_prettyprint_why (unsigned long why, unsigned long what,
+extern void proc_prettyprint_why (unsigned long long why, unsigned long long what,
 				  int verbose);
 
 extern void proc_prettyprint_syscalls (sysset_t *sysset, int verbose);
@@ -50,18 +50,18 @@ extern void proc_prettyfprint_syscall (FILE *file, int num, int verbose);
 
 extern void proc_prettyfprint_signal (FILE *file, int signo, int verbose);
 
-extern void proc_prettyfprint_flags (FILE *file, unsigned long flags,
+extern void proc_prettyfprint_flags (FILE *file, unsigned long long flags,
 				     int verbose);
 
-extern void proc_prettyfprint_why (FILE *file, unsigned long why, 
-				   unsigned long what, int verbose);
+extern void proc_prettyfprint_why (FILE *file, unsigned long long why, 
+				   unsigned long long what, int verbose);
 
 extern void proc_prettyfprint_fault (FILE *file, int faultno, int verbose);
 
 extern void proc_prettyfprint_syscalls (FILE *file, sysset_t *sysset,
 					int verbose);
 
-extern void proc_prettyfprint_status (long, int, int, int);
+extern void proc_prettyfprint_status (long long, int, int, int);
 
 
 /* From proc-flags.c */
@@ -70,9 +70,9 @@ extern void proc_prettyfprint_status (long, int, int, int);
  * Pretty-print the prstatus flags.
  */
 
-extern void proc_prettyprint_flags (unsigned long flags, int verbose);
+extern void proc_prettyprint_flags (unsigned long long flags, int verbose);
 
-extern void proc_prettyfprint_flags (FILE *file, unsigned long flags,
+extern void proc_prettyfprint_flags (FILE *file, unsigned long long flags,
 				     int verbose);
 
 
@@ -84,7 +84,7 @@ extern void proc_prettyfprint_flags (FILE *file, unsigned long flags,
 
 extern  int   write_with_trace (int, void *, size_t, char *, int);
 extern  off_t lseek_with_trace (int, off_t,  int,    char *, int);
-extern  int   ioctl_with_trace (int, long, void *, char *, int);
+extern  int   ioctl_with_trace (int, long long, void *, char *, int);
 extern  pid_t wait_with_trace  (int *, char *, int);
 extern  int   open_with_trace  (char *, int, char *, int);
 extern  int   close_with_trace (int, char *, int);
@@ -115,5 +115,5 @@ extern  void  procfs_note      (const char *, const char *, int);
 #if defined (PROC_CTL_WORD_TYPE)
 typedef PROC_CTL_WORD_TYPE procfs_ctl_t;
 #else
-typedef long procfs_ctl_t;
+typedef long long procfs_ctl_t;
 #endif
diff --git a/gdb/proc-why.c b/gdb/proc-why.c
index b3a602c..6f6863d 100644
--- a/gdb/proc-why.c
+++ b/gdb/proc-why.c
@@ -60,7 +60,7 @@ static struct trans pr_why_table[] =
    lwpstatus'.  */
 
 void
-proc_prettyfprint_why (FILE *file, unsigned long why, unsigned long what,
+proc_prettyfprint_why (FILE *file, unsigned long long why, unsigned long long what,
 		       int verbose)
 {
   int i;
@@ -108,7 +108,7 @@ proc_prettyfprint_why (FILE *file, unsigned long why, unsigned long what,
 }
 
 void
-proc_prettyprint_why (unsigned long why, unsigned long what, int verbose)
+proc_prettyprint_why (unsigned long long why, unsigned long long what, int verbose)
 {
   proc_prettyfprint_why (stdout, why, what, verbose);
 }
diff --git a/gdb/procfs.c b/gdb/procfs.c
index e6c6066..bc9844c 100644
--- a/gdb/procfs.c
+++ b/gdb/procfs.c
@@ -604,7 +604,7 @@ sysset_t_alloc (procinfo *pi)
    than have a bunch of #ifdefs all thru the gdb target vector
    functions, we do our best to hide them all in here.  */
 
-static long proc_flags (procinfo *pi);
+static long long proc_flags (procinfo *pi);
 static int proc_why (procinfo *pi);
 static int proc_what (procinfo *pi);
 static int proc_set_current_signal (procinfo *pi, int signo);
@@ -683,7 +683,7 @@ proc_get_status (procinfo *pi)
 
 /* Returns the process flags (pr_flags field).  */
 
-static long
+static long long
 proc_flags (procinfo *pi)
 {
   if (!pi->status_valid)
@@ -751,14 +751,14 @@ proc_nsysarg (procinfo *pi)
 /* Returns the pr_sysarg field (pointer to the arguments of current
    syscall).  */
 
-static long *
+static long long *
 proc_sysargs (procinfo *pi)
 {
   if (!pi->status_valid)
     if (!proc_get_status (pi))
       return NULL;
 
-  return (long *) &pi->prstatus.pr_lwp.pr_sysarg;
+  return (long long *) &pi->prstatus.pr_lwp.pr_sysarg;
 }
 
 /* Set or reset any of the following process flags:
@@ -779,9 +779,9 @@ proc_sysargs (procinfo *pi)
 enum { FLAG_RESET, FLAG_SET };
 
 static int
-proc_modify_flag (procinfo *pi, long flag, long mode)
+proc_modify_flag (procinfo *pi, long long flag, long long mode)
 {
-  long win = 0;		/* default to fail */
+  long long win = 0;		/* default to fail */
 
   /* These operations affect the process as a whole, and applying them
      to an individual LWP has the same meaning as applying them to the
@@ -2349,7 +2349,7 @@ wait_again:
 		    proc_prettyprint_syscall (proc_what (pi), 0);
 		    printf_filtered ("\n");
 
-		    long i, nsysargs, *sysargs;
+		    long long i, nsysargs, *sysargs;
 
 		    if ((nsysargs = proc_nsysarg (pi)) > 0 &&
 			(sysargs  = proc_sysargs (pi)) != NULL)
@@ -2433,7 +2433,7 @@ wait_again:
 		    proc_prettyprint_syscall (proc_what (pi), 0);
 		    printf_filtered ("\n");
 
-		    long i, nsysargs, *sysargs;
+		    long long i, nsysargs, *sysargs;
 
 		    if ((nsysargs = proc_nsysarg (pi)) > 0 &&
 			(sysargs  = proc_sysargs (pi)) != NULL)
@@ -3464,7 +3464,7 @@ procfs_target::find_memory_regions (find_memory_region_ftype func, void *data)
 /* Returns an ascii representation of a memory mapping's flags.  */
 
 static char *
-mappingflags (long flags)
+mappingflags (long long flags)
 {
   static char asciiflags[8];
 
@@ -3497,16 +3497,16 @@ info_mappings_callback (struct prmap *map, find_memory_region_ftype ignore,
 
   if (gdbarch_addr_bit (target_gdbarch ()) == 32)
     printf_filtered ("\t%#10lx %#10lx %#10lx %#10x %7s\n",
-		     (unsigned long) map->pr_vaddr,
-		     (unsigned long) map->pr_vaddr + map->pr_size - 1,
-		     (unsigned long) map->pr_size,
+		     (unsigned long long) map->pr_vaddr,
+		     (unsigned long long) map->pr_vaddr + map->pr_size - 1,
+		     (unsigned long long) map->pr_size,
 		     pr_off,
 		     mappingflags (map->pr_mflags));
   else
     printf_filtered ("  %#18lx %#18lx %#10lx %#10x %7s\n",
-		     (unsigned long) map->pr_vaddr,
-		     (unsigned long) map->pr_vaddr + map->pr_size - 1,
-		     (unsigned long) map->pr_size,
+		     (unsigned long long) map->pr_vaddr,
+		     (unsigned long long) map->pr_vaddr + map->pr_size - 1,
+		     (unsigned long long) map->pr_size,
 		     pr_off,
 		     mappingflags (map->pr_mflags));
 
@@ -3762,7 +3762,7 @@ procfs_do_thread_registers (bfd *obfd, ptid_t ptid,
   struct regcache *regcache = get_thread_regcache (ptid);
   gdb_gregset_t gregs;
   gdb_fpregset_t fpregs;
-  unsigned long merged_pid;
+  unsigned long long merged_pid;
 
   merged_pid = ptid.lwp () << 16 | ptid.pid ();
 
diff --git a/gdb/progspace.h b/gdb/progspace.h
index c2cc87d..df9a29d 100644
--- a/gdb/progspace.h
+++ b/gdb/progspace.h
@@ -149,7 +149,7 @@ struct program_space
   /* The BFD handle for the main executable.  */
   bfd *ebfd = NULL;
   /* The last-modified time, from when the exec was brought in.  */
-  long ebfd_mtime = 0;
+  long long ebfd_mtime = 0;
   /* Similar to bfd_get_filename (exec_bfd) but in original form given
      by user, without symbolic links and pathname resolved.
      It needs to be freed by xfree.  It is not NULL iff EBFD is not NULL.  */
diff --git a/gdb/psymtab.c b/gdb/psymtab.c
index fa59ee2..52b0d02 100644
--- a/gdb/psymtab.c
+++ b/gdb/psymtab.c
@@ -1616,10 +1616,10 @@ end_psymtab_common (struct objfile *objfile, struct partial_symtab *pst)
    and name.  These are the values which are set by
    add_psymbol_to_bcache.  */
 
-static unsigned long
+static unsigned long long
 psymbol_hash (const void *addr, int length)
 {
-  unsigned long h = 0;
+  unsigned long long h = 0;
   struct partial_symbol *psymbol = (struct partial_symbol *) addr;
   unsigned int lang = psymbol->ginfo.language;
   unsigned int domain = PSYMBOL_DOMAIN (psymbol);
diff --git a/gdb/python/py-arch.c b/gdb/python/py-arch.c
index a1fdbd6..8c58e0d 100644
--- a/gdb/python/py-arch.c
+++ b/gdb/python/py-arch.c
@@ -120,7 +120,7 @@ archpy_disassemble (PyObject *self, PyObject *args, PyObject *kw)
   CORE_ADDR start, end = 0;
   CORE_ADDR pc;
   gdb_py_ulongest start_temp;
-  long count = 0, i;
+  long long count = 0, i;
   PyObject *end_obj = NULL, *count_obj = NULL;
   struct gdbarch *gdbarch = NULL;
 
diff --git a/gdb/python/py-breakpoint.c b/gdb/python/py-breakpoint.c
index a66e553..830fe17 100644
--- a/gdb/python/py-breakpoint.c
+++ b/gdb/python/py-breakpoint.c
@@ -190,7 +190,7 @@ static int
 bppy_set_thread (PyObject *self, PyObject *newvalue, void *closure)
 {
   gdbpy_breakpoint_object *self_bp = (gdbpy_breakpoint_object *) self;
-  long id;
+  long long id;
 
   BPPY_SET_REQUIRE_VALID (self_bp);
 
@@ -231,7 +231,7 @@ static int
 bppy_set_task (PyObject *self, PyObject *newvalue, void *closure)
 {
   gdbpy_breakpoint_object *self_bp = (gdbpy_breakpoint_object *) self;
-  long id;
+  long long id;
   int valid_id = 0;
 
   BPPY_SET_REQUIRE_VALID (self_bp);
@@ -309,7 +309,7 @@ static int
 bppy_set_ignore_count (PyObject *self, PyObject *newvalue, void *closure)
 {
   gdbpy_breakpoint_object *self_bp = (gdbpy_breakpoint_object *) self;
-  long value;
+  long long value;
 
   BPPY_SET_REQUIRE_VALID (self_bp);
 
@@ -361,7 +361,7 @@ bppy_set_hit_count (PyObject *self, PyObject *newvalue, void *closure)
     }
   else
     {
-      long value;
+      long long value;
 
       if (! gdb_py_int_as_long (newvalue, &value))
 	return -1;
diff --git a/gdb/python/py-cmd.c b/gdb/python/py-cmd.c
index 27c4689..16686e7 100644
--- a/gdb/python/py-cmd.c
+++ b/gdb/python/py-cmd.c
@@ -294,14 +294,14 @@ cmdpy_completer_handle_brkchars (struct cmd_list_element *command,
       /* User code may also return one of the completion constants,
 	 thus requesting that sort of completion.  We are only
 	 interested in this kind of return.  */
-      long value;
+      long long value;
 
       if (!gdb_py_int_as_long (resultobj.get (), &value))
 	{
 	  /* Ignore.  */
 	  PyErr_Clear ();
 	}
-      else if (value >= 0 && value < (long) N_COMPLETERS)
+      else if (value >= 0 && value < (long long) N_COMPLETERS)
 	{
 	  completer_handle_brkchars_ftype *brkchars_fn;
 
@@ -337,14 +337,14 @@ cmdpy_completer (struct cmd_list_element *command,
     {
       /* User code may also return one of the completion constants,
 	 thus requesting that sort of completion.  */
-      long value;
+      long long value;
 
       if (! gdb_py_int_as_long (resultobj.get (), &value))
 	{
 	  /* Ignore.  */
 	  PyErr_Clear ();
 	}
-      else if (value >= 0 && value < (long) N_COMPLETERS)
+      else if (value >= 0 && value < (long long) N_COMPLETERS)
 	completers[value].completer (command, tracker, text, word);
     }
   else
diff --git a/gdb/python/py-infthread.c b/gdb/python/py-infthread.c
index 36ae71b..1675cb0 100644
--- a/gdb/python/py-infthread.c
+++ b/gdb/python/py-infthread.c
@@ -259,7 +259,7 @@ PyObject *
 gdbpy_create_ptid_object (ptid_t ptid)
 {
   int pid;
-  long tid, lwp;
+  long long tid, lwp;
   PyObject *ret;
 
   ret = PyTuple_New (3);
diff --git a/gdb/python/py-lazy-string.c b/gdb/python/py-lazy-string.c
index e0138cc..f11f654 100644
--- a/gdb/python/py-lazy-string.c
+++ b/gdb/python/py-lazy-string.c
@@ -41,7 +41,7 @@ typedef struct {
      If TYPE is not an array: Then this value represents the string's length.
      In either case, if the value is -1 then the string will be fetched and
      encoded up to the first null of appropriate width.  */
-  long length;
+  long long length;
 
   /* This attribute holds the type of the string.
      For example if the lazy string was created from a C "char*" then TYPE
@@ -166,7 +166,7 @@ stpy_dealloc (PyObject *self)
    -1 is still used) or must be the length of the array.  */
 
 PyObject *
-gdbpy_create_lazy_string_object (CORE_ADDR address, long length,
+gdbpy_create_lazy_string_object (CORE_ADDR address, long long length,
 				 const char *encoding, struct type *type)
 {
   lazy_string_object *str_obj = NULL;
@@ -276,7 +276,7 @@ stpy_lazy_string_elt_type (lazy_string_object *lazy)
 void
 gdbpy_extract_lazy_string (PyObject *string, CORE_ADDR *addr,
 			   struct type **str_elt_type,
-			   long *length,
+			   long long *length,
 			   gdb::unique_xmalloc_ptr<char> *encoding)
 {
   lazy_string_object *lazy;
diff --git a/gdb/python/py-param.c b/gdb/python/py-param.c
index 0f0214b..ec526c8 100644
--- a/gdb/python/py-param.c
+++ b/gdb/python/py-param.c
@@ -230,7 +230,7 @@ set_parameter_value (parmpy_object *self, PyObject *value)
     case var_zuinteger:
     case var_zuinteger_unlimited:
       {
-	long l;
+	long long l;
 	int ok;
 
 	if (! PyInt_Check (value))
diff --git a/gdb/python/py-prettyprint.c b/gdb/python/py-prettyprint.c
index 21b1ce9..cf427b8 100644
--- a/gdb/python/py-prettyprint.c
+++ b/gdb/python/py-prettyprint.c
@@ -296,7 +296,7 @@ print_string_repr (PyObject *printer, const char *hint,
       else if (gdbpy_is_lazy_string (py_str.get ()))
 	{
 	  CORE_ADDR addr;
-	  long length;
+	  long long length;
 	  struct type *type;
 	  gdb::unique_xmalloc_ptr<char> encoding;
 	  struct value_print_options local_opts = *options;
@@ -315,7 +315,7 @@ print_string_repr (PyObject *printer, const char *hint,
 	  if (string != NULL)
 	    {
 	      char *output;
-	      long length;
+	      long long length;
 	      struct type *type;
 
 #ifdef IS_PY3K
@@ -593,7 +593,7 @@ print_children (PyObject *printer, const char *hint,
 	{
 	  CORE_ADDR addr;
 	  struct type *type;
-	  long length;
+	  long long length;
 	  gdb::unique_xmalloc_ptr<char> encoding;
 	  struct value_print_options local_opts = *options;
 
diff --git a/gdb/python/py-record-btrace.c b/gdb/python/py-record-btrace.c
index 057475e..ccde4da 100644
--- a/gdb/python/py-record-btrace.c
+++ b/gdb/python/py-record-btrace.c
@@ -719,8 +719,8 @@ recpy_bt_instruction_history (PyObject *self, void *closure)
   const recpy_record_object * const record = (recpy_record_object *) self;
   thread_info *const tinfo = record->thread;
   struct btrace_insn_iterator iterator;
-  unsigned long first = 0;
-  unsigned long last = 0;
+  unsigned long long first = 0;
+  unsigned long long last = 0;
 
    if (tinfo == NULL)
      Py_RETURN_NONE;
@@ -748,8 +748,8 @@ recpy_bt_function_call_history (PyObject *self, void *closure)
   const recpy_record_object * const record = (recpy_record_object *) self;
   thread_info *const tinfo = record->thread;
   struct btrace_call_iterator iterator;
-  unsigned long first = 0;
-  unsigned long last = 0;
+  unsigned long long first = 0;
+  unsigned long long last = 0;
 
   if (tinfo == NULL)
     Py_RETURN_NONE;
diff --git a/gdb/python/py-type.c b/gdb/python/py-type.c
index c7cad2e..cbb4532 100644
--- a/gdb/python/py-type.c
+++ b/gdb/python/py-type.c
@@ -491,7 +491,7 @@ typy_get_composite (struct type *type)
 static PyObject *
 typy_array_1 (PyObject *self, PyObject *args, int is_vector)
 {
-  long n1, n2;
+  long long n1, n2;
   PyObject *n2_obj = NULL;
   struct type *array = NULL;
   struct type *type = ((type_object *) self)->type;
diff --git a/gdb/python/py-unwind.c b/gdb/python/py-unwind.c
index 569d1f4..6d68b57 100644
--- a/gdb/python/py-unwind.c
+++ b/gdb/python/py-unwind.c
@@ -123,7 +123,7 @@ pyuw_parse_register_id (struct gdbarch *gdbarch, PyObject *pyo_reg_id,
     }
   else if (PyInt_Check (pyo_reg_id))
     {
-      long value;
+      long long value;
       if (gdb_py_int_as_long (pyo_reg_id, &value) && (int) value == value)
         {
           *reg_num = (int) value;
diff --git a/gdb/python/py-utils.c b/gdb/python/py-utils.c
index 01fd6ad..09b2474 100644
--- a/gdb/python/py-utils.c
+++ b/gdb/python/py-utils.c
@@ -299,14 +299,14 @@ PyObject *
 gdb_py_object_from_longest (LONGEST l)
 {
 #ifdef IS_PY3K
-  if (sizeof (l) > sizeof (long))
+  if (sizeof (l) > sizeof (long long))
     return PyLong_FromLongLong (l);
   return PyLong_FromLong (l);
 #else
 #ifdef HAVE_LONG_LONG		/* Defined by Python.  */
   /* If we have 'long long', and the value overflows a 'long', use a
      Python Long; otherwise use a Python Int.  */
-  if (sizeof (l) > sizeof (long)
+  if (sizeof (l) > sizeof (long long)
       && (l > PyInt_GetMax () || l < (- (LONGEST) PyInt_GetMax ()) - 1))
     return PyLong_FromLongLong (l);
 #endif
@@ -321,14 +321,14 @@ PyObject *
 gdb_py_object_from_ulongest (ULONGEST l)
 {
 #ifdef IS_PY3K
-  if (sizeof (l) > sizeof (unsigned long))
+  if (sizeof (l) > sizeof (unsigned long long))
     return PyLong_FromUnsignedLongLong (l);
   return PyLong_FromUnsignedLong (l);
 #else
 #ifdef HAVE_LONG_LONG		/* Defined by Python.  */
   /* If we have 'long long', and the value overflows a 'long', use a
      Python Long; otherwise use a Python Int.  */
-  if (sizeof (l) > sizeof (unsigned long) && l > PyInt_GetMax ())
+  if (sizeof (l) > sizeof (unsigned long long) && l > PyInt_GetMax ())
     return PyLong_FromUnsignedLongLong (l);
 #endif
 
@@ -343,7 +343,7 @@ gdb_py_object_from_ulongest (ULONGEST l)
    the value into an out parameter.  */
 
 int
-gdb_py_int_as_long (PyObject *obj, long *result)
+gdb_py_int_as_long (PyObject *obj, long long *result)
 {
   *result = PyInt_AsLong (obj);
   return ! (*result == -1 && PyErr_Occurred ());
diff --git a/gdb/python/py-value.c b/gdb/python/py-value.c
index 1b880fa..eafdf92 100644
--- a/gdb/python/py-value.c
+++ b/gdb/python/py-value.c
@@ -717,7 +717,7 @@ valpy_getitem (PyObject *self, PyObject *key)
   value_object *self_value = (value_object *) self;
   gdb::unique_xmalloc_ptr<char> field;
   struct type *base_class_type = NULL, *field_type = NULL;
-  long bitpos = -1;
+  long long bitpos = -1;
   PyObject *result = NULL;
 
   if (gdbpy_is_string (key))
@@ -1663,7 +1663,7 @@ convert_value_from_python (PyObject *obj)
 #if PY_MAJOR_VERSION == 2
       else if (PyInt_Check (obj))
 	{
-	  long l = PyInt_AsLong (obj);
+	  long long l = PyInt_AsLong (obj);
 
 	  if (! PyErr_Occurred ())
 	    value = value_from_longest (builtin_type_pyint, l);
diff --git a/gdb/python/python-internal.h b/gdb/python/python-internal.h
index c4f0e21..0b2b1b0 100644
--- a/gdb/python/python-internal.h
+++ b/gdb/python/python-internal.h
@@ -168,8 +168,8 @@ typedef unsigned PY_LONG_LONG gdb_py_ulongest;
 
 #define GDB_PY_LL_ARG "L"
 #define GDB_PY_LLU_ARG "K"
-typedef long gdb_py_longest;
-typedef unsigned long gdb_py_ulongest;
+typedef long long gdb_py_longest;
+typedef unsigned long long gdb_py_ulongest;
 #define gdb_py_long_from_longest PyLong_FromLong
 #define gdb_py_long_from_ulongest PyLong_FromUnsignedLong
 #define gdb_py_long_as_ulongest PyLong_AsUnsignedLong
@@ -177,7 +177,7 @@ typedef unsigned long gdb_py_ulongest;
 #endif /* HAVE_LONG_LONG */
 
 #if PY_VERSION_HEX < 0x03020000
-typedef long Py_hash_t;
+typedef long long Py_hash_t;
 #endif
 
 /* PyMem_RawMalloc appeared in Python 3.4.  For earlier versions, we can just
@@ -494,7 +494,7 @@ PyObject *gdbpy_selected_frame (PyObject *self, PyObject *args);
 PyObject *gdbpy_block_for_pc (PyObject *self, PyObject *args);
 PyObject *gdbpy_lookup_type (PyObject *self, PyObject *args, PyObject *kw);
 int gdbpy_is_field (PyObject *obj);
-PyObject *gdbpy_create_lazy_string_object (CORE_ADDR address, long length,
+PyObject *gdbpy_create_lazy_string_object (CORE_ADDR address, long long length,
 					   const char *encoding,
 					   struct type *type);
 PyObject *gdbpy_inferiors (PyObject *unused, PyObject *unused2);
@@ -684,7 +684,7 @@ gdb::unique_xmalloc_ptr<char> gdbpy_exception_to_string (PyObject *ptype,
 int gdbpy_is_lazy_string (PyObject *result);
 void gdbpy_extract_lazy_string (PyObject *string, CORE_ADDR *addr,
 				struct type **str_type,
-				long *length,
+				long long *length,
 				gdb::unique_xmalloc_ptr<char> *encoding);
 
 int gdbpy_is_value_object (PyObject *obj);
@@ -721,7 +721,7 @@ int get_addr_from_python (PyObject *obj, CORE_ADDR *addr)
 
 PyObject *gdb_py_object_from_longest (LONGEST l);
 PyObject *gdb_py_object_from_ulongest (ULONGEST l);
-int gdb_py_int_as_long (PyObject *, long *);
+int gdb_py_int_as_long (PyObject *, long long *);
 
 PyObject *gdb_py_generic_dict (PyObject *self, void *closure);
 
diff --git a/gdb/python/python.c b/gdb/python/python.c
index 20fc674..9adbd3c 100644
--- a/gdb/python/python.c
+++ b/gdb/python/python.c
@@ -688,7 +688,7 @@ gdbpy_rbreak (PyObject *self, PyObject *args, PyObject *kw)
 
   char *regex = NULL;
   std::vector<symbol_search> symbols;
-  unsigned long count = 0;
+  unsigned long long count = 0;
   PyObject *symtab_list = NULL;
   PyObject *minsyms_p_obj = NULL;
   int minsyms_p = 0;
@@ -1941,7 +1941,7 @@ do_finish_initialization (const struct extension_language_defn *extlang)
   if (!(sys_path && PyList_Check (sys_path)))
     {
 #ifdef IS_PY3K
-      PySys_SetPath (L"");
+      PySys_SetPath (U"");
 #else
       PySys_SetPath ("");
 #endif
diff --git a/gdb/ravenscar-thread.c b/gdb/ravenscar-thread.c
index e60fad8..6fd3b67 100644
--- a/gdb/ravenscar-thread.c
+++ b/gdb/ravenscar-thread.c
@@ -113,7 +113,7 @@ struct ravenscar_thread_target final : public target_ops
 
   const char *pid_to_str (ptid_t) override;
 
-  ptid_t get_ada_task_ptid (long lwp, long thread) override;
+  ptid_t get_ada_task_ptid (long long lwp, long long thread) override;
 
   void mourn_inferior () override;
 
@@ -569,7 +569,7 @@ ravenscar_inferior_created (struct target_ops *target, int from_tty)
 }
 
 ptid_t
-ravenscar_thread_target::get_ada_task_ptid (long lwp, long thread)
+ravenscar_thread_target::get_ada_task_ptid (long long lwp, long long thread)
 {
   return ptid_t (base_ptid.pid (), 0, thread);
 }
diff --git a/gdb/record-full.c b/gdb/record-full.c
index 4d8988d..8ad4cb8 100644
--- a/gdb/record-full.c
+++ b/gdb/record-full.c
@@ -2415,7 +2415,7 @@ record_full_restore (void)
 				    "  Reading register %d (1 "
 				    "plus %lu plus %d bytes)\n",
 				    rec->u.reg.num,
-				    (unsigned long) sizeof (regnum),
+				    (unsigned long long) sizeof (regnum),
 				    rec->u.reg.len);
 	      break;
 
@@ -2442,8 +2442,8 @@ record_full_restore (void)
 				    "%lu plus %lu plus %d bytes)\n",
 				    paddress (get_current_arch (),
 					      rec->u.mem.addr),
-				    (unsigned long) sizeof (addr),
-				    (unsigned long) sizeof (len),
+				    (unsigned long long) sizeof (addr),
+				    (unsigned long long) sizeof (len),
 				    rec->u.mem.len);
 	      break;
 
@@ -2467,8 +2467,8 @@ record_full_restore (void)
 		fprintf_unfiltered (gdb_stdlog,
 				    "  Reading record_full_end (1 + "
 				    "%lu + %lu bytes), offset == %s\n",
-				    (unsigned long) sizeof (signal),
-				    (unsigned long) sizeof (count),
+				    (unsigned long long) sizeof (signal),
+				    (unsigned long long) sizeof (count),
 				    paddress (get_current_arch (),
 					      bfd_offset));
 	      break;
@@ -2651,7 +2651,7 @@ record_full_base_target::save_record (const char *recfilename)
 				    "  Writing register %d (1 "
 				    "plus %lu plus %d bytes)\n",
 				    record_full_list->u.reg.num,
-				    (unsigned long) sizeof (regnum),
+				    (unsigned long long) sizeof (regnum),
 				    record_full_list->u.reg.len);
 
               /* Write regnum.  */
@@ -2672,8 +2672,8 @@ record_full_base_target::save_record (const char *recfilename)
 				    "%lu plus %lu plus %d bytes)\n",
 				    paddress (gdbarch,
 					      record_full_list->u.mem.addr),
-				    (unsigned long) sizeof (addr),
-				    (unsigned long) sizeof (len),
+				    (unsigned long long) sizeof (addr),
+				    (unsigned long long) sizeof (len),
 				    record_full_list->u.mem.len);
 
 	      /* Write memlen.  */
@@ -2697,8 +2697,8 @@ record_full_base_target::save_record (const char *recfilename)
 		  fprintf_unfiltered (gdb_stdlog,
 				      "  Writing record_full_end (1 + "
 				      "%lu + %lu bytes)\n", 
-				      (unsigned long) sizeof (signal),
-				      (unsigned long) sizeof (count));
+				      (unsigned long long) sizeof (signal),
+				      (unsigned long long) sizeof (count));
 		/* Write signal value.  */
 		signal = netorder32 (record_full_list->u.end.sigval);
 		bfdcore_write (obfd.get (), osec, &signal,
diff --git a/gdb/record.c b/gdb/record.c
index 2fd7782..a072ecc 100644
--- a/gdb/record.c
+++ b/gdb/record.c
@@ -144,7 +144,7 @@ record_read_memory (struct gdbarch *gdbarch,
 
   if (ret != 0)
     DEBUG ("error reading memory at addr %s len = %ld.\n",
-	   paddress (gdbarch, memaddr), (long) len);
+	   paddress (gdbarch, memaddr), (long long) len);
 
   return ret;
 }
@@ -458,7 +458,7 @@ get_context_size (const char **arg)
   if (!isdigit (*pos))
     error (_("Expected positive number, got: %s."), pos);
 
-  long result = strtol (pos, &end, 10);
+  long long result = strtol (pos, &end, 10);
   *arg = end;
   return result;
 }
diff --git a/gdb/regcache.c b/gdb/regcache.c
index f3f845a..9e6c312 100644
--- a/gdb/regcache.c
+++ b/gdb/regcache.c
@@ -50,7 +50,7 @@ struct regcache_descr
      redundant information - if the PC is constructed from two
      registers then those registers and not the PC lives in the raw
      cache.  */
-  long sizeof_raw_registers;
+  long long sizeof_raw_registers;
 
   /* The cooked register space.  Each cooked register in the range
      [0..NR_RAW_REGISTERS) is direct-mapped onto the corresponding raw
@@ -59,14 +59,14 @@ struct regcache_descr
      both raw registers and memory by the architecture methods
      gdbarch_pseudo_register_read and gdbarch_pseudo_register_write.  */
   int nr_cooked_registers;
-  long sizeof_cooked_registers;
+  long long sizeof_cooked_registers;
 
   /* Offset and size (in 8 bit bytes), of each register in the
      register cache.  All registers (including those in the range
      [NR_RAW_REGISTERS .. NR_COOKED_REGISTERS) are given an
      offset.  */
-  long *register_offset;
-  long *sizeof_register;
+  long long *register_offset;
+  long long *sizeof_register;
 
   /* Cached table containing the type of each register.  */
   struct type **register_type;
@@ -107,12 +107,12 @@ init_regcache_descr (struct gdbarch *gdbarch)
      same.  */
 
   {
-    long offset = 0;
+    long long offset = 0;
 
     descr->sizeof_register
-      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
+      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long long);
     descr->register_offset
-      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
+      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long long);
     for (i = 0; i < gdbarch_num_regs (gdbarch); i++)
       {
 	descr->sizeof_register[i] = TYPE_LENGTH (descr->register_type[i]);
@@ -1308,7 +1308,7 @@ register_dump::dump (ui_file *file)
   int footnote_nr = 0;
   int footnote_register_offset = 0;
   int footnote_register_type_name_null = 0;
-  long register_offset = 0;
+  long long register_offset = 0;
 
   gdb_assert (descr->nr_cooked_registers
 	      == (gdbarch_num_regs (m_gdbarch)
diff --git a/gdb/remote-fileio.c b/gdb/remote-fileio.c
index 313da64..7eead57 100644
--- a/gdb/remote-fileio.c
+++ b/gdb/remote-fileio.c
@@ -120,7 +120,7 @@ remote_fileio_close_target_fd (int target_fd)
 }
 
 static int
-remote_fileio_oflags_to_host (long flags)
+remote_fileio_oflags_to_host (long long flags)
 {
   int hflags = 0;
 
@@ -147,7 +147,7 @@ remote_fileio_oflags_to_host (long flags)
 }
 
 static mode_t
-remote_fileio_mode_to_host (long mode, int open_call)
+remote_fileio_mode_to_host (long long mode, int open_call)
 {
   mode_t hmode = 0;
 
@@ -192,7 +192,7 @@ remote_fileio_mode_to_host (long mode, int open_call)
 }
 
 static int
-remote_fileio_seek_flag_to_host (long num, int *flag)
+remote_fileio_seek_flag_to_host (long long num, int *flag)
 {
   if (!flag)
     return 0;
@@ -250,7 +250,7 @@ remote_fileio_extract_long (char **buf, LONGEST *retlong)
 }
 
 static int
-remote_fileio_extract_int (char **buf, long *retint)
+remote_fileio_extract_int (char **buf, long long *retint)
 {
   int ret;
   LONGEST retlong;
@@ -259,7 +259,7 @@ remote_fileio_extract_int (char **buf, long *retint)
     return -1;
   ret = remote_fileio_extract_long (buf, &retlong);
   if (!ret)
-    *retint = (long) retlong;
+    *retint = (long long) retlong;
   return ret;
 }
 
@@ -372,7 +372,7 @@ remote_fileio_func_open (remote_target *remote, char *buf)
 {
   CORE_ADDR ptrval;
   int length;
-  long num;
+  long long num;
   int flags, fd;
   mode_t mode;
   char *pathname;
@@ -439,7 +439,7 @@ remote_fileio_func_open (remote_target *remote, char *buf)
 static void
 remote_fileio_func_close (remote_target *remote, char *buf)
 {
-  long num;
+  long long num;
   int fd;
 
   /* Parameter: file descriptor */
@@ -464,7 +464,7 @@ remote_fileio_func_close (remote_target *remote, char *buf)
 static void
 remote_fileio_func_read (remote_target *remote, char *buf)
 {
-  long target_fd, num;
+  long long target_fd, num;
   LONGEST lnum;
   CORE_ADDR ptrval;
   int fd, ret;
@@ -590,7 +590,7 @@ remote_fileio_func_read (remote_target *remote, char *buf)
 static void
 remote_fileio_func_write (remote_target *remote, char *buf)
 {
-  long target_fd, num;
+  long long target_fd, num;
   LONGEST lnum;
   CORE_ADDR ptrval;
   int fd, ret;
@@ -663,7 +663,7 @@ remote_fileio_func_write (remote_target *remote, char *buf)
 static void
 remote_fileio_func_lseek (remote_target *remote, char *buf)
 {
-  long num;
+  long long num;
   LONGEST lnum;
   int fd, flag;
   off_t offset, ret;
@@ -911,7 +911,7 @@ remote_fileio_func_fstat (remote_target *remote, char *buf)
 {
   CORE_ADDR ptrval;
   int fd, ret;
-  long target_fd;
+  long long target_fd;
   LONGEST lnum;
   struct stat st;
   struct fio_stat fst;
@@ -1037,7 +1037,7 @@ remote_fileio_func_gettimeofday (remote_target *remote, char *buf)
 static void
 remote_fileio_func_isatty (remote_target *remote, char *buf)
 {
-  long target_fd;
+  long long target_fd;
   int fd;
 
   /* Parameter: file descriptor */
diff --git a/gdb/remote.c b/gdb/remote.c
index 9a5286d..c94e331 100644
--- a/gdb/remote.c
+++ b/gdb/remote.c
@@ -192,8 +192,8 @@ struct readahead_cache
 
 struct packet_reg
 {
-  long offset; /* Offset into G packet.  */
-  long regnum; /* GDB's internal register number.  */
+  long long offset; /* Offset into G packet.  */
+  long long regnum; /* GDB's internal register number.  */
   LONGEST pnum; /* Remote protocol register number.  */
   int in_g_packet; /* Always part of G packet.  */
   /* long size in bytes;  == register_size (target_gdbarch (), regnum);
@@ -207,7 +207,7 @@ struct remote_arch_state
   explicit remote_arch_state (struct gdbarch *gdbarch);
 
   /* Description of the remote protocol registers.  */
-  long sizeof_g_packet;
+  long long sizeof_g_packet;
 
   /* Description of the remote protocol registers indexed by REGNUM
      (making an array gdbarch_num_regs in size).  */
@@ -219,11 +219,11 @@ struct remote_arch_state
      typically only reserve a buffer large enough to hold the ``g''
      packet.  The size does not include packet overhead (headers and
      trailers).  */
-  long actual_register_packet_size;
+  long long actual_register_packet_size;
 
   /* This is the maximum size (in chars) of a non read/write packet.
      It is also used as a cap on the size of read/write packets.  */
-  long remote_packet_size;
+  long long remote_packet_size;
 };
 
 /* Description of the remote protocol state for the currently
@@ -249,7 +249,7 @@ public: /* data */
      REMOTE_PACKET_SIZE should be used to limit the length of outgoing
      packets.  */
   char *buf;
-  long buf_size;
+  long long buf_size;
 
   /* True if we're going through initial connection setup (finding out
      about the remote side's threads, relocating symbols, etc.).  */
@@ -259,7 +259,7 @@ public: /* data */
      heuristics for the largest packet size that will not overflow
      a buffer in the stub), this will be set to that packet size.
      Otherwise zero, meaning to use the guessed size.  */
-  long explicit_packet_size = 0;
+  long long explicit_packet_size = 0;
 
   /* remote_wait is normally called when the target is running and
      waits for a stop reply packet.  But sometimes we need to call it
@@ -493,7 +493,7 @@ public:
 
   const char *extra_thread_info (struct thread_info *) override;
 
-  ptid_t get_ada_task_ptid (long lwp, long thread) override;
+  ptid_t get_ada_task_ptid (long long lwp, long long thread) override;
 
   thread_info *thread_handle_to_thread_info (const gdb_byte *thread_handle,
 					     int handle_len,
@@ -727,11 +727,11 @@ public: /* Remote specific methods.  */
 
   struct remote_state *get_remote_state ();
 
-  long get_remote_packet_size (void);
-  long get_memory_packet_size (struct memory_packet_config *config);
+  long long get_remote_packet_size (void);
+  long long get_memory_packet_size (struct memory_packet_config *config);
 
-  long get_memory_write_packet_size ();
-  long get_memory_read_packet_size ();
+  long long get_memory_write_packet_size ();
+  long long get_memory_read_packet_size ();
 
   char *append_pending_thread_resumptions (char *p, char *endp,
 					   ptid_t ptid);
@@ -902,12 +902,12 @@ public: /* Remote specific methods.  */
   int putpkt_binary (const char *buf, int cnt);
 
   void skip_frame ();
-  long read_frame (char **buf_p, long *sizeof_buf);
-  void getpkt (char **buf, long *sizeof_buf, int forever);
-  int getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf, int forever,
+  long long read_frame (char **buf_p, long long *sizeof_buf);
+  void getpkt (char **buf, long long *sizeof_buf, int forever);
+  int getpkt_or_notif_sane_1 (char **buf, long long *sizeof_buf, int forever,
 			      int expecting_notif, int *is_notif);
-  int getpkt_sane (char **buf, long *sizeof_buf, int forever);
-  int getpkt_or_notif_sane (char **buf, long *sizeof_buf, int forever,
+  int getpkt_sane (char **buf, long long *sizeof_buf, int forever);
+  int getpkt_or_notif_sane (char **buf, long long *sizeof_buf, int forever,
 			    int *is_notif);
   int remote_vkill (int pid);
   void remote_kill_k ();
@@ -1434,7 +1434,7 @@ get_current_remote_target ()
 /* Return the current allowed size of a remote packet.  This is
    inferred from the current architecture, and should be used to
    limit the length of outgoing packets.  */
-long
+long long
 remote_target::get_remote_packet_size ()
 {
   struct remote_state *rs = get_remote_state ();
@@ -1448,7 +1448,7 @@ remote_target::get_remote_packet_size ()
 
 static struct packet_reg *
 packet_reg_from_regnum (struct gdbarch *gdbarch, struct remote_arch_state *rsa,
-			long regnum)
+			long long regnum)
 {
   if (regnum < 0 && regnum >= gdbarch_num_regs (gdbarch))
     return NULL;
@@ -1572,7 +1572,7 @@ static unsigned int remote_address_size;
 struct memory_packet_config
 {
   const char *name;
-  long size;
+  long long size;
   int fixed_p;
 };
 
@@ -1588,7 +1588,7 @@ struct memory_packet_config
 
 /* Get the memory packet size, assuming it is fixed.  */
 
-static long
+static long long
 get_fixed_memory_packet_size (struct memory_packet_config *config)
 {
   gdb_assert (config->fixed_p);
@@ -1602,13 +1602,13 @@ get_fixed_memory_packet_size (struct memory_packet_config *config)
 /* Compute the current size of a read/write packet.  Since this makes
    use of ``actual_register_packet_size'' the computation is dynamic.  */
 
-long
+long long
 remote_target::get_memory_packet_size (struct memory_packet_config *config)
 {
   struct remote_state *rs = get_remote_state ();
   remote_arch_state *rsa = rs->get_remote_arch_state (target_gdbarch ());
 
-  long what_they_get;
+  long long what_they_get;
   if (config->fixed_p)
     what_they_get = get_fixed_memory_packet_size (config);
   else
@@ -1647,7 +1647,7 @@ static void
 set_memory_packet_size (const char *args, struct memory_packet_config *config)
 {
   int fixed_p = config->fixed_p;
-  long size = config->size;
+  long long size = config->size;
 
   if (args == NULL)
     error (_("Argument required (integer, `fixed' or `limited')."));
@@ -1674,7 +1674,7 @@ set_memory_packet_size (const char *args, struct memory_packet_config *config)
   if (fixed_p && !config->fixed_p)
     {
       /* So that the query shows the correct value.  */
-      long query_size = (size <= 0
+      long long query_size = (size <= 0
 			 ? DEFAULT_MAX_MEMORY_PACKET_SIZE_FIXED
 			 : size);
 
@@ -1728,7 +1728,7 @@ show_memory_write_packet_size (const char *args, int from_tty)
   show_memory_packet_size (&memory_write_packet_config);
 }
 
-long
+long long
 remote_target::get_memory_write_packet_size ()
 {
   return get_memory_packet_size (&memory_write_packet_config);
@@ -1751,10 +1751,10 @@ show_memory_read_packet_size (const char *args, int from_tty)
   show_memory_packet_size (&memory_read_packet_config);
 }
 
-long
+long long
 remote_target::get_memory_read_packet_size ()
 {
-  long size = get_memory_packet_size (&memory_read_packet_config);
+  long long size = get_memory_packet_size (&memory_read_packet_config);
 
   /* FIXME: cagney/1999-11-07: Functions like getpkt() need to get an
      extra buffer size argument before the memory read size can be
@@ -3970,7 +3970,7 @@ remote_target::static_tracepoint_markers_by_strid (const char *strid)
 /* Implement the to_get_ada_task_ptid function for the remote targets.  */
 
 ptid_t
-remote_target::get_ada_task_ptid (long lwp, long thread)
+remote_target::get_ada_task_ptid (long long lwp, long long thread)
 {
   return ptid_t (inferior_ptid.pid (), lwp, 0);
 }
@@ -4871,7 +4871,7 @@ remote_target::remote_check_symbols ()
 {
   char *msg, *reply, *tmp;
   int end;
-  long reply_size;
+  long long reply_size;
   struct cleanup *old_chain;
 
   /* The remote side has no concept of inferiors that aren't running
@@ -8050,12 +8050,12 @@ remote_target::process_g_packet (struct regcache *regcache)
      the 'p' packet must be used.  */
   if (buf_len < 2 * rsa->sizeof_g_packet)
     {
-      long sizeof_g_packet = buf_len / 2;
+      long long sizeof_g_packet = buf_len / 2;
 
       for (i = 0; i < gdbarch_num_regs (gdbarch); i++)
 	{
-	  long offset = rsa->regs[i].offset;
-	  long reg_size = register_size (gdbarch, i);
+	  long long offset = rsa->regs[i].offset;
+	  long long reg_size = register_size (gdbarch, i);
 
 	  if (rsa->regs[i].pnum == -1)
 	    continue;
@@ -8104,7 +8104,7 @@ remote_target::process_g_packet (struct regcache *regcache)
   for (i = 0; i < gdbarch_num_regs (gdbarch); i++)
     {
       struct packet_reg *r = &rsa->regs[i];
-      long reg_size = register_size (gdbarch, i);
+      long long reg_size = register_size (gdbarch, i);
 
       if (r->in_g_packet)
 	{
@@ -9370,11 +9370,11 @@ remote_target::skip_frame ()
    trailing NULL) on success. (could be extended to return one of the
    SERIAL status indications).  */
 
-long
-remote_target::read_frame (char **buf_p, long *sizeof_buf)
+long long
+remote_target::read_frame (char **buf_p, long long *sizeof_buf)
 {
   unsigned char csum;
-  long bc;
+  long long bc;
   int c;
   char *buf = *buf_p;
   struct remote_state *rs = get_remote_state ();
@@ -9503,7 +9503,7 @@ remote_target::read_frame (char **buf_p, long *sizeof_buf)
    thing to do it for those.  */
 
 void
-remote_target::getpkt (char **buf, long *sizeof_buf, int forever)
+remote_target::getpkt (char **buf, long long *sizeof_buf, int forever)
 {
   getpkt_sane (buf, sizeof_buf, forever);
 }
@@ -9522,7 +9522,7 @@ remote_target::getpkt (char **buf, long *sizeof_buf, int forever)
    (a regular packet).  */
 
 int
-remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,
+remote_target::getpkt_or_notif_sane_1 (char **buf, long long *sizeof_buf,
 				       int forever, int expecting_notif,
 				       int *is_notif)
 {
@@ -9664,13 +9664,13 @@ remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,
 }
 
 int
-remote_target::getpkt_sane (char **buf, long *sizeof_buf, int forever)
+remote_target::getpkt_sane (char **buf, long long *sizeof_buf, int forever)
 {
   return getpkt_or_notif_sane_1 (buf, sizeof_buf, forever, 0, NULL);
 }
 
 int
-remote_target::getpkt_or_notif_sane (char **buf, long *sizeof_buf, int forever,
+remote_target::getpkt_or_notif_sane (char **buf, long long *sizeof_buf, int forever,
 				     int *is_notif)
 {
   return getpkt_or_notif_sane_1 (buf, sizeof_buf, forever, 1,
@@ -10624,7 +10624,7 @@ int
 remote_target::verify_memory (const gdb_byte *data, CORE_ADDR lma, ULONGEST size)
 {
   struct remote_state *rs = get_remote_state ();
-  unsigned long host_crc, target_crc;
+  unsigned long long host_crc, target_crc;
   char *tmp;
 
   /* It doesn't make sense to use qCRC if the remote target is
@@ -10638,7 +10638,7 @@ remote_target::verify_memory (const gdb_byte *data, CORE_ADDR lma, ULONGEST size
 
       /* FIXME: assumes lma can fit into long.  */
       xsnprintf (rs->buf, get_remote_packet_size (), "qCRC:%lx,%lx",
-		 (long) lma, (long) size);
+		 (long long) lma, (long long) size);
       putpkt (rs->buf);
 
       /* Be clever; compute the host_crc before waiting for target
diff --git a/gdb/remote.h b/gdb/remote.h
index 82c3736..060d398 100644
--- a/gdb/remote.h
+++ b/gdb/remote.h
@@ -31,7 +31,7 @@ struct remote_target;
    for a target that is is executing user code to stop.  */
 
 extern void getpkt (remote_target *remote,
-		    char **buf, long *sizeof_buf, int forever);
+		    char **buf, long long *sizeof_buf, int forever);
 
 /* Send a packet to the remote machine, with error checking.  The data
    of the packet is in BUF.  The string in BUF can be at most PBUFSIZ
diff --git a/gdb/reverse.c b/gdb/reverse.c
index bd9cd20..ac4536f 100644
--- a/gdb/reverse.c
+++ b/gdb/reverse.c
@@ -233,7 +233,7 @@ static void
 goto_bookmark_command (const char *args, int from_tty)
 {
   struct bookmark *b;
-  unsigned long num;
+  unsigned long long num;
   const char *p = args;
 
   if (args == NULL || args[0] == '\0')
diff --git a/gdb/riscv-tdep.c b/gdb/riscv-tdep.c
index 4c68ef7..5952b09 100644
--- a/gdb/riscv-tdep.c
+++ b/gdb/riscv-tdep.c
@@ -66,7 +66,7 @@ struct riscv_inferior_data * riscv_inferior_data (struct inferior *const inf);
 /* Define a series of is_XXX_insn functions to check if the value INSN
    is an instance of instruction XXX.  */
 #define DECLARE_INSN(INSN_NAME, INSN_MATCH, INSN_MASK) \
-static inline bool is_ ## INSN_NAME ## _insn (long insn) \
+static inline bool is_ ## INSN_NAME ## _insn (long long insn) \
 { \
   return (insn & INSN_MASK) == INSN_MATCH; \
 }
@@ -940,7 +940,7 @@ public:
 private:
 
   /* Extract 5 bit register field at OFFSET from instruction OPCODE.  */
-  int decode_register_index (unsigned long opcode, int offset)
+  int decode_register_index (unsigned long long opcode, int offset)
   {
     return (opcode >> offset) & 0x1F;
   }
@@ -1142,7 +1142,7 @@ riscv_scan_prologue (struct gdbarch *gdbarch,
 		     CORE_ADDR start_pc, CORE_ADDR limit_pc)
 {
   CORE_ADDR cur_pc, next_pc;
-  long frame_offset = 0;
+  long long frame_offset = 0;
   CORE_ADDR end_prologue_addr = 0;
 
   if (limit_pc > start_pc + 200)
diff --git a/gdb/rs6000-nat.c b/gdb/rs6000-nat.c
index ad411f9..39f49a9 100644
--- a/gdb/rs6000-nat.c
+++ b/gdb/rs6000-nat.c
@@ -556,7 +556,7 @@ rs6000_nat_target::create_inferior (const char *exec_file,
 				    char **env, int from_tty)
 {
   enum bfd_architecture arch;
-  unsigned long mach;
+  unsigned long long mach;
   bfd abfd;
   struct gdbarch_info info;
 
@@ -618,7 +618,7 @@ rs6000_ptrace_ldinfo (ptid_t ptid)
   while (1)
     {
       if (ARCH64 ())
-	rc = rs6000_ptrace64 (PT_LDINFO, pid, (unsigned long) ldi.data (),
+	rc = rs6000_ptrace64 (PT_LDINFO, pid, (unsigned long long) ldi.data (),
 			      ldi.size (), NULL);
       else
 	rc = rs6000_ptrace32 (PT_LDINFO, pid, (int *) ldi.data (),
diff --git a/gdb/rs6000-tdep.c b/gdb/rs6000-tdep.c
index 45bf982..1bddc28 100644
--- a/gdb/rs6000-tdep.c
+++ b/gdb/rs6000-tdep.c
@@ -655,7 +655,7 @@ ppc_collect_fpregset (const struct regset *regset,
 }
 
 static int
-insn_changes_sp_or_jumps (unsigned long insn)
+insn_changes_sp_or_jumps (unsigned long long insn)
 {
   int opcode = (insn >> 26) & 0x03f;
   int sd = (insn >> 21) & 0x01f;
@@ -714,7 +714,7 @@ rs6000_in_function_epilogue_frame_p (struct frame_info *curfrm,
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   bfd_byte insn_buf[PPC_INSN_SIZE];
   CORE_ADDR scan_pc, func_start, func_end, epilogue_start, epilogue_end;
-  unsigned long insn;
+  unsigned long long insn;
 
   /* Find the search limits based on function boundaries and hard limit.  */
 
@@ -1079,7 +1079,7 @@ static int max_skip_non_prologue_insns = 10;
    Frame Pointer.  */
 
 static int
-store_param_on_stack_p (unsigned long op, int framep, int *r0_contains_arg)
+store_param_on_stack_p (unsigned long long op, int framep, int *r0_contains_arg)
 {
   /* Move parameters from argument registers to temporary register.  */
   if ((op & 0xfc0007fe) == 0x7c000378)         /* mr(.)  Rx,Ry */
@@ -1182,8 +1182,8 @@ bl_to_blrl_insn_p (CORE_ADDR pc, int insn, enum bfd_endian byte_order)
    Return false otherwise.
    */
 static bool
-store_insn_p (unsigned long op, unsigned long rs,
-	      unsigned long ra, bool with_update)
+store_insn_p (unsigned long long op, unsigned long long rs,
+	      unsigned long long ra, bool with_update)
 {
   rs = rs << 21;
   ra = ra << 16;
@@ -1220,12 +1220,12 @@ store_insn_p (unsigned long op, unsigned long rs,
 #define BL_INSTRUCTION 0x48000001
 #define BL_DISPLACEMENT_MASK 0x03fffffc
 
-static unsigned long
+static unsigned long long
 rs6000_fetch_instruction (struct gdbarch *gdbarch, const CORE_ADDR pc)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   gdb_byte buf[4];
-  unsigned long op;
+  unsigned long long op;
 
   /* Fetch the instruction and convert it to an integer.  */
   if (target_read_memory (pc, buf, 4))
@@ -1244,7 +1244,7 @@ static CORE_ADDR
 rs6000_skip_stack_check (struct gdbarch *gdbarch, const CORE_ADDR start_pc)
 {
   CORE_ADDR pc = start_pc;
-  unsigned long op = rs6000_fetch_instruction (gdbarch, pc);
+  unsigned long long op = rs6000_fetch_instruction (gdbarch, pc);
 
   /* First possible sequence: A small number of probes.
          stw 0, -<some immediate>(1)
@@ -1430,15 +1430,15 @@ skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc, CORE_ADDR lim_pc,
   CORE_ADDR last_prologue_pc = pc;
   CORE_ADDR li_found_pc = 0;
   gdb_byte buf[4];
-  unsigned long op;
-  long offset = 0;
-  long alloca_reg_offset = 0;
-  long vr_saved_offset = 0;
+  unsigned long long op;
+  long long offset = 0;
+  long long alloca_reg_offset = 0;
+  long long vr_saved_offset = 0;
   int lr_reg = -1;
   int cr_reg = -1;
   int vr_reg = -1;
   int ev_reg = -1;
-  long ev_offset = 0;
+  long long ev_offset = 0;
   int vrsave_reg = -1;
   int reg;
   int framep = 0;
@@ -1742,7 +1742,7 @@ skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc, CORE_ADDR lim_pc,
       else if ((op & 0xfc0007fe) == 0x7c000378 &&	/* mr(.)  Rx,Ry */
                (((op >> 21) & 31) >= 3) &&              /* R3 >= Ry >= R10 */
                (((op >> 21) & 31) <= 10) &&
-               ((long) ((op >> 16) & 31)
+               ((long long) ((op >> 16) & 31)
 		>= fdata->saved_gpr)) /* Rx: local var reg */
 	{
 	  continue;
@@ -2079,7 +2079,7 @@ rs6000_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   gdb_byte buf[4];
-  unsigned long op;
+  unsigned long long op;
 
   if (target_read_memory (pc, buf, 4))
     return pc;
@@ -3020,7 +3020,7 @@ struct variant
     enum bfd_architecture arch;
 
     /* bfd_arch_info.mach corresponding to variant.  */
-    unsigned long mach;
+    unsigned long long mach;
 
     /* Target description for this variant.  */
     struct target_desc **tdesc;
@@ -3086,7 +3086,7 @@ static struct variant variants[] =
    MACH.  If no such variant exists, return null.  */
 
 static const struct variant *
-find_variant_by_arch (enum bfd_architecture arch, unsigned long mach)
+find_variant_by_arch (enum bfd_architecture arch, unsigned long long mach)
 {
   const struct variant *v;
 
@@ -5809,7 +5809,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   struct gdbarch_tdep *tdep;
   int wordsize, from_xcoff_exec, from_elf_exec;
   enum bfd_architecture arch;
-  unsigned long mach;
+  unsigned long long mach;
   bfd abfd;
   enum auto_boolean soft_float_flag = powerpc_soft_float_global;
   int soft_float;
diff --git a/gdb/s390-linux-nat.c b/gdb/s390-linux-nat.c
index 2c60562..8875cd9 100644
--- a/gdb/s390-linux-nat.c
+++ b/gdb/s390-linux-nat.c
@@ -276,7 +276,7 @@ fetch_regs (struct regcache *regcache, int tid)
   parea.len = sizeof (regs);
   parea.process_addr = (addr_t) &regs;
   parea.kernel_addr = offsetof (struct user_regs_struct, psw);
-  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long) &parea, 0) < 0)
+  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long long) &parea, 0) < 0)
     perror_with_name (_("Couldn't get registers"));
 
   supply_gregset (regcache, (const gregset_t *) &regs);
@@ -293,12 +293,12 @@ store_regs (const struct regcache *regcache, int tid, int regnum)
   parea.len = sizeof (regs);
   parea.process_addr = (addr_t) &regs;
   parea.kernel_addr = offsetof (struct user_regs_struct, psw);
-  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long) &parea, 0) < 0)
+  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long long) &parea, 0) < 0)
     perror_with_name (_("Couldn't get registers"));
 
   fill_gregset (regcache, &regs, regnum);
 
-  if (ptrace (PTRACE_POKEUSR_AREA, tid, (long) &parea, 0) < 0)
+  if (ptrace (PTRACE_POKEUSR_AREA, tid, (long long) &parea, 0) < 0)
     perror_with_name (_("Couldn't write registers"));
 }
 
@@ -313,7 +313,7 @@ fetch_fpregs (struct regcache *regcache, int tid)
   parea.len = sizeof (fpregs);
   parea.process_addr = (addr_t) &fpregs;
   parea.kernel_addr = offsetof (struct user_regs_struct, fp_regs);
-  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long) &parea, 0) < 0)
+  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long long) &parea, 0) < 0)
     perror_with_name (_("Couldn't get floating point status"));
 
   supply_fpregset (regcache, (const fpregset_t *) &fpregs);
@@ -330,12 +330,12 @@ store_fpregs (const struct regcache *regcache, int tid, int regnum)
   parea.len = sizeof (fpregs);
   parea.process_addr = (addr_t) &fpregs;
   parea.kernel_addr = offsetof (struct user_regs_struct, fp_regs);
-  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long) &parea, 0) < 0)
+  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long long) &parea, 0) < 0)
     perror_with_name (_("Couldn't get floating point status"));
 
   fill_fpregset (regcache, &fpregs, regnum);
 
-  if (ptrace (PTRACE_POKEUSR_AREA, tid, (long) &parea, 0) < 0)
+  if (ptrace (PTRACE_POKEUSR_AREA, tid, (long long) &parea, 0) < 0)
     perror_with_name (_("Couldn't write floating point status"));
 }
 
@@ -353,7 +353,7 @@ fetch_regset (struct regcache *regcache, int tid,
   iov.iov_base = buf;
   iov.iov_len = regsize;
 
-  if (ptrace (PTRACE_GETREGSET, tid, (long) regset_id, (long) &iov) < 0)
+  if (ptrace (PTRACE_GETREGSET, tid, (long long) regset_id, (long long) &iov) < 0)
     {
       if (errno == ENODATA)
 	regcache_supply_regset (regset, regcache, -1, NULL, regsize);
@@ -377,12 +377,12 @@ store_regset (struct regcache *regcache, int tid,
   iov.iov_base = buf;
   iov.iov_len = regsize;
 
-  if (ptrace (PTRACE_GETREGSET, tid, (long) regset_id, (long) &iov) < 0)
+  if (ptrace (PTRACE_GETREGSET, tid, (long long) regset_id, (long long) &iov) < 0)
     perror_with_name (_("Couldn't get register set"));
 
   regcache_collect_regset (regset, regcache, -1, buf, regsize);
 
-  if (ptrace (PTRACE_SETREGSET, tid, (long) regset_id, (long) &iov) < 0)
+  if (ptrace (PTRACE_SETREGSET, tid, (long long) regset_id, (long long) &iov) < 0)
     perror_with_name (_("Couldn't set register set"));
 }
 
@@ -397,7 +397,7 @@ check_regset (int tid, int regset, int regsize)
   iov.iov_base = buf;
   iov.iov_len = regsize;
 
-  if (ptrace (PTRACE_GETREGSET, tid, (long) regset, (long) &iov) >= 0
+  if (ptrace (PTRACE_GETREGSET, tid, (long long) regset, (long long) &iov) >= 0
       || errno == ENODATA)
     return 1;
   return 0;
@@ -965,10 +965,10 @@ s390_target_wordsize (void)
   /* Check for 64-bit inferior process.  This is the case when the host is
      64-bit, and in addition bit 32 of the PSW mask is set.  */
 #ifdef __s390x__
-  long pswm;
+  long long pswm;
 
   errno = 0;
-  pswm = (long) ptrace (PTRACE_PEEKUSER, s390_inferior_tid (), PT_PSWMASK, 0);
+  pswm = (long long) ptrace (PTRACE_PEEKUSER, s390_inferior_tid (), PT_PSWMASK, 0);
   if (errno == 0 && (pswm & 0x100000000ul) != 0)
     wordsize = 8;
 #endif
diff --git a/gdb/ser-go32.c b/gdb/ser-go32.c
index 8dd1bba..e0e45a1 100644
--- a/gdb/ser-go32.c
+++ b/gdb/ser-go32.c
@@ -127,7 +127,7 @@
 #include <dos.h>
 #include <go32.h>
 #include <dpmi.h>
-typedef unsigned long u_long;
+typedef unsigned long long u_long;
 
 /* 16550 rx fifo trigger point */
 #define FIFO_TRIGGER	FIFO_TRIGGER_4
@@ -627,7 +627,7 @@ static int
 dos_readchar (struct serial *scb, int timeout)
 {
   struct dos_ttystate *port = &ports[scb->fd];
-  long then;
+  long long then;
   int c;
 
   then = rawclock () + (timeout * RAWHZ);
@@ -712,7 +712,7 @@ dos_print_tty_state (struct serial *scb, serial_ttystate ttystate,
 static int
 dos_baudconv (int rate)
 {
-  long x, err;
+  long long x, err;
 
   if (rate <= 0)
     return -1;
@@ -796,7 +796,7 @@ dos_write (struct serial *scb, const void *buf, size_t count)
 {
   volatile struct dos_ttystate *port = &ports[scb->fd];
   size_t fifosize = port->fifo ? 16 : 1;
-  long then;
+  long long then;
   size_t cnt;
   const char *str = (const char *) buf;
 
@@ -840,7 +840,7 @@ dos_sendbreak (struct serial *scb)
 {
   volatile struct dos_ttystate *port = &ports[scb->fd];
   unsigned char cfcr;
-  long then;
+  long long then;
 
   cfcr = inb (port, com_cfcr);
   outb (port, com_cfcr, cfcr | CFCR_SBREAK);
@@ -898,7 +898,7 @@ info_serial_command (const char *arg, int from_tty)
     {
       if (port->baudrate == 0)
 	continue;
-      printf_filtered ("Port:\tCOM%ld (%sactive)\n", (long)(port - ports) + 1,
+      printf_filtered ("Port:\tCOM%ld (%sactive)\n", (long long)(port - ports) + 1,
 		       port->intrupt ? "" : "not ");
       printf_filtered ("Addr:\t0x%03x (irq %d)\n", port->base, port->irq);
       printf_filtered ("16550:\t%s\n", port->fifo ? "yes" : "no");
@@ -911,7 +911,7 @@ info_serial_command (const char *arg, int from_tty)
   printf_filtered ("\nTotal interrupts: %d\n", intrcnt);
   for (i = 0; i < NCNT; i++)
     if (cnts[i])
-      printf_filtered ("%s:\t%lu\n", cntnames[i], (unsigned long) cnts[i]);
+      printf_filtered ("%s:\t%lu\n", cntnames[i], (unsigned long long) cnts[i]);
 #endif
 }
 
diff --git a/gdb/ser-mingw.c b/gdb/ser-mingw.c
index 605a071..c397b6c 100644
--- a/gdb/ser-mingw.c
+++ b/gdb/ser-mingw.c
@@ -1070,9 +1070,9 @@ static int
 net_windows_socket_check_pending (struct serial *scb)
 {
   struct net_windows_state *state = (struct net_windows_state *) scb->state;
-  unsigned long available;
+  unsigned long long available;
 
-  if (ioctlsocket (scb->fd, FIONREAD, &available) != 0)
+  if (ioctlsocket (scb->fd, FIONREAD, (u_long*)&available) != 0)
     {
       /* The socket closed, or some other error.  */
       SetEvent (state->base.except_event);
diff --git a/gdb/sol-thread.c b/gdb/sol-thread.c
index a5980f1..e71d3e5 100644
--- a/gdb/sol-thread.c
+++ b/gdb/sol-thread.c
@@ -89,7 +89,7 @@ public:
   void resume (ptid_t, int, enum gdb_signal) override;
   void mourn_inferior () override;
   const char *pid_to_str (ptid_t) override;
-  ptid_t get_ada_task_ptid (long lwp, long thread) override;
+  ptid_t get_ada_task_ptid (long long lwp, long long thread) override;
 
   void fetch_registers (struct regcache *, int) override;
   void store_registers (struct regcache *, int) override;
@@ -1155,7 +1155,7 @@ info_solthreads (const char *args, int from_tty)
 static int
 thread_db_find_thread_from_tid (struct thread_info *thread, void *data)
 {
-  long *tid = (long *) data;
+  long long *tid = (long long *) data;
 
   if (thread->ptid.tid () == *tid)
     return 1;
@@ -1164,7 +1164,7 @@ thread_db_find_thread_from_tid (struct thread_info *thread, void *data)
 }
 
 ptid_t
-sol_thread_target::get_ada_task_ptid (long lwp, long thread)
+sol_thread_target::get_ada_task_ptid (long long lwp, long long thread)
 {
   struct thread_info *thread_info =
     iterate_over_threads (thread_db_find_thread_from_tid, &thread);
diff --git a/gdb/solib-darwin.c b/gdb/solib-darwin.c
index ed8e0c1..00a35bc 100644
--- a/gdb/solib-darwin.c
+++ b/gdb/solib-darwin.c
@@ -48,7 +48,7 @@ struct gdb_dyld_image_info
   /* Image file path.  */
   CORE_ADDR file_path;
   /* st.m_time of image file.  */
-  unsigned long mtime;
+  unsigned long long mtime;
 };
 
 /* Content of inferior dyld_all_image_infos structure.
@@ -164,7 +164,7 @@ struct lm_info_darwin : public lm_info_base
 static CORE_ADDR
 lookup_symbol_from_bfd (bfd *abfd, const char *symname)
 {
-  long storage_needed;
+  long long storage_needed;
   asymbol **symbol_table;
   unsigned int number_of_symbols;
   unsigned int i;
@@ -260,7 +260,7 @@ darwin_current_sos (void)
       CORE_ADDR load_addr;
       CORE_ADDR path_addr;
       struct mach_o_header_external hdr;
-      unsigned long hdr_val;
+      unsigned long long hdr_val;
       gdb::unique_xmalloc_ptr<char> file_path;
       int errcode;
 
@@ -319,7 +319,7 @@ darwin_validate_exec_header (CORE_ADDR load_addr)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
   struct mach_o_header_external hdr;
-  unsigned long hdr_val;
+  unsigned long long hdr_val;
 
   /* Read Mach-O header from memory.  */
   if (target_read_memory (load_addr, (gdb_byte *) &hdr, sizeof (hdr) - 4))
diff --git a/gdb/solib-dsbt.c b/gdb/solib-dsbt.c
index 4f75526..567969e 100644
--- a/gdb/solib-dsbt.c
+++ b/gdb/solib-dsbt.c
@@ -81,7 +81,7 @@ struct int_elf32_dsbt_loadseg
   /* VMA recorded in the program header.  */
   CORE_ADDR p_vaddr;
   /* Size of this segment in memory.  */
-  long p_memsz;
+  long long p_memsz;
 };
 
 struct int_elf32_dsbt_loadmap
@@ -414,7 +414,7 @@ static int
 scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)
 {
   int arch_size, step, sect_size;
-  long dyn_tag;
+  long long dyn_tag;
   CORE_ADDR dyn_ptr, dyn_addr;
   gdb_byte *bufend, *bufstart, *buf;
   Elf32_External_Dyn *x_dynp_32;
diff --git a/gdb/solib-frv.c b/gdb/solib-frv.c
index 6ebc6d4..631b5fd 100644
--- a/gdb/solib-frv.c
+++ b/gdb/solib-frv.c
@@ -75,7 +75,7 @@ struct int_elf32_fdpic_loadseg
   /* VMA recorded in the program header.  */
   CORE_ADDR p_vaddr;
   /* Size of this segment in memory.  */
-  long p_memsz;
+  long long p_memsz;
 };
 
 struct int_elf32_fdpic_loadmap {
@@ -1021,7 +1021,7 @@ find_canonical_descriptor_in_load_object
      for more information.)  */
   if (lm->dyn_syms == NULL)
     {
-      long storage_needed;
+      long long storage_needed;
       unsigned int number_of_symbols;
 
       /* Determine amount of space needed to hold the dynamic symbol table.  */
@@ -1044,7 +1044,7 @@ find_canonical_descriptor_in_load_object
   /* Fetch the dynamic relocations if not already cached.  */
   if (lm->dyn_relocs == NULL)
     {
-      long storage_needed;
+      long long storage_needed;
 
       /* Determine amount of space needed to hold the dynamic relocs.  */
       storage_needed = bfd_get_dynamic_reloc_upper_bound (abfd);
diff --git a/gdb/solib-svr4.c b/gdb/solib-svr4.c
index 6f48c68..d0548f3 100644
--- a/gdb/solib-svr4.c
+++ b/gdb/solib-svr4.c
@@ -597,7 +597,7 @@ scan_dyntag (const int desired_dyntag, bfd *abfd, CORE_ADDR *ptr,
 	     CORE_ADDR *ptr_addr)
 {
   int arch_size, step, sect_size;
-  long current_dyntag;
+  long long current_dyntag;
   CORE_ADDR dyn_ptr, dyn_addr;
   gdb_byte *bufend, *bufstart, *buf;
   Elf32_External_Dyn *x_dynp_32;
@@ -701,7 +701,7 @@ scan_dyntag_auxv (const int desired_dyntag, CORE_ADDR *ptr,
 {
   enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
   int sect_size, arch_size, step;
-  long current_dyntag;
+  long long current_dyntag;
   CORE_ADDR dyn_ptr;
   CORE_ADDR base_addr;
   gdb_byte *bufend, *bufstart, *buf;
@@ -946,7 +946,7 @@ solib_svr4_r_ldsomap (struct svr4_info *info)
    file.  */
 
 static int
-svr4_keep_data_in_core (CORE_ADDR vaddr, unsigned long size)
+svr4_keep_data_in_core (CORE_ADDR vaddr, unsigned long long size)
 {
   struct svr4_info *info;
   CORE_ADDR ldsomap;
diff --git a/gdb/solib.c b/gdb/solib.c
index e1d237e..9d40141 100644
--- a/gdb/solib.c
+++ b/gdb/solib.c
@@ -1169,7 +1169,7 @@ solib_name_from_address (struct program_space *pspace, CORE_ADDR address)
    file (in particular, for readonly sections).  */
 
 int
-solib_keep_data_in_core (CORE_ADDR vaddr, unsigned long size)
+solib_keep_data_in_core (CORE_ADDR vaddr, unsigned long long size)
 {
   const struct target_so_ops *ops = solib_ops (target_gdbarch ());
 
@@ -1467,7 +1467,7 @@ gdb_bfd_lookup_symbol_from_symtab (bfd *abfd,
 						     const void *),
 				   const void *data)
 {
-  long storage_needed = bfd_get_symtab_upper_bound (abfd);
+  long long storage_needed = bfd_get_symtab_upper_bound (abfd);
   CORE_ADDR symaddr = 0;
 
   if (storage_needed > 0)
@@ -1526,7 +1526,7 @@ bfd_lookup_symbol_from_dyn_symtab (bfd *abfd,
 						     const void *),
 				   const void *data)
 {
-  long storage_needed = bfd_get_dynamic_symtab_upper_bound (abfd);
+  long long storage_needed = bfd_get_dynamic_symtab_upper_bound (abfd);
   CORE_ADDR symaddr = 0;
 
   if (storage_needed > 0)
diff --git a/gdb/solib.h b/gdb/solib.h
index f6f02ad..bbb8fcb 100644
--- a/gdb/solib.h
+++ b/gdb/solib.h
@@ -62,7 +62,7 @@ extern int solib_contains_address_p (const struct so_list *, CORE_ADDR);
    applies when the section would otherwise not be kept in the core
    file (in particular, for readonly sections).  */
 
-extern int solib_keep_data_in_core (CORE_ADDR vaddr, unsigned long size);
+extern int solib_keep_data_in_core (CORE_ADDR vaddr, unsigned long long size);
 
 /* Return 1 if PC lies in the dynamic symbol resolution code of the
    run time loader.  */
diff --git a/gdb/solist.h b/gdb/solist.h
index 6875d1b..a87f09f 100644
--- a/gdb/solist.h
+++ b/gdb/solist.h
@@ -158,7 +158,7 @@ struct target_so_ops
        applies when the section would otherwise not be kept in the
        core file (in particular, for readonly sections).  */
     int (*keep_data_in_core) (CORE_ADDR vaddr,
-			      unsigned long size);
+			      unsigned long long size);
 
     /* Enable or disable optional solib event breakpoints as
        appropriate.  This should be called whenever
diff --git a/gdb/source.c b/gdb/source.c
index cc5c46d..7a63041 100644
--- a/gdb/source.c
+++ b/gdb/source.c
@@ -1149,7 +1149,7 @@ find_source_lines (struct symtab *s, int desc)
   int nlines = 0;
   int lines_allocated = 1000;
   int *line_charpos;
-  long mtime = 0;
+  long long mtime = 0;
   int size;
 
   gdb_assert (s);
diff --git a/gdb/sparc-linux-tdep.c b/gdb/sparc-linux-tdep.c
index 0933a44..ff731e9 100644
--- a/gdb/sparc-linux-tdep.c
+++ b/gdb/sparc-linux-tdep.c
@@ -159,7 +159,7 @@ sparc32_linux_sigframe_init (const struct tramp_frame *self,
    address.  */
 
 static CORE_ADDR
-sparc32_linux_step_trap (struct frame_info *frame, unsigned long insn)
+sparc32_linux_step_trap (struct frame_info *frame, unsigned long long insn)
 {
   if (insn == 0x91d02010)
     {
diff --git a/gdb/sparc-nat.c b/gdb/sparc-nat.c
index 494cf47..653b0e3 100644
--- a/gdb/sparc-nat.c
+++ b/gdb/sparc-nat.c
@@ -257,15 +257,15 @@ sparc_xfer_wcookie (struct target_ops *ops, enum target_object object,
 		    const gdb_byte *writebuf, ULONGEST offset, ULONGEST len,
 		    ULONGEST *xfered_len)
 {
-  unsigned long wcookie = 0;
+  unsigned long long wcookie = 0;
   char *buf = (char *)&wcookie;
 
   gdb_assert (object == TARGET_OBJECT_WCOOKIE);
   gdb_assert (readbuf && writebuf == NULL);
 
-  if (offset == sizeof (unsigned long))
+  if (offset == sizeof (unsigned long long))
     return TARGET_XFER_EOF;			/* Signal EOF.  */
-  if (offset > sizeof (unsigned long))
+  if (offset > sizeof (unsigned long long))
     return TARGET_XFER_E_IO;
 
 #ifdef PT_WCOOKIE
@@ -296,8 +296,8 @@ sparc_xfer_wcookie (struct target_ops *ops, enum target_object object,
   }
 #endif /* PT_WCOOKIE */
 
-  if (len > sizeof (unsigned long) - offset)
-    len = sizeof (unsigned long) - offset;
+  if (len > sizeof (unsigned long long) - offset)
+    len = sizeof (unsigned long long) - offset;
 
   memcpy (readbuf, buf + offset, len);
   *xfered_len = (ULONGEST) len;
diff --git a/gdb/sparc-nbsd-tdep.c b/gdb/sparc-nbsd-tdep.c
index a58c6e4..eba216e 100644
--- a/gdb/sparc-nbsd-tdep.c
+++ b/gdb/sparc-nbsd-tdep.c
@@ -262,7 +262,7 @@ static const struct frame_unwind sparc32nbsd_sigcontext_frame_unwind =
    address.  */
 
 CORE_ADDR
-sparcnbsd_step_trap (struct frame_info *frame, unsigned long insn)
+sparcnbsd_step_trap (struct frame_info *frame, unsigned long long insn)
 {
   if ((X_I (insn) == 0 && X_RS1 (insn) == 0 && X_RS2 (insn) == 0)
       || (X_I (insn) == 1 && X_RS1 (insn) == 0 && (insn & 0x7f) == 0))
diff --git a/gdb/sparc-obsd-tdep.c b/gdb/sparc-obsd-tdep.c
index 0f6caa6..4458e68 100644
--- a/gdb/sparc-obsd-tdep.c
+++ b/gdb/sparc-obsd-tdep.c
@@ -47,7 +47,7 @@ static int
 sparc32obsd_pc_in_sigtramp (CORE_ADDR pc, const char *name)
 {
   CORE_ADDR start_pc = (pc & ~(sparc32obsd_page_size - 1));
-  unsigned long insn;
+  unsigned long long insn;
 
   if (name)
     return 0;
diff --git a/gdb/sparc-tdep.c b/gdb/sparc-tdep.c
index 7a50a8d..38014c5 100644
--- a/gdb/sparc-tdep.c
+++ b/gdb/sparc-tdep.c
@@ -94,11 +94,11 @@ struct regset;
 /* Fetch the instruction at PC.  Instructions are always big-endian
    even if the processor operates in little-endian mode.  */
 
-unsigned long
+unsigned long long
 sparc_fetch_instruction (CORE_ADDR pc)
 {
   gdb_byte buf[4];
-  unsigned long insn;
+  unsigned long long insn;
   int i;
 
   /* If we can't read the instruction at PC, return zero.  */
@@ -118,7 +118,7 @@ sparc_fetch_instruction (CORE_ADDR pc)
 static int
 sparc_is_unimp_insn (CORE_ADDR pc)
 {
-  const unsigned long insn = sparc_fetch_instruction (pc);
+  const unsigned long long insn = sparc_fetch_instruction (pc);
   
   return ((insn & 0xc1c00000) == 0);
 }
@@ -143,7 +143,7 @@ sparc_is_annulled_branch_insn (CORE_ADDR pc)
      This leaves out ILLTRAP (OP2=0), SETHI/NOP (OP2=4) and the V8
      coprocessor branch instructions (Op2=7).  */
 
-  const unsigned long insn = sparc_fetch_instruction (pc);
+  const unsigned long long insn = sparc_fetch_instruction (pc);
   const unsigned op2 = X_OP2 (insn);
 
   if ((X_OP (insn) == 0)
@@ -778,7 +778,7 @@ static CORE_ADDR
 sparc_skip_stack_check (const CORE_ADDR start_pc)
 {
   CORE_ADDR pc = start_pc;
-  unsigned long insn;
+  unsigned long long insn;
   int probing_loop = 0;
 
   /* With GCC, all stack checking sequences begin with the same two
@@ -984,7 +984,7 @@ sparc_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,
 			CORE_ADDR current_pc, struct sparc_frame_cache *cache)
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
-  unsigned long insn;
+  unsigned long long insn;
   int offset = 0;
   int dest = -1;
 
@@ -1152,7 +1152,7 @@ sparc32_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
 
   while (1)
     {
-      unsigned long insn = sparc_fetch_instruction (start_pc);
+      unsigned long long insn = sparc_fetch_instruction (start_pc);
 
       /* Recognize instructions that store incoming arguments into the
 	 corresponding stack slots.  */
@@ -1629,10 +1629,10 @@ static CORE_ADDR
 sparc_analyze_control_transfer (struct regcache *regcache,
 				CORE_ADDR pc, CORE_ADDR *npc)
 {
-  unsigned long insn = sparc_fetch_instruction (pc);
+  unsigned long long insn = sparc_fetch_instruction (pc);
   int conditional_p = X_COND (insn) & 0x7;
   int branch_p = 0, fused_p = 0;
-  long offset = 0;			/* Must be signed for sign-extend.  */
+  long long offset = 0;			/* Must be signed for sign-extend.  */
 
   if (X_OP (insn) == 0 && X_OP2 (insn) == 3)
     {
@@ -1722,7 +1722,7 @@ sparc_analyze_control_transfer (struct regcache *regcache,
 }
 
 static CORE_ADDR
-sparc_step_trap (struct frame_info *frame, unsigned long insn)
+sparc_step_trap (struct frame_info *frame, unsigned long long insn)
 {
   return 0;
 }
diff --git a/gdb/sparc-tdep.h b/gdb/sparc-tdep.h
index 4ca67d0..f4d9abb 100644
--- a/gdb/sparc-tdep.h
+++ b/gdb/sparc-tdep.h
@@ -83,7 +83,7 @@ struct gdbarch_tdep
   size_t plt_entry_size;
 
   /* Alternative location for trap return.  Used for single-stepping.  */
-  CORE_ADDR (*step_trap) (struct frame_info *frame, unsigned long insn);
+  CORE_ADDR (*step_trap) (struct frame_info *frame, unsigned long long insn);
 
   /* ISA-specific data types.  */
   struct type *sparc_psr_type;
@@ -190,7 +190,7 @@ struct sparc_frame_cache
 };
 
 /* Fetch the instruction at PC.  */
-extern unsigned long sparc_fetch_instruction (CORE_ADDR pc);
+extern unsigned long long sparc_fetch_instruction (CORE_ADDR pc);
 
 /* Fetch StackGhost Per-Process XOR cookie.  */
 extern ULONGEST sparc_fetch_wcookie (struct gdbarch *gdbarch);
@@ -260,7 +260,7 @@ extern const struct sparc_gregmap sparc32nbsd_gregmap;
 /* Return the address of a system call's alternative return
    address.  */
 extern CORE_ADDR sparcnbsd_step_trap (struct frame_info *frame,
-				      unsigned long insn);
+				      unsigned long long insn);
 
 extern void sparc32nbsd_init_abi (struct gdbarch_info info,
 				  struct gdbarch *gdbarch);
diff --git a/gdb/sparc64-linux-tdep.c b/gdb/sparc64-linux-tdep.c
index 6451ffd..d09426c 100644
--- a/gdb/sparc64-linux-tdep.c
+++ b/gdb/sparc64-linux-tdep.c
@@ -128,7 +128,7 @@ sparc64_linux_handle_segmentation_fault (struct gdbarch *gdbarch,
     return;
 
   CORE_ADDR addr = 0;
-  long si_code = 0;
+  long long si_code = 0;
 
   TRY
     {
@@ -176,7 +176,7 @@ sparc64_linux_handle_segmentation_fault (struct gdbarch *gdbarch,
    address.  */
 
 static CORE_ADDR
-sparc64_linux_step_trap (struct frame_info *frame, unsigned long insn)
+sparc64_linux_step_trap (struct frame_info *frame, unsigned long long insn)
 {
   /* __NR_rt_sigreturn is 101  */
   if ((insn == 0x91d0206d)
diff --git a/gdb/sparc64-obsd-tdep.c b/gdb/sparc64-obsd-tdep.c
index 48b45c4..b08943e 100644
--- a/gdb/sparc64-obsd-tdep.c
+++ b/gdb/sparc64-obsd-tdep.c
@@ -124,7 +124,7 @@ static int
 sparc64obsd_pc_in_sigtramp (CORE_ADDR pc, const char *name)
 {
   CORE_ADDR start_pc = (pc & ~(sparc64obsd_page_size - 1));
-  unsigned long insn;
+  unsigned long long insn;
   const int *offset;
 
   if (name)
diff --git a/gdb/sparc64-tdep.c b/gdb/sparc64-tdep.c
index 8d96cfc..395713b 100644
--- a/gdb/sparc64-tdep.c
+++ b/gdb/sparc64-tdep.c
@@ -89,12 +89,12 @@ static struct cmd_list_element *sparc64adilist = NULL;
 typedef struct
 {
   /* The ADI block size.  */
-  unsigned long blksize;
+  unsigned long long blksize;
 
   /* Number of bits used for an ADI version tag which can be
      used together with the shift value for an ADI version tag
      to encode or extract the ADI version value in a pointer.  */
-  unsigned long nbits;
+  unsigned long long nbits;
 
   /* The maximum ADI version tag value supported.  */
   int max_version;
@@ -292,7 +292,7 @@ adi_tag_fd (void)
     return proc->stat.tag_fd;
 
   char cl_name[MAX_PROC_NAME_SIZE];
-  snprintf (cl_name, sizeof(cl_name), "/proc/%ld/adi/tags", (long) pid);
+  snprintf (cl_name, sizeof(cl_name), "/proc/%ld/adi/tags", (long long) pid);
   int target_errno;
   proc->stat.tag_fd = target_fileio_open (NULL, cl_name, O_RDWR|O_EXCL, 
                                           0, &target_errno);
@@ -310,7 +310,7 @@ adi_is_addr_mapped (CORE_ADDR vaddr, size_t cnt)
   size_t i = 0;
 
   pid_t pid = inferior_ptid.pid ();
-  snprintf (filename, sizeof filename, "/proc/%ld/adi/maps", (long) pid);
+  snprintf (filename, sizeof filename, "/proc/%ld/adi/maps", (long long) pid);
   gdb::unique_xmalloc_ptr<char> data
     = target_fileio_read_stralloc (NULL, filename);
   if (data)
diff --git a/gdb/spu-linux-nat.c b/gdb/spu-linux-nat.c
index c2d6569..5986ad8 100644
--- a/gdb/spu-linux-nat.c
+++ b/gdb/spu-linux-nat.c
@@ -102,7 +102,7 @@ fetch_ppc_register (int regno)
       perror_with_name (_(mess));
     }
 
-  return (ULONGEST) (unsigned long) res;
+  return (ULONGEST) (unsigned long long) res;
 }
 
 /* Fetch WORD from PPU memory at (aligned) MEMADDR in thread TID.  */
diff --git a/gdb/stabsread.c b/gdb/stabsread.c
index ed4a3d3..157e3c0 100644
--- a/gdb/stabsread.c
+++ b/gdb/stabsread.c
@@ -88,7 +88,7 @@ read_one_struct_field (struct field_info *, const char **, const char *,
 
 static struct type *dbx_alloc_type (int[2], struct objfile *);
 
-static long read_huge_number (const char **, int, int *, int);
+static long long read_huge_number (const char **, int, int *, int);
 
 static struct type *error_type (const char **, struct objfile *);
 
@@ -2880,7 +2880,7 @@ read_one_struct_field (struct field_info *fip, const char **pp, const char *p,
       /* Possible future hook for nested types.  */
       if (**pp == '!')
 	{
-	  fip->list->field.bitpos = (long) -2;	/* nested type */
+	  fip->list->field.bitpos = (long long) -2;	/* nested type */
 	  p = ++(*pp);
 	}
       else
@@ -3627,7 +3627,7 @@ read_enum_type (const char **pp, struct type *type,
   struct gdbarch *gdbarch = get_objfile_arch (objfile);
   const char *p;
   char *name;
-  long n;
+  long long n;
   struct symbol *sym;
   int nsyms = 0;
   struct pending **symlist;
@@ -3871,19 +3871,19 @@ read_sun_floating_type (const char **pp, int typenums[2],
 
    If encounter garbage, set *BITS to -1 and return 0.  */
 
-static long
+static long long
 read_huge_number (const char **pp, int end, int *bits,
 		  int twos_complement_bits)
 {
   const char *p = *pp;
   int sign = 1;
   int sign_bit = 0;
-  long n = 0;
+  long long n = 0;
   int radix = 10;
   char overflow = 0;
   int nbits = 0;
   int c;
-  long upper_limit;
+  long long upper_limit;
   int twos_complement_representation = 0;
 
   if (*p == '-')
@@ -3945,7 +3945,7 @@ read_huge_number (const char **pp, int end, int *bits,
 		 this case, n is the corresponding absolute value.  */
 	      if (n == 0)
 		{
-		  long sn = c - '0' - ((2 * (c - '0')) | (2 << sign_bit));
+		  long long sn = c - '0' - ((2 * (c - '0')) | (2 << sign_bit));
 
 		  n = -sn;
 		}
@@ -4043,7 +4043,7 @@ read_range_type (const char **pp, int typenums[2], int type_size,
   struct gdbarch *gdbarch = get_objfile_arch (objfile);
   const char *orig_pp = *pp;
   int rangenums[2];
-  long n2, n3;
+  long long n2, n3;
   int n2bits, n3bits;
   int self_subrange;
   struct type *result_type;
@@ -4107,7 +4107,7 @@ read_range_type (const char **pp, int typenums[2], int type_size,
          fit in a long but <large number>-1 does.  */
       else if ((n2bits != 0 && n3bits != 0 && n2bits == n3bits + 1)
 	       || (n2bits != 0 && n3bits == 0
-		   && (n2bits == sizeof (long) * HOST_CHAR_BIT)
+		   && (n2bits == sizeof (long long) * HOST_CHAR_BIT)
 		   && n3 == LONG_MAX))
 	{
 	  got_signed = 1;
@@ -4189,7 +4189,7 @@ read_range_type (const char **pp, int typenums[2], int type_size,
          two; we don't want 3- and 5-byte integers flying around.  */
       {
 	int bytes;
-	unsigned long bits;
+	unsigned long long bits;
 
 	bits = n3;
 	for (bytes = 0; (bits & 0xff) == 0xff; bytes++)
diff --git a/gdb/stabsread.h b/gdb/stabsread.h
index d24b25d..463fcb5 100644
--- a/gdb/stabsread.h
+++ b/gdb/stabsread.h
@@ -131,7 +131,7 @@ EXTERN int n_allocated_this_object_header_files;
 
 extern void cleanup_undefined_stabs_types (struct objfile *);
 
-extern long read_number (char **, int);
+extern long long read_number (char **, int);
 
 extern struct symbol *define_symbol (CORE_ADDR, const char *, int, int,
 				     struct objfile *);
diff --git a/gdb/stack.c b/gdb/stack.c
index f909308..1796dab 100644
--- a/gdb/stack.c
+++ b/gdb/stack.c
@@ -190,14 +190,14 @@ print_stack_frame (struct frame_info *frame, int print_level,
    argument (not just the first nameless argument).  */
 
 static void
-print_frame_nameless_args (struct frame_info *frame, long start, int num,
+print_frame_nameless_args (struct frame_info *frame, long long start, int num,
 			   int first, struct ui_file *stream)
 {
   struct gdbarch *gdbarch = get_frame_arch (frame);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int i;
   CORE_ADDR argsaddr;
-  long arg_value;
+  long long arg_value;
 
   for (i = 0; i < num; i++)
     {
@@ -540,7 +540,7 @@ print_frame_args (struct symbol *func, struct frame_info *frame,
   /* Offset of next stack argument beyond the one we have seen that is
      at the highest offset, or -1 if we haven't come to a stack
      argument yet.  */
-  long highest_offset = -1;
+  long long highest_offset = -1;
   /* Number of ints of arguments that we have printed so far.  */
   int args_printed = 0;
   /* True if we should print arguments, false otherwise.  */
@@ -569,7 +569,7 @@ print_frame_args (struct symbol *func, struct frame_info *frame,
 	    case LOC_ARG:
 	    case LOC_REF_ARG:
 	      {
-		long current_offset = SYMBOL_VALUE (sym);
+		long long current_offset = SYMBOL_VALUE (sym);
 		int arg_size = TYPE_LENGTH (SYMBOL_TYPE (sym));
 
 		/* Compute address of next argument by adding the size of
@@ -705,7 +705,7 @@ print_frame_args (struct symbol *func, struct frame_info *frame,
      enough about the stack to find them.  */
   if (num != -1)
     {
-      long start;
+      long long start;
 
       if (highest_offset == -1)
 	start = gdbarch_frame_args_skip (get_frame_arch (frame));
diff --git a/gdb/stap-probe.c b/gdb/stap-probe.c
index ed7e1a0..0f34cf6 100644
--- a/gdb/stap-probe.c
+++ b/gdb/stap-probe.c
@@ -712,7 +712,7 @@ stap_parse_register_operand (struct stap_parse_info *p)
   if (isdigit (*p->arg))
     {
       /* The value of the displacement.  */
-      long displacement;
+      long long displacement;
       char *endp;
 
       disp_p = 1;
@@ -910,7 +910,7 @@ stap_parse_single_operand (struct stap_parse_info *p)
       /* A temporary variable, needed for lookahead.  */
       const char *tmp = p->arg;
       char *endp;
-      long number;
+      long long number;
 
       /* We can be dealing with a numeric constant, or with a register
 	 displacement.  */
@@ -953,7 +953,7 @@ stap_parse_single_operand (struct stap_parse_info *p)
   else if (stap_is_integer_prefix (gdbarch, p->arg, &int_prefix))
     {
       /* We are dealing with a numeric constant.  */
-      long number;
+      long long number;
       char *endp;
       const char *int_suffix;
 
diff --git a/gdb/stubs/ia64vms-stub.c b/gdb/stubs/ia64vms-stub.c
index 8283184..e744188 100644
--- a/gdb/stubs/ia64vms-stub.c
+++ b/gdb/stubs/ia64vms-stub.c
@@ -1338,7 +1338,7 @@ handle_q_packet (const unsigned char *pkt, unsigned int pktlen)
       gdb_buf[2] = 'C';
       gdb_blen = 3;
       if (has_threads)
-	long2pkt ((unsigned long) get_teb ());
+	long2pkt ((unsigned long long) get_teb ());
       return;
     }
   else if (pktlen > XFER_UIB_LEN
@@ -1570,7 +1570,7 @@ packet_status (void)
   if (has_threads)
     {
       str2pkt ("$T05thread:");
-      long2pkt ((unsigned long) get_teb ());
+      long2pkt ((unsigned long long) get_teb ());
       gdb_buf[gdb_blen++] = ';';
     }
   else
@@ -2490,7 +2490,7 @@ stub_start (unsigned __int64 *progxfer, void *cli_util,
 		    1, "KESU" + (imcb->imcb$b_access_mode & 3),
 		    imcb->imcb$t_log_image_name);
 
-	  if ((long) ldrimg < 0 || trace_images < 2)
+	  if ((long long) ldrimg < 0 || trace_images < 2)
 	    continue;
 	  ldrisd = ldrimg->ldrimg$l_segments;
 	  for (j = 0; j < ldrimg->ldrimg$l_segcount; j++)
diff --git a/gdb/stubs/m32r-stub.c b/gdb/stubs/m32r-stub.c
index 4d54f72..6a35cd1 100644
--- a/gdb/stubs/m32r-stub.c
+++ b/gdb/stubs/m32r-stub.c
@@ -193,7 +193,7 @@ static void stash_registers (void);
 static void restore_registers (void);
 static int prepare_to_step (int);
 static int finish_from_step (void);
-static unsigned long crc32 (unsigned char *, int, unsigned long);
+static unsigned long long crc32 (unsigned char *, int, unsigned long long);
 
 static void gdb_error (char *, char *);
 static int gdb_putchar (int), gdb_puts (char *), gdb_write (char *, int);
@@ -518,7 +518,7 @@ handle_exception (int exceptionVector)
 	  if (*ptr++ == 'C' &&
 	      *ptr++ == 'R' && *ptr++ == 'C' && *ptr++ == ':')
 	    {
-	      unsigned long start, len, our_crc;
+	      unsigned long long start, len, our_crc;
 
 	      if (hexToInt (&ptr, (int *) &start) &&
 		  *ptr++ == ',' && hexToInt (&ptr, (int *) &len))
@@ -526,7 +526,7 @@ handle_exception (int exceptionVector)
 		  remcomOutBuffer[0] = 'C';
 		  our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
 		  mem2hex ((char *) &our_crc,
-			   &remcomOutBuffer[1], sizeof (long), 0);
+			   &remcomOutBuffer[1], sizeof (long long), 0);
 		}		/* else do nothing */
 	    }			/* else do nothing */
 	  break;
@@ -543,16 +543,16 @@ handle_exception (int exceptionVector)
 /* qCRC support */
 
 /* Table used by the crc32 function to calcuate the checksum. */
-static unsigned long crc32_table[256] = { 0, 0 };
+static unsigned long long crc32_table[256] = { 0, 0 };
 
-static unsigned long
-crc32 (unsigned char *buf, int len, unsigned long crc)
+static unsigned long long
+crc32 (unsigned char *buf, int len, unsigned long long crc)
 {
   if (!crc32_table[1])
     {
       /* Initialize the CRC table and the decoding table. */
       int i, j;
-      unsigned long c;
+      unsigned long long c;
 
       for (i = 0; i < 256; i++)
 	{
@@ -1131,11 +1131,11 @@ branchSideEffects (unsigned char *instr, int branchCode)
 static struct STEPPING_CONTEXT
 {
   int stepping;			/* true when we've started a single-step */
-  unsigned long target_addr;	/* the instr we're trying to execute */
-  unsigned long target_size;	/* the size of the target instr */
-  unsigned long noop_addr;	/* where we've inserted a no-op, if any */
-  unsigned long trap1_addr;	/* the trap following the target instr */
-  unsigned long trap2_addr;	/* the trap at a branch destination, if any */
+  unsigned long long target_addr;	/* the instr we're trying to execute */
+  unsigned long long target_size;	/* the size of the target instr */
+  unsigned long long noop_addr;	/* where we've inserted a no-op, if any */
+  unsigned long long trap1_addr;	/* the trap following the target instr */
+  unsigned long long trap2_addr;	/* the trap at a branch destination, if any */
   unsigned short noop_save;	/* instruction overwritten by our no-op */
   unsigned short trap1_save;	/* instruction overwritten by trap1 */
   unsigned short trap2_save;	/* instruction overwritten by trap2 */
@@ -1163,7 +1163,7 @@ static int
 prepare_to_step (continue_p)
      int continue_p;		/* if this isn't REALLY a single-step (see below) */
 {
-  unsigned long pc = registers[PC];
+  unsigned long long pc = registers[PC];
   int branchCode = isBranch ((unsigned char *) pc);
   unsigned char *p;
 
diff --git a/gdb/stubs/sparc-stub.c b/gdb/stubs/sparc-stub.c
index c12d436..7260f29 100644
--- a/gdb/stubs/sparc-stub.c
+++ b/gdb/stubs/sparc-stub.c
@@ -552,14 +552,14 @@ hexToInt(char **ptr, int *intValue)
 extern void breakinst();
 
 static void
-handle_exception (unsigned long *registers)
+handle_exception (unsigned long long *registers)
 {
   int tt;			/* Trap type */
   int sigval;
   int addr;
   int length;
   char *ptr;
-  unsigned long *sp;
+  unsigned long long *sp;
 
 /* First, we must force all of the windows to be spilled out */
 
@@ -581,13 +581,13 @@ handle_exception (unsigned long *registers)
 	restore
 ");
 
-  if (registers[PC] == (unsigned long)breakinst)
+  if (registers[PC] == (unsigned long long)breakinst)
     {
       registers[PC] = registers[NPC];
       registers[NPC] += 4;
     }
 
-  sp = (unsigned long *)registers[SP];
+  sp = (unsigned long long *)registers[SP];
 
   tt = (registers[TBR] >> 4) & 0xff;
 
@@ -665,7 +665,7 @@ handle_exception (unsigned long *registers)
 
 	case 'G':	   /* set the value of the CPU registers - return OK */
 	  {
-	    unsigned long *newsp, psr;
+	    unsigned long long *newsp, psr;
 
 	    psr = registers[PSR];
 
@@ -678,7 +678,7 @@ handle_exception (unsigned long *registers)
 	       locals and ins to the new location.  This keeps the window
 	       overflow and underflow routines happy.  */
 
-	    newsp = (unsigned long *)registers[SP];
+	    newsp = (unsigned long long *)registers[SP];
 	    if (sp != newsp)
 	      sp = memcpy(newsp, sp, 16 * 4);
 
diff --git a/gdb/symfile.c b/gdb/symfile.c
index 39d06d8..b01fc94 100644
--- a/gdb/symfile.c
+++ b/gdb/symfile.c
@@ -69,12 +69,12 @@
 #include "psymtab.h"
 
 int (*deprecated_ui_load_progress_hook) (const char *section,
-					 unsigned long num);
+					 unsigned long long num);
 void (*deprecated_show_load_progress) (const char *section,
-			    unsigned long section_sent,
-			    unsigned long section_size,
-			    unsigned long total_sent,
-			    unsigned long total_size);
+			    unsigned long long section_sent,
+			    unsigned long long section_size,
+			    unsigned long long total_sent,
+			    unsigned long long total_size);
 void (*deprecated_pre_add_symbol_hook) (const char *);
 void (*deprecated_post_add_symbol_hook) (void);
 
@@ -1276,10 +1276,10 @@ symbol_file_clear (int from_tty)
 int separate_debug_file_debug = 0;
 
 static int
-separate_debug_file_exists (const std::string &name, unsigned long crc,
+separate_debug_file_exists (const std::string &name, unsigned long long crc,
 			    struct objfile *parent_objfile)
 {
-  unsigned long file_crc;
+  unsigned long long file_crc;
   int file_crc_p;
   struct stat parent_stat, abfd_stat;
   int verified_as_different;
@@ -1331,7 +1331,7 @@ separate_debug_file_exists (const std::string &name, unsigned long crc,
 
   if (crc != file_crc)
     {
-      unsigned long parent_crc;
+      unsigned long long parent_crc;
 
       /* If the files could not be verified as different with
 	 bfd_stat then we need to calculate the parent's CRC
@@ -1381,7 +1381,7 @@ static std::string
 find_separate_debug_file (const char *dir,
 			  const char *canon_dir,
 			  const char *debuglink,
-			  unsigned long crc32, struct objfile *objfile)
+			  unsigned long long crc32, struct objfile *objfile)
 {
   if (separate_debug_file_debug)
     printf_unfiltered (_("\nLooking for separate debug info (debug link) for "
@@ -1466,7 +1466,7 @@ terminate_after_last_dir_separator (char *path)
 std::string
 find_separate_debug_file_by_debuglink (struct objfile *objfile)
 {
-  unsigned long crc32;
+  unsigned long long crc32;
 
   gdb::unique_xmalloc_ptr<char> debuglink
     (bfd_get_debug_link_info (objfile->obfd, &crc32));
@@ -1805,8 +1805,8 @@ add_section_size_callback (bfd *abfd, asection *asec, void *data)
 struct load_progress_data
 {
   /* Cumulative data.  */
-  unsigned long write_count = 0;
-  unsigned long data_count = 0;
+  unsigned long long write_count = 0;
+  unsigned long long data_count = 0;
   bfd_size_type total_size = 0;
 };
 
@@ -1943,8 +1943,8 @@ load_section_callback (bfd *abfd, asection *asec, void *data)
 }
 
 static void print_transfer_performance (struct ui_file *stream,
-					unsigned long data_count,
-					unsigned long write_count,
+					unsigned long long data_count,
+					unsigned long long write_count,
 				        std::chrono::steady_clock::duration d);
 
 void
@@ -2034,8 +2034,8 @@ generic_load (const char *args, int from_tty)
 
 static void
 print_transfer_performance (struct ui_file *stream,
-			    unsigned long data_count,
-			    unsigned long write_count,
+			    unsigned long long data_count,
+			    unsigned long long write_count,
 			    std::chrono::steady_clock::duration time)
 {
   using namespace std::chrono;
@@ -2046,7 +2046,7 @@ print_transfer_performance (struct ui_file *stream,
   uiout->text ("Transfer rate: ");
   if (ms.count () > 0)
     {
-      unsigned long rate = ((ULONGEST) data_count * 1000) / ms.count ();
+      unsigned long long rate = ((ULONGEST) data_count * 1000) / ms.count ();
 
       if (uiout->is_mi_like_p ())
 	{
@@ -2367,7 +2367,7 @@ void
 reread_symbols (void)
 {
   struct objfile *objfile;
-  long new_modtime;
+  long long new_modtime;
   struct stat new_statbuf;
   int res;
   std::vector<struct objfile *> new_objfiles;
diff --git a/gdb/symmisc.c b/gdb/symmisc.c
index d30a354..6ba9d58 100644
--- a/gdb/symmisc.c
+++ b/gdb/symmisc.c
@@ -250,7 +250,7 @@ dump_msymbols (struct objfile *objfile, struct ui_file *outfile)
 						section->the_bfd_section));
 	  else
 	    fprintf_filtered (outfile, " spurious section %ld",
-			      (long) (section - objfile->sections));
+			      (long long) (section - objfile->sections));
 	}
       if (MSYMBOL_DEMANGLED_NAME (msymbol) != NULL)
 	{
diff --git a/gdb/symtab.h b/gdb/symtab.h
index eb14f34..9a55d57 100644
--- a/gdb/symtab.h
+++ b/gdb/symtab.h
@@ -652,7 +652,7 @@ struct minimal_symbol
      information to calculate the end of the partial symtab based on the
      address of the last symbol plus the size of the last symbol.  */
 
-  unsigned long size;
+  unsigned long long size;
 
   /* Which source file is this symbol in?  Only relevant for mst_file_*.  */
   const char *filename;
diff --git a/gdb/target-delegates.c b/gdb/target-delegates.c
index 319a9bb..c970f24 100644
--- a/gdb/target-delegates.c
+++ b/gdb/target-delegates.c
@@ -97,7 +97,7 @@ struct dummy_target : public target_ops
   void flash_erase (ULONGEST arg0, LONGEST arg1) override;
   void flash_done () override;
   const struct target_desc *read_description () override;
-  ptid_t get_ada_task_ptid (long arg0, long arg1) override;
+  ptid_t get_ada_task_ptid (long long arg0, long long arg1) override;
   int auxv_parse (gdb_byte **arg0, gdb_byte *arg1, CORE_ADDR *arg2, CORE_ADDR *arg3) override;
   int search_memory (CORE_ADDR arg0, ULONGEST arg1, const gdb_byte *arg2, ULONGEST arg3, CORE_ADDR *arg4) override;
   bool can_execute_reverse () override;
@@ -265,7 +265,7 @@ struct debug_target : public target_ops
   void flash_erase (ULONGEST arg0, LONGEST arg1) override;
   void flash_done () override;
   const struct target_desc *read_description () override;
-  ptid_t get_ada_task_ptid (long arg0, long arg1) override;
+  ptid_t get_ada_task_ptid (long long arg0, long long arg1) override;
   int auxv_parse (gdb_byte **arg0, gdb_byte *arg1, CORE_ADDR *arg2, CORE_ADDR *arg3) override;
   int search_memory (CORE_ADDR arg0, ULONGEST arg1, const gdb_byte *arg2, ULONGEST arg3, CORE_ADDR *arg4) override;
   bool can_execute_reverse () override;
@@ -2533,19 +2533,19 @@ debug_target::read_description ()
 }
 
 ptid_t
-target_ops::get_ada_task_ptid (long arg0, long arg1)
+target_ops::get_ada_task_ptid (long long arg0, long long arg1)
 {
   return this->beneath ()->get_ada_task_ptid (arg0, arg1);
 }
 
 ptid_t
-dummy_target::get_ada_task_ptid (long arg0, long arg1)
+dummy_target::get_ada_task_ptid (long long arg0, long long arg1)
 {
   return default_get_ada_task_ptid (this, arg0, arg1);
 }
 
 ptid_t
-debug_target::get_ada_task_ptid (long arg0, long arg1)
+debug_target::get_ada_task_ptid (long long arg0, long long arg1)
 {
   ptid_t result;
   fprintf_unfiltered (gdb_stdlog, "-> %s->get_ada_task_ptid (...)\n", this->beneath ()->shortname ());
diff --git a/gdb/target-descriptions.c b/gdb/target-descriptions.c
index a96416c..28bc395 100644
--- a/gdb/target-descriptions.c
+++ b/gdb/target-descriptions.c
@@ -1812,7 +1812,7 @@ maintenance_check_xml_descriptions (const char *dir, int from_tty)
 	failed++;
     }
   printf_filtered (_("Tested %lu XML files, %d failed\n"),
-		   (long) selftests::xml_tdesc.size (), failed);
+		   (long long) selftests::xml_tdesc.size (), failed);
 }
 
 void
diff --git a/gdb/target-float.c b/gdb/target-float.c
index c2878cb..4e60edd 100644
--- a/gdb/target-float.c
+++ b/gdb/target-float.c
@@ -165,11 +165,11 @@ floatformat_normalize_byteorder (const struct floatformat *fmt,
 
 /* Extract a field which starts at START and is LEN bytes long.  DATA and
    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
-static unsigned long
+static unsigned long long
 get_field (const bfd_byte *data, enum floatformat_byteorders order,
 	   unsigned int total_len, unsigned int start, unsigned int len)
 {
-  unsigned long result;
+  unsigned long long result;
   unsigned int cur_byte;
   int cur_bitshift;
 
@@ -212,7 +212,7 @@ get_field (const bfd_byte *data, enum floatformat_byteorders order,
   /* Move towards the most significant part of the field.  */
   while (cur_bitshift < len)
     {
-      result |= (unsigned long)*(data + cur_byte) << cur_bitshift;
+      result |= (unsigned long long)*(data + cur_byte) << cur_bitshift;
       cur_bitshift += FLOATFORMAT_CHAR_BIT;
       switch (order)
 	{
@@ -235,7 +235,7 @@ get_field (const bfd_byte *data, enum floatformat_byteorders order,
 static void
 put_field (unsigned char *data, enum floatformat_byteorders order,
 	   unsigned int total_len, unsigned int start, unsigned int len,
-	   unsigned long stuff_to_put)
+	   unsigned long long stuff_to_put)
 {
   unsigned int cur_byte;
   int cur_bitshift;
@@ -325,8 +325,8 @@ static enum float_kind
 floatformat_classify (const struct floatformat *fmt,
 		      const bfd_byte *uval)
 {
-  long exponent;
-  unsigned long mant;
+  long long exponent;
+  unsigned long long mant;
   unsigned int mant_bits, mant_off;
   int mant_bits_left;
   enum floatformat_byteorders order;
@@ -414,7 +414,7 @@ floatformat_mantissa (const struct floatformat *fmt,
 		      const bfd_byte *val)
 {
   unsigned char *uval = (unsigned char *) val;
-  unsigned long mant;
+  unsigned long long mant;
   unsigned int mant_bits, mant_off;
   int mant_bits_left;
   static char res[50];
@@ -628,8 +628,8 @@ host_float_ops<T>::from_target (const struct floatformat *fmt,
 
   unsigned char *ufrom = (unsigned char *) from;
   T dto;
-  long exponent;
-  unsigned long mant;
+  long long exponent;
+  unsigned long long mant;
   unsigned int mant_bits, mant_off;
   int mant_bits_left;
   int special_exponent;		/* It's a NaN, denorm or zero.  */
@@ -870,12 +870,12 @@ host_float_ops<T>::to_target (const struct floatformat *fmt,
   mant_off = fmt->man_start;
   while (mant_bits_left > 0)
     {
-      unsigned long mant_long;
+      unsigned long long mant_long;
 
       mant_bits = mant_bits_left < 32 ? mant_bits_left : 32;
 
       mant *= 4294967296.0;
-      mant_long = ((unsigned long) mant) & 0xffffffffL;
+      mant_long = ((unsigned long long) mant) & 0xffffffffL;
       mant -= mant_long;
 
       /* If the integer bit is implicit, then we need to discard it.
@@ -1223,7 +1223,7 @@ mpfr_float_ops::from_target (const struct floatformat *fmt,
 {
   const gdb_byte *from = orig_from;
   mpfr_exp_t exponent;
-  unsigned long mant;
+  unsigned long long mant;
   unsigned int mant_bits, mant_off;
   int mant_bits_left;
   int special_exponent;		/* It's a NaN, denorm or zero.  */
@@ -1436,7 +1436,7 @@ mpfr_float_ops::to_target (const struct floatformat *fmt,
   mant_off = fmt->man_start;
   while (mant_bits_left > 0)
     {
-      unsigned long mant_long;
+      unsigned long long mant_long;
 
       mant_bits = mant_bits_left < 32 ? mant_bits_left : 32;
 
diff --git a/gdb/target.c b/gdb/target.c
index 19d59ba..f56042e 100644
--- a/gdb/target.c
+++ b/gdb/target.c
@@ -64,7 +64,7 @@ static int default_region_ok_for_hw_watchpoint (struct target_ops *,
 static void default_rcmd (struct target_ops *, const char *, struct ui_file *);
 
 static ptid_t default_get_ada_task_ptid (struct target_ops *self,
-					 long lwp, long tid);
+					 long long lwp, long long tid);
 
 static int default_follow_fork (struct target_ops *self, int follow_child,
 				int detach_fork);
@@ -616,7 +616,7 @@ default_terminal_info (struct target_ops *self, const char *args, int from_tty)
    inferior_ptid.  */
 
 static ptid_t
-default_get_ada_task_ptid (struct target_ops *self, long lwp, long tid)
+default_get_ada_task_ptid (struct target_ops *self, long long lwp, long long tid)
 {
   return ptid_t (inferior_ptid.pid (), lwp, tid);
 }
diff --git a/gdb/target.h b/gdb/target.h
index 18c4a84..af30797 100644
--- a/gdb/target.h
+++ b/gdb/target.h
@@ -814,7 +814,7 @@ struct target_ops
        based on LWP and THREAD.  These values are extracted from the
        task Private_Data section of the Ada Task Control Block, and
        their interpretation depends on the target.  */
-    virtual ptid_t get_ada_task_ptid (long lwp, long thread)
+    virtual ptid_t get_ada_task_ptid (long long lwp, long long thread)
       TARGET_DEFAULT_FUNC (default_get_ada_task_ptid);
 
     /* Read one auxv entry from *READPTR, not reading locations >= ENDPTR.
diff --git a/gdb/testsuite/gdb.arch/aarch64-atomic-inst.c b/gdb/testsuite/gdb.arch/aarch64-atomic-inst.c
index 93cb0f7..fdc9201 100644
--- a/gdb/testsuite/gdb.arch/aarch64-atomic-inst.c
+++ b/gdb/testsuite/gdb.arch/aarch64-atomic-inst.c
@@ -17,8 +17,8 @@
 
 int main(void)
 {
-  unsigned long tmp, cond;
-  unsigned long dword = 0;
+  unsigned long long tmp, cond;
+  unsigned long long dword = 0;
 
   /* Test that we can step over ldxr/stxr. This sequence should step from
      ldxr to the following __asm __volatile.  */
diff --git a/gdb/testsuite/gdb.arch/aarch64-fp.c b/gdb/testsuite/gdb.arch/aarch64-fp.c
index 0ff8e00..7c3fbbc 100644
--- a/gdb/testsuite/gdb.arch/aarch64-fp.c
+++ b/gdb/testsuite/gdb.arch/aarch64-fp.c
@@ -22,7 +22,7 @@ main (void)
                  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
   char buf1[] = {0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
                  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f};
-  long val;
+  long long val;
   void *addr;
     
   addr = &buf0[0];
diff --git a/gdb/testsuite/gdb.arch/amd64-pseudo.c b/gdb/testsuite/gdb.arch/amd64-pseudo.c
index d8234d2..892a2d0 100644
--- a/gdb/testsuite/gdb.arch/amd64-pseudo.c
+++ b/gdb/testsuite/gdb.arch/amd64-pseudo.c
@@ -45,14 +45,14 @@ main (int argc, char **argv)
   register int edx asm ("edx");
   register int esi asm ("esi");
   register int edi asm ("edi");
-  register long r8 asm ("r8");
-  register long r9 asm ("r9");
-  register long r10 asm ("r10");
-  register long r11 asm ("r11");
-  register long r12 asm ("r12");
-  register long r13 asm ("r13");
-  register long r14 asm ("r14");
-  register long r15 asm ("r15");
+  register long long r8 asm ("r8");
+  register long long r9 asm ("r9");
+  register long long r10 asm ("r10");
+  register long long r11 asm ("r11");
+  register long long r12 asm ("r12");
+  register long long r13 asm ("r13");
+  register long long r14 asm ("r14");
+  register long long r15 asm ("r15");
 
   asm ("mov 0(%0), %%eax\n\t"
        "mov 4(%0), %%ebx\n\t"
diff --git a/gdb/testsuite/gdb.arch/i386-pkru.c b/gdb/testsuite/gdb.arch/i386-pkru.c
index de36102..79038a5 100644
--- a/gdb/testsuite/gdb.arch/i386-pkru.c
+++ b/gdb/testsuite/gdb.arch/i386-pkru.c
@@ -26,7 +26,7 @@
 
 unsigned int have_pkru (void) NOINLINE;
 
-static inline unsigned long
+static inline unsigned long long
 rdpkru (void)
 {
   unsigned int eax, edx;
diff --git a/gdb/testsuite/gdb.arch/iwmmxt-regs.c b/gdb/testsuite/gdb.arch/iwmmxt-regs.c
index d2ed1c1..2075b8d 100644
--- a/gdb/testsuite/gdb.arch/iwmmxt-regs.c
+++ b/gdb/testsuite/gdb.arch/iwmmxt-regs.c
@@ -18,7 +18,7 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 void
-read_regs (unsigned long long regs[16], unsigned long control_regs[6])
+read_regs (unsigned long long regs[16], unsigned long long control_regs[6])
 {
   asm volatile ("wstrd wR0, %0" : "=m" (regs[0]));
   asm volatile ("wstrd wR1, %0" : "=m" (regs[1]));
@@ -46,7 +46,7 @@ read_regs (unsigned long long regs[16], unsigned long control_regs[6])
 }
 
 void
-write_regs (unsigned long long regs[16], unsigned long control_regs[6])
+write_regs (unsigned long long regs[16], unsigned long long control_regs[6])
 {
   asm volatile ("wldrd wR0, %0" : : "m" (regs[0]));
   asm volatile ("wldrd wR1, %0" : : "m" (regs[1]));
@@ -77,7 +77,7 @@ int
 main ()
 {
   unsigned long long regs[16];
-  unsigned long control_regs[6];
+  unsigned long long control_regs[6];
 
   read_regs (regs, control_regs);
   write_regs (regs, control_regs);
diff --git a/gdb/testsuite/gdb.arch/mips16-thunks-sin.c b/gdb/testsuite/gdb.arch/mips16-thunks-sin.c
index 10ef1d3..d90ec8a 100644
--- a/gdb/testsuite/gdb.arch/mips16-thunks-sin.c
+++ b/gdb/testsuite/gdb.arch/mips16-thunks-sin.c
@@ -24,9 +24,9 @@ double sinblah (double d);
 double sinblah16 (double d);
 
 double sinmips16 (double d);
-long lsinmips16 (double d);
+long long lsinmips16 (double d);
 
-extern long i;
+extern long long i;
 
 double
 sinhelper (double d)
@@ -40,10 +40,10 @@ sinhelper (double d)
   return d;
 }
 
-long
+long long
 lsinhelper (double d)
 {
-  long l;
+  long long l;
 
   i++;
   d = sin (d);
diff --git a/gdb/testsuite/gdb.arch/mips16-thunks-sinfrob.c b/gdb/testsuite/gdb.arch/mips16-thunks-sinfrob.c
index 7c4f69c..24c6609 100644
--- a/gdb/testsuite/gdb.arch/mips16-thunks-sinfrob.c
+++ b/gdb/testsuite/gdb.arch/mips16-thunks-sinfrob.c
@@ -17,7 +17,7 @@
 
 #include <math.h>
 
-extern long i;
+extern long long i;
 
 double
 sinfrob (double d)
diff --git a/gdb/testsuite/gdb.arch/mips16-thunks-sinfrob16.c b/gdb/testsuite/gdb.arch/mips16-thunks-sinfrob16.c
index 4a56b67..27c0b9d 100644
--- a/gdb/testsuite/gdb.arch/mips16-thunks-sinfrob16.c
+++ b/gdb/testsuite/gdb.arch/mips16-thunks-sinfrob16.c
@@ -17,7 +17,7 @@
 
 #include <math.h>
 
-extern long i;
+extern long long i;
 
 double
 sinfrob16 (double d)
diff --git a/gdb/testsuite/gdb.arch/mips16-thunks-sinmain.c b/gdb/testsuite/gdb.arch/mips16-thunks-sinmain.c
index f1bf0d3..3ac6c86 100644
--- a/gdb/testsuite/gdb.arch/mips16-thunks-sinmain.c
+++ b/gdb/testsuite/gdb.arch/mips16-thunks-sinmain.c
@@ -22,19 +22,19 @@ double sinblah (double d);
 double sinblah16 (double d);
 
 double sinhelper (double);
-long lsinhelper (double);
+long long lsinhelper (double);
 
 double (*sinfunc) (double) = sinfrob;
 double (*sinfunc16) (double) = sinfrob16;
 
 double f = 1.0;
-long i = 1;
+long long i = 1;
 
 int
 main (void)
 {
   double d = f;
-  long l = i;
+  long long l = i;
 
   d = sinfrob16 (d);
   d = sinfrob (d);
diff --git a/gdb/testsuite/gdb.arch/mips16-thunks-sinmips16.c b/gdb/testsuite/gdb.arch/mips16-thunks-sinmips16.c
index 6d17516..4e52fcc 100644
--- a/gdb/testsuite/gdb.arch/mips16-thunks-sinmips16.c
+++ b/gdb/testsuite/gdb.arch/mips16-thunks-sinmips16.c
@@ -26,7 +26,7 @@ double sinblah16 (double d);
 extern double (*sinfunc) (double);
 extern double (*sinfunc16) (double);
 
-extern long i;
+extern long long i;
 
 double
 sinmips16 (double d)
@@ -41,13 +41,13 @@ sinmips16 (double d)
   return d;
 }
 
-long
+long long
 lsinmips16 (double d)
 {
   union
     {
       double d;
-      long l[2];
+      long long l[2];
     }
   u;
 
diff --git a/gdb/testsuite/gdb.arch/s390-multiarch.c b/gdb/testsuite/gdb.arch/s390-multiarch.c
index 7371edd..6f3b6b4 100644
--- a/gdb/testsuite/gdb.arch/s390-multiarch.c
+++ b/gdb/testsuite/gdb.arch/s390-multiarch.c
@@ -206,7 +206,7 @@ elfbuf_write_to_file (struct elfbuf *elf, const char *path)
 
 static void
 elfbuf_handle_auxv (struct elfbuf *elf, size_t offset, size_t len,
-		    unsigned long hwcap_mask)
+		    unsigned long long hwcap_mask)
 {
   size_t i;
   uint32_t *auxv32 = (uint32_t *) (elf->buf + offset);
@@ -237,7 +237,7 @@ elfbuf_handle_auxv (struct elfbuf *elf, size_t offset, size_t len,
 
 static void
 elfbuf_handle_note_segment (struct elfbuf *elf, size_t offset, size_t len,
-			    unsigned note_type, unsigned long hwcap_mask)
+			    unsigned note_type, unsigned long long hwcap_mask)
 {
   size_t pos = 0;
 
@@ -261,7 +261,7 @@ elfbuf_handle_note_segment (struct elfbuf *elf, size_t offset, size_t len,
 
 static void
 elfbuf_handle_core_notes (struct elfbuf *elf, unsigned note_type,
-			  unsigned long hwcap_mask)
+			  unsigned long long hwcap_mask)
 {
   unsigned ph_idx;
 
@@ -289,7 +289,7 @@ int
 main (int argc, char *argv[])
 {
   unsigned note_type;
-  unsigned long hwcap_mask = 0;
+  unsigned long long hwcap_mask = 0;
   struct elfbuf elf;
 
   if (argc < 4)
diff --git a/gdb/testsuite/gdb.arch/sparc64-adi.c b/gdb/testsuite/gdb.arch/sparc64-adi.c
index 54e85fd..338325f 100644
--- a/gdb/testsuite/gdb.arch/sparc64-adi.c
+++ b/gdb/testsuite/gdb.arch/sparc64-adi.c
@@ -51,9 +51,9 @@
 static int
 memory_fill (char *addr, size_t size, int pattern)
 {
-  long *aligned_addr = (long *) addr;
-  long i;
-  for (i = 0; i < size / sizeof (long); i += ONEKB) 
+  long long *aligned_addr = (long long *) addr;
+  long long i;
+  for (i = 0; i < size / sizeof (long long); i += ONEKB) 
     { 
       *aligned_addr = pattern; 
       aligned_addr = aligned_addr + ONEKB;
diff --git a/gdb/testsuite/gdb.base/all-types.c b/gdb/testsuite/gdb.base/all-types.c
index 570fd43..59d19d8 100644
--- a/gdb/testsuite/gdb.base/all-types.c
+++ b/gdb/testsuite/gdb.base/all-types.c
@@ -18,9 +18,9 @@ int		v_int;
 signed int	v_signed_int;
 unsigned int	v_unsigned_int;
 
-long		v_long;
-signed long	v_signed_long;
-unsigned long	v_unsigned_long;
+long long		v_long;
+signed long long	v_signed_long;
+unsigned long long	v_unsigned_long;
 
 float		v_float;
 double		v_double;
diff --git a/gdb/testsuite/gdb.base/attach-pie-misread.c b/gdb/testsuite/gdb.base/attach-pie-misread.c
index ef32e1b..037abd9 100644
--- a/gdb/testsuite/gdb.base/attach-pie-misread.c
+++ b/gdb/testsuite/gdb.base/attach-pie-misread.c
@@ -31,7 +31,7 @@ main (int argc, char **argv)
   /* Generator of GEN written in Python takes about 15s for x86_64's 4MB.  */
   if (argc == 2)
     {
-      long count = strtol (argv[1], NULL, 0);
+      long long count = strtol (argv[1], NULL, 0);
 
       while (count-- > 0)
 	puts ("0x55,");
diff --git a/gdb/testsuite/gdb.base/attach-twice.c b/gdb/testsuite/gdb.base/attach-twice.c
index 93adf93..483a944 100644
--- a/gdb/testsuite/gdb.base/attach-twice.c
+++ b/gdb/testsuite/gdb.base/attach-twice.c
@@ -24,7 +24,7 @@
 int
 main (void)
 {
-  long l;
+  long long l;
 
   switch (fork ())
   {
diff --git a/gdb/testsuite/gdb.base/bigcore.c b/gdb/testsuite/gdb.base/bigcore.c
index 9f969f9..a1971f3 100644
--- a/gdb/testsuite/gdb.base/bigcore.c
+++ b/gdb/testsuite/gdb.base/bigcore.c
@@ -77,7 +77,7 @@ static void
 print_address (const void *a)
 {
   print_string ("0x");
-  print_hex ((unsigned long) a);
+  print_hex ((unsigned long long) a);
 }
 
 static void
@@ -140,7 +140,7 @@ struct list
 static struct list dummy;
 static struct list heap = { &dummy, &dummy };
 
-static unsigned long bytes_allocated;
+static unsigned long long bytes_allocated;
 
 #ifdef O_LARGEFILE
 #define large_off_t off64_t
@@ -225,7 +225,7 @@ main ()
   print_string ("Alocating the entire heap ...\n");
   {
     size_t chunk_size;
-    unsigned long chunks_allocated = 0;
+    unsigned long long chunks_allocated = 0;
     /* Create a linked list of memory chunks.  Start with
        MAX_CHUNK_SIZE blocks of memory and then try allocating smaller
        and smaller amounts until all (well at least most) memory has
@@ -234,7 +234,7 @@ main ()
 	 chunk_size >= sizeof (struct list);
 	 chunk_size >>= 1)
       {
-	unsigned long count = 0;
+	unsigned long long count = 0;
 	print_string ("  ");
 	print_byte_count (chunk_size);
 	print_string (" ... ");
diff --git a/gdb/testsuite/gdb.base/break.c b/gdb/testsuite/gdb.base/break.c
index daf762f..a44db83 100644
--- a/gdb/testsuite/gdb.base/break.c
+++ b/gdb/testsuite/gdb.base/break.c
@@ -21,7 +21,7 @@
 extern int marker1 (void);
 extern int marker2 (int a);
 extern void marker3 (char *a, char *b);
-extern void marker4 (long d);
+extern void marker4 (long long d);
 
 /* We're used by a test that requires malloc, so make sure it is in
    the executable.  */
diff --git a/gdb/testsuite/gdb.base/break1.c b/gdb/testsuite/gdb.base/break1.c
index dab8769..72ee2ea 100644
--- a/gdb/testsuite/gdb.base/break1.c
+++ b/gdb/testsuite/gdb.base/break1.c
@@ -56,4 +56,4 @@ int some_variable;
 int marker1 (void) { return (0); }	/* set breakpoint 15 here */
 int marker2 (int a) { return (1); }	/* set breakpoint 8 here */
 void marker3 (char *a, char *b) {}	/* set breakpoint 17 here */
-void marker4 (long d) { values[0].a_field = d; }	/* set breakpoint 14 here */
+void marker4 (long long d) { values[0].a_field = d; }	/* set breakpoint 14 here */
diff --git a/gdb/testsuite/gdb.base/call-sc.c b/gdb/testsuite/gdb.base/call-sc.c
index 38c8247..05b995a 100644
--- a/gdb/testsuite/gdb.base/call-sc.c
+++ b/gdb/testsuite/gdb.base/call-sc.c
@@ -22,7 +22,7 @@ typedef void t;
 typedef char tc;
 typedef short ts;
 typedef int ti;
-typedef long tl;
+typedef long long tl;
 typedef long long tll;
 typedef float tf;
 typedef double td;
diff --git a/gdb/testsuite/gdb.base/callfuncs.c b/gdb/testsuite/gdb.base/callfuncs.c
index dc26087..3c4c5a1 100644
--- a/gdb/testsuite/gdb.base/callfuncs.c
+++ b/gdb/testsuite/gdb.base/callfuncs.c
@@ -37,8 +37,8 @@ short short_val2 = -23;
 int int_val1 = 87;
 int int_val2 = -26;
 
-long long_val1 = 789;
-long long_val2 = -321;
+long long long_val1 = 789;
+long long long_val2 = -321;
 
 float float_val1 = 3.14159;
 float float_val2 = -2.3765;
@@ -108,7 +108,7 @@ struct struct1 {
   char c;
   short s;
   int i;
-  long l;
+  long long l;
   float f;
   double d;
   char a[4];
@@ -204,7 +204,7 @@ int sum_args (argc, argv) int argc; int argv[];
 char   t_structs_c (struct struct1 tstruct) { return (tstruct.c); }
 short  t_structs_s (struct struct1 tstruct) { return (tstruct.s); }
 int    t_structs_i (struct struct1 tstruct) { return (tstruct.i); }
-long   t_structs_l (struct struct1 tstruct) { return (tstruct.l); }
+long long   t_structs_l (struct struct1 tstruct) { return (tstruct.l); }
 float  t_structs_f (struct struct1 tstruct) { return (tstruct.f); }
 double t_structs_d (struct struct1 tstruct) { return (tstruct.d); }
 char  *t_structs_a (struct struct1 tstruct)
@@ -222,7 +222,7 @@ long double _Complex t_structs_ldc (struct struct1 tstruct) { return tstruct.ldc
 char   t_structs_c (tstruct) struct struct1 tstruct; { return (tstruct.c); }
 short  t_structs_s (tstruct) struct struct1 tstruct; { return (tstruct.s); }
 int    t_structs_i (tstruct) struct struct1 tstruct; { return (tstruct.i); }
-long   t_structs_l (tstruct) struct struct1 tstruct; { return (tstruct.l); }
+long long   t_structs_l (tstruct) struct struct1 tstruct; { return (tstruct.l); }
 float  t_structs_f (tstruct) struct struct1 tstruct; { return (tstruct.f); }
 double t_structs_d (tstruct) struct struct1 tstruct; { return (tstruct.d); }
 char  *t_structs_a (tstruct) struct struct1 tstruct;
@@ -322,10 +322,10 @@ int int_arg1, int_arg2;
 }
 
 #ifdef PROTOTYPES
-int t_long_values (long long_arg1, long long_arg2)
+int t_long_values (long long long_arg1, long long long_arg2)
 #else
 int t_long_values (long_arg1, long_arg2)
-long long_arg1, long_arg2;
+long long long_arg1, long_arg2;
 #endif
 {
   return ((long_arg1 == long_val1) && (long_arg2 == long_val2));
diff --git a/gdb/testsuite/gdb.base/charset.c b/gdb/testsuite/gdb.base/charset.c
index d8480e2..856d10c 100644
--- a/gdb/testsuite/gdb.base/charset.c
+++ b/gdb/testsuite/gdb.base/charset.c
@@ -75,7 +75,7 @@ my_wchar_t myvar;
 /* Some arrays for simple assignment tests.  */
 short short_array[3];
 int int_array[3];
-long long_array[3];
+long long long_array[3];
 
 void
 init_string (char string[],
diff --git a/gdb/testsuite/gdb.base/checkpoint.c b/gdb/testsuite/gdb.base/checkpoint.c
index b1b2cbe..d7cd22e 100644
--- a/gdb/testsuite/gdb.base/checkpoint.c
+++ b/gdb/testsuite/gdb.base/checkpoint.c
@@ -19,14 +19,14 @@
 #include <stdio.h>
 #include <unistd.h>
 
-long lines = 0;
+long long lines = 0;
 
 int main()
 {
   char linebuf[128];
   FILE *in, *out;
   char *tmp = &linebuf[0];
-  long i;
+  long long i;
   int c = 0;
 
   in  = fopen (PI_TXT, "r");
diff --git a/gdb/testsuite/gdb.base/constvars.c b/gdb/testsuite/gdb.base/constvars.c
index 60cca2a..3c8de29 100644
--- a/gdb/testsuite/gdb.base/constvars.c
+++ b/gdb/testsuite/gdb.base/constvars.c
@@ -12,7 +12,7 @@ qux1 (const char cc, const char /*&*/ccr, const char *ccp, char *const cpc)
 
 int
 qux2 (volatile unsigned char vuc, const volatile int cvi,
-      volatile short /*&*/vsr, volatile long *vlp, float *volatile fpv,
+      volatile short /*&*/vsr, volatile long long *vlp, float *volatile fpv,
       const volatile signed char *const volatile cvscpcv)
 {
   return 400;
@@ -25,8 +25,8 @@ main (void)
   unsigned char lavish = 10;
   short lax = 20;
   unsigned short lecherous = 30;
-  long lechery = 40;
-  unsigned long lectern = 50;
+  long long lechery = 40;
+  unsigned long long lectern = 50;
   float leeway = 60;
   double legacy = 70;
   signed char lemonade = 35;
@@ -35,8 +35,8 @@ main (void)
   const unsigned char   laggard = 1;
   const short           lagoon = 2;
   const unsigned short  laity = 3;
-  const long            lambent = 4;
-  const unsigned long   laminated = 5;
+  const long long            lambent = 4;
+  const unsigned long long   laminated = 5;
   const float           lampoon = 6;
   const double          languid = 7;
 
@@ -46,8 +46,8 @@ main (void)
   const unsigned char  *legerdemain = &lavish;
   const short          *leniency    = &lax;
   const unsigned short *leonine     = &lecherous;
-  const long           *lesion      = &lechery;
-  const unsigned long  *lethal      = &lectern;
+  const long long           *lesion      = &lechery;
+  const unsigned long long  *lethal      = &lectern;
   const float          *lethargic   = &leeway;
   const double         *levity      = &legacy;
 
@@ -57,8 +57,8 @@ main (void)
   const unsigned char  *const lexicographer = &laggard;
   const short          *const lexicon       = &lagoon;
   const unsigned short *const liaison       = &laity;
-  const long           *const libation      = &lambent;
-  const unsigned long  *const libelous      = &laminated;
+  const long long           *const libation      = &lambent;
+  const unsigned long long  *const libelous      = &laminated;
   const float          *const libertine     = &lampoon;
   const double         *const libidinous    = &languid;
 
@@ -68,8 +68,8 @@ main (void)
   unsigned char  const *languor    = &laggard;
   short          const *lank       = &lagoon;
   unsigned short const *lapidary   = &laity;
-  long           const *larceny    = &lambent;
-  unsigned long  const *largess    = &laminated;
+  long long           const *larceny    = &lambent;
+  unsigned long long  const *largess    = &laminated;
   float          const *lascivious = &lampoon;
   double         const *lassitude  = &languid;
 
@@ -79,8 +79,8 @@ main (void)
   unsigned char  *const   lariat    = &lavish;
   short          *const   laudanum  = &lax;
   unsigned short *const   lecithin  = &lecherous;
-  long           *const   leviathan = &lechery;
-  unsigned long  *const   libretto  = &lectern;
+  long long           *const   leviathan = &lechery;
+  unsigned long long  *const   libretto  = &lectern;
   float          *const   lissome   = &leeway;
   double         *const   locust    = &legacy;
 
@@ -89,8 +89,8 @@ main (void)
   const unsigned char lugged[2] = {laggard, laggard};
   const short luck[2] = {lagoon, lagoon};
   const unsigned short lunar[2] = {laity, laity};
-  const long lumen[2] = {lambent, lambent};
-  const unsigned long lurk[2] = {laminated, laminated};
+  const long long lumen[2] = {lambent, lambent};
+  const unsigned long long lurk[2] = {laminated, laminated};
   const float lush[2] = {lampoon, lampoon};
   const double lynx[2] = {languid, languid};
 
@@ -100,8 +100,8 @@ main (void)
   volatile unsigned char victuals = 13;
   volatile short vixen = 200;
   volatile unsigned short vitriol = 300;
-  volatile long vellum = 1000;
-  volatile unsigned long valve = 2000;
+  volatile long long vellum = 1000;
+  volatile unsigned long long valve = 2000;
   volatile float vacuity = 3.0;
   volatile double vertigo = 10.3;
     
@@ -111,8 +111,8 @@ main (void)
   volatile unsigned char  * viper  = &victuals;
   volatile short          * vigour = &vixen;
   volatile unsigned short * vapour = &vitriol;
-  volatile long           * ventricle = &vellum;
-  volatile unsigned long  * vigintillion = &valve;
+  volatile long long           * ventricle = &vellum;
+  volatile unsigned long long  * vigintillion = &valve;
   volatile float          * vocation = &vacuity;
   volatile double         * veracity = &vertigo;
 
@@ -122,8 +122,8 @@ main (void)
   volatile unsigned char  * volatile velocity = &victuals;
   volatile short          * volatile veneer = &vixen;
   volatile unsigned short * volatile video = &vitriol;
-  volatile long           * volatile vacuum = &vellum;
-  volatile unsigned long  * volatile veniality = &valve;
+  volatile long long           * volatile vacuum = &vellum;
+  volatile unsigned long long  * volatile veniality = &valve;
   volatile float          * volatile vitality = &vacuity;
   volatile double         * volatile voracity = &vertigo;
 
@@ -132,8 +132,8 @@ main (void)
   volatile unsigned char violet[2] = {victuals, victuals};
   volatile short vips[2] = {vixen, vixen};
   volatile unsigned short virgen[2] = {vitriol, vitriol};
-  volatile long vulgar[2] = {vellum, vellum};
-  volatile unsigned long vulture[2] = {valve, valve};
+  volatile long long vulgar[2] = {vellum, vellum};
+  volatile unsigned long long vulture[2] = {valve, valve};
   volatile float vilify[2] = {vacuity, vacuity};
   volatile double villar[2] = {vertigo, vertigo};
 
diff --git a/gdb/testsuite/gdb.base/cvexpr.c b/gdb/testsuite/gdb.base/cvexpr.c
index c71c76a..be0f5f8 100644
--- a/gdb/testsuite/gdb.base/cvexpr.c
+++ b/gdb/testsuite/gdb.base/cvexpr.c
@@ -34,9 +34,9 @@ int		v_int;
 signed int	v_signed_int;
 unsigned int	v_unsigned_int;
 
-long		v_long;
-signed long	v_signed_long;
-unsigned long	v_unsigned_long;
+long long		v_long;
+signed long long	v_signed_long;
+unsigned long long	v_unsigned_long;
 
 long long	   v_long_long;
 signed long long   v_signed_long_long;
@@ -64,9 +64,9 @@ int		v_int_array[2];
 signed int	v_signed_int_array[2];
 unsigned int	v_unsigned_int_array[2];
 
-long		v_long_array[2];
-signed long	v_signed_long_array[2];
-unsigned long	v_unsigned_long_array[2];
+long long		v_long_array[2];
+signed long long	v_signed_long_array[2];
+unsigned long long	v_unsigned_long_array[2];
 
 float		v_float_array[2];
 double		v_double_array[2];
@@ -88,9 +88,9 @@ int		*v_int_pointer;
 signed int	*v_signed_int_pointer;
 unsigned int	*v_unsigned_int_pointer;
 
-long		*v_long_pointer;
-signed long	*v_signed_long_pointer;
-unsigned long	*v_unsigned_long_pointer;
+long long		*v_long_pointer;
+signed long long	*v_signed_long_pointer;
+unsigned long long	*v_unsigned_long_pointer;
 
 float		*v_float_pointer;
 double		*v_double_pointer;
@@ -107,9 +107,9 @@ int		**v_int_pointer_pointer;
 signed int	**v_signed_int_pointer_pointer;
 unsigned int	**v_unsigned_int_pointer_pointer;
 
-long		**v_long_pointer_pointer;
-signed long	**v_signed_long_pointer_pointer;
-unsigned long	**v_unsigned_long_pointer_pointer;
+long long		**v_long_pointer_pointer;
+signed long long	**v_signed_long_pointer_pointer;
+unsigned long long	**v_unsigned_long_pointer_pointer;
 
 float		**v_float_pointer_pointer;
 double		**v_double_pointer_pointer;
@@ -128,9 +128,9 @@ int		*v_int_array_pointer[2];
 signed int	*v_signed_int_array_pointer[2];
 unsigned int	*v_unsigned_int_array_pointer[2];
 
-long		*v_long_array_pointer[2];
-signed long	*v_signed_long_array_pointer[2];
-unsigned long	*v_unsigned_long_array_pointer[2];
+long long		*v_long_array_pointer[2];
+signed long long	*v_signed_long_array_pointer[2];
+unsigned long long	*v_unsigned_long_array_pointer[2];
 
 float		*v_float_array_pointer[2];
 double		*v_double_array_pointer[2];
@@ -147,9 +147,9 @@ int		(*v_int_pointer_array)[2];
 signed int	(*v_signed_int_pointer_array)[2];
 unsigned int	(*v_unsigned_int_pointer_array)[2];
 
-long		(*v_long_pointer_array)[2];
-signed long	(*v_signed_long_pointer_array)[2];
-unsigned long	(*v_unsigned_long_pointer_array)[2];
+long long		(*v_long_pointer_array)[2];
+signed long long	(*v_signed_long_pointer_array)[2];
+unsigned long long	(*v_unsigned_long_pointer_array)[2];
 
 float		(*v_float_pointer_array)[2];
 double		(*v_double_pointer_array)[2];
@@ -161,7 +161,7 @@ struct t_struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_struct1;
@@ -172,7 +172,7 @@ struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_struct2;
@@ -192,7 +192,7 @@ union t_union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_union;
@@ -201,7 +201,7 @@ union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_union2;
@@ -258,9 +258,9 @@ int		(*v_int_func) (int, int*);
 signed int	(*v_signed_int_func) (int, int*);
 unsigned int	(*v_unsigned_int_func) (int, int*);
 
-long		(*v_long_func) (int, int*);
-signed long	(*v_signed_long_func) (int, int*);
-unsigned long	(*v_unsigned_long_func) (int, int*);
+long long		(*v_long_func) (int, int*);
+signed long long	(*v_signed_long_func) (int, int*);
+unsigned long long	(*v_unsigned_long_func) (int, int*);
 
 long long		(*v_long_long_func) (int, int*);
 signed long long	(*v_signed_long_long_func) (int, int*);
diff --git a/gdb/testsuite/gdb.base/d10vovly.c b/gdb/testsuite/gdb.base/d10vovly.c
index bdb90fe..c49bead 100644
--- a/gdb/testsuite/gdb.base/d10vovly.c
+++ b/gdb/testsuite/gdb.base/d10vovly.c
@@ -7,11 +7,11 @@
 
 /* Local functions and data: */
 
-extern unsigned long _ovly_table[][4];
-extern unsigned long _novlys __attribute__ ((section (".data")));
+extern unsigned long long _ovly_table[][4];
+extern unsigned long long _novlys __attribute__ ((section (".data")));
 enum ovly_index { VMA, SIZE, LMA, MAPPED};
 
-static void ovly_copy (unsigned long dst, unsigned long src, long size);
+static void ovly_copy (unsigned long long dst, unsigned long long src, long long size);
 
 /* Flush the data and instruction caches at address START for SIZE bytes.
    Support for each new port must be added here.  */
@@ -36,9 +36,9 @@ FlushCache (void)
  */
 
 bool
-OverlayLoad (unsigned long ovlyno)
+OverlayLoad (unsigned long long ovlyno)
 {
-  unsigned long i;
+  unsigned long long i;
 
   if (ovlyno < 0 || ovlyno >= _novlys)
     exit (-1);	/* fail, bad ovly number */
@@ -68,7 +68,7 @@ OverlayLoad (unsigned long ovlyno)
  */
  
 bool
-OverlayUnload (unsigned long ovlyno)
+OverlayUnload (unsigned long long ovlyno)
 {
   if (ovlyno < 0 || ovlyno >= _novlys)
     exit (-1);  /* fail, bad ovly number */
@@ -89,13 +89,13 @@ OverlayUnload (unsigned long ovlyno)
 #define DMAP        (*(short *)(0xff04))
 
 static void
-D10VTranslate (unsigned long logical,
+D10VTranslate (unsigned long long logical,
 	       short *dmap,
-	       unsigned long **addr)
+	       unsigned long long **addr)
 {
-  unsigned long physical;
-  unsigned long seg;
-  unsigned long off;
+  unsigned long long physical;
+  unsigned long long seg;
+  unsigned long long off;
 
   /* to access data, we use the following mapping 
      0x00xxxxxx: Logical data address segment        (DMAP translated memory)
@@ -165,16 +165,16 @@ D10VTranslate (unsigned long logical,
     {
     case 0x10:	/* dst is a 15 bit offset into the on-chip memory */
       *dmap = 0;
-      *addr = (long *) (0x0000 + ((short)off & 0x7fff));
+      *addr = (long long *) (0x0000 + ((short)off & 0x7fff));
       break;
     case 0x11:	/* dst is an 18-bit offset into the on-chip
 		   instruction memory */
       *dmap = 0x1000L | ((off & 0x3ffffL) >> 14);
-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));
+      *addr = (long long *) (0x8000 + ((short)off & 0x3fff));
       break;
     case 0x12:	/* dst is a 24-bit offset into unified memory */
       *dmap = off >> 14;
-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));
+      *addr = (long long *) (0x8000 + ((short)off & 0x3fff));
       break;
     default:
       exit (-1);	/* error */
@@ -183,7 +183,7 @@ D10VTranslate (unsigned long logical,
 #endif /* __D10V__ */
 
 static void
-ovly_copy (unsigned long dst, unsigned long src, long size)
+ovly_copy (unsigned long long dst, unsigned long long src, long long size)
 {
 #ifdef  __M32R__
   memcpy ((void *) dst, (void *) src, size);
@@ -191,7 +191,7 @@ ovly_copy (unsigned long dst, unsigned long src, long size)
 #endif /* M32R */
 
 #ifdef  __D10V__
-  unsigned long *s, *d, tmp;
+  unsigned long long *s, *d, tmp;
   short dmap_src, dmap_dst;
   short dmap_save;
 
diff --git a/gdb/testsuite/gdb.base/dfp-test.c b/gdb/testsuite/gdb.base/dfp-test.c
index 058b939..076b548 100644
--- a/gdb/testsuite/gdb.base/dfp-test.c
+++ b/gdb/testsuite/gdb.base/dfp-test.c
@@ -111,7 +111,7 @@ d128_t2 v_d128_t2;
 struct decstruct
 {
   int int4;
-  long long8;
+  long long long8;
   float float4;
   double double8;
   _Decimal32 dec32;
diff --git a/gdb/testsuite/gdb.base/exprs.c b/gdb/testsuite/gdb.base/exprs.c
index cd605f3..e606cfe 100644
--- a/gdb/testsuite/gdb.base/exprs.c
+++ b/gdb/testsuite/gdb.base/exprs.c
@@ -33,9 +33,9 @@ int		v_int;
 signed int	v_signed_int;
 unsigned int	v_unsigned_int;
 
-long		v_long;
-signed long	v_signed_long;
-unsigned long	v_unsigned_long;
+long long		v_long;
+signed long long	v_signed_long;
+unsigned long long	v_unsigned_long;
 
 float		v_float;
 double		v_double;
@@ -58,9 +58,9 @@ int		v_int_array[2];
 signed int	v_signed_int_array[2];
 unsigned int	v_unsigned_int_array[2];
 
-long		v_long_array[2];
-signed long	v_signed_long_array[2];
-unsigned long	v_unsigned_long_array[2];
+long long		v_long_array[2];
+signed long long	v_signed_long_array[2];
+unsigned long long	v_unsigned_long_array[2];
 
 float		v_float_array[2];
 double		v_double_array[2];
@@ -83,9 +83,9 @@ int		*v_int_pointer;
 signed int	*v_signed_int_pointer;
 unsigned int	*v_unsigned_int_pointer;
 
-long		*v_long_pointer;
-signed long	*v_signed_long_pointer;
-unsigned long	*v_unsigned_long_pointer;
+long long		*v_long_pointer;
+signed long long	*v_signed_long_pointer;
+unsigned long long	*v_unsigned_long_pointer;
 
 float		*v_float_pointer;
 double		*v_double_pointer;
@@ -96,7 +96,7 @@ struct t_struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_struct1;
@@ -105,7 +105,7 @@ struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_struct2;
@@ -116,7 +116,7 @@ union t_union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_union;
@@ -125,7 +125,7 @@ union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_union2;
@@ -144,9 +144,9 @@ int		v_int_func () { return (0); }
 signed int	v_signed_int_func () { return (0); }
 unsigned int	v_unsigned_int_func () { return (0); }
 
-long		v_long_func () { return (0); }
-signed long	v_signed_long_func () { return (0); }
-unsigned long	v_unsigned_long_func () { return (0); }
+long long		v_long_func () { return (0); }
+signed long long	v_signed_long_func () { return (0); }
+unsigned long long	v_unsigned_long_func () { return (0); }
 
 float		v_float_func () { return (0.0); }
 double		v_double_func () { return (0.0); }
diff --git a/gdb/testsuite/gdb.base/fileio.c b/gdb/testsuite/gdb.base/fileio.c
index 7f482a3..aefae9a 100644
--- a/gdb/testsuite/gdb.base/fileio.c
+++ b/gdb/testsuite/gdb.base/fileio.c
@@ -226,29 +226,29 @@ test_lseek (void)
     {
       errno = 0;
       ret = lseek (fd, 0, SEEK_CUR);
-      printf ("lseek 1: ret = %ld, errno = %d, %s\n", (long) ret, errno,
+      printf ("lseek 1: ret = %ld, errno = %d, %s\n", (long long) ret, errno,
               ret == 0 ? "OK" : "");
       stop ();
       errno = 0;
       ret = lseek (fd, 0, SEEK_END);
-      printf ("lseek 2: ret = %ld, errno = %d, %s\n", (long) ret, errno,
+      printf ("lseek 2: ret = %ld, errno = %d, %s\n", (long long) ret, errno,
               ret == 11 ? "OK" : "");
       stop ();
       errno = 0;
       ret = lseek (fd, 3, SEEK_SET);
-      printf ("lseek 3: ret = %ld, errno = %d, %s\n", (long) ret, errno,
+      printf ("lseek 3: ret = %ld, errno = %d, %s\n", (long long) ret, errno,
               ret == 3 ? "OK" : "");
       close (fd);
     }
   else
     {
-      printf ("lseek 1: ret = %ld, errno = %d %s\n", (long) ret, errno,
+      printf ("lseek 1: ret = %ld, errno = %d %s\n", (long long) ret, errno,
 	      strerrno (errno));
       stop ();
-      printf ("lseek 2: ret = %ld, errno = %d %s\n", (long) ret, errno,
+      printf ("lseek 2: ret = %ld, errno = %d %s\n", (long long) ret, errno,
 	      strerrno (errno));
       stop ();
-      printf ("lseek 3: ret = %ld, errno = %d %s\n", (long) ret, errno,
+      printf ("lseek 3: ret = %ld, errno = %d %s\n", (long long) ret, errno,
 	      strerrno (errno));
     }
   /* Seeking on an invalid file descriptor */
@@ -511,12 +511,12 @@ test_time (void)
 
   errno = 0;
   ret = time (&t);
-  printf ("time 1: ret = %ld, errno = %d, t = %ld %s\n", (long) ret, errno, (long) t, ret == t ? "OK" : "");
+  printf ("time 1: ret = %ld, errno = %d, t = %ld %s\n", (long long) ret, errno, (long long) t, ret == t ? "OK" : "");
   stop ();
   errno = 0;
   ret = time (NULL);
   printf ("time 2: ret = %ld, errno = %d, t = %ld %s\n",
-	  (long) ret, errno, (long) t, ret >= t && ret < t + 10 ? "OK" : "");
+	  (long long) ret, errno, (long long) t, ret >= t && ret < t + 10 ? "OK" : "");
   stop ();
 }
 
diff --git a/gdb/testsuite/gdb.base/funcargs.c b/gdb/testsuite/gdb.base/funcargs.c
index 600792f..5ee719e 100644
--- a/gdb/testsuite/gdb.base/funcargs.c
+++ b/gdb/testsuite/gdb.base/funcargs.c
@@ -41,11 +41,11 @@ int *ip = &i;
 unsigned int ui = 7;
 unsigned int *uip = &ui;
 
-long l = 3;
-long *lp = &l;
+long long l = 3;
+long long *lp = &l;
 
-unsigned long ul = 8;
-unsigned long *ulp = &ul;
+unsigned long long ul = 8;
+unsigned long long *ulp = &ul;
 
 float f = 4.0;
 float *fp = &f;
@@ -67,7 +67,7 @@ struct stag *stp = &st;
 
 union utag {
     int u1;
-    long u2;
+    long long u2;
 } un;
 union utag *unp = &un;
 
@@ -77,7 +77,7 @@ char carray[] = {'a', 'n', ' ', 'a', 'r', 'r', 'a', 'y', '\0'};
 /* Test various permutations and interleaving of integral arguments */
 
 
-void call0a (char c, short s, int i, long l)
+void call0a (char c, short s, int i, long long l)
 {
   c = 'a';
   s = 5;
@@ -85,22 +85,22 @@ void call0a (char c, short s, int i, long l)
   l = 7;
 }
 
-void call0b (short s, int i, long l, char c)
+void call0b (short s, int i, long long l, char c)
 {
   s = 6; i = 7; l = 8; c = 'j';
 }
 
-void call0c (int i, long l, char c, short s)
+void call0c (int i, long long l, char c, short s)
 {
   i = 3; l = 4; c = 'k'; s = 5;
 }
 
-void call0d (long l, char c, short s, int i)
+void call0d (long long l, char c, short s, int i)
 {
   l = 7; c = 'z'; s = 8; i = 9;
 }
 
-void call0e (char c1, long l, char c2, int i, char c3, short s, char c4, char c5)
+void call0e (char c1, long long l, char c2, int i, char c3, short s, char c4, char c5)
 {
   c1 = 'a'; l = 5; c2 = 'b'; i = 7; c3 = 'c'; s = 7; c4 = 'f'; c5 = 'g';
 }
@@ -109,27 +109,27 @@ void call0e (char c1, long l, char c2, int i, char c3, short s, char c4, char c5
 /* Test various permutations and interleaving of unsigned integral arguments */
 
 
-void call1a (unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call1a (unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   uc = 5; us = 6; ui = 7; ul = 8;
 }
 
-void call1b (unsigned short us, unsigned int ui, unsigned long ul, unsigned char uc)
+void call1b (unsigned short us, unsigned int ui, unsigned long long ul, unsigned char uc)
 {
   uc = 5; us = 6; ui = 7; ul = 8;
 }
 
-void call1c (unsigned int ui, unsigned long ul, unsigned char uc, unsigned short us)
+void call1c (unsigned int ui, unsigned long long ul, unsigned char uc, unsigned short us)
 {
   uc = 5; us = 6; ui = 7; ul = 8;
 }
 
-void call1d (unsigned long ul, unsigned char uc, unsigned short us, unsigned int ui)
+void call1d (unsigned long long ul, unsigned char uc, unsigned short us, unsigned int ui)
 {
   uc = 5; us = 6; ui = 7; ul = 8;
 }
 
-void call1e (unsigned char uc1, unsigned long ul, unsigned char uc2, unsigned int ui, unsigned char uc3, unsigned short us, unsigned char uc4, unsigned char uc5)
+void call1e (unsigned char uc1, unsigned long long ul, unsigned char uc2, unsigned int ui, unsigned char uc3, unsigned short us, unsigned char uc4, unsigned char uc5)
 {
   uc1 = 5; ul = 7; uc2 = 8; ui = 9; uc3 = 10; us = 11; uc4 = 12; uc5 = 55;
 }
@@ -138,42 +138,42 @@ void call1e (unsigned char uc1, unsigned long ul, unsigned char uc2, unsigned in
    floating point arguments. */
 
 
-void call2a (char c, float f1, short s, double d1, int i, float f2, long l, double d2)
+void call2a (char c, float f1, short s, double d1, int i, float f2, long long l, double d2)
 {
   c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
 }
 
-void call2b (float f1, short s, double d1, int i, float f2, long l, double d2, char c)
+void call2b (float f1, short s, double d1, int i, float f2, long long l, double d2, char c)
 {
   c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
 }
 
-void call2c (short s, double d1, int i, float f2, long l, double d2, char c, float f1)
+void call2c (short s, double d1, int i, float f2, long long l, double d2, char c, float f1)
 {
   c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
 }
 
-void call2d (double d1, int i, float f2, long l, double d2, char c, float f1, short s)
+void call2d (double d1, int i, float f2, long long l, double d2, char c, float f1, short s)
 {
   c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
 }
 
-void call2e (int i, float f2, long l, double d2, char c, float f1, short s, double d1)
+void call2e (int i, float f2, long long l, double d2, char c, float f1, short s, double d1)
 {
   c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
 }
 
-void call2f (float f2, long l, double d2, char c, float f1, short s, double d1, int i)
+void call2f (float f2, long long l, double d2, char c, float f1, short s, double d1, int i)
 {
   c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
 }
 
-void call2g (long l, double d2, char c, float f1, short s, double d1, int i, float f2)
+void call2g (long long l, double d2, char c, float f1, short s, double d1, int i, float f2)
 {
   c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
 }
 
-void call2h (double d2, char c, float f1, short s, double d1, int i, float f2, long l)
+void call2h (double d2, char c, float f1, short s, double d1, int i, float f2, long long l)
 {
   c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
 }
@@ -188,12 +188,12 @@ void call2i (char c1, float f1, char c2, char c3, double d1, char c4, char c5, c
 /* Test pointers to various integral and floating types. */
 
 
-void call3a (char *cp, short *sp, int *ip, long *lp)
+void call3a (char *cp, short *sp, int *ip, long long *lp)
 {
   cp = 0; sp = 0; ip = 0; lp = 0;
 }
 
-void call3b (unsigned char *ucp, unsigned short *usp, unsigned int *uip, unsigned long *ulp)
+void call3b (unsigned char *ucp, unsigned short *usp, unsigned int *uip, unsigned long long *ulp)
 {
   ucp = 0; usp = 0; uip = 0; ulp = 0;
 }
@@ -238,23 +238,23 @@ void callcf (long double _Complex ldc1, float _Complex fc1, double _Complex dc1)
 
 
 /* Test passing _Complex type and integral.  */
-void callc1a (char c, short s, int i, unsigned int ui, long l,
+void callc1a (char c, short s, int i, unsigned int ui, long long l,
 	      float _Complex fc1, double _Complex dc1,
 	      long double _Complex ldc1)
 {}
 
 void callc1b (long double _Complex ldc1, char c, short s, int i,
-	      float _Complex fc1, unsigned int ui, long l,  double _Complex dc1)
+	      float _Complex fc1, unsigned int ui, long long l,  double _Complex dc1)
 {}
 
 
-void callc2a (char c, short s, int i, unsigned int ui, long l, float f,
+void callc2a (char c, short s, int i, unsigned int ui, long long l, float f,
 	      double d, float _Complex fc1, double _Complex dc1,
 	      long double _Complex ldc1)
 {}
 
 void callc2b (float _Complex fc1, char c, short s, int i, unsigned int ui,
-	      long double _Complex ldc1, long l, float f, double d,
+	      long double _Complex ldc1, long long l, float f, double d,
 	      double _Complex dc1)
 {}
 
@@ -290,61 +290,61 @@ void call6k ()
 {
 }
 
-void call6j (unsigned long ul)
+void call6j (unsigned long long ul)
 {
   ul = ul;
     call6k ();
 }
 
-void call6i (unsigned int ui, unsigned long ul)
+void call6i (unsigned int ui, unsigned long long ul)
 {
   ui = ui;
     call6j (ul);
 }
 
-void call6h (unsigned short us, unsigned int ui, unsigned long ul)
+void call6h (unsigned short us, unsigned int ui, unsigned long long ul)
 {
   us = us;
     call6i (ui, ul);
 }
 
-void call6g (unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call6g (unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   uc = uc;
     call6h (us, ui, ul);
 }
 
-void call6f (double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call6f (double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   d = d;
     call6g (uc, us, ui, ul);
 }
 
-void call6e (float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call6e (float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   f = f;
     call6f (d, uc, us, ui, ul);
 }
 
-void call6d (long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call6d (long long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   l = l;
     call6e (f, d, uc, us, ui, ul);
 }
 
-void call6c (int i, long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call6c (int i, long long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   i = i;
     call6d (l, f, d, uc, us, ui, ul);
 }
 
-void call6b (short s, int i, long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call6b (short s, int i, long long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   s = s;
     call6c (i, l, f, d, uc, us, ui, ul);
 }
 
-void call6a (char c, short s, int i, long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call6a (char c, short s, int i, long long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   c = c;
     call6b (s, i, l, f, d, uc, us, ui, ul);
@@ -353,58 +353,58 @@ void call6a (char c, short s, int i, long l, float f, double d, unsigned char uc
 /*  Test shuffling of args, round robin */
 
 
-void call7k (char c, int i, short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui)
+void call7k (char c, int i, short s, long long l, float f, unsigned char uc, double d, unsigned short us, unsigned long long ul, unsigned int ui)
 {
   c = 'a'; i = 7; s = 8; l = 7; f = 0.3; uc = 44; d = 0.44; us = 77;
   ul = 43; ui = 33;
 }
 
-void call7j (unsigned int ui, char c, int i, short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul)
+void call7j (unsigned int ui, char c, int i, short s, long long l, float f, unsigned char uc, double d, unsigned short us, unsigned long long ul)
 {
     call7k (c, i, s, l, f, uc, d, us, ul, ui);
 }
 
-void call7i (unsigned long ul, unsigned int ui, char c, int i, short s, long l, float f, unsigned char uc, double d, unsigned short us)
+void call7i (unsigned long long ul, unsigned int ui, char c, int i, short s, long long l, float f, unsigned char uc, double d, unsigned short us)
 {
     call7j (ui, c, i, s, l, f, uc, d, us, ul);
 }
 
-void call7h (unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s, long l, float f, unsigned char uc, double d)
+void call7h (unsigned short us, unsigned long long ul, unsigned int ui, char c, int i, short s, long long l, float f, unsigned char uc, double d)
 {
     call7i (ul, ui, c, i, s, l, f, uc, d, us);
 }
 
-void call7g (double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s, long l, float f, unsigned char uc)
+void call7g (double d, unsigned short us, unsigned long long ul, unsigned int ui, char c, int i, short s, long long l, float f, unsigned char uc)
 {
     call7h (us, ul, ui, c, i, s, l, f, uc, d);
 }
 
-void call7f (unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s, long l, float f)
+void call7f (unsigned char uc, double d, unsigned short us, unsigned long long ul, unsigned int ui, char c, int i, short s, long long l, float f)
 {
     call7g (d, us, ul, ui, c, i, s, l, f, uc);
 }
 
-void call7e (float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s, long l)
+void call7e (float f, unsigned char uc, double d, unsigned short us, unsigned long long ul, unsigned int ui, char c, int i, short s, long long l)
 {
     call7f (uc, d, us, ul, ui, c, i, s, l, f);
 }
 
-void call7d (long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s)
+void call7d (long long l, float f, unsigned char uc, double d, unsigned short us, unsigned long long ul, unsigned int ui, char c, int i, short s)
 {
     call7e (f, uc, d, us, ul, ui, c, i, s, l);
 }
 
-void call7c (short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i)
+void call7c (short s, long long l, float f, unsigned char uc, double d, unsigned short us, unsigned long long ul, unsigned int ui, char c, int i)
 {
     call7d (l, f, uc, d, us, ul, ui, c, i, s);
 }
 
-void call7b (int i, short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c)
+void call7b (int i, short s, long long l, float f, unsigned char uc, double d, unsigned short us, unsigned long long ul, unsigned int ui, char c)
 {
     call7c (s, l, f, uc, d, us, ul, ui, c, i);
 }
 
-void call7a (char c, int i, short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui)
+void call7a (char c, int i, short s, long long l, float f, unsigned char uc, double d, unsigned short us, unsigned long long ul, unsigned int ui)
 {
     call7b (i, s, l, f, uc, d, us, ul, ui, c);
 }
@@ -417,7 +417,7 @@ typedef struct s
 {
   short s;
   int i;
-  long l;
+  long long l;
 } SVAL;	
 
 void hitbottom ()
@@ -444,7 +444,7 @@ void test_struct_args ()
    calls alloca may do things differently with respect to frames.  So give
    it a try.  */
 
-void localvars_after_alloca (char c, short s, int i, long l)
+void localvars_after_alloca (char c, short s, int i, long long l)
 {
 #ifdef HAVE_STACK_ALLOCA
   /* No need to use the alloca.c alloca-on-top-of-malloc; it doesn't
@@ -459,14 +459,14 @@ void localvars_after_alloca (char c, short s, int i, long l)
   l = 7;
 }
 
-void call_after_alloca_subr (char c, short s, int i, long l, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
+void call_after_alloca_subr (char c, short s, int i, long long l, unsigned char uc, unsigned short us, unsigned int ui, unsigned long long ul)
 {
   c = 'a';
   i = 7; s = 8; l = 7; uc = 44; us = 77;
   ul = 43; ui = 33;
 }
 
-void call_after_alloca (char c, short s, int i, long l)
+void call_after_alloca (char c, short s, int i, long long l)
 {
 #ifdef HAVE_STACK_ALLOCA
   /* No need to use the alloca.c alloca-on-top-of-malloc; it doesn't
@@ -475,7 +475,7 @@ void call_after_alloca (char c, short s, int i, long l)
 
   char *z = alloca (s + 50);
 #endif
-  call_after_alloca_subr (c, s, i, l, 'b', 11, 12, (unsigned long)13);
+  call_after_alloca_subr (c, s, i, l, 'b', 11, 12, (unsigned long long)13);
 }
 
 
@@ -500,7 +500,7 @@ marker_call_with_trampolines () {}
 
 int main ()
 {
-  void (*pointer_to_call0a) (char, short, int, long) = (void (*)(char, short, int, long))call0a;
+  void (*pointer_to_call0a) (char, short, int, long long) = (void (*)(char, short, int, long long))call0a;
   double (*pointer_to_call_with_trampolines) (double) = call_with_trampolines;
 
   /* Test calling with basic integer types */
diff --git a/gdb/testsuite/gdb.base/gnu-ifunc-lib.c b/gdb/testsuite/gdb.base/gnu-ifunc-lib.c
index 7aac81f..c2aab56 100644
--- a/gdb/testsuite/gdb.base/gnu-ifunc-lib.c
+++ b/gdb/testsuite/gdb.base/gnu-ifunc-lib.c
@@ -16,7 +16,7 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 extern volatile int gnu_ifunc_initialized;
-extern volatile unsigned long resolver_hwcap;
+extern volatile unsigned long long resolver_hwcap;
 extern int init_stub (int arg);
 extern int final (int arg);
 
@@ -25,10 +25,10 @@ typedef int (*final_t) (int arg);
 #ifndef IFUNC_RESOLVER_ATTR
 asm (".type gnu_ifunc, %gnu_indirect_function");
 final_t
-gnu_ifunc (unsigned long hwcap)
+gnu_ifunc (unsigned long long hwcap)
 #else
 final_t
-gnu_ifunc_resolver (unsigned long hwcap)
+gnu_ifunc_resolver (unsigned long long hwcap)
 #endif
 {
   resolver_hwcap = hwcap;
diff --git a/gdb/testsuite/gdb.base/gnu-ifunc.c b/gdb/testsuite/gdb.base/gnu-ifunc.c
index a4abaca..a424a8e 100644
--- a/gdb/testsuite/gdb.base/gnu-ifunc.c
+++ b/gdb/testsuite/gdb.base/gnu-ifunc.c
@@ -31,7 +31,7 @@ volatile int gnu_ifunc_initialized;
 
 /* This stores the argument received by the ifunc resolver.  */
 
-volatile unsigned long resolver_hwcap = -1;
+volatile unsigned long long resolver_hwcap = -1;
 
 static void
 gnu_ifunc_pre (void)
diff --git a/gdb/testsuite/gdb.base/infcall-nested-structs.c b/gdb/testsuite/gdb.base/infcall-nested-structs.c
index f024ac6..208b4aa 100644
--- a/gdb/testsuite/gdb.base/infcall-nested-structs.c
+++ b/gdb/testsuite/gdb.base/infcall-nested-structs.c
@@ -33,7 +33,7 @@
 typedef char tc;
 typedef short ts;
 typedef int ti;
-typedef long tl;
+typedef long long tl;
 typedef long long tll;
 typedef float tf;
 typedef double td;
diff --git a/gdb/testsuite/gdb.base/jitreader.c b/gdb/testsuite/gdb.base/jitreader.c
index d385778..7f5c9b9 100644
--- a/gdb/testsuite/gdb.base/jitreader.c
+++ b/gdb/testsuite/gdb.base/jitreader.c
@@ -41,7 +41,7 @@ struct reader_state
 static enum gdb_status
 read_debug_info (struct gdb_reader_funcs *self,
 		 struct gdb_symbol_callbacks *cbs,
-                 void *memory, long memory_sz)
+                 void *memory, long long memory_sz)
 {
   struct jithost_abi *symfile = memory;
   struct gdb_object *object = cbs->object_open (cbs);
diff --git a/gdb/testsuite/gdb.base/long_long.c b/gdb/testsuite/gdb.base/long_long.c
index a82a59a..bd38fdd 100644
--- a/gdb/testsuite/gdb.base/long_long.c
+++ b/gdb/testsuite/gdb.base/long_long.c
@@ -90,7 +90,7 @@ int main() {
    pack (c, sizeof (char), 2);
    pack (s, sizeof (short), 2);
    pack (i, sizeof (int), 2);
-   pack (l, sizeof (long), 2);
+   pack (l, sizeof (long long), 2);
    pack (ll, sizeof (long long), 2);
 
    known_types();
diff --git a/gdb/testsuite/gdb.base/m32rovly.c b/gdb/testsuite/gdb.base/m32rovly.c
index bdb90fe..c49bead 100644
--- a/gdb/testsuite/gdb.base/m32rovly.c
+++ b/gdb/testsuite/gdb.base/m32rovly.c
@@ -7,11 +7,11 @@
 
 /* Local functions and data: */
 
-extern unsigned long _ovly_table[][4];
-extern unsigned long _novlys __attribute__ ((section (".data")));
+extern unsigned long long _ovly_table[][4];
+extern unsigned long long _novlys __attribute__ ((section (".data")));
 enum ovly_index { VMA, SIZE, LMA, MAPPED};
 
-static void ovly_copy (unsigned long dst, unsigned long src, long size);
+static void ovly_copy (unsigned long long dst, unsigned long long src, long long size);
 
 /* Flush the data and instruction caches at address START for SIZE bytes.
    Support for each new port must be added here.  */
@@ -36,9 +36,9 @@ FlushCache (void)
  */
 
 bool
-OverlayLoad (unsigned long ovlyno)
+OverlayLoad (unsigned long long ovlyno)
 {
-  unsigned long i;
+  unsigned long long i;
 
   if (ovlyno < 0 || ovlyno >= _novlys)
     exit (-1);	/* fail, bad ovly number */
@@ -68,7 +68,7 @@ OverlayLoad (unsigned long ovlyno)
  */
  
 bool
-OverlayUnload (unsigned long ovlyno)
+OverlayUnload (unsigned long long ovlyno)
 {
   if (ovlyno < 0 || ovlyno >= _novlys)
     exit (-1);  /* fail, bad ovly number */
@@ -89,13 +89,13 @@ OverlayUnload (unsigned long ovlyno)
 #define DMAP        (*(short *)(0xff04))
 
 static void
-D10VTranslate (unsigned long logical,
+D10VTranslate (unsigned long long logical,
 	       short *dmap,
-	       unsigned long **addr)
+	       unsigned long long **addr)
 {
-  unsigned long physical;
-  unsigned long seg;
-  unsigned long off;
+  unsigned long long physical;
+  unsigned long long seg;
+  unsigned long long off;
 
   /* to access data, we use the following mapping 
      0x00xxxxxx: Logical data address segment        (DMAP translated memory)
@@ -165,16 +165,16 @@ D10VTranslate (unsigned long logical,
     {
     case 0x10:	/* dst is a 15 bit offset into the on-chip memory */
       *dmap = 0;
-      *addr = (long *) (0x0000 + ((short)off & 0x7fff));
+      *addr = (long long *) (0x0000 + ((short)off & 0x7fff));
       break;
     case 0x11:	/* dst is an 18-bit offset into the on-chip
 		   instruction memory */
       *dmap = 0x1000L | ((off & 0x3ffffL) >> 14);
-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));
+      *addr = (long long *) (0x8000 + ((short)off & 0x3fff));
       break;
     case 0x12:	/* dst is a 24-bit offset into unified memory */
       *dmap = off >> 14;
-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));
+      *addr = (long long *) (0x8000 + ((short)off & 0x3fff));
       break;
     default:
       exit (-1);	/* error */
@@ -183,7 +183,7 @@ D10VTranslate (unsigned long logical,
 #endif /* __D10V__ */
 
 static void
-ovly_copy (unsigned long dst, unsigned long src, long size)
+ovly_copy (unsigned long long dst, unsigned long long src, long long size)
 {
 #ifdef  __M32R__
   memcpy ((void *) dst, (void *) src, size);
@@ -191,7 +191,7 @@ ovly_copy (unsigned long dst, unsigned long src, long size)
 #endif /* M32R */
 
 #ifdef  __D10V__
-  unsigned long *s, *d, tmp;
+  unsigned long long *s, *d, tmp;
   short dmap_src, dmap_dst;
   short dmap_save;
 
diff --git a/gdb/testsuite/gdb.base/miscexprs.c b/gdb/testsuite/gdb.base/miscexprs.c
index a9930c1..3b02930 100644
--- a/gdb/testsuite/gdb.base/miscexprs.c
+++ b/gdb/testsuite/gdb.base/miscexprs.c
@@ -16,7 +16,7 @@ main ()
   } ibig;
 
   STORAGE struct {
-    long l[900];
+    long long l[900];
   } lbig;
 
   STORAGE struct {
diff --git a/gdb/testsuite/gdb.base/offsets.c b/gdb/testsuite/gdb.base/offsets.c
index 0735599..fae57a3 100644
--- a/gdb/testsuite/gdb.base/offsets.c
+++ b/gdb/testsuite/gdb.base/offsets.c
@@ -18,7 +18,7 @@
 struct big_struct
 {
   char first[0x10000000 + 16];
-  long second;
+  long long second;
 } big_struct;
 
 int
diff --git a/gdb/testsuite/gdb.base/ovlymgr.c b/gdb/testsuite/gdb.base/ovlymgr.c
index 533606b..a5f89ee 100644
--- a/gdb/testsuite/gdb.base/ovlymgr.c
+++ b/gdb/testsuite/gdb.base/ovlymgr.c
@@ -8,22 +8,22 @@
 #ifdef __SPU__
 /* SPU tool chain provides its own overlay manager.  */
 bool
-OverlayLoad (unsigned long ovlyno)
+OverlayLoad (unsigned long long ovlyno)
 {
 }
 bool
-OverlayUnload (unsigned long ovlyno)
+OverlayUnload (unsigned long long ovlyno)
 {
 }
 #else /* __SPU__ */
 
 /* Local functions and data: */
 
-extern unsigned long _ovly_table[][4];
-extern unsigned long _novlys __attribute__ ((section (".data")));
+extern unsigned long long _ovly_table[][4];
+extern unsigned long long _novlys __attribute__ ((section (".data")));
 enum ovly_index { VMA, SIZE, LMA, MAPPED};
 
-static void ovly_copy (unsigned long dst, unsigned long src, long size);
+static void ovly_copy (unsigned long long dst, unsigned long long src, long long size);
 
 /* Flush the data and instruction caches at address START for SIZE bytes.
    Support for each new port must be added here.  */
@@ -57,9 +57,9 @@ _ovly_debug_event (void)
  */
 
 bool
-OverlayLoad (unsigned long ovlyno)
+OverlayLoad (unsigned long long ovlyno)
 {
-  unsigned long i;
+  unsigned long long i;
 
   if (ovlyno < 0 || ovlyno >= _novlys)
     exit (-1);	/* fail, bad ovly number */
@@ -89,7 +89,7 @@ OverlayLoad (unsigned long ovlyno)
  */
  
 bool
-OverlayUnload (unsigned long ovlyno)
+OverlayUnload (unsigned long long ovlyno)
 {
   if (ovlyno < 0 || ovlyno >= _novlys)
     exit (-1);  /* fail, bad ovly number */
@@ -111,13 +111,13 @@ OverlayUnload (unsigned long ovlyno)
 #define DMAP        (*(short *)(0xff04))
 
 static void
-D10VTranslate (unsigned long logical,
+D10VTranslate (unsigned long long logical,
 	       short *dmap,
-	       unsigned long **addr)
+	       unsigned long long **addr)
 {
-  unsigned long physical;
-  unsigned long seg;
-  unsigned long off;
+  unsigned long long physical;
+  unsigned long long seg;
+  unsigned long long off;
 
   /* to access data, we use the following mapping 
      0x00xxxxxx: Logical data address segment        (DMAP translated memory)
@@ -187,16 +187,16 @@ D10VTranslate (unsigned long logical,
     {
     case 0x10:	/* dst is a 15 bit offset into the on-chip memory */
       *dmap = 0;
-      *addr = (long *) (0x0000 + ((short)off & 0x7fff));
+      *addr = (long long *) (0x0000 + ((short)off & 0x7fff));
       break;
     case 0x11:	/* dst is an 18-bit offset into the on-chip
 		   instruction memory */
       *dmap = 0x1000L | ((off & 0x3ffffL) >> 14);
-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));
+      *addr = (long long *) (0x8000 + ((short)off & 0x3fff));
       break;
     case 0x12:	/* dst is a 24-bit offset into unified memory */
       *dmap = off >> 14;
-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));
+      *addr = (long long *) (0x8000 + ((short)off & 0x3fff));
       break;
     default:
       exit (-1);	/* error */
@@ -205,10 +205,10 @@ D10VTranslate (unsigned long logical,
 #endif /* __D10V__ */
 
 static void
-ovly_copy (unsigned long dst, unsigned long src, long size)
+ovly_copy (unsigned long long dst, unsigned long long src, long long size)
 {
 #ifdef  __D10V__
-  unsigned long *s, *d, tmp;
+  unsigned long long *s, *d, tmp;
   short dmap_src, dmap_dst;
   short dmap_save;
 
diff --git a/gdb/testsuite/gdb.base/ovlymgr.h b/gdb/testsuite/gdb.base/ovlymgr.h
index bd0d40a..60dbd30 100644
--- a/gdb/testsuite/gdb.base/ovlymgr.h
+++ b/gdb/testsuite/gdb.base/ovlymgr.h
@@ -12,6 +12,6 @@ typedef enum { FALSE, TRUE } bool;
 
 /* Entry Points: */
 
-bool OverlayLoad   PARAMS((unsigned long ovlyno));
-bool OverlayUnload PARAMS((unsigned long ovlyno));
+bool OverlayLoad   PARAMS((unsigned long long ovlyno));
+bool OverlayUnload PARAMS((unsigned long long ovlyno));
 
diff --git a/gdb/testsuite/gdb.base/pointers.c b/gdb/testsuite/gdb.base/pointers.c
index 96f2b52..35add64 100644
--- a/gdb/testsuite/gdb.base/pointers.c
+++ b/gdb/testsuite/gdb.base/pointers.c
@@ -15,9 +15,9 @@ int		v_int;
 signed int	v_signed_int;
 unsigned int	v_unsigned_int;
 
-long		v_long;
-signed long	v_signed_long;
-unsigned long	v_unsigned_long;
+long long		v_long;
+signed long long	v_signed_long;
+unsigned long long	v_unsigned_long;
 
 float		v_float;
 double		v_double;
@@ -37,9 +37,9 @@ int             *v_int_pointer2;
 signed int	*v_signed_int_pointer;
 unsigned int	*v_unsigned_int_pointer;
 
-long		*v_long_pointer;
-signed long	*v_signed_long_pointer;
-unsigned long	*v_unsigned_long_pointer;
+long long		*v_long_pointer;
+signed long long	*v_signed_long_pointer;
+unsigned long long	*v_unsigned_long_pointer;
 
 float		*v_float_pointer;
 double		*v_double_pointer;
@@ -57,9 +57,9 @@ int		v_int_array[2];
 signed int	v_signed_int_array[2];
 unsigned int	v_unsigned_int_array[2];
 
-long		v_long_array[2];
-signed long	v_signed_long_array[2];
-unsigned long	v_unsigned_long_array[2];
+long long		v_long_array[2];
+signed long long	v_signed_long_array[2];
+unsigned long long	v_unsigned_long_array[2];
 
 float		v_float_array[2];
 double		v_double_array[2];
@@ -72,7 +72,7 @@ float ** ptr_to_ptr_to_float;
 int y;
 
 
-typedef long k[5];
+typedef long long k[5];
 
 typedef struct {
   k array_variable;
@@ -185,8 +185,8 @@ int more_code()
     unsigned short US, *pUS;
     int I, *pI;
     unsigned int UI, *pUI;
-    long L, *pL;
-    unsigned long UL, *pUL;
+    long long L, *pL;
+    unsigned long long UL, *pUL;
     float F, *pF;
     double D, *pD;
 
diff --git a/gdb/testsuite/gdb.base/ptype.c b/gdb/testsuite/gdb.base/ptype.c
index 4148da7..0d21c75 100644
--- a/gdb/testsuite/gdb.base/ptype.c
+++ b/gdb/testsuite/gdb.base/ptype.c
@@ -24,9 +24,9 @@ int		v_int;
 signed int	v_signed_int;
 unsigned int	v_unsigned_int;
 
-long		v_long;
-signed long	v_signed_long;
-unsigned long	v_unsigned_long;
+long long		v_long;
+signed long long	v_signed_long;
+unsigned long long	v_unsigned_long;
 
 float		v_float;
 double		v_double;
@@ -50,9 +50,9 @@ int		v_int_array[2];
 signed int	v_signed_int_array[2];
 unsigned int	v_unsigned_int_array[2];
 
-long		v_long_array[2];
-signed long	v_signed_long_array[2];
-unsigned long	v_unsigned_long_array[2];
+long long		v_long_array[2];
+signed long long	v_signed_long_array[2];
+unsigned long long	v_unsigned_long_array[2];
 
 float		v_float_array[2];
 double		v_double_array[2];
@@ -75,9 +75,9 @@ int		*v_int_pointer;
 signed int	*v_signed_int_pointer;
 unsigned int	*v_unsigned_int_pointer;
 
-long		*v_long_pointer;
-signed long	*v_signed_long_pointer;
-unsigned long	*v_unsigned_long_pointer;
+long long		*v_long_pointer;
+signed long long	*v_signed_long_pointer;
+unsigned long long	*v_unsigned_long_pointer;
 
 float		*v_float_pointer;
 double		*v_double_pointer;
@@ -88,7 +88,7 @@ struct t_struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_struct1;
@@ -99,7 +99,7 @@ struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_struct2;
@@ -119,7 +119,7 @@ union t_union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_union;
@@ -128,7 +128,7 @@ union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_union2;
@@ -156,9 +156,9 @@ int		v_int_func () { return (0); }
 signed int	v_signed_int_func () { return (0); }
 unsigned int	v_unsigned_int_func () { return (0); }
 
-long		v_long_func () { return (0); }
-signed long	v_signed_long_func () { return (0); }
-unsigned long	v_unsigned_long_func () { return (0); }
+long long		v_long_func () { return (0); }
+signed long long	v_signed_long_func () { return (0); }
+unsigned long long	v_unsigned_long_func () { return (0); }
 
 float		v_float_func () { return (0.0); }
 double		v_double_func () { return (0.0); }
@@ -189,13 +189,13 @@ struct outer_struct {
 	int outer_int;
 	struct inner_struct {
 		int inner_int;
-		long inner_long;
+		long long inner_long;
 	}inner_struct_instance;
 	union inner_union {
 		int inner_union_int;
-		long inner_union_long;
+		long long inner_union_long;
 	}inner_union_instance;
-	long outer_long;
+	long long outer_long;
 } nested_su;
 
 struct highest
@@ -246,7 +246,7 @@ int (*fptr) (int, float);
 int *(*fptr2) (int (*) (int, float), float);
 int (*xptr) (int (*) (), int (*) (void), int);
 int (*(*ffptr) (char)) (short);
-int (*(*(*fffptr) (char)) (short)) (long);
+int (*(*(*fffptr) (char)) (short)) (long long);
 
 func_type v_func_type;
 
diff --git a/gdb/testsuite/gdb.base/remote.c b/gdb/testsuite/gdb.base/remote.c
index a43c40b..75b726a 100644
--- a/gdb/testsuite/gdb.base/remote.c
+++ b/gdb/testsuite/gdb.base/remote.c
@@ -6189,6 +6189,6 @@ unsigned char random_data[RANDOM_DATA_SIZE] = {
 int
 main() 
 {
-  long size = sizeof (random_data) / sizeof (random_data[0]);
+  long long size = sizeof (random_data) / sizeof (random_data[0]);
   printf ("%d\n", random_data [size - 1]);
 }
diff --git a/gdb/testsuite/gdb.base/return2.c b/gdb/testsuite/gdb.base/return2.c
index 58d85ec..ec51349 100644
--- a/gdb/testsuite/gdb.base/return2.c
+++ b/gdb/testsuite/gdb.base/return2.c
@@ -6,7 +6,7 @@ int main_test = 0;
 char      char_returnval      = '1';
 short     short_returnval     = 1;
 int       int_returnval       = 1;
-long      long_returnval      = 1;
+long long      long_returnval      = 1;
 long long long_long_returnval = 1;
 float     float_returnval     = 1;
 double    double_returnval    = 1;
@@ -15,7 +15,7 @@ union {
   char      char_testval;
   short     short_testval;
   int       int_testval;
-  long      long_testval;
+  long long      long_testval;
   long long long_long_testval;
   float     float_testval;
   double    double_testval;
@@ -42,7 +42,7 @@ int int_func ()
   return int_returnval;
 }
 
-long long_func ()
+long long long_func ()
 {
   return long_returnval;
 }
@@ -67,7 +67,7 @@ int main (int argc, char **argv)
   char char_resultval;
   short short_resultval;
   int int_resultval;
-  long long_resultval;
+  long long long_resultval;
   long long long_long_resultval;
   float float_resultval;
   double double_resultval;
diff --git a/gdb/testsuite/gdb.base/sepdebug.c b/gdb/testsuite/gdb.base/sepdebug.c
index 2f4dd4b..34b5e00 100644
--- a/gdb/testsuite/gdb.base/sepdebug.c
+++ b/gdb/testsuite/gdb.base/sepdebug.c
@@ -26,7 +26,7 @@
 int marker1 (void) { return (0); }
 int marker2 (int a) { return (1); } /* set breakpoint 8 here */
 void marker3 (char *a, char *b) {}
-void marker4 (long d) {} /* set breakpoint 14 here */
+void marker4 (long long d) {} /* set breakpoint 14 here */
 
 /*
  *	This simple classical example of recursion is useful for
diff --git a/gdb/testsuite/gdb.base/setvar.c b/gdb/testsuite/gdb.base/setvar.c
index 1b8d808..dc11d23 100644
--- a/gdb/testsuite/gdb.base/setvar.c
+++ b/gdb/testsuite/gdb.base/setvar.c
@@ -34,9 +34,9 @@ int		v_int;
 signed int	v_signed_int;
 unsigned int	v_unsigned_int;
 
-long		v_long;
-signed long	v_signed_long;
-unsigned long	v_unsigned_long;
+long long		v_long;
+signed long long	v_signed_long;
+unsigned long long	v_unsigned_long;
 
 float		v_float;
 double		v_double;
@@ -60,9 +60,9 @@ int		v_int_array[2];
 signed int	v_signed_int_array[2];
 unsigned int	v_unsigned_int_array[2];
 
-long		v_long_array[2];
-signed long	v_signed_long_array[2];
-unsigned long	v_unsigned_long_array[2];
+long long		v_long_array[2];
+signed long long	v_signed_long_array[2];
+unsigned long long	v_unsigned_long_array[2];
 
 float		v_float_array[2];
 double		v_double_array[2];
@@ -81,9 +81,9 @@ int		*v_int_pointer;
 signed int	*v_signed_int_pointer;
 unsigned int	*v_unsigned_int_pointer;
 
-long		*v_long_pointer;
-signed long	*v_signed_long_pointer;
-unsigned long	*v_unsigned_long_pointer;
+long long		*v_long_pointer;
+signed long long	*v_signed_long_pointer;
+unsigned long long	*v_unsigned_long_pointer;
 
 float		*v_float_pointer;
 double		*v_double_pointer;
@@ -94,7 +94,7 @@ struct t_struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_struct1;
@@ -103,14 +103,14 @@ struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_struct2;
 
 struct
 {
-  long v_long_member;
+  long long v_long_member;
   struct t_struct t;
   char v_char_member;
 } v_struct3;
@@ -121,7 +121,7 @@ union t_union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_union;
@@ -130,7 +130,7 @@ union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
     float	v_float_member;
     double	v_double_member;
 } v_union2;
@@ -149,9 +149,9 @@ int		v_int_func () { return (0); }
 signed int	v_signed_int_func () { return (0); }
 unsigned int	v_unsigned_int_func () { return (0); }
 
-long		v_long_func () { return (0); }
-signed long	v_signed_long_func () { return (0); }
-unsigned long	v_unsigned_long_func () { return (0); }
+long long		v_long_func () { return (0); }
+signed long long	v_signed_long_func () { return (0); }
+unsigned long long	v_unsigned_long_func () { return (0); }
 
 float		v_float_func () { return (0.0); }
 double		v_double_func () { return (0.0); }
diff --git a/gdb/testsuite/gdb.base/sigbpt.c b/gdb/testsuite/gdb.base/sigbpt.c
index 7b7ff6f..a690000 100644
--- a/gdb/testsuite/gdb.base/sigbpt.c
+++ b/gdb/testsuite/gdb.base/sigbpt.c
@@ -24,11 +24,11 @@ keeper (int sig)
 {
 }
 
-volatile long v1 = 0;
-volatile long v2 = 0;
-volatile long v3 = 0;
+volatile long long v1 = 0;
+volatile long long v2 = 0;
+volatile long long v3 = 0;
 
-extern long
+extern long long
 bowler (void)
 {
   /* Try to read address zero.  Do it in a slightly convoluted way so
diff --git a/gdb/testsuite/gdb.base/signest.c b/gdb/testsuite/gdb.base/signest.c
index d815aeb..c32d603 100644
--- a/gdb/testsuite/gdb.base/signest.c
+++ b/gdb/testsuite/gdb.base/signest.c
@@ -22,7 +22,7 @@
 
 volatile char *p = NULL;
 
-extern long
+extern long long
 bowler (void)
 {
   return *p;
diff --git a/gdb/testsuite/gdb.base/signull.c b/gdb/testsuite/gdb.base/signull.c
index 194288e..1e4b640 100644
--- a/gdb/testsuite/gdb.base/signull.c
+++ b/gdb/testsuite/gdb.base/signull.c
@@ -28,8 +28,8 @@ static volatile enum tests test;
 
 /* Some basic types and zero buffers.  */
 
-typedef long data_t;
-typedef long code_t (void);
+typedef long long data_t;
+typedef long long code_t (void);
 data_t *volatile data;
 code_t *volatile code;
 /* "desc" is intentionally initialized to a data object.  This is
@@ -45,7 +45,7 @@ keeper (int sig)
   siglongjmp (env, 0);
 }
 
-extern long
+extern long long
 bowler (void)
 {
   switch (test)
diff --git a/gdb/testsuite/gdb.base/sizeof.c b/gdb/testsuite/gdb.base/sizeof.c
index fde5213..38a4fdb 100644
--- a/gdb/testsuite/gdb.base/sizeof.c
+++ b/gdb/testsuite/gdb.base/sizeof.c
@@ -20,7 +20,7 @@ struct {
 
 struct {
   padding p1;
-  long v;
+  long long v;
   padding p2;
 } padding_long;
 
@@ -49,7 +49,7 @@ struct {
 } padding_long_double;
 
 static void
-fill (void *buf, long sizeof_buf)
+fill (void *buf, long long sizeof_buf)
 {
   char *p = buf;
   int i;
@@ -103,7 +103,7 @@ main ()
   size = (int) sizeof (char);
   size = (int) sizeof (short);
   size = (int) sizeof (int);
-  size = (int) sizeof (long);
+  size = (int) sizeof (long long);
   size = (int) sizeof (long long);
   size = (int) sizeof (void*);
   size = (int) sizeof (void (*)(void));
diff --git a/gdb/testsuite/gdb.base/store.c b/gdb/testsuite/gdb.base/store.c
index 545515d..01f541a 100644
--- a/gdb/testsuite/gdb.base/store.c
+++ b/gdb/testsuite/gdb.base/store.c
@@ -27,8 +27,8 @@ add_int (register int u, register int v)
   return u + v;
 }
 
-long
-add_long (register long u, register long v)
+long long
+add_long (register long long u, register long long v)
 {
   return u + v;
 }
@@ -87,15 +87,15 @@ wack_int (register int u, register int v)
   return l + r;
 }
 
-long
-wack_long (register long u, register long v)
+long long
+wack_long (register long long u, register long long v)
 {
-  register long l = u, r = v;
+  register long long l = u, r = v;
   l = add_long (l, r);
   return l + r;
 }
 
-long
+long long
 wack_longest (register longest u, register longest v)
 {
   register longest l = u, r = v;
diff --git a/gdb/testsuite/gdb.base/structs.c b/gdb/testsuite/gdb.base/structs.c
index 680b009..289d741 100644
--- a/gdb/testsuite/gdb.base/structs.c
+++ b/gdb/testsuite/gdb.base/structs.c
@@ -20,7 +20,7 @@ typedef void t;
 typedef char tc;
 typedef short ts;
 typedef int ti;
-typedef long tl;
+typedef long long tl;
 typedef long long tll;
 typedef float tf;
 typedef double td;
diff --git a/gdb/testsuite/gdb.base/type-opaque-main.c b/gdb/testsuite/gdb.base/type-opaque-main.c
index f1c4f41..8a6a6bb 100644
--- a/gdb/testsuite/gdb.base/type-opaque-main.c
+++ b/gdb/testsuite/gdb.base/type-opaque-main.c
@@ -25,7 +25,7 @@ struct struct_libtype_empty
 
 struct struct_libtype_filled
   {
-    long mainfield_filled;
+    long long mainfield_filled;
   };    
 
 union union_libtype_opaque;
@@ -36,7 +36,7 @@ union union_libtype_empty
 
 union union_libtype_filled
   {
-    long mainfield_filled;
+    long long mainfield_filled;
   };    
 
 int main (void)
@@ -48,7 +48,7 @@ int main (void)
   volatile union union_libtype_empty *pointer_union_empty = (void *) 0;
   volatile union union_libtype_filled *pointer_union_filled = (void *) 0;
 
-  return (long) pointer_struct_opaque + (long) pointer_struct_empty
-	 + (long) pointer_struct_filled + (long) pointer_union_opaque
-	 + (long) pointer_union_empty + (long) pointer_union_filled;
+  return (long long) pointer_struct_opaque + (long long) pointer_struct_empty
+	 + (long long) pointer_struct_filled + (long long) pointer_union_opaque
+	 + (long long) pointer_union_empty + (long long) pointer_union_filled;
 }
diff --git a/gdb/testsuite/gdb.base/vla-datatypes.c b/gdb/testsuite/gdb.base/vla-datatypes.c
index 97fb249..2f10a9e 100644
--- a/gdb/testsuite/gdb.base/vla-datatypes.c
+++ b/gdb/testsuite/gdb.base/vla-datatypes.c
@@ -36,8 +36,8 @@ vla_factory (int n)
   unsigned int    unsigned_int_vla[n];
   double          double_vla[n];
   float           float_vla[n];
-  long            long_vla[n];
-  unsigned long   unsigned_long_vla[n];
+  long long            long_vla[n];
+  unsigned long long   unsigned_long_vla[n];
   char            char_vla[n];
   short           short_vla[n];
   unsigned short  unsigned_short_vla[n];
diff --git a/gdb/testsuite/gdb.base/watch-bitfields.c b/gdb/testsuite/gdb.base/watch-bitfields.c
index c0184c5..69d3690 100644
--- a/gdb/testsuite/gdb.base/watch-bitfields.c
+++ b/gdb/testsuite/gdb.base/watch-bitfields.c
@@ -17,14 +17,14 @@
 
 struct foo
 {
-  unsigned long a:1;
+  unsigned long long a:1;
   unsigned char b:2;
-  unsigned long c:3;
+  unsigned long long c:3;
   char d:4;
   int e:5;
   char f:6;
   int g:7;
-  long h:8;
+  long long h:8;
 } q = { 0 };
 
 int
diff --git a/gdb/testsuite/gdb.base/watch_thread_num.c b/gdb/testsuite/gdb.base/watch_thread_num.c
index a48a45b..1ffedc5 100644
--- a/gdb/testsuite/gdb.base/watch_thread_num.c
+++ b/gdb/testsuite/gdb.base/watch_thread_num.c
@@ -39,7 +39,7 @@ int main () {
     int res;
     pthread_t threads[NUM];
     void *thread_result;
-    long i;
+    long long i;
 
     pthread_barrier_init (&threads_started_barrier, NULL, NUM + 1);
 
@@ -64,7 +64,7 @@ loop (void)
 }
 
 void *thread_function (void *arg) {
-    int my_number = (long) arg;
+    int my_number = (long long) arg;
 
     pthread_barrier_wait (&threads_started_barrier);
 
diff --git a/gdb/testsuite/gdb.base/wchar.c b/gdb/testsuite/gdb.base/wchar.c
index 3746728..0555691 100644
--- a/gdb/testsuite/gdb.base/wchar.c
+++ b/gdb/testsuite/gdb.base/wchar.c
@@ -28,18 +28,18 @@ main (void)
   int i;
   wchar_t narrow = 97;
   wchar_t single = 0xbeef;
-  wchar_t simple[] = L"facile";
+  wchar_t simple[] = U"facile";
   wchar_t difficile[] = { 0xdead, 0xbeef, 0xfeed, 0xface};
   wchar_t mixed[] = {L'f', 0xdead, L'a', L'c', 0xfeed, 0xface};
-  wchar_t *cent = L"\242";
+  wchar_t *cent = U"\242";
   wchar_t repeat[128];
   wchar_t *repeat_p = repeat;
 
   repeat[0] = 0;
-  wcscat (repeat, L"A");
+  wcscat (repeat, U"A");
   for (i = 0; i < 21; ++i)
     wcscat (repeat, cent);
-  wcscat (repeat, L"B");
+  wcscat (repeat, U"B");
 
   do_nothing (&narrow); /* START */
   do_nothing (&single);
diff --git a/gdb/testsuite/gdb.base/whatis.c b/gdb/testsuite/gdb.base/whatis.c
index b28ea3b..5b15813 100644
--- a/gdb/testsuite/gdb.base/whatis.c
+++ b/gdb/testsuite/gdb.base/whatis.c
@@ -36,9 +36,9 @@ int		v_int;
 signed int	v_signed_int;
 unsigned int	v_unsigned_int;
 
-long		v_long;
-signed long	v_signed_long;
-unsigned long	v_unsigned_long;
+long long		v_long;
+signed long long	v_signed_long;
+unsigned long long	v_unsigned_long;
 
 #ifndef NO_LONG_LONG
 long long		v_long_long;
@@ -68,9 +68,9 @@ int		v_int_array[2];
 signed int	v_signed_int_array[2];
 unsigned int	v_unsigned_int_array[2];
 
-long		v_long_array[2];
-signed long	v_signed_long_array[2];
-unsigned long	v_unsigned_long_array[2];
+long long		v_long_array[2];
+signed long long	v_signed_long_array[2];
+unsigned long long	v_unsigned_long_array[2];
 
 #ifndef NO_LONG_LONG
 long long		v_long_long_array[2];
@@ -91,7 +91,7 @@ typedef char *char_addr;
 char_addr a_char_addr;
 typedef unsigned short *ushort_addr;
 ushort_addr a_ushort_addr;
-typedef signed long *slong_addr;
+typedef signed long long *slong_addr;
 slong_addr a_slong_addr;
 #ifndef NO_LONG_LONG
 typedef signed long long *slong_long_addr;
@@ -110,9 +110,9 @@ int		*v_int_pointer;
 signed int	*v_signed_int_pointer;
 unsigned int	*v_unsigned_int_pointer;
 
-long		*v_long_pointer;
-signed long	*v_signed_long_pointer;
-unsigned long	*v_unsigned_long_pointer;
+long long		*v_long_pointer;
+signed long long	*v_signed_long_pointer;
+unsigned long long	*v_unsigned_long_pointer;
 
 #ifndef NO_LONG_LONG
 long long		*v_long_long_pointer;
@@ -129,7 +129,7 @@ struct t_struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
 #ifndef NO_LONG_LONG
     long long	v_long_long_member;
 #endif
@@ -141,7 +141,7 @@ struct {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
 #ifndef NO_LONG_LONG
     long long	v_long_long_member;
 #endif
@@ -155,7 +155,7 @@ union t_union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
 #ifndef NO_LONG_LONG
     long long	v_long_long_member;
 #endif
@@ -167,7 +167,7 @@ union {
     char	v_char_member;
     short	v_short_member;
     int		v_int_member;
-    long	v_long_member;
+    long long	v_long_member;
 #ifndef NO_LONG_LONG
     long long	v_long_long_member;
 #endif
@@ -189,9 +189,9 @@ int		v_int_func () { return (0); }
 signed int	v_signed_int_func () { return (0); }
 unsigned int	v_unsigned_int_func () { return (0); }
 
-long		v_long_func () { return (0); }
-signed long	v_signed_long_func () { return (0); }
-unsigned long	v_unsigned_long_func () { return (0); }
+long long		v_long_func () { return (0); }
+signed long long	v_signed_long_func () { return (0); }
+unsigned long long	v_unsigned_long_func () { return (0); }
 
 #ifndef NO_LONG_LONG
 long long		v_long_long_func () { return (0); }
@@ -228,13 +228,13 @@ struct outer_struct {
 	int outer_int;
 	struct inner_struct {
 		int inner_int;
-		long inner_long;
+		long long inner_long;
 	}inner_struct_instance;
 	union inner_union {
 		int inner_union_int;
-		long inner_union_long;
+		long long inner_union_long;
 	}inner_union_instance;
-	long outer_long;
+	long long outer_long;
 } nested_su;
 
 /**** Enumerations *******/
diff --git a/gdb/testsuite/gdb.cell/bt.c b/gdb/testsuite/gdb.cell/bt.c
index bcaa0b3..33d10b9 100644
--- a/gdb/testsuite/gdb.cell/bt.c
+++ b/gdb/testsuite/gdb.cell/bt.c
@@ -41,7 +41,7 @@ spe_thread (void * arg)
 }
 
 int
-indirect_handler (unsigned char *base, unsigned long offset)
+indirect_handler (unsigned char *base, unsigned long long offset)
 {
   int flags = 0;
   unsigned int entry = SPE_DEFAULT_ENTRY;
@@ -57,7 +57,7 @@ static pthread_mutex_t crash_mutex = PTHREAD_MUTEX_INITIALIZER;
 static int crash_count = 0;
 
 int
-crash_handler (unsigned char *base, unsigned long offset)
+crash_handler (unsigned char *base, unsigned long long offset)
 {
   int count;
 
diff --git a/gdb/testsuite/gdb.cell/data-spu.c b/gdb/testsuite/gdb.cell/data-spu.c
index 94a4e0c..96392c1 100644
--- a/gdb/testsuite/gdb.cell/data-spu.c
+++ b/gdb/testsuite/gdb.cell/data-spu.c
@@ -26,7 +26,7 @@ main (unsigned long long speid, unsigned long long argp,
   char var_char = 'c';
   short var_short = 7;
   int var_int = 1337;
-  long var_long = 123456;
+  long long var_long = 123456;
   long long var_longlong = 123456789;
   float var_float = 1.23;
   double var_double = 2.3456;
diff --git a/gdb/testsuite/gdb.cell/data.c b/gdb/testsuite/gdb.cell/data.c
index 3331897..26fca64 100644
--- a/gdb/testsuite/gdb.cell/data.c
+++ b/gdb/testsuite/gdb.cell/data.c
@@ -49,7 +49,7 @@ int main (void)
   char var_char = 'c';
   short var_short = 7;
   int var_int = 1337;
-  long var_long = 123456;
+  long long var_long = 123456;
   long long var_longlong = 123456789;
   float var_float = 1.23;
   double var_double = 2.3456;
diff --git a/gdb/testsuite/gdb.cell/ea-cache-spu.c b/gdb/testsuite/gdb.cell/ea-cache-spu.c
index eeaec9f..a403416 100644
--- a/gdb/testsuite/gdb.cell/ea-cache-spu.c
+++ b/gdb/testsuite/gdb.cell/ea-cache-spu.c
@@ -29,7 +29,7 @@ main (unsigned long long speid, unsigned long long argp,
   printf ("spe.c | argp = 0x%llx\n", argp);
 
 #ifdef __EA32__
-  ppe_int_ptr = (__ea int *)(unsigned long)argp;
+  ppe_int_ptr = (__ea int *)(unsigned long long)argp;
 #else
   ppe_int_ptr = (__ea int *)argp;
 #endif
diff --git a/gdb/testsuite/gdb.cell/size-spu.c b/gdb/testsuite/gdb.cell/size-spu.c
index 83356a3..dfaa643 100644
--- a/gdb/testsuite/gdb.cell/size-spu.c
+++ b/gdb/testsuite/gdb.cell/size-spu.c
@@ -33,7 +33,7 @@ main (unsigned long long speid, unsigned long long argp,
   int i  = sizeof (int);
   printf ("sizeof(int)=%d\n", i);
 
-  int l  = sizeof (long);
+  int l  = sizeof (long long);
   printf ("sizeof(long)=%d\n", l);
 
   int ll = sizeof (long long);
diff --git a/gdb/testsuite/gdb.cell/size.c b/gdb/testsuite/gdb.cell/size.c
index 274fe27..f6a0de5 100644
--- a/gdb/testsuite/gdb.cell/size.c
+++ b/gdb/testsuite/gdb.cell/size.c
@@ -55,7 +55,7 @@ main (void)
   int i  = sizeof (int);
   printf ("sizeof(int)=%d\n", i);
 
-  int l  = sizeof (long);
+  int l  = sizeof (long long);
   printf ("sizeof(long)=%d\n", l);
 
   int ll = sizeof (long long);
diff --git a/gdb/testsuite/gdb.compile/compile.c b/gdb/testsuite/gdb.compile/compile.c
index cbe9358..92dfd53 100644
--- a/gdb/testsuite/gdb.compile/compile.c
+++ b/gdb/testsuite/gdb.compile/compile.c
@@ -36,8 +36,8 @@ struct struct_type {
   int intfield;
   unsigned int uintfield;
   unsigned int bitfield : 3;
-  long longfield;
-  unsigned long ulongfield;
+  long long longfield;
+  unsigned long long ulongfield;
   enum enum_type enumfield;
   float floatfield;
   double doublefield;
@@ -70,7 +70,7 @@ enum ulonger_enum_type ulonger;
 
 enum longer_enum_type {
   MINUS_1 = -1,
-  FORCE_TO_LONG = 1L << ((8 * sizeof (long)) - 2)
+  FORCE_TO_LONG = 1L << ((8 * sizeof (long long)) - 2)
 };
 
 enum longer_enum_type longer;
diff --git a/gdb/testsuite/gdb.dwarf2/clztest.c b/gdb/testsuite/gdb.dwarf2/clztest.c
index 5fad7ec..a1bfa25 100644
--- a/gdb/testsuite/gdb.dwarf2/clztest.c
+++ b/gdb/testsuite/gdb.dwarf2/clztest.c
@@ -3,21 +3,21 @@
 
 volatile int vv;
 
-__attribute__((noinline, noclone)) long
-foo (long x)
+__attribute__((noinline, noclone)) long long
+foo (long long x)
 {
-  long f = __builtin_clzl (x);
-  long g = f;
+  long long f = __builtin_clzl (x);
+  long long g = f;
   asm volatile ("" : "+r" (f));
   vv++;		/* { dg-final { gdb-test 12 "g" "43" } } */
   return f;	/* { dg-final { gdb-test 12 "f" "43" } } */
 }
 
-__attribute__((noinline, noclone)) long
-bar (long x)
+__attribute__((noinline, noclone)) long long
+bar (long long x)
 {
-  long f = __builtin_clzl (x);
-  long g = f;
+  long long f = __builtin_clzl (x);
+  long long g = f;
   asm volatile ("" : "+r" (f));
   vv++;		/* { dg-final { gdb-test 22 "g" "33" } } */
   return f;	/* { dg-final { gdb-test 22 "f" "33" } } */
@@ -26,7 +26,7 @@ bar (long x)
 int
 main ()
 {
-  long x = vv;
+  long long x = vv;
   foo (x + 0x123456UL);
   bar (x + 0x7fffffffUL);
   return 0;
diff --git a/gdb/testsuite/gdb.mi/mi-var-child.c b/gdb/testsuite/gdb.mi/mi-var-child.c
index 03a216a..99f08cb 100644
--- a/gdb/testsuite/gdb.mi/mi-var-child.c
+++ b/gdb/testsuite/gdb.mi/mi-var-child.c
@@ -48,17 +48,17 @@ typedef struct _struct_decl {
   int   integer;
   char  character;
   char *char_ptr;
-  long  long_int;
+  long long  long_int;
   int  **int_ptr_ptr;
-  long  long_array[12];
+  long long  long_array[12];
 
   void (*func_ptr) (void);
-  struct _struct_decl (*func_ptr_struct) (int, char *, long);
-  struct _struct_decl *(*func_ptr_ptr) (int, char *, long);
+  struct _struct_decl (*func_ptr_struct) (int, char *, long long);
+  struct _struct_decl *(*func_ptr_ptr) (int, char *, long long);
   union {
     int   a;
     char *b;
-    long  c;
+    long long  c;
     enum foo d;
   } u1;
 
@@ -71,7 +71,7 @@ typedef struct _struct_decl {
         efoo foo;
       } u1s1;
 
-      long f;
+      long long f;
       struct {
         char array_ptr[2];
         int (*func) (int, char *);
@@ -80,20 +80,20 @@ typedef struct _struct_decl {
 
     int g;
     char h;
-    long i[10];
+    long long i[10];
   } s2;
 } weird_struct;
 
 struct _struct_n_pointer {
   char ****char_ptr;
-  long ****long_ptr;
+  long long ****long_ptr;
   struct _struct_n_pointer *ptrs[3];
   struct _struct_n_pointer *next;
 };
 
 void do_locals_tests (void);
 void do_block_tests (void);
-void subroutine1 (int, long *);
+void subroutine1 (int, long long *);
 void nothing (void);
 void do_children_tests (void);
 void do_special_tests (void);
@@ -112,8 +112,8 @@ do_locals_tests ()
   int *lpinteger;
   char lcharacter;
   char *lpcharacter;
-  long llong;
-  long *lplong;
+  long long llong;
+  long long *lplong;
   float lfloat;
   float *lpfloat;
   double ldouble;
@@ -161,7 +161,7 @@ nothing ()
 }
 
 struct _struct_decl
-nothing1 (int a, char *b, long c)
+nothing1 (int a, char *b, long long c)
 {
   struct _struct_decl foo;
 
@@ -169,13 +169,13 @@ nothing1 (int a, char *b, long c)
 }
 
 struct _struct_decl *
-nothing2 (int a, char *b, long c)
+nothing2 (int a, char *b, long long c)
 {
   return (struct _struct_decl *) 0;
 }
 
 void
-subroutine1 (int i, long *l)
+subroutine1 (int i, long long *l)
 {
   global_simple.integer = i + 3;
   i = 212;
@@ -214,9 +214,9 @@ do_children_tests (void)
   char a0[2] = {}, *a1, **a2, ***a3;
   char b0[2] = {}, *b1, **b2, ***b3;
   char c0[2] = {}, *c1, **c2, ***c3;
-  long z0, *z1, **z2, ***z3;
-  long y0, *y1, **y2, ***y3;
-  long x0, *x1, **x2, ***x3;
+  long long z0, *z1, **z2, ***z3;
+  long long y0, *y1, **y2, ***y3;
+  long long x0, *x1, **x2, ***x3;
   int *foo;
   int bar;
 
@@ -309,13 +309,13 @@ do_special_tests (void)
   union {
     int a;
     char b;
-    long c;
+    long long c;
   } anonu;
   struct _simple_struct s;
   struct {
     int a;
     char b;
-    long c;
+    long long c;
   } anons;
   enum foo e;
   enum { A, B, C } anone;
diff --git a/gdb/testsuite/gdb.mi/nsintrall.c b/gdb/testsuite/gdb.mi/nsintrall.c
index b836b82..c6857a2 100644
--- a/gdb/testsuite/gdb.mi/nsintrall.c
+++ b/gdb/testsuite/gdb.mi/nsintrall.c
@@ -30,7 +30,7 @@ int main() {
     int res;
     pthread_t threads[NUM];
     void *thread_result;
-    long i;
+    long long i;
 
     for (i = 1; i <= NUM; i++)
       {
@@ -49,7 +49,7 @@ int main() {
 }
 
 void *thread_function(void *arg) {
-    int my_number =  (long) arg;
+    int my_number =  (long long) arg;
     int *myp = (int *) &args[my_number];
 
     /* Don't run forever.  Run just short of it :)  */
diff --git a/gdb/testsuite/gdb.mi/nsmoribund.c b/gdb/testsuite/gdb.mi/nsmoribund.c
index f155354..94504a3 100644
--- a/gdb/testsuite/gdb.mi/nsmoribund.c
+++ b/gdb/testsuite/gdb.mi/nsmoribund.c
@@ -29,7 +29,7 @@ volatile int done = 0;
 void *
 thread_function (void *arg)
 {
-  int my_number = (long) arg;
+  int my_number = (long long) arg;
   volatile int *myp = (volatile int *) &args[my_number];
 
   /* Don't run forever.  Run just short of it :)  */
@@ -51,7 +51,7 @@ main (int argc, char **argv)
   int res;
   pthread_t *threads;
   void *thread_result;
-  long i = 0;
+  long long i = 0;
 
   threads = malloc (THREADS * sizeof (pthread_t));
   args = malloc (THREADS * sizeof (unsigned int));
diff --git a/gdb/testsuite/gdb.mi/var-cmd.c b/gdb/testsuite/gdb.mi/var-cmd.c
index 2eb6add..d17a134 100644
--- a/gdb/testsuite/gdb.mi/var-cmd.c
+++ b/gdb/testsuite/gdb.mi/var-cmd.c
@@ -48,17 +48,17 @@ typedef struct _struct_decl {
   int   integer;
   char  character;
   char *char_ptr;
-  long  long_int;
+  long long  long_int;
   int  **int_ptr_ptr;
-  long  long_array[10];
+  long long  long_array[10];
 
   void (*func_ptr) (void);
-  struct _struct_decl (*func_ptr_struct) (int, char *, long);
-  struct _struct_decl *(*func_ptr_ptr) (int, char *, long);
+  struct _struct_decl (*func_ptr_struct) (int, char *, long long);
+  struct _struct_decl *(*func_ptr_ptr) (int, char *, long long);
   union {
     int   a;
     char *b;
-    long  c;
+    long long  c;
     enum foo d;
   } u1;
 
@@ -71,7 +71,7 @@ typedef struct _struct_decl {
         efoo foo;
       } u1s1;
 
-      long f;
+      long long f;
       struct {
         char array_ptr[2];
         int (*func) (int, char *);
@@ -80,13 +80,13 @@ typedef struct _struct_decl {
 
     int g;
     char h;
-    long i[10];
+    long long i[10];
   } s2;
 } weird_struct;
 
 struct _struct_n_pointer {
   char ****char_ptr;
-  long ****long_ptr;
+  long long ****long_ptr;
   struct _struct_n_pointer *ptrs[3];
   struct _struct_n_pointer *next;
 };
@@ -111,7 +111,7 @@ struct anonymous {
 
 void do_locals_tests (void);
 void do_block_tests (void);
-void subroutine1 (int, long *);
+void subroutine1 (int, long long *);
 void nothing (void);
 void do_children_tests (void);
 void do_special_tests (void);
@@ -134,8 +134,8 @@ do_locals_tests ()
   int *lpinteger = 0;
   char lcharacter[2] = { 0, 0 };
   char *lpcharacter = 0;
-  long llong = 0;
-  long *lplong = 0;
+  long long llong = 0;
+  long long *lplong = 0;
   float lfloat = 0;
   float *lpfloat = 0;
   double ldouble = 0;
@@ -183,7 +183,7 @@ nothing ()
 }
 
 struct _struct_decl
-nothing1 (int a, char *b, long c)
+nothing1 (int a, char *b, long long c)
 {
   struct _struct_decl foo;
 
@@ -191,13 +191,13 @@ nothing1 (int a, char *b, long c)
 }
 
 struct _struct_decl *
-nothing2 (int a, char *b, long c)
+nothing2 (int a, char *b, long long c)
 {
   return (struct _struct_decl *) 0;
 }
 
 void
-subroutine1 (int i, long *l)
+subroutine1 (int i, long long *l)
 {
   global_simple.integer = i + 3;
   i = 212;
@@ -236,9 +236,9 @@ do_children_tests (void)
   char a0[2] = {}, *a1, **a2, ***a3;
   char b0[2] = {}, *b1, **b2, ***b3;
   char c0[2] = {}, *c1, **c2, ***c3;
-  long z0, *z1, **z2, ***z3;
-  long y0, *y1, **y2, ***y3;
-  long x0, *x1, **x2, ***x3;
+  long long z0, *z1, **z2, ***z3;
+  long long y0, *y1, **y2, ***y3;
+  long long x0, *x1, **x2, ***x3;
   int *foo;
   int bar;
 
@@ -330,13 +330,13 @@ do_special_tests (void)
   union {
     int a;
     char b;
-    long c;
+    long long c;
   } anonu;
   struct _simple_struct s;
   struct {
     int a;
     char b;
-    long c;
+    long long c;
   } anons;
   enum foo e;
   enum { A, B, C } anone;
diff --git a/gdb/testsuite/gdb.multi/multi-term-settings.c b/gdb/testsuite/gdb.multi/multi-term-settings.c
index c96779e..82a90b2 100644
--- a/gdb/testsuite/gdb.multi/multi-term-settings.c
+++ b/gdb/testsuite/gdb.multi/multi-term-settings.c
@@ -38,7 +38,7 @@ main ()
     {
       struct termios termios;
 
-      printf ("pid=%ld, count=%d\n", (long) getpid (), count++);
+      printf ("pid=%ld, count=%d\n", (long long) getpid (), count++);
 
       /* This generates a SIGTTOU if our progress group is not in the
 	 foreground.  */
diff --git a/gdb/testsuite/gdb.perf/backtrace.c b/gdb/testsuite/gdb.perf/backtrace.c
index d331d9c..985922a 100644
--- a/gdb/testsuite/gdb.perf/backtrace.c
+++ b/gdb/testsuite/gdb.perf/backtrace.c
@@ -28,7 +28,7 @@ fun2 (void)
 }
 
 static void
-fun1 (int i, int j, long k, struct s ss)
+fun1 (int i, int j, long long k, struct s ss)
 {
   /* Allocate local variables on stack.  */
   struct s s1;
diff --git a/gdb/testsuite/gdb.python/py-pp-integral.c b/gdb/testsuite/gdb.python/py-pp-integral.c
index c289498..e6718e8 100644
--- a/gdb/testsuite/gdb.python/py-pp-integral.c
+++ b/gdb/testsuite/gdb.python/py-pp-integral.c
@@ -15,7 +15,7 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */
 
-typedef long time_t;
+typedef long long time_t;
 
 static void
 tick_tock (time_t *t)
diff --git a/gdb/testsuite/gdb.python/py-pp-re-notag.c b/gdb/testsuite/gdb.python/py-pp-re-notag.c
index c289498..e6718e8 100644
--- a/gdb/testsuite/gdb.python/py-pp-re-notag.c
+++ b/gdb/testsuite/gdb.python/py-pp-re-notag.c
@@ -15,7 +15,7 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */
 
-typedef long time_t;
+typedef long long time_t;
 
 static void
 tick_tock (time_t *t)
diff --git a/gdb/testsuite/gdb.reverse/finish-reverse.c b/gdb/testsuite/gdb.reverse/finish-reverse.c
index 040bcbf..4a51cd5 100644
--- a/gdb/testsuite/gdb.reverse/finish-reverse.c
+++ b/gdb/testsuite/gdb.reverse/finish-reverse.c
@@ -23,7 +23,7 @@ int main_test = 0;
 char      char_returnval      = '1';
 short     short_returnval     = 1;
 int       int_returnval       = 1;
-long      long_returnval      = 1;
+long long      long_returnval      = 1;
 long long long_long_returnval = 1;
 float     float_returnval     = 1;
 double    double_returnval    = 1;
@@ -32,7 +32,7 @@ union {
   char      char_testval;
   short     short_testval;
   int       int_testval;
-  long      long_testval;
+  long long      long_testval;
   long long long_long_testval;
   float     float_testval;
   double    double_testval;
@@ -59,7 +59,7 @@ int int_func ()
   return int_returnval;		/* INT FUNC */
 }
 
-long long_func ()
+long long long_func ()
 {
   return long_returnval;	/* LONG FUNC */
 }
@@ -84,7 +84,7 @@ int main (int argc, char **argv)
   char char_resultval;
   short short_resultval;
   int int_resultval;
-  long long_resultval;
+  long long long_resultval;
   long long long_long_resultval;
   float float_resultval;
   double double_resultval;
diff --git a/gdb/testsuite/gdb.reverse/insn-reverse-x86.c b/gdb/testsuite/gdb.reverse/insn-reverse-x86.c
index 5c90099..0abab1f 100644
--- a/gdb/testsuite/gdb.reverse/insn-reverse-x86.c
+++ b/gdb/testsuite/gdb.reverse/insn-reverse-x86.c
@@ -163,7 +163,7 @@ void
 rdseed (void)
 {
   /* Get a random seed from the rdseed assembly instruction.  */
-  register long seed;
+  register long long seed;
 
   if (!supports_rdseed)
     return;
diff --git a/gdb/testsuite/gdb.reverse/until-reverse.c b/gdb/testsuite/gdb.reverse/until-reverse.c
index 52f458f..a3a366e 100644
--- a/gdb/testsuite/gdb.reverse/until-reverse.c
+++ b/gdb/testsuite/gdb.reverse/until-reverse.c
@@ -21,7 +21,7 @@
 extern int marker1 (void);
 extern int marker2 (int a);
 extern void marker3 (char *a, char *b);
-extern void marker4 (long d);
+extern void marker4 (long long d);
 
 /*
  *	This simple classical example of recursion is useful for
diff --git a/gdb/testsuite/gdb.reverse/ur1.c b/gdb/testsuite/gdb.reverse/ur1.c
index 64afb33..5d302e0 100644
--- a/gdb/testsuite/gdb.reverse/ur1.c
+++ b/gdb/testsuite/gdb.reverse/ur1.c
@@ -29,7 +29,7 @@
 int marker1 (void) { return (0); }	/* set breakpoint 15 here */
 int marker2 (int a) { return (1); }	/* set breakpoint 8 here */
 void marker3 (char *a, char *b) {}	/* set breakpoint 17 here */
-void marker4 (long d) {}		/* set breakpoint 14 here */
+void marker4 (long long d) {}		/* set breakpoint 14 here */
 
 /* A structure we use for field name completion tests.  */
 struct some_struct
diff --git a/gdb/testsuite/gdb.threads/create-fail.c b/gdb/testsuite/gdb.threads/create-fail.c
index 601a243..bf8614c 100644
--- a/gdb/testsuite/gdb.threads/create-fail.c
+++ b/gdb/testsuite/gdb.threads/create-fail.c
@@ -85,7 +85,7 @@ main ()
       /* Should fail with EINVAL at some point.  */
       if (ret != 0)
 	{
-	  unsigned long t;
+	  unsigned long long t;
 
 	  fprintf (stderr, "pthread_create: %d: %s\n", ret, strerror (ret));
 
diff --git a/gdb/testsuite/gdb.threads/ia64-sigill.c b/gdb/testsuite/gdb.threads/ia64-sigill.c
index fd3aaba..f7dc03a 100644
--- a/gdb/testsuite/gdb.threads/ia64-sigill.c
+++ b/gdb/testsuite/gdb.threads/ia64-sigill.c
@@ -173,11 +173,11 @@ proc_string (const char *filename, const char *line)
   exit (EXIT_FAILURE);
 }
 
-static unsigned long
+static unsigned long long
 proc_ulong (const char *filename, const char *line)
 {
   const char *s = proc_string (filename, line);
-  long retval;
+  long long retval;
   char *end;
 
   errno = 0;
@@ -199,7 +199,7 @@ state_wait (pid_t process, const char *wanted)
   struct timespec start, now;
   const char *state;
 
-  i = asprintf (&filename, "/proc/%lu/status", (unsigned long) process);
+  i = asprintf (&filename, "/proc/%lu/status", (unsigned long long) process);
   assert (i > 0);
 
   i = clock_gettime (CLOCK_MONOTONIC, &start);
@@ -234,7 +234,7 @@ state_wait (pid_t process, const char *wanted)
   while (now.tv_sec - start.tv_sec < TIMEOUT);
 
   fprintf (stderr, "Timed out waiting for PID %lu \"%s\" (now it is \"%s\")!\n",
-	   (unsigned long) process, wanted, state);
+	   (unsigned long long) process, wanted, state);
   exit (EXIT_FAILURE);
 }
 
@@ -244,7 +244,7 @@ static pthread_t thread1, thread2;
 static void
 cleanup (void)
 {
-  printf ("Resuming GDB PID %lu.\n", (unsigned long) tracer);
+  printf ("Resuming GDB PID %lu.\n", (unsigned long long) tracer);
 
   if (tracer)
     {
@@ -309,7 +309,7 @@ main (int argc, char **argv)
      Need to wait for that before stopping GDB.  */
   pthread_barrier_wait (&threads_started_barrier);
 
-  printf ("Stopping GDB PID %lu.\n", (unsigned long) tracer);
+  printf ("Stopping GDB PID %lu.\n", (unsigned long long) tracer);
 
   if (tracer)
     {
@@ -338,8 +338,8 @@ main (int argc, char **argv)
     }
 
   printf ("Thread 1 TID = %lu, thread 2 TID = %lu, PID = %lu.\n",
-	  (unsigned long) thread1_tid, (unsigned long) thread2_tid,
-	  (unsigned long) getpid ());
+	  (unsigned long long) thread1_tid, (unsigned long long) thread2_tid,
+	  (unsigned long long) getpid ());
 
   printf ("Waiting till the threads get trapped by the breakpoint.\n");
 
diff --git a/gdb/testsuite/gdb.threads/linux-dp.c b/gdb/testsuite/gdb.threads/linux-dp.c
index 6458920..9ad1142 100644
--- a/gdb/testsuite/gdb.threads/linux-dp.c
+++ b/gdb/testsuite/gdb.threads/linux-dp.c
@@ -81,7 +81,7 @@ shared_random ()
 }
 
 void
-my_usleep (long usecs)
+my_usleep (long long usecs)
 {
   struct timeval timeout;
   
diff --git a/gdb/testsuite/gdb.threads/local-watch-wrong-thread.c b/gdb/testsuite/gdb.threads/local-watch-wrong-thread.c
index 6ac39ad..ac0154d 100644
--- a/gdb/testsuite/gdb.threads/local-watch-wrong-thread.c
+++ b/gdb/testsuite/gdb.threads/local-watch-wrong-thread.c
@@ -27,7 +27,7 @@ int trigger = 0;
 void *
 thread_function0 (void *arg)
 {
-  int my_number =  (long) arg;
+  int my_number =  (long long) arg;
   volatile int *myp = (volatile int *) &args[my_number];
 
   while (*myp > 0)
@@ -50,7 +50,7 @@ thread_function0_1 (void *arg)
 void *
 thread_function1 (void *arg)
 {
-  int my_number =  (long) arg;
+  int my_number =  (long long) arg;
 
   volatile int *myp = (volatile int *) &args[my_number];
 
@@ -69,7 +69,7 @@ main ()
   int res;
   pthread_t threads[2];
   void *thread_result;
-  long i = 0;
+  long long i = 0;
 
   args[i] = 1; /* Init value.  */
   res = pthread_create (&threads[i], NULL,
diff --git a/gdb/testsuite/gdb.threads/multiple-step-overs.c b/gdb/testsuite/gdb.threads/multiple-step-overs.c
index 8b82878..15f9c52 100644
--- a/gdb/testsuite/gdb.threads/multiple-step-overs.c
+++ b/gdb/testsuite/gdb.threads/multiple-step-overs.c
@@ -38,7 +38,7 @@ callme (void)
 void *
 child_function_3 (void *arg)
 {
-  int my_number =  (long) arg;
+  int my_number =  (long long) arg;
   volatile int *myp = (int *) &args[my_number];
 
   pthread_barrier_wait (&barrier);
@@ -55,7 +55,7 @@ child_function_3 (void *arg)
 void *
 child_function_2 (void *arg)
 {
-  int my_number =  (long) arg;
+  int my_number =  (long long) arg;
   volatile int *myp = (int *) &args[my_number];
 
   pthread_barrier_wait (&barrier);
@@ -79,7 +79,7 @@ int
 main ()
 {
   int res;
-  long i;
+  long long i;
 
   signal (SIGUSR1, sigusr1_handler);
 
diff --git a/gdb/testsuite/gdb.threads/multiple-successive-infcall.c b/gdb/testsuite/gdb.threads/multiple-successive-infcall.c
index 9bdb9a2..8b3783e 100644
--- a/gdb/testsuite/gdb.threads/multiple-successive-infcall.c
+++ b/gdb/testsuite/gdb.threads/multiple-successive-infcall.c
@@ -46,7 +46,7 @@ get_value ()
 }
 
 /* Return the nth Fibonacci number.  */
-static unsigned long
+static unsigned long long
 fast_fib (unsigned int n)
 {
   int a = 0;
@@ -71,7 +71,7 @@ thread_function (void *args)
   if (status == PTHREAD_BARRIER_SERIAL_THREAD)
     printf ("All threads entering compute region\n");
 
-  unsigned long result = fast_fib (100); /* testmarker01 */
+  unsigned long long result = fast_fib (100); /* testmarker01 */
   status = pthread_barrier_wait (&print_barrier);
   if (status == PTHREAD_BARRIER_SERIAL_THREAD)
     printf ("All threads outputting results\n");
diff --git a/gdb/testsuite/gdb.threads/pending-step.c b/gdb/testsuite/gdb.threads/pending-step.c
index 11da5a0..7fce93c 100644
--- a/gdb/testsuite/gdb.threads/pending-step.c
+++ b/gdb/testsuite/gdb.threads/pending-step.c
@@ -29,7 +29,7 @@ int main() {
     int res;
     pthread_t threads[NUM];
     void *thread_result;
-    long i;
+    long long i;
 
     for (i = 1; i <= NUM; i++)
       {
@@ -48,7 +48,7 @@ int main() {
 }
 
 void *thread_function(void *arg) {
-    int my_number =  (long) arg;
+    int my_number =  (long long) arg;
     int *myp = (int *) &args[my_number];
 
     /* Don't run forever.  Run just short of it :)  */
diff --git a/gdb/testsuite/gdb.threads/pthreads.c b/gdb/testsuite/gdb.threads/pthreads.c
index eb5255b..7a9a0ef 100644
--- a/gdb/testsuite/gdb.threads/pthreads.c
+++ b/gdb/testsuite/gdb.threads/pthreads.c
@@ -60,10 +60,10 @@ thread1 (void *arg)
   int i;
   int z = 0;
 
-  if (verbose) printf ("thread1 (%0lx) ; pid = %d\n", (long) arg, getpid ());
+  if (verbose) printf ("thread1 (%0lx) ; pid = %d\n", (long long) arg, getpid ());
   for (i=1; i <= 10000000; i++)
     {
-      if (verbose) printf("thread1 %ld\n", (long) pthread_self ());
+      if (verbose) printf("thread1 %ld\n", (long long) pthread_self ());
       z += i;
       common_routine (1);
       sleep(1);
@@ -77,10 +77,10 @@ thread2 (void * arg)
   int i;
   int k = 0;
 
-  if (verbose) printf ("thread2 (%0lx) ; pid = %d\n", (long) arg, getpid ());
+  if (verbose) printf ("thread2 (%0lx) ; pid = %d\n", (long long) arg, getpid ());
   for (i=1; i <= 10000000; i++)
     {
-      if (verbose) printf("thread2 %ld\n", (long) pthread_self ());
+      if (verbose) printf("thread2 %ld\n", (long long) pthread_self ());
       k += i;
       common_routine (2);
       sleep(1);
@@ -132,7 +132,7 @@ main(argc, argv)
       perror ("pthread_create 1");
       exit (1);
     }
-  if (verbose) printf ("Made thread %ld\n", (long) tid1);
+  if (verbose) printf ("Made thread %ld\n", (long long) tid1);
   sleep (1);
 
   if (pthread_create (&tid2, NULL, thread2, (void *) 0xdeadbeef))
@@ -140,13 +140,13 @@ main(argc, argv)
       perror ("pthread_create 2");
       exit (1);
     }
-  if (verbose) printf("Made thread %ld\n", (long) tid2);
+  if (verbose) printf("Made thread %ld\n", (long long) tid2);
 
   sleep (1);
 
   for (j = 1; j <= 10000000; j++)
     {
-      if (verbose) printf("top %ld\n", (long) pthread_self ());
+      if (verbose) printf("top %ld\n", (long long) pthread_self ());
       common_routine (0);
       sleep(1);
       t += j;
diff --git a/gdb/testsuite/gdb.threads/schedlock.c b/gdb/testsuite/gdb.threads/schedlock.c
index dea2bd6..5c4b256 100644
--- a/gdb/testsuite/gdb.threads/schedlock.c
+++ b/gdb/testsuite/gdb.threads/schedlock.c
@@ -30,7 +30,7 @@ int main() {
     int res;
     pthread_t threads[NUM];
     void *thread_result;
-    long i;
+    long long i;
 
     for (i = 1; i <= NUM; i++)
       {
@@ -71,7 +71,7 @@ volatile int call_function = 0;
     } while (0)
 
 void *thread_function(void *arg) {
-    int my_number =  (long) arg;
+    int my_number =  (long long) arg;
     int *myp = (int *) &args[my_number];
 
     /* Don't run forever.  Run just short of it :)  */
diff --git a/gdb/testsuite/gdb.threads/siginfo-threads.c b/gdb/testsuite/gdb.threads/siginfo-threads.c
index a048c51..e2ad28d 100644
--- a/gdb/testsuite/gdb.threads/siginfo-threads.c
+++ b/gdb/testsuite/gdb.threads/siginfo-threads.c
@@ -119,7 +119,7 @@ handler (int signo, siginfo_t *siginfo, void *exception)
   if (*varp)
     {
       fprintf (stderr, "Signal %d for TID %lu has been already hit!\n", signo,
-	       (unsigned long) gettid ());
+	       (unsigned long long) gettid ());
       exit (EXIT_FAILURE);
     }
   *varp = 1;
@@ -242,11 +242,11 @@ proc_string (const char *filename, const char *line)
   exit (EXIT_FAILURE);
 }
 
-static unsigned long
+static unsigned long long
 proc_ulong (const char *filename, const char *line)
 {
   const char *s = proc_string (filename, line);
-  long retval;
+  long long retval;
   char *end;
 
   errno = 0;
@@ -268,7 +268,7 @@ state_wait (pid_t process, const char *wanted)
   struct timespec start, now;
   const char *state;
 
-  i = asprintf (&filename, "/proc/%lu/status", (unsigned long) process);
+  i = asprintf (&filename, "/proc/%lu/status", (unsigned long long) process);
   assert (i > 0);
 
   i = clock_gettime (CLOCK_MONOTONIC, &start);
@@ -303,7 +303,7 @@ state_wait (pid_t process, const char *wanted)
   while (now.tv_sec - start.tv_sec < TIMEOUT);
 
   fprintf (stderr, "Timed out waiting for PID %lu \"%s\" (now it is \"%s\")!\n",
-	   (unsigned long) process, wanted, state);
+	   (unsigned long long) process, wanted, state);
   exit (EXIT_FAILURE);
 }
 
@@ -313,7 +313,7 @@ static pthread_t thread1, thread2;
 static void
 cleanup (void)
 {
-  printf ("Resuming GDB PID %lu.\n", (unsigned long) tracer);
+  printf ("Resuming GDB PID %lu.\n", (unsigned long long) tracer);
 
   if (tracer)
     {
@@ -393,7 +393,7 @@ main (int argc, char **argv)
      Need to wait for that before stopping GDB.  */
   pthread_barrier_wait (&threads_started_barrier);
 
-  printf ("Stopping GDB PID %lu.\n", (unsigned long) tracer);
+  printf ("Stopping GDB PID %lu.\n", (unsigned long long) tracer);
 
   if (tracer)
     {
@@ -423,8 +423,8 @@ main (int argc, char **argv)
     }
 
   printf ("Thread 1 TID = %lu, thread 2 TID = %lu, PID = %lu.\n",
-	  (unsigned long) thread1_tid, (unsigned long) thread2_tid,
-	  (unsigned long) getpid ());
+	  (unsigned long long) thread1_tid, (unsigned long long) thread2_tid,
+	  (unsigned long long) getpid ());
 
   errno = 0;
   i = tgkill (getpid (), thread1_tid, SIGUSR1);
diff --git a/gdb/testsuite/gdb.threads/signal-while-stepping-over-bp-other-thread.c b/gdb/testsuite/gdb.threads/signal-while-stepping-over-bp-other-thread.c
index a1b7854..35d9de1 100644
--- a/gdb/testsuite/gdb.threads/signal-while-stepping-over-bp-other-thread.c
+++ b/gdb/testsuite/gdb.threads/signal-while-stepping-over-bp-other-thread.c
@@ -40,7 +40,7 @@ callme (void)
 void *
 child_function_3 (void *arg)
 {
-  int my_number =  (long) arg;
+  int my_number =  (long long) arg;
   volatile int *myp = (int *) &args[my_number];
 
   pthread_barrier_wait (&barrier);
@@ -57,7 +57,7 @@ child_function_3 (void *arg)
 void *
 child_function_2 (void *arg)
 {
-  int my_number =  (long) arg;
+  int my_number =  (long long) arg;
   volatile int *myp = (int *) &args[my_number];
 
   pthread_barrier_wait (&barrier);
@@ -83,7 +83,7 @@ int
 main ()
 {
   int res;
-  long i;
+  long long i;
 
   signal (SIGUSR1, handler);
 
diff --git a/gdb/testsuite/gdb.threads/step-over-lands-on-breakpoint.c b/gdb/testsuite/gdb.threads/step-over-lands-on-breakpoint.c
index 3f91246..27260f4 100644
--- a/gdb/testsuite/gdb.threads/step-over-lands-on-breakpoint.c
+++ b/gdb/testsuite/gdb.threads/step-over-lands-on-breakpoint.c
@@ -45,7 +45,7 @@ int
 main ()
 {
   int res;
-  long i;
+  long long i;
 
   alarm (300);
 
diff --git a/gdb/testsuite/gdb.threads/step-over-trips-on-watchpoint.c b/gdb/testsuite/gdb.threads/step-over-trips-on-watchpoint.c
index 0be44c1..ffd8bbd 100644
--- a/gdb/testsuite/gdb.threads/step-over-trips-on-watchpoint.c
+++ b/gdb/testsuite/gdb.threads/step-over-trips-on-watchpoint.c
@@ -47,7 +47,7 @@ int
 main ()
 {
   int res;
-  long i;
+  long long i;
 
   alarm (300);
 
diff --git a/gdb/testsuite/gdb.threads/thread-specific.c b/gdb/testsuite/gdb.threads/thread-specific.c
index aa36710..02153eb 100644
--- a/gdb/testsuite/gdb.threads/thread-specific.c
+++ b/gdb/testsuite/gdb.threads/thread-specific.c
@@ -28,7 +28,7 @@ int main() {
     int res;
     pthread_t threads[2];
     void *thread_result;
-    long i = 1;
+    long long i = 1;
 
     args[0] = 1;
     res = pthread_create(&threads[0],
@@ -50,7 +50,7 @@ int main() {
 }
 
 void *thread_function(void *arg) {
-    int my_number =  (long) arg;
+    int my_number =  (long long) arg;
     int *myp = (int *) &args[my_number];
 
     /* Don't run forever.  Run just short of it :)  */
diff --git a/gdb/testsuite/gdb.threads/thread_check.c b/gdb/testsuite/gdb.threads/thread_check.c
index 4d80d4e..4afd3b6 100644
--- a/gdb/testsuite/gdb.threads/thread_check.c
+++ b/gdb/testsuite/gdb.threads/thread_check.c
@@ -29,17 +29,17 @@
 static void *
 tf (void *arg)
 {
-    int n = (int) (long int) arg;
+    int n = (int) (long long int) arg;
     char number[160];
     int unslept = 10;
 
-    sprintf(number, "tf(%ld): begin", (long)arg);
+    sprintf(number, "tf(%ld): begin", (long long)arg);
     puts (number);
 
     while (unslept > 0)
         unslept = sleep(unslept);
 
-    sprintf(number, "tf(%ld): end", (long)arg);
+    sprintf(number, "tf(%ld): end", (long long)arg);
     puts (number);
     return NULL;
 }
@@ -51,7 +51,7 @@ int main (int argc, char *argv[])
     pthread_t th[N];
 
     for (n = 0; n < N; ++n)
-    if (pthread_create (&th[n], NULL, tf, (void *) (long int) n) != 0)
+    if (pthread_create (&th[n], NULL, tf, (void *) (long long int) n) != 0)
     {
         while (unslept > 0)
            unslept = sleep(2);
diff --git a/gdb/testsuite/gdb.threads/threadapply.c b/gdb/testsuite/gdb.threads/threadapply.c
index 49edfbb..b6ebe96 100644
--- a/gdb/testsuite/gdb.threads/threadapply.c
+++ b/gdb/testsuite/gdb.threads/threadapply.c
@@ -33,7 +33,7 @@ int main() {
     int all_started;
     pthread_t threads[NUM];
     void *thread_result;
-    long i;
+    long long i;
 
     for (i = 0; i < NUM; i++)
       {
@@ -66,7 +66,7 @@ int main() {
 }
 
 void *thread_function(void *arg) {
-    int my_number =  (long) arg;
+    int my_number =  (long long) arg;
     int *myp = (int *) &args[my_number];
 
     /* Don't run forever.  Run just short of it :)  */
diff --git a/gdb/testsuite/gdb.threads/tid-reuse.c b/gdb/testsuite/gdb.threads/tid-reuse.c
index 1741325..8cacf3c 100644
--- a/gdb/testsuite/gdb.threads/tid-reuse.c
+++ b/gdb/testsuite/gdb.threads/tid-reuse.c
@@ -24,10 +24,10 @@
 #include <limits.h>
 
 /* How many threads fit in the target's thread number space.  */
-long tid_max = -1;
+long long tid_max = -1;
 
 /* Number of threads spawned.  */
-unsigned long thread_counter;
+unsigned long long thread_counter;
 
 /* How long it takes to spawn as many threads as fits in the thread
    number space.  On systems where thread IDs are just monotonically
diff --git a/gdb/testsuite/gdb.threads/tls.c b/gdb/testsuite/gdb.threads/tls.c
index 9a87e91..b707aa3 100644
--- a/gdb/testsuite/gdb.threads/tls.c
+++ b/gdb/testsuite/gdb.threads/tls.c
@@ -72,7 +72,7 @@ void print_error ()
 /* Routine for each thread to run, does nothing.  */
 void *spin( void *vp )
 {
-    int me = (long) vp;
+    int me = (long long) vp;
     int i;
     
     /* Use a_global. */
@@ -161,7 +161,7 @@ do_pass()
     /* Start N_THREADS threads, then join them so that they are terminated.  */
     for( i = 0; i < N_THREADS; i++ )
      {
-        err = pthread_create( &t[i], NULL, spin, (void *) (long) i );
+        err = pthread_create( &t[i], NULL, spin, (void *) (long long) i );
         if( err != 0 ) {
             fprintf(stderr, "Error in thread %d create\n", i );
         }
diff --git a/gdb/testsuite/gdb.threads/watchthreads-reorder.c b/gdb/testsuite/gdb.threads/watchthreads-reorder.c
index 91d2c11..6cd7d46 100644
--- a/gdb/testsuite/gdb.threads/watchthreads-reorder.c
+++ b/gdb/testsuite/gdb.threads/watchthreads-reorder.c
@@ -182,11 +182,11 @@ proc_string (const char *filename, const char *line)
   exit (EXIT_FAILURE);
 }
 
-static unsigned long
+static unsigned long long
 proc_ulong (const char *filename, const char *line)
 {
   const char *s = proc_string (filename, line);
-  long retval;
+  long long retval;
   char *end;
 
   errno = 0;
@@ -208,7 +208,7 @@ state_wait (pid_t process, const char *wanted)
   struct timespec start, now;
   const char *state;
 
-  i = asprintf (&filename, "/proc/%lu/status", (unsigned long) process);
+  i = asprintf (&filename, "/proc/%lu/status", (unsigned long long) process);
   assert (i > 0);
 
   i = clock_gettime (CLOCK_MONOTONIC, &start);
@@ -243,7 +243,7 @@ state_wait (pid_t process, const char *wanted)
   while (now.tv_sec - start.tv_sec < TIMEOUT);
 
   fprintf (stderr, "Timed out waiting for PID %lu \"%s\" (now it is \"%s\")!\n",
-	   (unsigned long) process, wanted, state);
+	   (unsigned long long) process, wanted, state);
   exit (EXIT_FAILURE);
 }
 
@@ -253,7 +253,7 @@ static pthread_t thread1, thread2;
 static void
 cleanup (void)
 {
-  printf ("Resuming GDB PID %lu.\n", (unsigned long) tracer);
+  printf ("Resuming GDB PID %lu.\n", (unsigned long long) tracer);
 
   if (tracer)
     {
@@ -318,7 +318,7 @@ main (int argc, char **argv)
      Need to wait for that before stopping GDB.  */
   pthread_barrier_wait (&threads_started_barrier);
 
-  printf ("Stopping GDB PID %lu.\n", (unsigned long) tracer);
+  printf ("Stopping GDB PID %lu.\n", (unsigned long long) tracer);
 
   if (tracer)
     {
@@ -347,8 +347,8 @@ main (int argc, char **argv)
     }
 
   printf ("Thread 1 TID = %lu, thread 2 TID = %lu, PID = %lu.\n",
-	  (unsigned long) thread1_tid, (unsigned long) thread2_tid,
-	  (unsigned long) getpid ());
+	  (unsigned long long) thread1_tid, (unsigned long long) thread2_tid,
+	  (unsigned long long) getpid ());
 
   printf ("Waiting till the threads get trapped by the watchpoints.\n");
 
diff --git a/gdb/testsuite/gdb.threads/watchthreads.c b/gdb/testsuite/gdb.threads/watchthreads.c
index 229ff36..adcb1a5 100644
--- a/gdb/testsuite/gdb.threads/watchthreads.c
+++ b/gdb/testsuite/gdb.threads/watchthreads.c
@@ -34,7 +34,7 @@ main ()
     int res;
     pthread_t threads[NUM];
     void *thread_result;
-    long i;
+    long long i;
 
     /* To keep the test determinative, initialize args first,
        then start all the threads.  Otherwise, the way watchthreads.exp
@@ -65,7 +65,7 @@ main ()
 void *
 thread_function (void *arg)
 {
-    int my_number =  (long) arg;
+    int my_number =  (long long) arg;
     int *myp = (int *) &args[my_number];
 
     /* Don't run forever.  Run just short of it :)  */
diff --git a/gdb/testsuite/gdb.threads/watchthreads2.c b/gdb/testsuite/gdb.threads/watchthreads2.c
index 9909e0c..142ee57 100644
--- a/gdb/testsuite/gdb.threads/watchthreads2.c
+++ b/gdb/testsuite/gdb.threads/watchthreads2.c
@@ -104,7 +104,7 @@ thread_function (void *arg)
     {
       pthread_mutex_lock (&x_mutex);
       /* For debugging.  */
-      printf ("Thread %ld changing x %d -> %d\n", (long) arg, x, x + 1);
+      printf ("Thread %ld changing x %d -> %d\n", (long long) arg, x, x + 1);
       /* The call to usleep is so that when the watchpoint triggers,
 	 the pc is still on the same line.  */
       ++x; usleep (1);  /* X increment.  */
diff --git a/gdb/testsuite/gdb.threads/wp-replication.c b/gdb/testsuite/gdb.threads/wp-replication.c
index 5d2c380..d287c4e 100644
--- a/gdb/testsuite/gdb.threads/wp-replication.c
+++ b/gdb/testsuite/gdb.threads/wp-replication.c
@@ -106,7 +106,7 @@ void *
 thread_function (void *arg)
 {
   int i, j;
-  long thread_number = (long) arg;
+  long long thread_number = (long long) arg;
 
   thread_started ();
 
diff --git a/gdb/testsuite/gdb.trace/actions.c b/gdb/testsuite/gdb.trace/actions.c
index ec004eb..064f1f9 100644
--- a/gdb/testsuite/gdb.trace/actions.c
+++ b/gdb/testsuite/gdb.trace/actions.c
@@ -25,13 +25,13 @@
 
 static char   gdb_char_test;
 static short  gdb_short_test;
-static long   gdb_long_test;
+static long long   gdb_long_test;
 static char   gdb_arr_test[25];
 static struct GDB_STRUCT_TEST
 {
   char   c;
   short  s;
-  long   l;
+  long long   l;
   int    bfield : 11;	/* collect bitfield */
   char   arr[25];
   struct GDB_STRUCT_TEST *next;
@@ -41,7 +41,7 @@ static union GDB_UNION_TEST
 {
   char   c;
   short  s;
-  long   l;
+  long long   l;
   int    bfield : 11;	/* collect bitfield */
   char   arr[4];
   union GDB_UNION_TEST *next;
@@ -75,43 +75,43 @@ void gdb_recursion_test (int depth,
 }
 
 
-unsigned long   gdb_c_test( unsigned long *parm )
+unsigned long long   gdb_c_test( unsigned long long *parm )
 
 {
    char *p = "gdb_c_test";
    char *ridiculously_long_variable_name_with_equally_long_string_assignment;
-   register long local_reg = 7;
-   static unsigned long local_static, local_static_sizeof;
-   long local_long;
-   unsigned long *stack_ptr;
-   unsigned long end_of_stack;
+   register long long local_reg = 7;
+   static unsigned long long local_static, local_static_sizeof;
+   long long local_long;
+   unsigned long long *stack_ptr;
+   unsigned long long end_of_stack;
 
    ridiculously_long_variable_name_with_equally_long_string_assignment = 
      "ridiculously long variable name with equally long string assignment";
    local_static = 9;
    local_static_sizeof = sizeof (struct GDB_STRUCT_TEST);
    local_long = local_reg + 1;
-   stack_ptr  = (unsigned long *) &local_long;
+   stack_ptr  = (unsigned long long *) &local_long;
    end_of_stack = 
-     (unsigned long) &stack_ptr + sizeof(stack_ptr) + sizeof(end_of_stack) - 1;
-
-   gdb_char_test   = gdb_struct1_test.c = (char)   ((long) parm[1] & 0xff);
-   gdb_short_test  = gdb_struct1_test.s = (short)  ((long) parm[2] & 0xffff);
-   gdb_long_test   = gdb_struct1_test.l = (long)   ((long) parm[3] & 0xffffffff);
-   gdb_union1_test.l = (long) parm[4];
-   gdb_arr_test[0] = gdb_struct1_test.arr[0] = (char) ((long) parm[1] & 0xff);
-   gdb_arr_test[1] = gdb_struct1_test.arr[1] = (char) ((long) parm[2] & 0xff);
-   gdb_arr_test[2] = gdb_struct1_test.arr[2] = (char) ((long) parm[3] & 0xff);
-   gdb_arr_test[3] = gdb_struct1_test.arr[3] = (char) ((long) parm[4] & 0xff);
-   gdb_arr_test[4] = gdb_struct1_test.arr[4] = (char) ((long) parm[5] & 0xff);
-   gdb_arr_test[5] = gdb_struct1_test.arr[5] = (char) ((long) parm[6] & 0xff);
+     (unsigned long long) &stack_ptr + sizeof(stack_ptr) + sizeof(end_of_stack) - 1;
+
+   gdb_char_test   = gdb_struct1_test.c = (char)   ((long long) parm[1] & 0xff);
+   gdb_short_test  = gdb_struct1_test.s = (short)  ((long long) parm[2] & 0xffff);
+   gdb_long_test   = gdb_struct1_test.l = (long long)   ((long long) parm[3] & 0xffffffff);
+   gdb_union1_test.l = (long long) parm[4];
+   gdb_arr_test[0] = gdb_struct1_test.arr[0] = (char) ((long long) parm[1] & 0xff);
+   gdb_arr_test[1] = gdb_struct1_test.arr[1] = (char) ((long long) parm[2] & 0xff);
+   gdb_arr_test[2] = gdb_struct1_test.arr[2] = (char) ((long long) parm[3] & 0xff);
+   gdb_arr_test[3] = gdb_struct1_test.arr[3] = (char) ((long long) parm[4] & 0xff);
+   gdb_arr_test[4] = gdb_struct1_test.arr[4] = (char) ((long long) parm[5] & 0xff);
+   gdb_arr_test[5] = gdb_struct1_test.arr[5] = (char) ((long long) parm[6] & 0xff);
    gdb_struct1_test.bfield = 144;
    gdb_struct1_test.next = &gdb_struct2_test;
    gdb_structp_test      = &gdb_struct1_test;
    gdb_structpp_test     = &gdb_structp_test;
 
-   gdb_recursion_test_ptr (3, (long) parm[1], (long) parm[2], (long) parm[3],
-		       (long) parm[4], (long) parm[5], (long) parm[6]);
+   gdb_recursion_test_ptr (3, (long long) parm[1], (long long) parm[2], (long long) parm[3],
+		       (long long) parm[4], (long long) parm[5], (long long) parm[6]);
 
    gdb_char_test = gdb_short_test = gdb_long_test = 0;
    gdb_structp_test  = (void *) 0;
@@ -120,7 +120,7 @@ unsigned long   gdb_c_test( unsigned long *parm )
    memset ((char *) &gdb_struct2_test, 0, sizeof (gdb_struct2_test));
    local_static_sizeof = 0;
    local_static = 0;
-   return ( (unsigned long) 0 );
+   return ( (unsigned long long) 0 );
 }
 
 void gdb_asm_test (void)
@@ -141,7 +141,7 @@ main (argc, argv, envp)
      char *argv[], **envp;
 {
   int i;
-  unsigned long myparms[10];
+  unsigned long long myparms[10];
 
   FAST_TRACEPOINT_LABEL (fast_tracepoint_loc);
 
diff --git a/gdb/testsuite/gdb.trace/collection.c b/gdb/testsuite/gdb.trace/collection.c
index a4fa9fe..3fa316b 100644
--- a/gdb/testsuite/gdb.trace/collection.c
+++ b/gdb/testsuite/gdb.trace/collection.c
@@ -62,7 +62,7 @@ signed char  c0,  c1,  c2,  c3,  c4,  c5,  c6,  c7,
              c8,  c9,  c10, c11, c12, c13, c14, c15, cminus;
 signed short s0,  s1,  s2,  s3,  s4,  s5,  s6,  s7,
              s8,  s9,  s10, s11, s12, s13, s14, s15, sminus;
-signed long  l0,  l1,  l2,  l3,  l4,  l5,  l6,  l7,
+signed long long  l0,  l1,  l2,  l3,  l4,  l5,  l6,  l7,
              l8,  l9,  l10, l11, l12, l13, l14, l15, lminus;
 
 
diff --git a/gdb/testsuite/gdb.trace/disconnected-tracing.c b/gdb/testsuite/gdb.trace/disconnected-tracing.c
index 5740cf9..255c23a 100644
--- a/gdb/testsuite/gdb.trace/disconnected-tracing.c
+++ b/gdb/testsuite/gdb.trace/disconnected-tracing.c
@@ -22,7 +22,7 @@ end (void)
 struct foo
 {
   int bar1;
-  long bar2;
+  long long bar2;
 };
 
 struct foo foo;
diff --git a/gdb/thread.c b/gdb/thread.c
index 517a807..548322e 100644
--- a/gdb/thread.c
+++ b/gdb/thread.c
@@ -1807,7 +1807,7 @@ thread_find_command (const char *arg, int from_tty)
 {
   struct thread_info *tp;
   const char *tmp;
-  unsigned long match = 0;
+  unsigned long long match = 0;
 
   if (arg == NULL || *arg == '\0')
     error (_("Command requires an argument."));
diff --git a/gdb/tic6x-tdep.c b/gdb/tic6x-tdep.c
index efb8b05..e82641c 100644
--- a/gdb/tic6x-tdep.c
+++ b/gdb/tic6x-tdep.c
@@ -134,7 +134,7 @@ tic6x_setup_default (struct tic6x_unwind_cache *cache)
     cache->reg_saved[i] = -1;
 }
 
-static unsigned long tic6x_fetch_instruction (struct gdbarch *, CORE_ADDR);
+static unsigned long long tic6x_fetch_instruction (struct gdbarch *, CORE_ADDR);
 static int tic6x_register_number (int reg, int side, int crosspath);
 
 /* Do a full analysis of the prologue at START_PC and update CACHE accordingly.
@@ -147,7 +147,7 @@ tic6x_analyze_prologue (struct gdbarch *gdbarch, const CORE_ADDR start_pc,
 			struct tic6x_unwind_cache *cache,
 			struct frame_info *this_frame)
 {
-  unsigned long inst;
+  unsigned long long inst;
   unsigned int src_reg, base_reg, dst_reg;
   int i;
   CORE_ADDR pc = start_pc;
@@ -170,7 +170,7 @@ tic6x_analyze_prologue (struct gdbarch *gdbarch, const CORE_ADDR start_pc,
      2nd one is optional.  */
   while (pc < current_pc)
     {
-      unsigned long inst = tic6x_fetch_instruction (gdbarch, pc);
+      unsigned long long inst = tic6x_fetch_instruction (gdbarch, pc);
 
       if ((inst & 0x1ffc) == 0x1dc0 || (inst & 0x1ffc) == 0x1bc0
 	  || (inst & 0x0ffc) == 0x9c0)
@@ -539,7 +539,7 @@ static const struct frame_unwind tic6x_stub_unwind =
 
 /* Return the instruction on address PC.  */
 
-static unsigned long
+static unsigned long long
 tic6x_fetch_instruction (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
@@ -550,7 +550,7 @@ tic6x_fetch_instruction (struct gdbarch *gdbarch, CORE_ADDR pc)
    return 1 if INST is not a conditional instruction.  */
 
 static int
-tic6x_condition_true (struct regcache *regcache, unsigned long inst)
+tic6x_condition_true (struct regcache *regcache, unsigned long long inst)
 {
   int register_number;
   int register_value;
@@ -594,7 +594,7 @@ static CORE_ADDR
 tic6x_get_next_pc (struct regcache *regcache, CORE_ADDR pc)
 {
   struct gdbarch *gdbarch = regcache->arch ();
-  unsigned long inst;
+  unsigned long long inst;
   int register_number;
   int last = 0;
 
@@ -1109,7 +1109,7 @@ tic6x_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
 static int
 tic6x_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
-  unsigned long inst = tic6x_fetch_instruction (gdbarch, pc);
+  unsigned long long inst = tic6x_fetch_instruction (gdbarch, pc);
   /* Normally, the epilogue is composed by instruction `b .S2 b3'.  */
   if ((inst & 0x0f83effc) == 0x360)
     {
diff --git a/gdb/top.c b/gdb/top.c
index d9876fd..805f1fe 100644
--- a/gdb/top.c
+++ b/gdb/top.c
@@ -1113,7 +1113,7 @@ gdb_safe_append_history (void)
   int ret, saved_errno;
 
   std::string local_history_filename
-    = string_printf ("%s-gdb%ld~", history_filename, (long) getpid ());
+    = string_printf ("%s-gdb%ld~", history_filename, (long long) getpid ());
 
   ret = rename (history_filename, local_history_filename.c_str ());
   saved_errno = errno;
@@ -1851,7 +1851,7 @@ init_history (void)
   tmpenv = getenv ("GDBHISTSIZE");
   if (tmpenv)
     {
-      long var;
+      long long var;
       int saved_errno;
       char *endptr;
 
diff --git a/gdb/tracepoint.c b/gdb/tracepoint.c
index 2f0715a..9c6004e 100644
--- a/gdb/tracepoint.c
+++ b/gdb/tracepoint.c
@@ -829,7 +829,7 @@ collection_list::add_register (unsigned int regno)
 void
 collection_list::add_memrange (struct gdbarch *gdbarch,
 			       int type, bfd_signed_vma base,
-			       unsigned long len)
+			       unsigned long long len)
 {
   if (info_verbose)
     printf_filtered ("(%d,%s,%ld)\n", type, paddress (gdbarch, base), len);
@@ -848,11 +848,11 @@ collection_list::add_memrange (struct gdbarch *gdbarch,
 void
 collection_list::collect_symbol (struct symbol *sym,
 				 struct gdbarch *gdbarch,
-				 long frame_regno, long frame_offset,
+				 long long frame_regno, long long frame_offset,
 				 CORE_ADDR scope,
 				 int trace_string)
 {
-  unsigned long len;
+  unsigned long long len;
   unsigned int reg;
   bfd_signed_vma offset;
   int treat_as_expr = 0;
@@ -1001,8 +1001,8 @@ struct add_local_symbols_data
   struct collection_list *collect;
   struct gdbarch *gdbarch;
   CORE_ADDR pc;
-  long frame_regno;
-  long frame_offset;
+  long long frame_regno;
+  long long frame_offset;
   int count;
   int trace_string;
 };
@@ -1033,7 +1033,7 @@ collection_list::add_wholly_collected (const char *print_name)
 
 void
 collection_list::add_local_symbols (struct gdbarch *gdbarch, CORE_ADDR pc,
-				    long frame_regno, long frame_offset, int type,
+				    long long frame_regno, long long frame_offset, int type,
 				    int trace_string)
 {
   const struct block *block;
@@ -1101,7 +1101,7 @@ collection_list::stringify ()
   char temp_buf[2048];
   int count;
   char *end;
-  long i;
+  long long i;
   std::vector<std::string> str_list;
 
   if (m_strace_data)
@@ -1145,7 +1145,7 @@ collection_list::stringify ()
 			   m_memranges[i].type,
 			   paddress (target_gdbarch (),
 				     m_memranges[i].start),
-			   (long) (m_memranges[i].end
+			   (long long) (m_memranges[i].end
 				   - m_memranges[i].start));
 	}
       if (count + 27 > MAX_AGENT_EXPR_LEN)
@@ -1165,10 +1165,10 @@ collection_list::stringify ()
            Special-case it.  */
         if (m_memranges[i].type == memrange_absolute)
           sprintf (end, "M-1,%s,%lX", phex_nz (m_memranges[i].start, 0),
-		   (long) length);
+		   (long long) length);
         else
           sprintf (end, "M%X,%s,%lX", m_memranges[i].type,
-		   phex_nz (m_memranges[i].start, 0), (long) length);
+		   phex_nz (m_memranges[i].start, 0), (long long) length);
       }
 
       count += strlen (end);
@@ -1320,7 +1320,7 @@ encode_actions_1 (struct command_line *action,
 		}
 	      else
 		{
-		  unsigned long addr;
+		  unsigned long long addr;
 
 		  expression_up exp = parse_exp_1 (&action_exp, tloc->address,
 						   block_for_pc (tloc->address),
@@ -1856,20 +1856,20 @@ tstatus_command (const char *args, int from_tty)
 
 	  /* Reporting a run time is more readable than two long numbers.  */
 	  printf_filtered (_("Trace started at %ld.%06ld secs, stopped %ld.%06ld secs later.\n"),
-			   (long int) (ts->start_time / 1000000),
-			   (long int) (ts->start_time % 1000000),
-			   (long int) (run_time / 1000000),
-			   (long int) (run_time % 1000000));
+			   (long long int) (ts->start_time / 1000000),
+			   (long long int) (ts->start_time % 1000000),
+			   (long long int) (run_time / 1000000),
+			   (long long int) (run_time % 1000000));
 	}
       else
 	printf_filtered (_("Trace started at %ld.%06ld secs.\n"),
-			 (long int) (ts->start_time / 1000000),
-			 (long int) (ts->start_time % 1000000));
+			 (long long int) (ts->start_time / 1000000),
+			 (long long int) (ts->start_time % 1000000));
     }
   else if (ts->stop_time)
     printf_filtered (_("Trace stopped at %ld.%06ld secs.\n"),
-		     (long int) (ts->stop_time / 1000000),
-		     (long int) (ts->stop_time % 1000000));
+		     (long long int) (ts->stop_time / 1000000),
+		     (long long int) (ts->stop_time % 1000000));
 
   /* Now report any per-tracepoint status available.  */
   for (breakpoint *t : all_tracepoints ())
@@ -1983,12 +1983,12 @@ trace_status_mi (int on_stop)
     char buf[100];
 
     xsnprintf (buf, sizeof buf, "%ld.%06ld",
-	       (long int) (ts->start_time / 1000000),
-	       (long int) (ts->start_time % 1000000));
+	       (long long int) (ts->start_time / 1000000),
+	       (long long int) (ts->start_time % 1000000));
     uiout->field_string ("start-time", buf);
     xsnprintf (buf, sizeof buf, "%ld.%06ld",
-	       (long int) (ts->stop_time / 1000000),
-	       (long int) (ts->stop_time % 1000000));
+	       (long long int) (ts->stop_time / 1000000),
+	       (long long int) (ts->stop_time % 1000000));
     uiout->field_string ("stop-time", buf);
   }
 }
diff --git a/gdb/tracepoint.h b/gdb/tracepoint.h
index 42e4130..69416c8 100644
--- a/gdb/tracepoint.h
+++ b/gdb/tracepoint.h
@@ -265,15 +265,15 @@ public:
   void add_register (unsigned int regno);
   void add_memrange (struct gdbarch *gdbarch,
 		     int type, bfd_signed_vma base,
-		     unsigned long len);
+		     unsigned long long len);
   void collect_symbol (struct symbol *sym,
 		       struct gdbarch *gdbarch,
-		       long frame_regno, long frame_offset,
+		       long long frame_regno, long long frame_offset,
 		       CORE_ADDR scope,
 		       int trace_string);
 
   void add_local_symbols (struct gdbarch *gdbarch, CORE_ADDR pc,
-			  long frame_regno, long frame_offset, int type,
+			  long long frame_regno, long long frame_offset, int type,
 			  int trace_string);
   void add_static_trace_data ();
 
diff --git a/gdb/tui/tui-file.c b/gdb/tui/tui-file.c
index fa335f9..a699589 100644
--- a/gdb/tui/tui-file.c
+++ b/gdb/tui/tui-file.c
@@ -44,7 +44,7 @@ tui_file::puts (const char *linebuffer)
 }
 
 void
-tui_file::write (const char *buf, long length_buf)
+tui_file::write (const char *buf, long long length_buf)
 {
   tui_write (buf, length_buf);
   /* gdb_stdout is buffered, and the caller must gdb_flush it at
diff --git a/gdb/tui/tui-file.h b/gdb/tui/tui-file.h
index 0490adc..60c9b0e 100644
--- a/gdb/tui/tui-file.h
+++ b/gdb/tui/tui-file.h
@@ -28,7 +28,7 @@ class tui_file : public stdio_file
 public:
   explicit tui_file (FILE *stream);
 
-  void write (const char *buf, long length_buf) override;
+  void write (const char *buf, long long length_buf) override;
   void puts (const char *) override;
   void flush () override;
 };
diff --git a/gdb/ui-file.c b/gdb/ui-file.c
index 1751509..adf9d73 100644
--- a/gdb/ui-file.c
+++ b/gdb/ui-file.c
@@ -70,7 +70,7 @@ ui_file::vprintf (const char *format, va_list args)
 
 
 void
-null_file::write (const char *buf, long sizeof_buf)
+null_file::write (const char *buf, long long sizeof_buf)
 {
   /* Discard the request.  */
 }
@@ -82,7 +82,7 @@ null_file::puts (const char *)
 }
 
 void
-null_file::write_async_safe (const char *buf, long sizeof_buf)
+null_file::write_async_safe (const char *buf, long long sizeof_buf)
 {
   /* Discard the request.  */
 }
@@ -104,7 +104,7 @@ ui_file_isatty (struct ui_file *file)
 void
 ui_file_write (struct ui_file *file,
 		const char *buf,
-		long length_buf)
+		long long length_buf)
 {
   file->write (buf, length_buf);
 }
@@ -112,13 +112,13 @@ ui_file_write (struct ui_file *file,
 void
 ui_file_write_async_safe (struct ui_file *file,
 			  const char *buf,
-			  long length_buf)
+			  long long length_buf)
 {
   file->write_async_safe (buf, length_buf);
 }
 
-long
-ui_file_read (struct ui_file *file, char *buf, long length_buf)
+long long
+ui_file_read (struct ui_file *file, char *buf, long long length_buf)
 {
   return file->read (buf, length_buf);
 }
@@ -135,7 +135,7 @@ string_file::~string_file ()
 {}
 
 void
-string_file::write (const char *buf, long length_buf)
+string_file::write (const char *buf, long long length_buf)
 {
   m_string.append (buf, length_buf);
 }
@@ -194,8 +194,8 @@ stdio_file::flush ()
   fflush (m_file);
 }
 
-long
-stdio_file::read (char *buf, long length_buf)
+long long
+stdio_file::read (char *buf, long long length_buf)
 {
   /* Wait until at least one byte of data is available, or we get
      interrupted with Control-C.  */
@@ -212,7 +212,7 @@ stdio_file::read (char *buf, long length_buf)
 }
 
 void
-stdio_file::write (const char *buf, long length_buf)
+stdio_file::write (const char *buf, long long length_buf)
 {
   /* Calling error crashes when we are called from the exception framework.  */
   if (fwrite (buf, length_buf, 1, m_file))
@@ -222,7 +222,7 @@ stdio_file::write (const char *buf, long length_buf)
 }
 
 void
-stdio_file::write_async_safe (const char *buf, long length_buf)
+stdio_file::write_async_safe (const char *buf, long long length_buf)
 {
   /* This is written the way it is to avoid a warning from gcc about not using the
      result of write (since it can be declared with attribute warn_unused_result).
@@ -255,7 +255,7 @@ stdio_file::isatty ()
    gdb_stdout is flushed before writing to gdb_stderr.  */
 
 void
-stderr_file::write (const char *buf, long length_buf)
+stderr_file::write (const char *buf, long long length_buf)
 {
   gdb_flush (gdb_stdout);
   stdio_file::write (buf, length_buf);
@@ -301,14 +301,14 @@ tee_file::flush ()
 }
 
 void
-tee_file::write (const char *buf, long length_buf)
+tee_file::write (const char *buf, long long length_buf)
 {
   m_one->write (buf, length_buf);
   m_two->write (buf, length_buf);
 }
 
 void
-tee_file::write_async_safe (const char *buf, long length_buf)
+tee_file::write_async_safe (const char *buf, long long length_buf)
 {
   m_one->write_async_safe (buf, length_buf);
   m_two->write_async_safe (buf, length_buf);
diff --git a/gdb/ui-file.h b/gdb/ui-file.h
index 2cf5f83..91e53cd 100644
--- a/gdb/ui-file.h
+++ b/gdb/ui-file.h
@@ -47,7 +47,7 @@ public:
   /* Methods below are both public, and overridable by ui_file
      subclasses.  */
 
-  virtual void write (const char *buf, long length_buf) = 0;
+  virtual void write (const char *buf, long long length_buf) = 0;
 
   /* This version of "write" is safe for use in signal handlers.  It's
      not guaranteed that all existing output will have been flushed
@@ -55,7 +55,7 @@ public:
      the request.  puts_async is not provided as the async versions
      are rarely used, no point in having both for a rarely used
      interface.  */
-  virtual void write_async_safe (const char *buf, long length_buf)
+  virtual void write_async_safe (const char *buf, long long length_buf)
   { gdb_assert_not_reached ("write_async_safe"); }
 
   /* Some ui_files override this to provide a efficient implementation
@@ -63,7 +63,7 @@ public:
   virtual void puts (const char *str)
   { this->write (str, strlen (str)); }
 
-  virtual long read (char *buf, long length_buf)
+  virtual long long read (char *buf, long long length_buf)
   { gdb_assert_not_reached ("can't read from this file type"); }
 
   virtual bool isatty ()
@@ -80,8 +80,8 @@ typedef std::unique_ptr<ui_file> ui_file_up;
 class null_file : public ui_file
 {
 public:
-  void write (const char *buf, long length_buf) override;
-  void write_async_safe (const char *buf, long sizeof_buf) override;
+  void write (const char *buf, long long length_buf) override;
+  void write_async_safe (const char *buf, long long sizeof_buf) override;
   void puts (const char *str) override;
 };
 
@@ -93,12 +93,12 @@ extern void gdb_flush (ui_file *);
 extern int ui_file_isatty (struct ui_file *);
 
 extern void ui_file_write (struct ui_file *file, const char *buf,
-			   long length_buf);
+			   long long length_buf);
 
 extern void ui_file_write_async_safe (struct ui_file *file, const char *buf,
-				      long length_buf);
+				      long long length_buf);
 
-extern long ui_file_read (struct ui_file *file, char *buf, long length_buf);
+extern long long ui_file_read (struct ui_file *file, char *buf, long long length_buf);
 
 /* A std::string-based ui_file.  Can be used as a scratch buffer for
    collecting output.  */
@@ -111,9 +111,9 @@ public:
 
   /* Override ui_file methods.  */
 
-  void write (const char *buf, long length_buf) override;
+  void write (const char *buf, long long length_buf) override;
 
-  long read (char *buf, long length_buf) override
+  long long read (char *buf, long long length_buf) override
   { gdb_assert_not_reached ("a string_file is not readable"); }
 
   /* string_file-specific public API.  */
@@ -170,13 +170,13 @@ public:
 
   void flush () override;
 
-  void write (const char *buf, long length_buf) override;
+  void write (const char *buf, long long length_buf) override;
 
-  void write_async_safe (const char *buf, long length_buf) override;
+  void write_async_safe (const char *buf, long long length_buf) override;
 
   void puts (const char *) override;
 
-  long read (char *buf, long length_buf) override;
+  long long read (char *buf, long long length_buf) override;
 
   bool isatty () override;
 
@@ -231,7 +231,7 @@ public:
 
   /* Override the output routines to flush gdb_stdout before deferring
      to stdio_file for the actual outputting.  */
-  void write (const char *buf, long length_buf) override;
+  void write (const char *buf, long long length_buf) override;
   void puts (const char *linebuffer) override;
 };
 
@@ -247,8 +247,8 @@ public:
 	    ui_file *two, bool close_two);
   ~tee_file () override;
 
-  void write (const char *buf, long length_buf) override;
-  void write_async_safe (const char *buf, long length_buf) override;
+  void write (const char *buf, long long length_buf) override;
+  void write_async_safe (const char *buf, long long length_buf) override;
   void puts (const char *) override;
 
   bool isatty () override;
diff --git a/gdb/utils.c b/gdb/utils.c
index 09381d9..f0ec8f2 100644
--- a/gdb/utils.c
+++ b/gdb/utils.c
@@ -742,7 +742,7 @@ maybe_quit (void)
    memory requested in SIZE.  */
 
 void
-malloc_failure (long size)
+malloc_failure (long long size)
 {
   if (size > 0)
     {
@@ -1966,8 +1966,8 @@ vfprintf_unfiltered (struct ui_file *stream, const char *format, va_list args)
       need_nl = (len > 0 && linebuffer[len - 1] != '\n');
 
       std::string timestamp = string_printf ("%ld.%06ld %s%s",
-					     (long) s.count (),
-					     (long) us.count (),
+					     (long long) s.count (),
+					     (long long) us.count (),
 					     linebuffer.c_str (),
 					     need_nl ? "\n": "");
       fputs_unfiltered (timestamp.c_str (), stream);
@@ -2990,7 +2990,7 @@ gdb_bfd_errmsg (bfd_error_type error_tag, char **matching)
 int
 parse_pid_to_attach (const char *args)
 {
-  unsigned long pid;
+  unsigned long long pid;
   char *dummy;
 
   if (!args)
diff --git a/gdb/v850-tdep.c b/gdb/v850-tdep.c
index 2a3812d..922ee1a 100644
--- a/gdb/v850-tdep.c
+++ b/gdb/v850-tdep.c
@@ -587,7 +587,7 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)
 
 struct reg_list
 {
-  long mask;
+  long long mask;
   int regno;
 };
 
@@ -599,9 +599,9 @@ v850_handle_prepare (int insn, int insn2, CORE_ADDR * current_pc_ptr,
 {
   CORE_ADDR current_pc = *current_pc_ptr;
   struct pifsr *pifsr = *pifsr_ptr;
-  long next = insn2 & 0xffff;
-  long list12 = ((insn & 1) << 16) + (next & 0xffe0);
-  long offset = (insn & 0x3e) << 1;
+  long long next = insn2 & 0xffff;
+  long long list12 = ((insn & 1) << 16) + (next & 0xffe0);
+  long long offset = (insn & 0x3e) << 1;
   static struct reg_list reg_table[] =
   {
     {0x00800, 20},		/* r20 */
@@ -668,8 +668,8 @@ v850_handle_pushm (int insn, int insn2, struct v850_frame_cache *pi,
 		   struct pifsr **pifsr_ptr)
 {
   struct pifsr *pifsr = *pifsr_ptr;
-  long list12 = ((insn & 0x0f) << 16) + (insn2 & 0xfff0);
-  long offset = 0;
+  long long list12 = ((insn & 0x0f) << 16) + (insn2 & 0xfff0);
+  long long offset = 0;
   static struct reg_list pushml_reg_table[] =
   {
     {0x80000, E_PS_REGNUM},	/* PSW */
@@ -818,9 +818,9 @@ v850_analyze_prologue (struct gdbarch *gdbarch,
 
       if ((insn & 0xffc0) == ((10 << 11) | 0x0780) && !regsave_func_p)
 	{			/* jarl <func>,10 */
-	  long low_disp = insn2 & ~(long) 1;
-	  long disp = (((((insn & 0x3f) << 16) + low_disp)
-			& ~(long) 1) ^ 0x00200000) - 0x00200000;
+	  long long low_disp = insn2 & ~(long long) 1;
+	  long long disp = (((((insn & 0x3f) << 16) + low_disp)
+			& ~(long long) 1) ^ 0x00200000) - 0x00200000;
 
 	  save_pc = current_pc;
 	  save_end = prologue_end;
@@ -835,7 +835,7 @@ v850_analyze_prologue (struct gdbarch *gdbarch,
 	}
       else if ((insn & 0xffc0) == 0x0200 && !regsave_func_p)
 	{			/* callt <imm6> */
-	  long adr = ctbp + ((insn & 0x3f) << 1);
+	  long long adr = ctbp + ((insn & 0x3f) << 1);
 
 	  save_pc = current_pc;
 	  save_end = prologue_end;
diff --git a/gdb/valops.c b/gdb/valops.c
index 9bdbf22..b963ffa 100644
--- a/gdb/valops.c
+++ b/gdb/valops.c
@@ -3383,7 +3383,7 @@ value_struct_elt_for_reference (struct type *domain, int offset,
 	      if (v != NULL)
 		{
 		  struct value *ptr;
-		  long mem_offset;
+		  long long mem_offset;
 		  struct type *type, *tmp;
 
 		  ptr = value_aggregate_elt (domain, name, NULL, 1, noside);
diff --git a/gdb/valprint.c b/gdb/valprint.c
index a48f39e..6538d1f 100644
--- a/gdb/valprint.c
+++ b/gdb/valprint.c
@@ -2151,7 +2151,7 @@ read_string (CORE_ADDR addr, int len, int width, unsigned int fetchlimit,
     }
   else if (len == -1)
     {
-      unsigned long bufsize = 0;
+      unsigned long long bufsize = 0;
       unsigned int chunksize;	/* Size of each fetch, in chars.  */
       int found_nul;		/* Non-zero if we found the nul char.  */
       gdb_byte *limit;		/* First location past end of fetch buffer.  */
@@ -2168,7 +2168,7 @@ read_string (CORE_ADDR addr, int len, int width, unsigned int fetchlimit,
       do
 	{
 	  QUIT;
-	  nfetch = std::min ((unsigned long) chunksize, fetchlimit - bufsize);
+	  nfetch = std::min ((unsigned long long) chunksize, fetchlimit - bufsize);
 
 	  if (*buffer == NULL)
 	    buffer->reset ((gdb_byte *) xmalloc (nfetch * width));
@@ -2192,7 +2192,7 @@ read_string (CORE_ADDR addr, int len, int width, unsigned int fetchlimit,
 	  limit = bufptr + nfetch * width;
 	  while (bufptr < limit)
 	    {
-	      unsigned long c;
+	      unsigned long long c;
 
 	      c = extract_unsigned_integer (bufptr, width, byte_order);
 	      addr += width;
@@ -2330,7 +2330,7 @@ print_wchar (gdb_wint_t w, const gdb_byte *orig,
 		    xsnprintf (octal, sizeof (octal), "\\%.3o",
 			       (int) (value & 0777));
 		  else
-		    xsnprintf (octal, sizeof (octal), "\\x%lx", (long) value);
+		    xsnprintf (octal, sizeof (octal), "\\x%lx", (long long) value);
 		  append_string_as_wide (octal, output);
 		}
 	      /* If we somehow have extra bytes, print them now.  */
@@ -2688,7 +2688,7 @@ generic_printstr (struct ui_file *stream, struct type *type,
 
   if (length == -1)
     {
-      unsigned long current_char = 1;
+      unsigned long long current_char = 1;
 
       for (i = 0; current_char; ++i)
 	{
diff --git a/gdb/varobj.c b/gdb/varobj.c
index 0244141..3964207 100644
--- a/gdb/varobj.c
+++ b/gdb/varobj.c
@@ -2283,7 +2283,7 @@ varobj_value_get_print_value (struct value *value,
 {
   struct value_print_options opts;
   struct type *type = NULL;
-  long len = 0;
+  long long len = 0;
   gdb::unique_xmalloc_ptr<char> encoding;
   /* Initialize it just to avoid a GCC false warning.  */
   CORE_ADDR str_addr = 0;
diff --git a/gdb/windows-nat.c b/gdb/windows-nat.c
index 6986dc3..3dd1c28 100644
--- a/gdb/windows-nat.c
+++ b/gdb/windows-nat.c
@@ -202,10 +202,10 @@ typedef enum
 #define DEBUG_EXCEPT(x)	if (debug_exceptions)	printf_unfiltered x
 
 static void cygwin_set_dr (int i, CORE_ADDR addr);
-static void cygwin_set_dr7 (unsigned long val);
+static void cygwin_set_dr7 (unsigned long long val);
 static CORE_ADDR cygwin_get_dr (int i);
-static unsigned long cygwin_get_dr6 (void);
-static unsigned long cygwin_get_dr7 (void);
+static unsigned long long cygwin_get_dr6 (void);
+static unsigned long long cygwin_get_dr7 (void);
 
 static enum gdb_signal last_sig = GDB_SIGNAL_0;
 /* Set if a signal was received from the debugged process.  */
@@ -341,7 +341,7 @@ struct windows_nat_target final : public x86_nat_target<inf_child_target>
 
   char *pid_to_exec_file (int pid) override;
 
-  ptid_t get_ada_task_ptid (long lwp, long thread) override;
+  ptid_t get_ada_task_ptid (long long lwp, long long thread) override;
 
   bool get_tib_address (ptid_t ptid, CORE_ADDR *addr) override;
 
@@ -532,12 +532,12 @@ windows_fetch_one_register (struct regcache *regcache,
 
   if (r == I387_FISEG_REGNUM (tdep))
     {
-      long l = *((long *) context_offset) & 0xffff;
+      long long l = *((long long *) context_offset) & 0xffff;
       regcache->raw_supply (r, (char *) &l);
     }
   else if (r == I387_FOP_REGNUM (tdep))
     {
-      long l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
+      long long l = (*((long long *) context_offset) >> 16) & ((1 << 11) - 1);
       regcache->raw_supply (r, (char *) &l);
     }
   else if (segment_register_p (r))
@@ -545,7 +545,7 @@ windows_fetch_one_register (struct regcache *regcache,
       /* GDB treats segment registers as 32bit registers, but they are
 	 in fact only 16 bits long.  Make sure we do not read extra
 	 bits from our source buffer.  */
-      long l = *((long *) context_offset) & 0xffff;
+      long long l = *((long long *) context_offset) & 0xffff;
       regcache->raw_supply (r, (char *) &l);
     }
   else
@@ -703,7 +703,7 @@ windows_make_so (const char *name, LPVOID load_addr)
 #ifdef __USEWIDE
 	{
 	  GetSystemDirectoryW (buf, sizeof (buf) / sizeof (wchar_t));
-	  wcscat (buf, L"\\ntdll.dll");
+	  wcscat (buf, U"\\ntdll.dll");
 	}
 #else
 	{
@@ -2589,10 +2589,10 @@ windows_nat_target::create_inferior (const char *exec_file,
       if (cygwin_conv_path (CCP_POSIX_TO_WIN_W, sh, shell, __PMAX) < 0)
       	error (_("Error starting executable via shell: %d"), errno);
 #ifdef __USEWIDE
-      len = sizeof (L" -c 'exec  '") + mbstowcs (NULL, exec_file, 0)
+      len = sizeof (U" -c 'exec  '") + mbstowcs (NULL, exec_file, 0)
 	    + mbstowcs (NULL, allargs, 0) + 2;
       cygallargs = (wchar_t *) alloca (len * sizeof (wchar_t));
-      swprintf (cygallargs, len, L" -c 'exec %s %s'", exec_file, allargs);
+      swprintf (cygallargs, len, U" -c 'exec %s %s'", exec_file, allargs);
 #else  /* !__USEWIDE */
       len = (sizeof (" -c 'exec  '") + strlen (exec_file)
 	     + strlen (allargs) + 2);
@@ -2612,7 +2612,7 @@ windows_nat_target::create_inferior (const char *exec_file,
   args = (cygwin_buf_t *) alloca ((wcslen (toexec) + wcslen (cygallargs) + 2)
 				  * sizeof (wchar_t));
   wcscpy (args, toexec);
-  wcscat (args, L" ");
+  wcscat (args, U" ");
   wcscat (args, cygallargs);
 #else  /* !__USEWIDE */
   args = (cygwin_buf_t *) alloca (strlen (toexec) + strlen (cygallargs) + 2);
@@ -3018,7 +3018,7 @@ windows_nat_target::get_tib_address (ptid_t ptid, CORE_ADDR *addr)
 }
 
 ptid_t
-windows_nat_target::get_ada_task_ptid (long lwp, long thread)
+windows_nat_target::get_ada_task_ptid (long long lwp, long long thread)
 {
   return ptid_t (inferior_ptid.pid (), 0, lwp);
 }
@@ -3145,7 +3145,7 @@ cygwin_set_dr (int i, CORE_ADDR addr)
    register.  Here we just store the address in D_REGS, the watchpoint
    will be actually set up in windows_wait.  */
 static void
-cygwin_set_dr7 (unsigned long val)
+cygwin_set_dr7 (unsigned long long val)
 {
   dr[7] = (CORE_ADDR) val;
   debug_registers_changed = 1;
@@ -3163,20 +3163,20 @@ cygwin_get_dr (int i)
 /* Get the value of the DR6 debug status register from the inferior.
    Here we just return the value stored in dr[6]
    by the last call to thread_rec for current_event.dwThreadId id.  */
-static unsigned long
+static unsigned long long
 cygwin_get_dr6 (void)
 {
-  return (unsigned long) dr[6];
+  return (unsigned long long) dr[6];
 }
 
 /* Get the value of the DR7 debug status register from the inferior.
    Here we just return the value stored in dr[7] by the last call to
    thread_rec for current_event.dwThreadId id.  */
 
-static unsigned long
+static unsigned long long
 cygwin_get_dr7 (void)
 {
-  return (unsigned long) dr[7];
+  return (unsigned long long) dr[7];
 }
 
 /* Determine if the thread referenced by "ptid" is alive
diff --git a/gdb/x86-bsd-nat.c b/gdb/x86-bsd-nat.c
index 542bcd0..4ba4141 100644
--- a/gdb/x86-bsd-nat.c
+++ b/gdb/x86-bsd-nat.c
@@ -52,7 +52,7 @@ size_t x86bsd_xsave_len;
 #endif
 #endif
 
-static unsigned long
+static unsigned long long
 x86bsd_dr_get (ptid_t ptid, int regnum)
 {
   struct dbreg dbregs;
@@ -65,7 +65,7 @@ x86bsd_dr_get (ptid_t ptid, int regnum)
 }
 
 static void
-x86bsd_dr_set (int regnum, unsigned long value)
+x86bsd_dr_set (int regnum, unsigned long long value)
 {
   struct thread_info *thread;
   struct dbreg dbregs;
@@ -91,7 +91,7 @@ x86bsd_dr_set (int regnum, unsigned long value)
 }
 
 static void
-x86bsd_dr_set_control (unsigned long control)
+x86bsd_dr_set_control (unsigned long long control)
 {
   x86bsd_dr_set (7, control);
 }
@@ -110,13 +110,13 @@ x86bsd_dr_get_addr (int regnum)
   return x86bsd_dr_get (inferior_ptid, regnum);
 }
 
-static unsigned long
+static unsigned long long
 x86bsd_dr_get_status (void)
 {
   return x86bsd_dr_get (inferior_ptid, 6);
 }
 
-static unsigned long
+static unsigned long long
 x86bsd_dr_get_control (void)
 {
   return x86bsd_dr_get (inferior_ptid, 7);
diff --git a/gdb/x86-linux-nat.c b/gdb/x86-linux-nat.c
index fe6598e..55a0976 100644
--- a/gdb/x86-linux-nat.c
+++ b/gdb/x86-linux-nat.c
@@ -120,8 +120,8 @@ x86_linux_nat_target::read_description ()
 
 #ifdef __x86_64__
   {
-    unsigned long cs;
-    unsigned long ds;
+    unsigned long long cs;
+    unsigned long long ds;
 
     /* Get CS register.  */
     errno = 0;
diff --git a/gdb/xcoffread.c b/gdb/xcoffread.c
index 79b1df7..45d0364 100644
--- a/gdb/xcoffread.c
+++ b/gdb/xcoffread.c
@@ -1965,7 +1965,7 @@ xcoff_symfile_finish (struct objfile *objfile)
 static void
 init_stringtab (bfd *abfd, file_ptr offset, struct objfile *objfile)
 {
-  long length;
+  long long length;
   int val;
   unsigned char lengthbuf[4];
   char *strtbl;
diff --git a/gdb/xtensa-linux-nat.c b/gdb/xtensa-linux-nat.c
index 007a5c3..063444b 100644
--- a/gdb/xtensa-linux-nat.c
+++ b/gdb/xtensa-linux-nat.c
@@ -206,7 +206,7 @@ fetch_gregs (struct regcache *regcache, int regnum)
   gdb_gregset_t regs;
   int areg;
   
-  if (ptrace (PTRACE_GETREGS, tid, 0, (long) &regs) < 0)
+  if (ptrace (PTRACE_GETREGS, tid, 0, (long long) &regs) < 0)
     {
       perror_with_name (_("Couldn't get registers"));
       return;
@@ -225,7 +225,7 @@ store_gregs (struct regcache *regcache, int regnum)
   gdb_gregset_t regs;
   int areg;
 
-  if (ptrace (PTRACE_GETREGS, tid, 0, (long) &regs) < 0)
+  if (ptrace (PTRACE_GETREGS, tid, 0, (long long) &regs) < 0)
     {
       perror_with_name (_("Couldn't get registers"));
       return;
@@ -233,7 +233,7 @@ store_gregs (struct regcache *regcache, int regnum)
 
   fill_gregset (regcache, &regs, regnum);
 
-  if (ptrace (PTRACE_SETREGS, tid, 0, (long) &regs) < 0)
+  if (ptrace (PTRACE_SETREGS, tid, 0, (long long) &regs) < 0)
     {
       perror_with_name (_("Couldn't write registers"));
       return;
@@ -253,7 +253,7 @@ fetch_xtregs (struct regcache *regcache, int regnum)
   const xtensa_regtable_t *ptr;
   char xtregs [XTENSA_ELF_XTREG_SIZE];
 
-  if (ptrace (PTRACE_GETXTREGS, tid, 0, (long)&xtregs) < 0)
+  if (ptrace (PTRACE_GETXTREGS, tid, 0, (long long)&xtregs) < 0)
     perror_with_name (_("Couldn't get extended registers"));
 
   for (ptr = xtensa_regmap_table; ptr->name; ptr++)
@@ -268,14 +268,14 @@ store_xtregs (struct regcache *regcache, int regnum)
   const xtensa_regtable_t *ptr;
   char xtregs [XTENSA_ELF_XTREG_SIZE];
 
-  if (ptrace (PTRACE_GETXTREGS, tid, 0, (long)&xtregs) < 0)
+  if (ptrace (PTRACE_GETXTREGS, tid, 0, (long long)&xtregs) < 0)
     perror_with_name (_("Couldn't get extended registers"));
 
   for (ptr = xtensa_regmap_table; ptr->name; ptr++)
     if (regnum == ptr->gdb_regnum || regnum == -1)
       regcache->raw_collect (ptr->gdb_regnum, xtregs + ptr->ptrace_offset);
 
-  if (ptrace (PTRACE_SETXTREGS, tid, 0, (long)&xtregs) < 0)
+  if (ptrace (PTRACE_SETXTREGS, tid, 0, (long long)&xtregs) < 0)
     perror_with_name (_("Couldn't write extended registers"));
 }
 
diff --git a/gdb/xtensa-tdep.c b/gdb/xtensa-tdep.c
index 7dc3660..94e9640 100644
--- a/gdb/xtensa-tdep.c
+++ b/gdb/xtensa-tdep.c
@@ -163,13 +163,13 @@ areg_number (struct gdbarch *gdbarch, int ar_regnum, unsigned int wb)
 }
 
 /* Read Xtensa register directly from the hardware.  */ 
-static unsigned long
+static unsigned long long
 xtensa_read_register (int regnum)
 {
   ULONGEST value;
 
   regcache_raw_read_unsigned (get_current_regcache (), regnum, &value);
-  return (unsigned long) value;
+  return (unsigned long long) value;
 }
 
 /* Write Xtensa register directly to the hardware.  */ 
@@ -1915,7 +1915,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,
 
       ra = (bp_addr & 0x3fffffff) | 0x40000000;
       regcache_raw_read_unsigned (regcache, gdbarch_ps_regnum (gdbarch), &val);
-      ps = (unsigned long) val & ~0x00030000;
+      ps = (unsigned long long) val & ~0x00030000;
       regcache_cooked_write_unsigned
 	(regcache, gdbarch_tdep (gdbarch)->a0_base + 4, ra);
       regcache_cooked_write_unsigned (regcache,
diff --git a/gdb/xtensa-tdep.h b/gdb/xtensa-tdep.h
index ccd3714..5f56e3a 100644
--- a/gdb/xtensa-tdep.h
+++ b/gdb/xtensa-tdep.h
@@ -215,9 +215,9 @@ struct gdbarch_tdep
 
   int max_register_raw_size;
   int max_register_virtual_size;
-  unsigned long *fp_layout;	/* Layout of custom/TIE regs in 'FP' area.  */
+  unsigned long long *fp_layout;	/* Layout of custom/TIE regs in 'FP' area.  */
   unsigned int fp_layout_bytes;	/* Size of layout information (in bytes).  */
-  unsigned long *gregmap;
+  unsigned long long *gregmap;
 
   /* Cached register types.  */
   struct ctype_cache *type_entries;
diff --git a/include/aout/aout64.h b/include/aout/aout64.h
index a0827d5..f7155f5 100644
--- a/include/aout/aout64.h
+++ b/include/aout/aout64.h
@@ -265,7 +265,7 @@ struct external_nlist
 
 struct internal_nlist
 {
-  unsigned long n_strx;			/* Index into string table of name.  */
+  unsigned long long n_strx;			/* Index into string table of name.  */
   unsigned char n_type;			/* Type of symbol.  */
   unsigned char n_other;		/* Misc info (usually empty).  */
   unsigned short n_desc;		/* Description field.  */
@@ -484,7 +484,7 @@ enum reloc_type
 struct reloc_internal
 {
   bfd_vma r_address;		/* Offset of data to relocate.  */
-  long	r_index;		/* Symbol table index of symbol.  */
+  long long	r_index;		/* Symbol table index of symbol.  */
   enum reloc_type r_type;	/* Relocation type.  */
   bfd_vma r_addend;		/* Datum addend.  */
 };
diff --git a/include/aout/encap.h b/include/aout/encap.h
index 765e7cd..985b8d1 100644
--- a/include/aout/encap.h
+++ b/include/aout/encap.h
@@ -46,32 +46,32 @@ struct coffheader
   /* filehdr */
   unsigned short f_magic;
   unsigned short f_nscns;
-  long f_timdat;
-  long f_symptr;
-  long f_nsyms;
+  long long f_timdat;
+  long long f_symptr;
+  long long f_nsyms;
   unsigned short f_opthdr;
   unsigned short f_flags;
   /* aouthdr */
   short magic;
   short vstamp;
-  long tsize;
-  long dsize;
-  long bsize;
-  long entry;
-  long text_start;
-  long data_start;
+  long long tsize;
+  long long dsize;
+  long long bsize;
+  long long entry;
+  long long text_start;
+  long long data_start;
   struct coffscn
     {
       char s_name[8];
-      long s_paddr;
-      long s_vaddr;
-      long s_size;
-      long s_scnptr;
-      long s_relptr;
-      long s_lnnoptr;
+      long long s_paddr;
+      long long s_vaddr;
+      long long s_size;
+      long long s_scnptr;
+      long long s_relptr;
+      long long s_lnnoptr;
       unsigned short s_nreloc;
       unsigned short s_nlnno;
-      long s_flags;
+      long long s_flags;
     } scns[3];
 };
 
diff --git a/include/aout/hp.h b/include/aout/hp.h
index 634f8ab..77c8e88 100644
--- a/include/aout/hp.h
+++ b/include/aout/hp.h
@@ -30,21 +30,21 @@ struct exec
 {
   unsigned short a_machtype;	/* machine type */
   unsigned short a_magic;	/* magic number */
-  unsigned long a_spare1;
-  unsigned long a_spare2;
-  unsigned long a_text;		/* length of text, in bytes */
-  unsigned long a_data;		/* length of data, in bytes */
-  unsigned long a_bss;		/* length of uninitialized data area for file, in bytes */
-  unsigned long a_trsize;	/* length of relocation info for text, in bytes */
-  unsigned long a_drsize;	/* length of relocation info for data, in bytes */
-  unsigned long a_spare3;	/* HP = pascal interface size */
-  unsigned long a_spare4;	/* HP = symbol table size */
-  unsigned long a_spare5;	/* HP = debug name table size */
-  unsigned long a_entry;	/* start address */
-  unsigned long a_spare6;	/* HP = source line table size */
-  unsigned long a_spare7;	/* HP = value table size */
-  unsigned long a_syms;		/* length of symbol table data in file, in bytes */
-  unsigned long a_spare8;
+  unsigned long long a_spare1;
+  unsigned long long a_spare2;
+  unsigned long long a_text;		/* length of text, in bytes */
+  unsigned long long a_data;		/* length of data, in bytes */
+  unsigned long long a_bss;		/* length of uninitialized data area for file, in bytes */
+  unsigned long long a_trsize;	/* length of relocation info for text, in bytes */
+  unsigned long long a_drsize;	/* length of relocation info for data, in bytes */
+  unsigned long long a_spare3;	/* HP = pascal interface size */
+  unsigned long long a_spare4;	/* HP = symbol table size */
+  unsigned long long a_spare5;	/* HP = debug name table size */
+  unsigned long long a_entry;	/* start address */
+  unsigned long long a_spare6;	/* HP = source line table size */
+  unsigned long long a_spare7;	/* HP = value table size */
+  unsigned long long a_syms;		/* length of symbol table data in file, in bytes */
+  unsigned long long a_spare8;
 };
 
 /* Tell a.out.gnu.h not to define `struct exec'.  */
diff --git a/include/aout/ranlib.h b/include/aout/ranlib.h
index 8cf3030..b8273d9 100644
--- a/include/aout/ranlib.h
+++ b/include/aout/ranlib.h
@@ -45,13 +45,13 @@ struct symdef
   {
     union
       {
-	unsigned long string_offset;	/* In the file */
+	unsigned long long string_offset;	/* In the file */
 	char *name;			/* In memory, sometimes */
       } s;
     /* this points to the front of the file header (AKA member header --
        a struct ar_hdr), not to the front of the file or into the file).
        in other words it only tells you which file to read */       
-    unsigned long file_offset;
+    unsigned long long file_offset;
   };
 
 /* Compatability with BSD code */
diff --git a/include/aout/sun4.h b/include/aout/sun4.h
index 882c411..23028a3 100644
--- a/include/aout/sun4.h
+++ b/include/aout/sun4.h
@@ -89,7 +89,7 @@ struct internal_sun4_dynamic_link
 {
   /* Linked list of loaded objects.  This is filled in at runtime by
      ld.so and probably by dlopen.  */
-  unsigned long ld_loaded;
+  unsigned long long ld_loaded;
 
   /* The address of the list of names of shared objects which must be
      included at runtime.  Each entry in the list is 16 bytes: the 4
@@ -100,7 +100,7 @@ struct internal_sun4_dynamic_link
      the next entry in the list (zero if this is the last entry).  The
      version numbers seem to only be non-zero when doing library
      searching.  */
-  unsigned long ld_need;
+  unsigned long long ld_need;
 
   /* The address of the path to search for the shared objects which
      must be included.  This points to a string in PATH format which
@@ -109,7 +109,7 @@ struct internal_sun4_dynamic_link
      beginning of this string and /lib:/usr/lib:/usr/local/lib to the
      end.  The string is terminated by a null byte.  This field is
      zero if there is no additional path.  */
-  unsigned long ld_rules;
+  unsigned long long ld_rules;
 
   /* The address of the global offset table.  This appears to be a
      virtual address, not a file offset.  The first entry in the
@@ -118,7 +118,7 @@ struct internal_sun4_dynamic_link
      The global offset table is used for PIC code to hold the
      addresses of variables.  A dynamically linked file which does not
      itself contain PIC code has a four byte global offset table.  */
-  unsigned long ld_got;
+  unsigned long long ld_got;
 
   /* The address of the procedure linkage table.  This appears to be a
      virtual address, not a file offset.
@@ -153,14 +153,14 @@ struct internal_sun4_dynamic_link
 
      The size of the procedure linkage table is given by the ld_plt_sz
      field.  */
-  unsigned long ld_plt;
+  unsigned long long ld_plt;
 
   /* The address of the relocs.  These are in the same format as
      ordinary relocs.  Symbol index numbers refer to the symbols
      pointed to by ld_stab.  I think the only way to determine the
      number of relocs is to assume that all the bytes from ld_rel to
      ld_hash contain reloc entries.  */
-  unsigned long ld_rel;
+  unsigned long long ld_rel;
 
   /* The address of a hash table of symbols.  The hash table has
      roughly the same number of entries as there are dynamic symbols;
@@ -189,33 +189,33 @@ struct internal_sun4_dynamic_link
      hash table entry) to move on to the next entry in this bucket.
      If the chain field is zero you have reached the end of the
      bucket, and the symbol is not in the hash table.  */ 
-  unsigned long ld_hash;
+  unsigned long long ld_hash;
 
   /* The address of the symbol table.  This is a list of
      external_nlist structures.  The string indices are relative to
      the ld_symbols field.  I think the only way to determine the
      number of symbols is to assume that all the bytes between ld_stab
      and ld_symbols are external_nlist structures.  */
-  unsigned long ld_stab;
+  unsigned long long ld_stab;
 
   /* I don't know what this is for.  It seems to always be zero.  */
-  unsigned long ld_stab_hash;
+  unsigned long long ld_stab_hash;
 
   /* The number of buckets in the hash table.  */
-  unsigned long ld_buckets;
+  unsigned long long ld_buckets;
 
   /* The address of the symbol string table.  The first string in this
      string table need not be the empty string.  */
-  unsigned long ld_symbols;
+  unsigned long long ld_symbols;
 
   /* The size in bytes of the symbol string table.  */
-  unsigned long ld_symb_size;
+  unsigned long long ld_symb_size;
 
   /* The size in bytes of the text segment.  */
-  unsigned long ld_text;
+  unsigned long long ld_text;
 
   /* The size in bytes of the procedure linkage table.  */
-  unsigned long ld_plt_sz;
+  unsigned long long ld_plt_sz;
 };
 
 /* The external form of the structure.  */
diff --git a/include/bout.h b/include/bout.h
index 3a95f77..3274884 100644
--- a/include/bout.h
+++ b/include/bout.h
@@ -110,13 +110,13 @@ struct nlist
       {
 	char*          n_name;
 	struct nlist * n_next;
-	long	       n_strx;	/* Index into string table	*/
+	long long	       n_strx;	/* Index into string table	*/
       } n_un;
 
     unsigned char n_type;	/* See below				*/
     char	  n_other;	/* Used in i80960 support -- see below	*/
     short	  n_desc;
-    unsigned long n_value;
+    unsigned long long n_value;
   };
 
 
diff --git a/include/coff/ecoff.h b/include/coff/ecoff.h
index 71c0c72..62f88d3 100644
--- a/include/coff/ecoff.h
+++ b/include/coff/ecoff.h
@@ -342,7 +342,7 @@ struct ecoff_find_line
   char *find_buffer;
 
   /* FDR table, sorted by address: */
-  long fdrtab_len;
+  long long fdrtab_len;
   struct ecoff_fdrtab_entry *fdrtab;
 
   /* Cache entry for most recently found line information.  The sect
diff --git a/include/coff/internal.h b/include/coff/internal.h
index a8efedb..e997c9d 100644
--- a/include/coff/internal.h
+++ b/include/coff/internal.h
@@ -54,7 +54,7 @@ struct internal_extra_pe_filehdr
   unsigned short e_oeminfo;	/* OEM information; e_oemid specific, 0x0 */
   unsigned short e_res2[10];	/* Reserved words, all 0x0 */
   bfd_vma  e_lfanew;		/* File address of new exe header, 0x80 */
-  unsigned long dos_message[16]; /* text which always follows dos header */
+  unsigned long long dos_message[16]; /* text which always follows dos header */
   bfd_vma  nt_signature;   	/* required NT signature, 0x4550 */
 };
 
@@ -74,9 +74,9 @@ struct internal_filehdr
   /* Standard coff internal info.  */
   unsigned short f_magic;	/* magic number			*/
   unsigned int   f_nscns;	/* number of sections		*/
-  long f_timdat;		/* time & date stamp		*/
+  long long f_timdat;		/* time & date stamp		*/
   bfd_vma f_symptr;		/* file pointer to symtab	*/
-  long f_nsyms;			/* number of symtab entries	*/
+  long long f_nsyms;			/* number of symtab entries	*/
   unsigned short f_opthdr;	/* sizeof(optional hdr)		*/
   unsigned short f_flags;	/* flags			*/
   unsigned short f_target_id;	/* (TI COFF specific)		*/
@@ -112,7 +112,7 @@ struct internal_filehdr
 typedef struct _IMAGE_DATA_DIRECTORY
 {
   bfd_vma VirtualAddress;
-  long    Size;
+  long long    Size;
 }  IMAGE_DATA_DIRECTORY;
 #define PE_EXPORT_TABLE			0
 #define PE_IMPORT_TABLE			1
@@ -135,14 +135,14 @@ typedef struct _IMAGE_DATA_DIRECTORY
 /* Extra structure used in debug directory.  */
 struct internal_IMAGE_DEBUG_DIRECTORY
 {
-  unsigned long  Characteristics;
-  unsigned long  TimeDateStamp;
+  unsigned long long  Characteristics;
+  unsigned long long  TimeDateStamp;
   unsigned short MajorVersion;
   unsigned short MinorVersion;
-  unsigned long  Type;
-  unsigned long  SizeOfData;
-  unsigned long  AddressOfRawData;
-  unsigned long  PointerToRawData;
+  unsigned long long  Type;
+  unsigned long long  SizeOfData;
+  unsigned long long  AddressOfRawData;
+  unsigned long long  PointerToRawData;
 };
 
 #define PE_IMAGE_DEBUG_TYPE_UNKNOWN          0
@@ -163,10 +163,10 @@ struct internal_IMAGE_DEBUG_DIRECTORY
 
 typedef struct _CODEVIEW_INFO
 {
-  unsigned long CVSignature;
+  unsigned long long CVSignature;
   char          Signature[CV_INFO_SIGNATURE_LENGTH];
   unsigned int  SignatureLength;
-  unsigned long Age;
+  unsigned long long Age;
   // char PdbFileName[];
 } CODEVIEW_INFO;
 
@@ -197,11 +197,11 @@ struct internal_extra_pe_aouthdr
   /* Linker minor version number.  */
   char MinorLinkerVersion;	
   /* Total size of all code sections.  */
-  long SizeOfCode;
+  long long SizeOfCode;
   /* Total size of all initialized data sections.  */
-  long SizeOfInitializedData;
+  long long SizeOfInitializedData;
   /* Total size of all uninitialized data sections.  */
-  long SizeOfUninitializedData;
+  long long SizeOfUninitializedData;
   /* Address of entry point relative to image base.  */
   bfd_vma AddressOfEntryPoint;
   /* Address of the first code section relative to image base.  */
@@ -221,10 +221,10 @@ struct internal_extra_pe_aouthdr
   short   MinorImageVersion;	/*  exe or dll being created, default to 0.  */ 
   short   MajorSubsystemVersion; /* Minimum subsystem version required to */
   short   MinorSubsystemVersion; /*  run exe; default to 3.1.  */
-  long    Reserved1;		/* Seems to be 0.  */
-  long    SizeOfImage;		/* Size of memory to allocate for prog.  */
-  long    SizeOfHeaders;	/* Size of PE header and section table.  */
-  long    CheckSum;		/* Set to 0.  */
+  long long    Reserved1;		/* Seems to be 0.  */
+  long long    SizeOfImage;		/* Size of memory to allocate for prog.  */
+  long long    SizeOfHeaders;	/* Size of PE header and section table.  */
+  long long    CheckSum;		/* Set to 0.  */
   short   Subsystem;	
 
   /* Type of subsystem exe uses for user interface,
@@ -240,8 +240,8 @@ struct internal_extra_pe_aouthdr
 				    initial thread's stack, default is 0x1000.  */
   bfd_vma SizeOfHeapReserve;	/* Amount of virtual memory to reserve and */
   bfd_vma SizeOfHeapCommit;	/*  commit, don't know what to defaut it to.  */
-  long    LoaderFlags;		/* Can probably set to 0.  */
-  long    NumberOfRvaAndSizes;	/* Number of entries in next entry, 16.  */
+  long long    LoaderFlags;		/* Can probably set to 0.  */
+  long long    NumberOfRvaAndSizes;	/* Number of entries in next entry, 16.  */
   IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
 };
 
@@ -275,14 +275,14 @@ struct internal_aouthdr
   /* ECOFF stuff */
   bfd_vma bss_start;		/* Base of bss section.		*/
   bfd_vma gp_value;		/* GP register value.		*/
-  unsigned long gprmask;	/* General registers used.	*/
-  unsigned long cprmask[4];	/* Coprocessor registers used.	*/
-  unsigned long fprmask;	/* Floating pointer registers used.  */
+  unsigned long long gprmask;	/* General registers used.	*/
+  unsigned long long cprmask[4];	/* Coprocessor registers used.	*/
+  unsigned long long fprmask;	/* Floating pointer registers used.  */
 
   /* Apollo stuff */
-  long o_inlib;			/* inlib data */
-  long o_sri;			/* Static Resource Information */
-  long vid[2];			/* Version id */
+  long long o_inlib;			/* inlib data */
+  long long o_sri;			/* Static Resource Information */
+  long long vid[2];			/* Version id */
 
   struct internal_extra_pe_aouthdr pe;
 };
@@ -406,9 +406,9 @@ struct internal_scnhdr
   bfd_vma s_scnptr;		/* file ptr to raw data for section */
   bfd_vma s_relptr;		/* file ptr to relocation	*/
   bfd_vma s_lnnoptr;		/* file ptr to line numbers	*/
-  unsigned long s_nreloc;	/* number of relocation entries	*/
-  unsigned long s_nlnno;	/* number of line number entries*/
-  long s_flags;			/* flags			*/
+  unsigned long long s_nreloc;	/* number of relocation entries	*/
+  unsigned long long s_nlnno;	/* number of line number entries*/
+  long long s_flags;			/* flags			*/
   unsigned char s_page;         /* TI COFF load page            */
 };
 
@@ -453,7 +453,7 @@ struct internal_lineno
     bfd_signed_vma l_symndx;		/* function name symbol index, iff l_lnno == 0*/
     bfd_signed_vma l_paddr;		/* (physical) address of line number	*/
   }     l_addr;
-  unsigned long l_lnno;		/* line number		*/
+  unsigned long long l_lnno;		/* line number		*/
 };
 
 /********************** SYMBOLS **********************/
@@ -526,11 +526,11 @@ struct internal_syment
 #define DTYPE(x)	(((x) & N_TMASK) >> N_BTSHFT)
 
 #define ISPTR(x) \
-  (((unsigned long) (x) & N_TMASK) == ((unsigned long) DT_PTR << N_BTSHFT))
+  (((unsigned long long) (x) & N_TMASK) == ((unsigned long long) DT_PTR << N_BTSHFT))
 #define ISFCN(x) \
-  (((unsigned long) (x) & N_TMASK) == ((unsigned long) DT_FCN << N_BTSHFT))
+  (((unsigned long long) (x) & N_TMASK) == ((unsigned long long) DT_FCN << N_BTSHFT))
 #define ISARY(x) \
-  (((unsigned long) (x) & N_TMASK) == ((unsigned long) DT_ARY << N_BTSHFT))
+  (((unsigned long long) (x) & N_TMASK) == ((unsigned long long) DT_ARY << N_BTSHFT))
 #define ISTAG(x) \
   ((x) == C_STRTAG || (x) == C_UNTAG || (x) == C_ENTAG)
 #define DECREF(x) \
@@ -543,7 +543,7 @@ union internal_auxent
 
     union
     {
-      long l;			/* str, un, or enum tag indx */
+      long long l;			/* str, un, or enum tag indx */
       struct coff_ptr_struct *p;
     }     x_tagndx;
 
@@ -554,7 +554,7 @@ union internal_auxent
 	unsigned short x_lnno;	/* declaration line number */
 	unsigned short x_size;	/* str/union/array size */
       }      x_lnsz;
-      long x_fsize;		/* size of function */
+      long long x_fsize;		/* size of function */
     }     x_misc;
 
     union
@@ -564,7 +564,7 @@ union internal_auxent
 	bfd_signed_vma x_lnnoptr;		/* ptr to fcn line # */
 	union
 	{			/* entry ndx past block end */
-	  long l;
+	  long long l;
 	  struct coff_ptr_struct *p;
 	}     x_endndx;
       }      x_fcn;
@@ -587,24 +587,24 @@ union internal_auxent
     char x_fname[20];
     struct
     {
-      long x_zeroes;
-      long x_offset;
+      long long x_zeroes;
+      long long x_offset;
     }      x_n;
   }     x_file;
 
   struct
   {
-    long x_scnlen;		/* section length */
+    long long x_scnlen;		/* section length */
     unsigned short x_nreloc;	/* # relocation entries */
     unsigned short x_nlinno;	/* # line numbers */
-    unsigned long x_checksum;	/* section COMDAT checksum for PE */
+    unsigned long long x_checksum;	/* section COMDAT checksum for PE */
     unsigned short x_associated; /* COMDAT associated section index for PE */
     unsigned char x_comdat;	/* COMDAT selection number for PE */
   }      x_scn;
 
   struct
   {
-    long x_tvfill;		/* tv fill value */
+    long long x_tvfill;		/* tv fill value */
     unsigned short x_tvlen;	/* length of .tv */
     unsigned short x_tvran[2];	/* tv range */
   }      x_tv;			/* info about .tv section (in auxent of symbol .tv)) */
@@ -619,13 +619,13 @@ union internal_auxent
 	bfd_signed_vma l;
 	struct coff_ptr_struct *p;
       } x_scnlen;
-    long x_parmhash;		/* parm type hash index */
+    long long x_parmhash;		/* parm type hash index */
     unsigned short x_snhash;	/* sect num with parm hash */
     unsigned char x_smtyp;	/* symbol align and type */
     /* 0-4 - Log 2 of alignment */
     /* 5-7 - symbol type */
     unsigned char x_smclas;	/* storage mapping class */
-    long x_stab;		/* dbx stab info index */
+    long long x_stab;		/* dbx stab info index */
     unsigned short x_snstab;	/* sect num with dbx stab */
   }      x_csect;		/* csect definition information */
 
@@ -667,11 +667,11 @@ union internal_auxent
 struct internal_reloc
 {
   bfd_vma r_vaddr;		/* Virtual address of reference */
-  long r_symndx;		/* Index into symbol table	*/
+  long long r_symndx;		/* Index into symbol table	*/
   unsigned short r_type;	/* Relocation type		*/
   unsigned char r_size;		/* Used by RS/6000 and ECOFF	*/
   unsigned char r_extern;	/* Used by ECOFF		*/
-  unsigned long r_offset;	/* Used by Alpha ECOFF, SPARC, others */
+  unsigned long long r_offset;	/* Used by Alpha ECOFF, SPARC, others */
 };
 
 /* X86-64 relocations.  */
diff --git a/include/coff/sym.h b/include/coff/sym.h
index 76204af..efed4b1 100644
--- a/include/coff/sym.h
+++ b/include/coff/sym.h
@@ -65,28 +65,28 @@
 typedef struct {
 	short	magic;		/* to verify validity of the table */
 	short	vstamp;		/* version stamp */
-	long	ilineMax;	/* number of line number entries */
+	long long	ilineMax;	/* number of line number entries */
 	bfd_vma	cbLine;		/* number of bytes for line number entries */
 	bfd_vma	cbLineOffset;	/* offset to start of line number entries*/
-	long	idnMax;		/* max index into dense number table */
+	long long	idnMax;		/* max index into dense number table */
 	bfd_vma	cbDnOffset;	/* offset to start dense number table */
-	long	ipdMax;		/* number of procedures */
+	long long	ipdMax;		/* number of procedures */
 	bfd_vma	cbPdOffset;	/* offset to procedure descriptor table */
-	long	isymMax;	/* number of local symbols */
+	long long	isymMax;	/* number of local symbols */
 	bfd_vma	cbSymOffset;	/* offset to start of local symbols*/
-	long	ioptMax;	/* max index into optimization symbol entries */
+	long long	ioptMax;	/* max index into optimization symbol entries */
 	bfd_vma	cbOptOffset;	/* offset to optimization symbol entries */
-	long	iauxMax;	/* number of auxillary symbol entries */
+	long long	iauxMax;	/* number of auxillary symbol entries */
 	bfd_vma	cbAuxOffset;	/* offset to start of auxillary symbol entries*/
-	long	issMax;		/* max index into local strings */
+	long long	issMax;		/* max index into local strings */
 	bfd_vma	cbSsOffset;	/* offset to start of local strings */
-	long	issExtMax;	/* max index into external strings */
+	long long	issExtMax;	/* max index into external strings */
 	bfd_vma	cbSsExtOffset;	/* offset to start of external strings */
-	long	ifdMax;		/* number of file descriptor entries */
+	long long	ifdMax;		/* number of file descriptor entries */
 	bfd_vma	cbFdOffset;	/* offset to file descriptor table */
-	long	crfd;		/* number of relative file descriptor entries */
+	long long	crfd;		/* number of relative file descriptor entries */
 	bfd_vma	cbRfdOffset;	/* offset to relative file descriptor table */
-	long	iextMax;	/* max index into external symbols */
+	long long	iextMax;	/* max index into external symbols */
 	bfd_vma	cbExtOffset;	/* offset to start of external symbol entries*/
 	/* If you add machine dependent fields, add them here */
 	} HDRR, *pHDRR; 
@@ -112,21 +112,21 @@ typedef struct {
  */
 typedef struct fdr {
 	bfd_vma	adr;		/* memory address of beginning of file */
-	long	rss;		/* file name (of source, if known) */
-	long	issBase;	/* file's string space */
+	long long	rss;		/* file name (of source, if known) */
+	long long	issBase;	/* file's string space */
 	bfd_vma	cbSs;		/* number of bytes in the ss */
-	long	isymBase;	/* beginning of symbols */
-	long	csym;		/* count file's of symbols */
-	long	ilineBase;	/* file's line symbols */
-	long	cline;		/* count of file's line symbols */
-	long	ioptBase;	/* file's optimization entries */
-	long	copt;		/* count of file's optimization entries */
+	long long	isymBase;	/* beginning of symbols */
+	long long	csym;		/* count file's of symbols */
+	long long	ilineBase;	/* file's line symbols */
+	long long	cline;		/* count of file's line symbols */
+	long long	ioptBase;	/* file's optimization entries */
+	long long	copt;		/* count of file's optimization entries */
 	unsigned short ipdFirst;/* start of procedures for this file */
 	short	cpd;		/* count of procedures for this file */
-	long	iauxBase;	/* file's auxiliary entries */
-	long	caux;		/* count of file's auxiliary entries */
-	long	rfdBase;	/* index into the file indirect table */
-	long	crfd;		/* count file indirect entries */
+	long long	iauxBase;	/* file's auxiliary entries */
+	long long	caux;		/* count of file's auxiliary entries */
+	long long	rfdBase;	/* index into the file indirect table */
+	long long	crfd;		/* count file indirect entries */
 	unsigned lang: 5;	/* language for this file */
 	unsigned fMerge : 1;	/* whether this file can be merged */
 	unsigned fReadin : 1;	/* true if it was read in (not just created) */
@@ -155,18 +155,18 @@ typedef struct fdr {
 
 typedef struct pdr {
 	bfd_vma	adr;		/* memory address of start of procedure */
-	long	isym;		/* start of local symbol entries */
-	long	iline;		/* start of line number entries*/
-	long	regmask;	/* save register mask */
-	long	regoffset;	/* save register offset */
-	long	iopt;		/* start of optimization symbol entries*/
-	long	fregmask;	/* save floating point register mask */
-	long	fregoffset;	/* save floating point register offset */
-	long	frameoffset;	/* frame size */
+	long long	isym;		/* start of local symbol entries */
+	long long	iline;		/* start of line number entries*/
+	long long	regmask;	/* save register mask */
+	long long	regoffset;	/* save register offset */
+	long long	iopt;		/* start of optimization symbol entries*/
+	long long	fregmask;	/* save floating point register mask */
+	long long	fregoffset;	/* save floating point register offset */
+	long long	frameoffset;	/* frame size */
 	short	framereg;	/* frame pointer register */
 	short	pcreg;		/* offset or reg of return pc */
-	long	lnLow;		/* lowest line in the procedure */
-	long	lnHigh;		/* highest line in the procedure */
+	long long	lnLow;		/* lowest line in the procedure */
+	long long	lnHigh;		/* highest line in the procedure */
 	bfd_vma	cbLineOffset;	/* byte offset for this procedure from the fd base */
 	/* These fields are new for 64 bit ECOFF.  */
 	unsigned gp_prologue : 8; /* byte size of GP prologue */
@@ -191,15 +191,15 @@ typedef struct pdr {
 #if 0
 typedef struct runtime_pdr {
 	bfd_vma	adr;		/* memory address of start of procedure */
-	long	regmask;	/* save register mask */
-	long	regoffset;	/* save register offset */
-	long	fregmask;	/* save floating point register mask */
-	long	fregoffset;	/* save floating point register offset */
-	long	frameoffset;	/* frame size */
+	long long	regmask;	/* save register mask */
+	long long	regoffset;	/* save register offset */
+	long long	fregmask;	/* save floating point register mask */
+	long long	fregoffset;	/* save floating point register offset */
+	long long	frameoffset;	/* frame size */
 	short	framereg;	/* frame pointer register */
 	short	pcreg;		/* offset or reg of return pc */
-	long	irpss;		/* index into the runtime string table */
-	long	reserved;
+	long long	irpss;		/* index into the runtime string table */
+	long long	reserved;
 	struct exception_info *exception_info;/* pointer to exception array */
 } RPDR, *pRPDR;
 #define cbRPDR sizeof(RPDR)
@@ -218,7 +218,7 @@ typedef struct runtime_pdr {
  * the first line of a procedure and represent the first address.
  */
 
-typedef	long LINER, *pLINER;
+typedef	long long LINER, *pLINER;
 #define lineNil ((pLINER)0)
 #define cbLINER sizeof(LINER)
 #define ilineNil	-1
@@ -230,7 +230,7 @@ typedef	long LINER, *pLINER;
  */
 
 typedef struct {
-	long	iss;		/* index into String Space of name */
+	long long	iss;		/* index into String Space of name */
 	bfd_vma	value;		/* value of symbol */
 	unsigned st : 6;	/* symbol type */
 	unsigned sc  : 5;	/* storage class - text, data, etc */
@@ -248,7 +248,7 @@ typedef struct {
 /* The following converts a memory resident string to an iss.
  * This hack is recognized in SbFIss, in sym.c of the debugger.
  */
-#define IssFSb(sb) (0x80000000 | ((unsigned long)(sb)))
+#define IssFSb(sb) (0x80000000 | ((unsigned long long)(sb)))
 
 /* E X T E R N A L   S Y M B O L  R E C O R D
  *
@@ -306,8 +306,8 @@ typedef struct {
  *	a rfd of 0xffffffff is an index into the global table.
  */
 typedef struct {
-	unsigned long	rfd;    /* index into the file table */
-	unsigned long	index; 	/* index int sym/aux/iss tables */
+	unsigned long long	rfd;    /* index into the file table */
+	unsigned long long	index; 	/* index int sym/aux/iss tables */
 	} DNR, *pDNR;
 #define cbDNR sizeof(DNR)
 #define dnNil ((pDNR)0)
@@ -342,12 +342,12 @@ typedef struct {
 typedef union {
 	TIR	ti;		/* type information record */
 	RNDXR	rndx;		/* relative index into symbol table */
-	long	dnLow;		/* low dimension */
-	long	dnHigh;		/* high dimension */
-	long	isym;		/* symbol table index (end of proc) */
-	long	iss;		/* index into string space (not used) */
-	long	width;		/* width for non-default sized struc fields */
-	long	count;		/* count of ranges for variant arm */
+	long long	dnLow;		/* low dimension */
+	long long	dnHigh;		/* high dimension */
+	long long	isym;		/* symbol table index (end of proc) */
+	long long	iss;		/* index into string space (not used) */
+	long long	width;		/* width for non-default sized struc fields */
+	long long	count;		/* count of ranges for variant arm */
 	} AUXU, *pAUXU;
 #define cbAUXU sizeof(AUXU)
 #define auxNil ((pAUXU)0)
@@ -369,7 +369,7 @@ typedef struct {
 	unsigned ot: 8;		/* optimization type */
 	unsigned value: 24;	/* address where we are moving it to */
 	RNDXR	rndx;		/* points to a symbol or opt entry */
-	unsigned long	offset;	/* relative offset this occured */
+	unsigned long long	offset;	/* relative offset this occured */
 	} OPTR, *pOPTR;
 #define optNil	((pOPTR) 0)
 #define cbOPTR sizeof(OPTR)
@@ -385,7 +385,7 @@ typedef struct {
  *
  */
 
-typedef long RFDT, *pRFDT;
+typedef long long RFDT, *pRFDT;
 #define cbRFDT sizeof(RFDT)
 #define rfdNil	-1
 
@@ -394,7 +394,7 @@ typedef long RFDT, *pRFDT;
  * This is done to keep the code in the loader readable in the area where
  * these tables are merged.  Note this is only a name change.
  */
-typedef long FIT, *pFIT;
+typedef long long FIT, *pFIT;
 #define cbFIT	sizeof(FIT)
 #define ifiNil	-1
 #define fiNil	((pFIT) 0)
diff --git a/include/coff/tic54x.h b/include/coff/tic54x.h
index b01b631..413c521 100644
--- a/include/coff/tic54x.h
+++ b/include/coff/tic54x.h
@@ -52,7 +52,7 @@
 #define NEEDS_PAGE(X) ((X)==C_EXT)
 #define PAGE_MASK       0xFF000000
 #define ADDR_MASK       0x00FFFFFF
-#define PG_TO_FLAG(p)   (((unsigned long)(p) & 0xFF) << 24)
+#define PG_TO_FLAG(p)   (((unsigned long long)(p) & 0xFF) << 24)
 #define FLAG_TO_PG(f)   (((f) >> 24) & 0xFF)
 
 #include "coff/ti.h"
diff --git a/include/coff/xcoff.h b/include/coff/xcoff.h
index 77c6bb2..7d323fd 100644
--- a/include/coff/xcoff.h
+++ b/include/coff/xcoff.h
@@ -183,7 +183,7 @@ struct internal_ldhdr
   /* The version number: 
      1 : 32 bit
      2 : 64 bit */
-  unsigned long l_version;
+  unsigned long long l_version;
 
   /* The number of symbol table entries.  */
   bfd_size_type l_nsyms;
@@ -227,11 +227,11 @@ struct internal_ldsym
     struct
     {
       /* Zero if the symbol name is more than SYMNMLEN characters.  */
-	long _l_zeroes;
+	long long _l_zeroes;
       
       /* The offset in the string table if the symbol name is more
 	 than SYMNMLEN characters.  */
-      long _l_offset;
+      long long _l_offset;
     } 
     _l_l;
   }
@@ -293,7 +293,7 @@ struct xcoff_link_hash_entry
 
   /* Symbol index in output file.  Set to -1 initially.  Set to -2 if
      there is a reloc against this symbol.  */
-  long indx;
+  long long indx;
 
   /* If we have created a TOC entry for this symbol, this is the .tc
      section which holds it.  */
@@ -307,7 +307,7 @@ struct xcoff_link_hash_entry
     
     /* If the TOC entry comes from an input file, this is set to the
        symbol index of the C_HIDEXT XMC_TC or XMC_TD symbol.  */
-    long toc_indx;
+    long long toc_indx;
   } 
   u;
 
@@ -323,10 +323,10 @@ struct xcoff_link_hash_entry
   /* If XCOFF_BUILT_LDSYM is set, this is the .loader symbol table
      index.  If XCOFF_BUILD_LDSYM is clear, and XCOFF_IMPORT is set,
      this is the l_ifile value.  */
-  long ldindx;
+  long long ldindx;
 
   /* Some linker flags.  */
-  unsigned long flags;
+  unsigned long long flags;
 
   /* The storage mapping class.  */
   unsigned char smclas;
diff --git a/include/demangle.h b/include/demangle.h
index b8d57cf..f6b380b 100644
--- a/include/demangle.h
+++ b/include/demangle.h
@@ -575,7 +575,7 @@ struct demangle_component
     struct
     {
       /* Parameter index.  */
-      long number;
+      long long number;
     } s_number;
 
     /* For DEMANGLE_COMPONENT_CHARACTER.  */
diff --git a/include/dis-asm.h b/include/dis-asm.h
index 77b9e61..aef2592 100644
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -72,7 +72,7 @@ typedef struct disassemble_info
   /* The bfd_arch value.  */
   enum bfd_architecture arch;
   /* The bfd_mach value.  */
-  unsigned long mach;
+  unsigned long long mach;
   /* Endianness (for bi-endian cpus).  Mono-endian cpus can ignore this.  */
   enum bfd_endian endian;
   /* Endianness of code, for mixed-endian situations such as ARM BE8.  */
@@ -106,7 +106,7 @@ typedef struct disassemble_info
   /* For use by the disassembler.
      The top 16 bits are reserved for public use (and are documented here).
      The bottom 16 bits are for the internal use of the disassembler.  */
-  unsigned long flags;
+  unsigned long long flags;
   /* Set if the disassembler has determined that there are one or more
      relocations associated with the instruction being disassembled.  */
 #define INSN_HAS_RELOC	 (1 << 31)
@@ -312,7 +312,7 @@ extern const disasm_options_and_args_t *disassembler_options_s390 (void);
    endian if BIG is true), bfd_mach value MACH, and ABFD, if that support
    is available.  ABFD may be NULL.  */
 extern disassembler_ftype disassembler (enum bfd_architecture arc,
-					bfd_boolean big, unsigned long mach,
+					bfd_boolean big, unsigned long long mach,
 					bfd *abfd);
 
 /* Amend the disassemble_info structure as necessary for the target architecture.
diff --git a/include/elf/alpha.h b/include/elf/alpha.h
index 73c79e6..ddd3492 100644
--- a/include/elf/alpha.h
+++ b/include/elf/alpha.h
@@ -52,11 +52,11 @@
 typedef struct
 {
   /* Mask of general purpose registers used.  */
-  unsigned long ri_gprmask;
+  unsigned long long ri_gprmask;
   /* Mask of co-processor registers used.  */
-  unsigned long ri_cprmask[4];
+  unsigned long long ri_cprmask[4];
   /* GP register value for this object file.  */
-  long ri_gp_value;
+  long long ri_gp_value;
 } Elf64_RegInfo;
 
 /* Special values for the st_other field in the symbol table.  */
diff --git a/include/elf/internal.h b/include/elf/internal.h
index 05f9fab..f261b4d 100644
--- a/include/elf/internal.h
+++ b/include/elf/internal.h
@@ -69,8 +69,8 @@ typedef struct elf_internal_ehdr {
   bfd_vma		e_entry;	/* Entry point virtual address */
   bfd_size_type		e_phoff;	/* Program header table file offset */
   bfd_size_type		e_shoff;	/* Section header table file offset */
-  unsigned long		e_version;	/* Identifies object file version */
-  unsigned long		e_flags;	/* Processor-specific flags */
+  unsigned long long		e_version;	/* Identifies object file version */
+  unsigned long long		e_flags;	/* Processor-specific flags */
   unsigned short	e_type;		/* Identifies object file type */
   unsigned short	e_machine;	/* Specifies required architecture */
   unsigned int		e_ehsize;	/* ELF header size in bytes */
@@ -84,8 +84,8 @@ typedef struct elf_internal_ehdr {
 /* Program header */
 
 struct elf_internal_phdr {
-  unsigned long	p_type;			/* Identifies program segment type */
-  unsigned long	p_flags;		/* Segment flags */
+  unsigned long long	p_type;			/* Identifies program segment type */
+  unsigned long long	p_flags;		/* Segment flags */
   bfd_vma	p_offset;		/* Segment file offset */
   bfd_vma	p_vaddr;		/* Segment virtual address */
   bfd_vma	p_paddr;		/* Segment physical address */
@@ -128,7 +128,7 @@ typedef struct elf_internal_chdr {
 struct elf_internal_sym {
   bfd_vma	st_value;		/* Value of the symbol */
   bfd_vma	st_size;		/* Associated symbol size */
-  unsigned long	st_name;		/* Symbol name, index in string tbl */
+  unsigned long long	st_name;		/* Symbol name, index in string tbl */
   unsigned char	st_info;		/* Type and binding attributes */
   unsigned char	st_other;		/* Visibilty, and target specific */
   unsigned char st_target_internal;	/* Internal-only information */
@@ -140,9 +140,9 @@ typedef struct elf_internal_sym Elf_Internal_Sym;
 /* Note segments */
 
 typedef struct elf_internal_note {
-  unsigned long	namesz;			/* Size of entry's owner string */
-  unsigned long	descsz;			/* Size of the note descriptor */
-  unsigned long	type;			/* Interpretation of the descriptor */
+  unsigned long long	namesz;			/* Size of entry's owner string */
+  unsigned long long	descsz;			/* Size of the note descriptor */
+  unsigned long long	type;			/* Interpretation of the descriptor */
   char *	namedata;		/* Start of the name+desc data */
   char *	descdata;		/* Start of the desc data */
   bfd_vma	descpos;		/* File offset of the descdata */
@@ -175,9 +175,9 @@ typedef struct elf_internal_verdef {
   unsigned short vd_flags;	/* Flags (VER_FLG_*).  */
   unsigned short vd_ndx;	/* Version index.  */
   unsigned short vd_cnt;	/* Number of verdaux entries.  */
-  unsigned long	 vd_hash;	/* Hash of name.  */
-  unsigned long	 vd_aux;	/* Offset to verdaux entries.  */
-  unsigned long	 vd_next;	/* Offset to next verdef.  */
+  unsigned long long	 vd_hash;	/* Hash of name.  */
+  unsigned long long	 vd_aux;	/* Offset to verdaux entries.  */
+  unsigned long long	 vd_next;	/* Offset to next verdef.  */
 
   /* These fields are set up when BFD reads in the structure.  FIXME:
      It would be cleaner to store these in a different structure.  */
@@ -191,8 +191,8 @@ typedef struct elf_internal_verdef {
 /* This structure appears in a SHT_GNU_verdef section.  */
 
 typedef struct elf_internal_verdaux {
-  unsigned long vda_name;	/* String table offset of name.  */
-  unsigned long vda_next;	/* Offset to next verdaux.  */
+  unsigned long long vda_name;	/* String table offset of name.  */
+  unsigned long long vda_next;	/* Offset to next verdaux.  */
 
   /* These fields are set up when BFD reads in the structure.  FIXME:
      It would be cleaner to store these in a different structure.  */
@@ -205,9 +205,9 @@ typedef struct elf_internal_verdaux {
 typedef struct elf_internal_verneed {
   unsigned short vn_version;	/* Version number of structure.  */
   unsigned short vn_cnt;	/* Number of vernaux entries.  */
-  unsigned long	 vn_file;	/* String table offset of library name.  */
-  unsigned long	 vn_aux;	/* Offset to vernaux entries.  */
-  unsigned long	 vn_next;	/* Offset to next verneed.  */
+  unsigned long long	 vn_file;	/* String table offset of library name.  */
+  unsigned long long	 vn_aux;	/* Offset to vernaux entries.  */
+  unsigned long long	 vn_next;	/* Offset to next verneed.  */
 
   /* These fields are set up when BFD reads in the structure.  FIXME:
      It would be cleaner to store these in a different structure.  */
@@ -220,11 +220,11 @@ typedef struct elf_internal_verneed {
 /* This structure appears in a SHT_GNU_verneed section.  */
 
 typedef struct elf_internal_vernaux {
-  unsigned long	 vna_hash;	/* Hash of dependency name.  */
+  unsigned long long	 vna_hash;	/* Hash of dependency name.  */
   unsigned short vna_flags;	/* Flags (VER_FLG_*).  */
   unsigned short vna_other;	/* Unused.  */
-  unsigned long	 vna_name;	/* String table offset to version name.  */
-  unsigned long	 vna_next;	/* Offset to next vernaux.  */
+  unsigned long long	 vna_name;	/* String table offset to version name.  */
+  unsigned long long	 vna_next;	/* Offset to next vernaux.  */
 
   /* These fields are set up when BFD reads in the structure.  FIXME:
      It would be cleaner to store these in a different structure.  */
@@ -262,9 +262,9 @@ struct elf_segment_map
   /* Next program segment.  */
   struct elf_segment_map *next;
   /* Program segment type.  */
-  unsigned long p_type;
+  unsigned long long p_type;
   /* Program segment flags.  */
-  unsigned long p_flags;
+  unsigned long long p_flags;
   /* Program segment physical address.  */
   bfd_vma p_paddr;
   /* Program segment virtual address offset from section vma.  */
diff --git a/include/elf/mips.h b/include/elf/mips.h
index 4e2cde3..cdb1ec5 100644
--- a/include/elf/mips.h
+++ b/include/elf/mips.h
@@ -457,15 +457,15 @@ END_RELOC_NUMBERS (R_MIPS_maxext)
 typedef struct
 {
   /* String table index for name of shared object.  */
-  unsigned long l_name;
+  unsigned long long l_name;
   /* Time stamp.  */
-  unsigned long l_time_stamp;
+  unsigned long long l_time_stamp;
   /* Checksum of symbol names and common sizes.  */
-  unsigned long l_checksum;
+  unsigned long long l_checksum;
   /* String table index for version.  */
-  unsigned long l_version;
+  unsigned long long l_version;
   /* Flags.  */
-  unsigned long l_flags;
+  unsigned long long l_flags;
 } Elf32_Lib;
 
 /* The external version of Elf32_Lib.  */
@@ -502,10 +502,10 @@ typedef struct
 
 /* A section of type SHT_MIPS_CONFLICT is an array of indices into the
    .dynsym section.  Each element has the following type.  */
-typedef unsigned long Elf32_Conflict;
+typedef unsigned long long Elf32_Conflict;
 typedef unsigned char Elf32_External_Conflict[4];
 
-typedef unsigned long Elf64_Conflict;
+typedef unsigned long long Elf64_Conflict;
 typedef unsigned char Elf64_External_Conflict[8];
 
 /* A section of type SHT_MIPS_GPTAB contains information about how
@@ -521,16 +521,16 @@ typedef union
   struct
     {
       /* -G value actually used for this object file.  */
-      unsigned long gt_current_g_value;
+      unsigned long long gt_current_g_value;
       /* Unused.  */
-      unsigned long gt_unused;
+      unsigned long long gt_unused;
     } gt_header;
   struct
     {
       /* If this -G argument has been used...  */
-      unsigned long gt_g_value;
+      unsigned long long gt_g_value;
       /* ...this many GP section bytes would be required.  */
-      unsigned long gt_bytes;
+      unsigned long long gt_bytes;
     } gt_entry;
 } Elf32_gptab;
 
@@ -555,11 +555,11 @@ typedef union
 typedef struct
 {
   /* Mask of general purpose registers used.  */
-  unsigned long ri_gprmask;
+  unsigned long long ri_gprmask;
   /* Mask of co-processor registers used.  */
-  unsigned long ri_cprmask[4];
+  unsigned long long ri_cprmask[4];
   /* GP register value for this object file.  */
-  long ri_gp_value;
+  long long ri_gp_value;
 } Elf32_RegInfo;
 
 /* The external version of the Elf_RegInfo structure.  */
@@ -909,7 +909,7 @@ typedef struct
   /* Address of relocation.  */
   bfd_vma r_offset;
   /* Symbol index.  */
-  unsigned long r_sym;
+  unsigned long long r_sym;
   /* Special symbol.  */
   unsigned char r_ssym;
   /* Third relocation.  */
@@ -945,7 +945,7 @@ typedef struct
   /* Address of relocation.  */
   bfd_vma r_offset;
   /* Symbol index.  */
-  unsigned long r_sym;
+  unsigned long long r_sym;
   /* Special symbol.  */
   unsigned char r_ssym;
   /* Third relocation.  */
@@ -1002,7 +1002,7 @@ typedef struct
   /* Section index of affected section, or 0 for global option.  */
   unsigned short section;
   /* Information specific to this kind of option.  */
-  unsigned long info;
+  unsigned long long info;
 } Elf_Internal_Options;
 
 /* MIPS ELF option header swapping routines.  */
@@ -1066,11 +1066,11 @@ typedef struct
 typedef struct
 {
   /* Mask of general purpose registers used.  */
-  unsigned long ri_gprmask;
+  unsigned long long ri_gprmask;
   /* Padding.  */
-  unsigned long ri_pad;
+  unsigned long long ri_pad;
   /* Mask of co-processor registers used.  */
-  unsigned long ri_cprmask[4];
+  unsigned long long ri_cprmask[4];
   /* GP register value for this object file.  */
   bfd_vma ri_gp_value;
 } Elf64_Internal_RegInfo;
@@ -1119,12 +1119,12 @@ typedef struct elf_internal_abiflags_v0
   /* The floating-point ABI.  */
   unsigned char fp_abi;
   /* Processor-specific extension.  */
-  unsigned long isa_ext;
+  unsigned long long isa_ext;
   /* Mask of ASEs used.  */
-  unsigned long ases;
+  unsigned long long ases;
   /* Mask of general flags.  */
-  unsigned long flags1;
-  unsigned long flags2;
+  unsigned long long flags1;
+  unsigned long long flags2;
 } Elf_Internal_ABIFlags_v0;
 
 typedef struct
@@ -1146,7 +1146,7 @@ typedef struct
 {
   /* The hash value computed from the name of the corresponding
      dynamic symbol.  */
-  unsigned long ms_hash_value;
+  unsigned long long ms_hash_value;
   /* Contains both the dynamic relocation index and the symbol flags
      field.  The macros ELF32_MS_REL_INDEX and ELF32_MS_FLAGS are used
      to access the individual values.  The dynamic relocation index
@@ -1154,7 +1154,7 @@ typedef struct
      references the dynamic symbol corresponding to this msym entry.
      If the index is 0, no dynamic relocations are associated with the
      symbol.  The symbol flags field is reserved for future use.  */
-  unsigned long ms_info;
+  unsigned long long ms_info;
 } Elf32_Internal_Msym;
 
 #define ELF32_MS_REL_INDEX(i) ((i) >> 8)
diff --git a/include/elf/reloc-macros.h b/include/elf/reloc-macros.h
index 1f82051..fe56cfa 100644
--- a/include/elf/reloc-macros.h
+++ b/include/elf/reloc-macros.h
@@ -97,9 +97,9 @@
    the relocation is not recognised, NULL is returned.  */
 
 #define START_RELOC_NUMBERS(name)   				\
-static const char *name (unsigned long rtype);			\
+static const char *name (unsigned long long rtype);			\
 static const char *						\
-name (unsigned long rtype)					\
+name (unsigned long long rtype)					\
 {								\
   switch (rtype)						\
     {
diff --git a/include/elf/sh.h b/include/elf/sh.h
index d60d879..66395a9 100644
--- a/include/elf/sh.h
+++ b/include/elf/sh.h
@@ -87,7 +87,7 @@ extern "C" {
 int sh_find_elf_flags (unsigned int arch_set);
 
 /* Convert bfd_mach_* into EF_SH*.  */
-int sh_elf_get_flags_from_mach (unsigned long mach);
+int sh_elf_get_flags_from_mach (unsigned long long mach);
 
 /* Other e_flags bits.  */
 
diff --git a/include/fibheap.h b/include/fibheap.h
index 9fc6dcd..144c771 100644
--- a/include/fibheap.h
+++ b/include/fibheap.h
@@ -46,7 +46,7 @@ Boston, MA 02110-1301, USA.  */
 extern "C" {
 #endif
 
-typedef long fibheapkey_t;
+typedef long long fibheapkey_t;
 
 typedef struct fibheap
 {
@@ -64,8 +64,8 @@ typedef struct fibnode
   fibheapkey_t key;
   void *data;
 #if defined (__GNUC__) && (!defined (SIZEOF_INT) || SIZEOF_INT < 4)
-  __extension__ unsigned long int degree : 31;
-  __extension__ unsigned long int mark : 1;
+  __extension__ unsigned long long int degree : 31;
+  __extension__ unsigned long long int mark : 1;
 #else
   unsigned int degree : 31;
   unsigned int mark : 1;
diff --git a/include/gcc-c-fe.def b/include/gcc-c-fe.def
index 73aa50f..16bbd58 100644
--- a/include/gcc-c-fe.def
+++ b/include/gcc-c-fe.def
@@ -84,8 +84,8 @@ GCC_METHOD5 (int /* bool */, build_add_field,
 	     gcc_type,			   /* Argument RECORD_OR_UNION_TYPE. */
 	     const char *,		   /* Argument FIELD_NAME.  */
 	     gcc_type,			   /* Argument FIELD_TYPE.  */
-	     unsigned long,		   /* Argument BITSIZE.  */
-	     unsigned long)		   /* Argument BITPOS.  */
+	     unsigned long long,		   /* Argument BITSIZE.  */
+	     unsigned long long)		   /* Argument BITPOS.  */
 
 /* After all the fields have been added to a struct or union, the
    struct or union type must be "finished".  This does some final
@@ -93,7 +93,7 @@ GCC_METHOD5 (int /* bool */, build_add_field,
 
 GCC_METHOD2 (int /* bool */, finish_record_or_union,
 	     gcc_type,			   /* Argument RECORD_OR_UNION_TYPE. */
-	     unsigned long)		   /* Argument SIZE_IN_BYTES.  */
+	     unsigned long long)		   /* Argument SIZE_IN_BYTES.  */
 
 /* Create a new 'enum' type.  The new type initially has no
    associated constants.  */
@@ -107,7 +107,7 @@ GCC_METHOD1 (gcc_type, build_enum_type,
 GCC_METHOD3 (int /* bool */, build_add_enum_constant,
 	     gcc_type,		       /* Argument ENUM_TYPE.  */
 	     const char *,	       /* Argument NAME.  */
-	     unsigned long)	       /* Argument VALUE.  */
+	     unsigned long long)	       /* Argument VALUE.  */
 
 /* After all the constants have been added to an enum, the type must
    be "finished".  This does some final cleanups in GCC.  */
@@ -130,13 +130,13 @@ GCC_METHOD3 (gcc_type, build_function_type,
 
 GCC_METHOD2 (gcc_type, int_type_v0,
 	     int /* bool */,               /* Argument IS_UNSIGNED.  */
-	     unsigned long)                /* Argument SIZE_IN_BYTES.  */
+	     unsigned long long)                /* Argument SIZE_IN_BYTES.  */
 
 /* Return a floating point type with the given properties.
    Deprecated in v1, use float_type instead.  */
 
 GCC_METHOD1 (gcc_type, float_type_v0,
-	     unsigned long)                /* Argument SIZE_IN_BYTES.  */
+	     unsigned long long)                /* Argument SIZE_IN_BYTES.  */
 
 /* Return the 'void' type.  */
 
@@ -189,7 +189,7 @@ GCC_METHOD2 (gcc_type, build_vector_type,
 GCC_METHOD5 (int /* bool */, build_constant,
 	     gcc_type,		  /* Argument TYPE.  */
 	     const char *,	  /* Argument NAME.  */
-	     unsigned long,	  /* Argument VALUE.  */
+	     unsigned long long,	  /* Argument VALUE.  */
 	     const char *,	  /* Argument FILENAME.  */
 	     unsigned int)	  /* Argument LINE_NUMBER.  */
 
@@ -204,7 +204,7 @@ GCC_METHOD1 (gcc_type, error,
 
 GCC_METHOD3 (gcc_type, int_type,
 	     int /* bool */,               /* Argument IS_UNSIGNED.  */
-	     unsigned long,                /* Argument SIZE_IN_BYTES.  */
+	     unsigned long long,                /* Argument SIZE_IN_BYTES.  */
 	     const char *)		   /* Argument BUILTIN_NAME.  */
 
 /* Return the 'char' type, a distinct type from both 'signed char' and
@@ -217,6 +217,6 @@ GCC_METHOD0 (gcc_type, char_type)
    signedness and size, and that is the type that will be returned.  */
 
 GCC_METHOD2 (gcc_type, float_type,
-	     unsigned long,                /* Argument SIZE_IN_BYTES.  */
+	     unsigned long long,                /* Argument SIZE_IN_BYTES.  */
 	     const char *)		   /* Argument BUILTIN_NAME.  */
 
diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index dd564e5..23d2247 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -605,7 +605,7 @@ GCC_METHOD5 (gcc_expr, build_dependent_expr,
 
 GCC_METHOD2 (gcc_expr, build_literal_expr,
 	     gcc_type,		  /* Argument TYPE.  */
-	     unsigned long)	  /* Argument VALUE.  */
+	     unsigned long long)	  /* Argument VALUE.  */
 
 /* Build a gcc_expr that denotes DECL, the declaration of a variable
    or function in namespace scope, or of a static member variable or
@@ -793,8 +793,8 @@ GCC_METHOD5 (gcc_decl, build_field,
 	     const char *,		   /* Argument FIELD_NAME.  */
 	     gcc_type,			   /* Argument FIELD_TYPE.  */
 	     enum gcc_cp_symbol_kind,	   /* Argument FIELD_FLAGS.  */
-	     unsigned long,		   /* Argument BITSIZE.  */
-	     unsigned long)		   /* Argument BITPOS.  */
+	     unsigned long long,		   /* Argument BITSIZE.  */
+	     unsigned long long)		   /* Argument BITPOS.  */
 
 /* After all the fields have been added to a struct, class or union,
    the struct or union type must be "finished".  This does some final
@@ -803,7 +803,7 @@ GCC_METHOD5 (gcc_decl, build_field,
    start_closure_class_type.  */
 
 GCC_METHOD1 (int /* bool */, finish_class_type,
-	     unsigned long)		   /* Argument SIZE_IN_BYTES.  */
+	     unsigned long long)		   /* Argument SIZE_IN_BYTES.  */
 
 /* Create a new 'enum' type, and record it in the current binding
    level.  The new type initially has no associated constants.
@@ -824,7 +824,7 @@ GCC_METHOD5 (gcc_type, start_enum_type,
 GCC_METHOD3 (gcc_decl, build_enum_constant,
 	     gcc_type,		       /* Argument ENUM_TYPE.  */
 	     const char *,	       /* Argument NAME.  */
-	     unsigned long)	       /* Argument VALUE.  */
+	     unsigned long long)	       /* Argument VALUE.  */
 
 /* After all the constants have been added to an enum, the type must
    be "finished".  This does some final cleanups in GCC.  */
@@ -892,7 +892,7 @@ GCC_METHOD1 (gcc_expr, build_lambda_expr,
 
 GCC_METHOD3 (gcc_type, get_int_type,
 	     int /* bool */,		   /* Argument IS_UNSIGNED.  */
-	     unsigned long,                /* Argument SIZE_IN_BYTES.  */
+	     unsigned long long,                /* Argument SIZE_IN_BYTES.  */
 	     const char *)		   /* Argument BUILTIN_NAME.  */
 
 /* Return the 'char' type, a distinct type from both 'signed char' and
@@ -905,7 +905,7 @@ GCC_METHOD0 (gcc_type, get_char_type)
    signedness and size, and that is the type that will be returned.  */
 
 GCC_METHOD2 (gcc_type, get_float_type,
-	     unsigned long,                /* Argument SIZE_IN_BYTES.  */
+	     unsigned long long,                /* Argument SIZE_IN_BYTES.  */
 	     const char *)		   /* Argument BUILTIN_NAME.  */
 
 /* Return the 'void' type.  */
@@ -974,7 +974,7 @@ GCC_METHOD2 (gcc_type, build_vector_type,
 GCC_METHOD5 (int /* bool */, build_constant,
 	     gcc_type,		  /* Argument TYPE.  */
 	     const char *,	  /* Argument NAME.  */
-	     unsigned long,	  /* Argument VALUE.  */
+	     unsigned long long,	  /* Argument VALUE.  */
 	     const char *,	  /* Argument FILENAME.  */
 	     unsigned int)	  /* Argument LINE_NUMBER.  */
 
diff --git a/include/gdb/callback.h b/include/gdb/callback.h
index dc6bd65..54b4c73 100644
--- a/include/gdb/callback.h
+++ b/include/gdb/callback.h
@@ -76,13 +76,13 @@ struct host_callback_struct
   int (*close) (host_callback *,int);
   int (*get_errno) (host_callback *);
   int (*isatty) (host_callback *, int);
-  int (*lseek) (host_callback *, int, long , int);
+  int (*lseek) (host_callback *, int, long long , int);
   int (*open) (host_callback *, const char*, int mode);
   int (*read) (host_callback *,int,  char *, int);
   int (*read_stdin) ( host_callback *, char *, int);
   int (*rename) (host_callback *, const char *, const char *);
   int (*system) (host_callback *, const char *);
-  long (*time) (host_callback *, long *);
+  long long (*time) (host_callback *, long long *);
   int (*unlink) (host_callback *, const char *);
   int (*write) (host_callback *,int, const char *, int);
   int (*write_stdout) (host_callback *, const char *, int);
@@ -92,8 +92,8 @@ struct host_callback_struct
   int (*to_stat) (host_callback *, const char *, struct stat *);
   int (*to_fstat) (host_callback *, int, struct stat *);
   int (*to_lstat) (host_callback *, const char *, struct stat *);
-  int (*ftruncate) (host_callback *, int, long);
-  int (*truncate) (host_callback *, const char *, long);
+  int (*ftruncate) (host_callback *, int, long long);
+  int (*truncate) (host_callback *, const char *, long long);
   int (*pipe) (host_callback *, int *);
 
   /* Called by the framework when a read call has emptied a pipe buffer.  */
@@ -246,12 +246,12 @@ typedef struct cb_syscall {
   /* The target's value of what system call to perform.  */
   int func;
   /* The arguments to the syscall.  */
-  long arg1, arg2, arg3, arg4;
+  long long arg1, arg2, arg3, arg4;
 
   /* The result.  */
-  long result;
+  long long result;
   /* Some system calls have two results.  */
-  long result2;
+  long long result2;
   /* The target's errno value, or 0 if success.
      This is converted to the target's value with host_to_target_errno.  */
   int errcode;
@@ -259,7 +259,7 @@ typedef struct cb_syscall {
   /* Working space to be used by memory read/write callbacks.  */
   PTR p1;
   PTR p2;
-  long x1,x2;
+  long long x1,x2;
 
   /* Callbacks for reading/writing memory (e.g. for read/write syscalls).
      ??? long or unsigned long might be better to use for the `count'
@@ -267,10 +267,10 @@ typedef struct cb_syscall {
      test any changes with -Wall -Werror, mixed signed comparisons
      will get you.  */
   int (*read_mem) (host_callback * /*cb*/, struct cb_syscall * /*sc*/,
-		   unsigned long /*taddr*/, char * /*buf*/,
+		   unsigned long long /*taddr*/, char * /*buf*/,
 		   int /*bytes*/);
   int (*write_mem) (host_callback * /*cb*/, struct cb_syscall * /*sc*/,
-		    unsigned long /*taddr*/, const char * /*buf*/,
+		    unsigned long long /*taddr*/, const char * /*buf*/,
 		    int /*bytes*/);
 
   /* For sanity checking, should be last entry.  */
@@ -331,7 +331,7 @@ const char *cb_target_str_signal (host_callback *, int);
 int cb_host_to_target_stat (host_callback *, const struct stat *, PTR);
 
 /* Translate a value to target endian.  */
-void cb_store_target_endian (host_callback *, char *, int, long);
+void cb_store_target_endian (host_callback *, char *, int, long long);
 
 /* Tests for special fds.  */
 int cb_is_stdin (host_callback *, int);
@@ -339,7 +339,7 @@ int cb_is_stdout (host_callback *, int);
 int cb_is_stderr (host_callback *, int);
 
 /* Read a string out of the target.  */
-int cb_get_string (host_callback *, CB_SYSCALL *, char *, int, unsigned long);
+int cb_get_string (host_callback *, CB_SYSCALL *, char *, int, unsigned long long);
 
 /* Perform a system call.  */
 CB_RC cb_syscall (host_callback *, CB_SYSCALL *);
diff --git a/include/hp-symtab.h b/include/hp-symtab.h
index a778e37..a036f9f 100644
--- a/include/hp-symtab.h
+++ b/include/hp-symtab.h
@@ -947,11 +947,11 @@ struct dntt_type_with
   unsigned int nestlevel: 	6;    /* # of nesting levels back     */
   unsigned int doc_ranges: 	1;    /* 1 => location is range list  */
   unsigned int unused:   	10;
-  long location;       		      /* where stored (allocated)     */
+  long long location;       		      /* where stored (allocated)     */
   sltpointer address;
   dnttpointer type;                   /* type of with expression      */
   vtpointer name;                     /* name of with expression      */
-  unsigned long  offset;              /* byte offset from location    */
+  unsigned long long  offset;              /* byte offset from location    */
 };                                   
 
 /* DNTT_TYPE_COMMON is unsupported by GDB.  */
@@ -1045,9 +1045,9 @@ struct dntt_type_class
   unsigned int expansion:   1;     /* 1=template expansion.  */
   unsigned int unused:     17;     
   dnttpointer memberlist     ;     /* Ptr to chain of [GEN]FIELDs.  */
-  unsigned long vtbl_loc     ;     /* Offset in obj of ptr to vtbl.  */
+  unsigned long long vtbl_loc     ;     /* Offset in obj of ptr to vtbl.  */
   dnttpointer parentlist     ;     /* Ptr to K_INHERITANCE list.  */
-  unsigned long bitlength    ;     /* Total at this level.  */
+  unsigned long long bitlength    ;     /* Total at this level.  */
   dnttpointer identlist      ;     /* Ptr to chain of class ident's.  */
   dnttpointer friendlist     ;     /* Ptr to K_FRIEND list.  */
   dnttpointer templateptr    ;     /* Ptr to template.  */
@@ -1078,7 +1078,7 @@ struct dntt_type_vfunc
   unsigned int pure:        1;     /* pure virtual function ?       */
   unsigned int unused:	   20;
   dnttpointer funcptr        ;     /* points to FUNCTION symbol     */
-  unsigned long vtbl_offset  ;     /* offset into vtbl for virtual  */
+  unsigned long long vtbl_offset  ;     /* offset into vtbl for virtual  */
 };
 
 /* Not precisely sure what this is intended for - DDE ignores it.  */
@@ -1105,9 +1105,9 @@ struct dntt_type_inheritance
   unsigned int visibility:  2;     /* pub = 0, prot = 1, priv = 2   */
   unsigned int unused:	   18;
   dnttpointer classname      ;     /* first parent class, if any    */
-  unsigned long offset       ;     /* offset to start of base class */
+  unsigned long long offset       ;     /* offset to start of base class */
   dnttpointer next           ;     /* pointer to next K_INHERITANCE */
-  unsigned long future[2]    ;     /* padding to 3-word block end   */
+  unsigned long long future[2]    ;     /* padding to 3-word block end   */
 };
 
 /* C++ "friend" classes ... */
@@ -1129,7 +1129,7 @@ struct dntt_type_friend_func
   dnttpointer funcptr        ;     /* pointer to function           */
   dnttpointer classptr       ;     /* pointer to class DNTT         */
   dnttpointer next           ;     /* next DNTT_FRIEND              */
-  unsigned long future[2]    ;     /* padding to 3-word block end   */
+  unsigned long long future[2]    ;     /* padding to 3-word block end   */
 };
 
 /* DDE appears to ignore the DNTT_TYPE_MODIFIER record.
@@ -1147,7 +1147,7 @@ struct dntt_type_modifier
   unsigned int m_duplicate: 1;     /* duplicate                     */
   unsigned int unused:	   16;
   dnttpointer type           ;     /* subtype                       */
-  unsigned long future       ;     /* padding to 3-word block end   */
+  unsigned long long future       ;     /* padding to 3-word block end   */
 };
 
 /* I'm not sure what this was intended for - DDE ignores it.  */
@@ -1158,11 +1158,11 @@ struct dntt_type_object_id
   unsigned int kind:       10;     /* always DNTT_TYPE_OBJECT_ID */
   unsigned int indirect:    1;     /* Is object_ident addr of addr? */
   unsigned int unused:	   20;
-  unsigned long object_ident ;     /* object identifier             */
-  unsigned long offset       ;     /* offset to start of base class */
+  unsigned long long object_ident ;     /* object identifier             */
+  unsigned long long offset       ;     /* offset to start of base class */
   dnttpointer next           ;     /* pointer to next K_OBJECT_ID   */
-  unsigned long segoffset    ;     /* for linker fixup              */
-  unsigned long future       ;     /* padding to 3-word block end   */
+  unsigned long long segoffset    ;     /* for linker fixup              */
+  unsigned long long future       ;     /* padding to 3-word block end   */
 };
 
 /* No separate dntt_type_memfunc; same as dntt_type_func */
@@ -1183,9 +1183,9 @@ struct dntt_type_template
   unsigned int class_decl:  2;     /* 0=class,1=union,2=struct      */
   unsigned int unused:	   18;
   dnttpointer memberlist     ;     /* ptr to chain of K_[GEN]FIELDs */
-  long unused2               ;     /* offset in obj of ptr to vtbl  */
+  long long unused2               ;     /* offset in obj of ptr to vtbl  */
   dnttpointer parentlist     ;     /* ptr to K_INHERITANCE list     */
-  unsigned long bitlength    ;     /* total at this level           */
+  unsigned long long bitlength    ;     /* total at this level           */
   dnttpointer identlist      ;     /* ptr to chain of class ident's */
   dnttpointer friendlist     ;     /* ptr to K_FRIEND list          */
   dnttpointer arglist        ;     /* ptr to argument list          */
@@ -1209,7 +1209,7 @@ struct dntt_type_templ_arg
   vtpointer name             ;     /* name of argument             */
   dnttpointer type           ;     /* for non type arguments       */
   dnttpointer nextarg        ;     /* Next argument if any         */
-  long future[2]             ;     /* padding to 3-word block end  */
+  long long future[2]             ;     /* padding to 3-word block end  */
 };
 
 /* FUNC_TEMPLATE records are sort of like FUNCTION, but are emitted
@@ -1259,10 +1259,10 @@ struct dntt_type_link
   unsigned int kind:       10;     /* always DNTT_TYPE_LINK */
   unsigned int linkKind:    4;     /* always LINK_UNKNOWN          */
   unsigned int unused:	   17;
-  long future1               ;     /* expansion                    */
+  long long future1               ;     /* expansion                    */
   dnttpointer ptr1           ;     /* link from template           */
   dnttpointer ptr2           ;     /* to expansion                 */
-  long future[2]             ;     /* padding to 3-word block end  */
+  long long future[2]             ;     /* padding to 3-word block end  */
 };
 
 /* end of C++ specific SOM's.  */
@@ -1644,11 +1644,11 @@ typedef struct PXDB_struct
 
 typedef struct XDB_header_struct
 {
-  long gntt_length; 
-  long lntt_length; 
-  long slt_length; 
-  long vt_length; 
-  long xt_length; 
+  long long gntt_length; 
+  long long lntt_length; 
+  long long slt_length; 
+  long long vt_length; 
+  long long xt_length; 
 } XDB_header;
 
 /* Header version for the case that there is DOC info and the
@@ -1706,14 +1706,14 @@ typedef struct DOC_info_header_struct
   unsigned int has_lines_table: 1;     /* space contains a $LINES$ subspace for line tables. */
   unsigned int has_lt_offset_map: 1;   /* space contains an lt_offset subspace for line table mapping.  */
 
-  long   gntt_length;  /* same as old header */
-  long   lntt_length;  /* same as old header */
-  long   slt_length;   /* same as old header */
-  long   vt_length;    /* same as old header */
-  long   xt_length;    /* same as old header */
-  long   ctxt_length;  /* present only if version >= 2 */
-  long   range_length; /* present only if version >= 2 */
-  long   expr_length;  /* present only if version >= 2 */
+  long long   gntt_length;  /* same as old header */
+  long long   lntt_length;  /* same as old header */
+  long long   slt_length;   /* same as old header */
+  long long   vt_length;    /* same as old header */
+  long long   xt_length;    /* same as old header */
+  long long   ctxt_length;  /* present only if version >= 2 */
+  long long   range_length; /* present only if version >= 2 */
+  long long   expr_length;  /* present only if version >= 2 */
 
 } DOC_info_header;
 
@@ -1731,7 +1731,7 @@ typedef union GenericDebugHeader_union
 
 typedef struct quick_procedure
 {
-  long           isym;		/* 0-based index of first symbol
+  long long           isym;		/* 0-based index of first symbol
                                    for procedure in $LNTT$, 
                                    i.e. the procedure itself.  */
   CORE_ADDR	 adrStart;	/* memory adr of start of proc	*/
@@ -1770,7 +1770,7 @@ typedef struct quick_procedure
 
 typedef struct quick_source
 {
-  long	         isym;		/* 0-based index in $LNTT$ of
+  long long	         isym;		/* 0-based index in $LNTT$ of
                                    first symbol for this file.     */
   CORE_ADDR      adrStart;	/* mem adr of start of file's code */
   CORE_ADDR      adrEnd;	/* mem adr of end of file's code   */
@@ -1790,7 +1790,7 @@ typedef struct quick_source
 
 typedef struct quick_module
 {
-  long           isym;		   /* 0-based index of first
+  long long           isym;		   /* 0-based index of first
                                       symbol for module.        */
   CORE_ADDR	 adrStart;	   /* adr of start of mod.	*/
   CORE_ADDR	 adrEnd;	   /* adr of end of mod.	*/
@@ -1809,8 +1809,8 @@ typedef struct quick_module
 
 typedef struct quick_aux_procedure
 {
-  long	 isym_inln;	/* start on inline list for proc */
-  long   spare;
+  long long	 isym_inln;	/* start on inline list for proc */
+  long long   spare;
 } quick_aux_procedure_entry, *quick_aux_procedure_entry_ptr;
 
 /*  Paragraph Descriptor:
@@ -1818,7 +1818,7 @@ typedef struct quick_aux_procedure
 
 typedef struct quick_paragraph
 {
-  long             isym;       /* first symbol for label (index)  */
+  long long             isym;       /* first symbol for label (index)  */
   CORE_ADDR        adrStart;   /* memory adr of start of label    */
   CORE_ADDR        adrEnd;     /* memory adr of end of label      */
   char            *sbLab;      /* name of label                   */
@@ -1833,7 +1833,7 @@ typedef struct quick_paragraph
 typedef struct quick_class
 {
   char	         *sbClass;	/* name of class	        */
-  long            isym;         /* class symbol (tag)           */
+  long long            isym;         /* class symbol (tag)           */
   unsigned int	  type : 2;	/* 0=class, 1=union, 2=struct   */
   unsigned int	  fTemplate : 1;/* class template               */
   unsigned int	  expansion : 1;/* template expansion           */
@@ -1860,8 +1860,8 @@ typedef struct quick_alias
 typedef struct quick_obj_ID
 {
   CORE_ADDR    obj_ident;	/* class identifier         */
-  long         isym;		/* class symbol             */
-  long         offset;		/* offset to object start   */
+  long long         isym;		/* class symbol             */
+  long long         offset;		/* offset to object start   */
 } quick_obj_ID_entry, *quick_obj_ID_entry_ptr;
 
 #endif /* HP_SYMTAB_INCLUDED */
diff --git a/include/libiberty.h b/include/libiberty.h
index dc09e79..59ee83a 100644
--- a/include/libiberty.h
+++ b/include/libiberty.h
@@ -156,7 +156,7 @@ extern char *reconcat (char *, const char *, ...) ATTRIBUTE_MALLOC ATTRIBUTE_RET
    strings.  You must pass NULL as the last argument of this function,
    to terminate the list of strings.  */
 
-extern unsigned long concat_length (const char *, ...) ATTRIBUTE_SENTINEL;
+extern unsigned long long concat_length (const char *, ...) ATTRIBUTE_SENTINEL;
 
 /* Concatenate an arbitrary number of strings into a SUPPLIED area of
    memory.  You must pass NULL as the last argument of this function,
@@ -211,7 +211,7 @@ extern int gettimeofday (struct timeval *, void *);
 
 /* Get the amount of time the process has run, in microseconds.  */
 
-extern long get_run_time (void);
+extern long long get_run_time (void);
 
 /* Generate a relocated path to some installation directory.  Allocates
    return value using malloc.  */
@@ -581,10 +581,10 @@ extern int pex_get_status (struct pex_obj *, int count, int *vector);
 
 struct pex_time
 {
-  unsigned long user_seconds;
-  unsigned long user_microseconds;
-  unsigned long system_seconds;
-  unsigned long system_microseconds;
+  unsigned long long user_seconds;
+  unsigned long long user_microseconds;
+  unsigned long long system_seconds;
+  unsigned long long system_microseconds;
 };
 
 extern int pex_get_times (struct pex_obj *, int count,
@@ -676,12 +676,12 @@ extern int strverscmp (const char *, const char *);
 #endif
 
 #if defined(HAVE_DECL_STRTOL) && !HAVE_DECL_STRTOL
-extern long int strtol (const char *nptr,
+extern long long int strtol (const char *nptr,
                         char **endptr, int base);
 #endif
 
 #if defined(HAVE_DECL_STRTOUL) && !HAVE_DECL_STRTOUL
-extern unsigned long int strtoul (const char *nptr,
+extern unsigned long long int strtoul (const char *nptr,
                                   char **endptr, int base);
 #endif
 
@@ -706,7 +706,7 @@ extern int strverscmp (const char *, const char *);
 extern void setproctitle (const char *name, ...);
 
 /* Increase stack limit if possible.  */
-extern void stack_limit_increase (unsigned long);
+extern void stack_limit_increase (unsigned long long);
 
 #define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))
 
@@ -723,7 +723,7 @@ extern void *C_alloca (size_t) ATTRIBUTE_MALLOC;
 # undef C_ALLOCA
 # define ASTRDUP(X) \
   (__extension__ ({ const char *const libiberty_optr = (X); \
-   const unsigned long libiberty_len = strlen (libiberty_optr) + 1; \
+   const unsigned long long libiberty_len = strlen (libiberty_optr) + 1; \
    char *const libiberty_nptr = (char *) alloca (libiberty_len); \
    (char *) memcpy (libiberty_nptr, libiberty_optr, libiberty_len); }))
 #else
@@ -734,7 +734,7 @@ extern void *C_alloca (size_t) ATTRIBUTE_MALLOC;
 # define C_ALLOCA 1
 extern const char *libiberty_optr;
 extern char *libiberty_nptr;
-extern unsigned long libiberty_len;
+extern unsigned long long libiberty_len;
 # define ASTRDUP(X) \
   (libiberty_optr = (X), \
    libiberty_len = strlen (libiberty_optr) + 1, \
diff --git a/include/longlong.h b/include/longlong.h
index 7f3dc17..bd78d9f 100644
--- a/include/longlong.h
+++ b/include/longlong.h
@@ -1589,7 +1589,7 @@ extern UHItype __stormy16_count_leading_zeros (UHItype);
 	     "rQR" ((unsigned int)(bl)))
 #define umul_ppmm(xh, xl, m0, m1) \
   do {									\
-    union {long int __ll;						\
+    union {long long int __ll;						\
 	   struct {unsigned int __h, __l;} __i;				\
 	  } __xx;							\
     unsigned int __m0 = (m0), __m1 = (m1);				\
diff --git a/include/md5.h b/include/md5.h
index 80bf1ed..abab9bc 100644
--- a/include/md5.h
+++ b/include/md5.h
@@ -64,7 +64,7 @@ typedef uintptr_t md5_uintptr;
     typedef unsigned short md5_uint32;
 #  else
 #   if LONG_MAX == INT_MAX_32_BITS
-     typedef unsigned long md5_uint32;
+     typedef unsigned long long md5_uint32;
 #   else
      /* The following line is intended to evoke an error.
         Using #error is not portable enough.  */
@@ -74,7 +74,7 @@ typedef uintptr_t md5_uintptr;
 # endif
 /* We have to make a guess about the integer type equivalent in size
    to pointers which should always be correct.  */
-typedef unsigned long int md5_uintptr;
+typedef unsigned long long int md5_uintptr;
 #endif
 
 #ifdef __cplusplus
diff --git a/include/objalloc.h b/include/objalloc.h
index 96d0e67..783101b 100644
--- a/include/objalloc.h
+++ b/include/objalloc.h
@@ -58,7 +58,7 @@ struct objalloc_align { char x; double d; };
 #endif
 #endif
 #ifndef offsetof
-#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
+#define offsetof(TYPE, MEMBER) ((unsigned long long) &((TYPE *)0)->MEMBER)
 #endif
 #define OBJALLOC_ALIGN offsetof (struct objalloc_align, d)
 
@@ -69,7 +69,7 @@ extern struct objalloc *objalloc_create (void);
 /* Allocate space from an objalloc structure.  Returns NULL if malloc
    fails.  */
 
-extern void *_objalloc_alloc (struct objalloc *, unsigned long);
+extern void *_objalloc_alloc (struct objalloc *, unsigned long long);
 
 /* The macro version of objalloc_alloc.  We only define this if using
    gcc, because otherwise we would have to evaluate the arguments
@@ -87,7 +87,7 @@ extern void *_objalloc_alloc (struct objalloc *, unsigned long);
 #define objalloc_alloc(o, l)						\
   __extension__								\
   ({ struct objalloc *__o = (o);					\
-     unsigned long __len = (l);						\
+     unsigned long long __len = (l);						\
      if (__len == 0)							\
        __len = 1;							\
      __len = (__len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);	\
diff --git a/include/obstack.h b/include/obstack.h
index 43c71f4..37002c5 100644
--- a/include/obstack.h
+++ b/include/obstack.h
@@ -115,7 +115,7 @@
 /* For binary compatibility with obstack version 1, which used "int"
    and "long" for these two types.  */
 # define _OBSTACK_SIZE_T unsigned int
-# define _CHUNK_SIZE_T unsigned long
+# define _CHUNK_SIZE_T unsigned long long
 # define _OBSTACK_CAST(type, expr) ((type) (expr))
 #else
 /* Version 2 with sane types, especially for 64-bit hosts.  */
diff --git a/include/opcode/arm.h b/include/opcode/arm.h
index 83b3f22..c6c6008 100644
--- a/include/opcode/arm.h
+++ b/include/opcode/arm.h
@@ -351,8 +351,8 @@
    and use macro ARM_FEATURE to initialize the feature set variable.  */
 typedef struct
 {
-  unsigned long core[2];
-  unsigned long coproc;
+  unsigned long long core[2];
+  unsigned long long coproc;
 } arm_feature_set;
 
 /* Test whether CPU and FEAT have any features in common.  */
diff --git a/include/opcode/bfin.h b/include/opcode/bfin.h
index cdfd287..f8c40a8 100644
--- a/include/opcode/bfin.h
+++ b/include/opcode/bfin.h
@@ -68,7 +68,7 @@ static inline int is_macmod_signed (int x)
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_src1;
   int mask_src1;
   int bits_src0;
@@ -204,7 +204,7 @@ typedef DSP32Mac DSP32Mult;
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_src1;
   int mask_src1;
   int bits_src0;
@@ -288,7 +288,7 @@ typedef struct
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_src1;
   int mask_src1;
   int bits_src0;
@@ -362,7 +362,7 @@ typedef struct
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_src1;
   int mask_src1;
   int bits_immag;
@@ -433,7 +433,7 @@ typedef struct
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_offset;
   int mask_offset;
   int bits_reg;
@@ -906,7 +906,7 @@ typedef struct
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_addr;
   int mask_addr;
   int bits_S;
@@ -979,7 +979,7 @@ typedef struct
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_expected;
   int mask_expected;
   int bits_regtest;
@@ -1180,7 +1180,7 @@ typedef struct
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_framesize;
   int mask_framesize;
   int bits_R;
@@ -1214,7 +1214,7 @@ typedef struct
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_eoffset;
   int mask_eoffset;
   int bits_dontcare;
@@ -1268,7 +1268,7 @@ typedef struct
 
 typedef struct
 {
-  unsigned long opcode;
+  unsigned long long opcode;
   int bits_hword;
   int mask_hword;
   int bits_reg;
diff --git a/include/opcode/cgen.h b/include/opcode/cgen.h
index d882376..c466c05 100644
--- a/include/opcode/cgen.h
+++ b/include/opcode/cgen.h
@@ -586,19 +586,19 @@ const CGEN_KEYWORD_ENTRY *cgen_keyword_search_next
 /* Operand value support routines.  */
 
 extern const char *cgen_parse_keyword
-  (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
+  (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long long *);
 #ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
 extern const char *cgen_parse_signed_integer
-  (CGEN_CPU_DESC, const char **, int, long *);
+  (CGEN_CPU_DESC, const char **, int, long long *);
 extern const char *cgen_parse_unsigned_integer
-  (CGEN_CPU_DESC, const char **, int, unsigned long *);
+  (CGEN_CPU_DESC, const char **, int, unsigned long long *);
 extern const char *cgen_parse_address
   (CGEN_CPU_DESC, const char **, int, int,
    enum cgen_parse_operand_result *, bfd_vma *);
 extern const char *cgen_validate_signed_integer
-  (long, long, long);
+  (long long, long long, long long);
 extern const char *cgen_validate_unsigned_integer
-  (unsigned long, unsigned long, unsigned long);
+  (unsigned long long, unsigned long long, unsigned long long);
 #endif
 
 /* Operand modes.  */
@@ -933,7 +933,7 @@ typedef struct
 
 #ifdef CGEN_MAX_EXTRA_OPCODE_OPERANDS
   /* Extra opcode values beyond base_value.  */
-  unsigned long ifield_values[CGEN_MAX_EXTRA_OPCODE_OPERANDS];
+  unsigned long long ifield_values[CGEN_MAX_EXTRA_OPCODE_OPERANDS];
 #endif
 } CGEN_IVALUE;
 
@@ -1317,7 +1317,7 @@ typedef struct cgen_cpu_desc
   void (*set_vma_operand)
     (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, bfd_vma value_);
 #else
-  long (*get_vma_operand) ();
+  long long (*get_vma_operand) ();
   void (*set_vma_operand) ();
 #endif
 #define CGEN_CPU_GET_INT_OPERAND(cd) ((cd)->get_int_operand)
diff --git a/include/opcode/cr16.h b/include/opcode/cr16.h
index a5870b3..d181747 100644
--- a/include/opcode/cr16.h
+++ b/include/opcode/cr16.h
@@ -256,7 +256,7 @@ typedef struct
   /* Size (in words).  */
   unsigned int size;
   /* Constant prefix (matched by the disassembler).  */
-  unsigned long match;  /* ie opcode */
+  unsigned long long match;  /* ie opcode */
   /* Match size (in bits).  */
   /* MASK: if( (i & match_bits) == match ) then match */
   int match_bits;
@@ -282,7 +282,7 @@ typedef struct
   /* Processor register. 32 bit  */
   preg prp;
   /* Constant/immediate/absolute value.  */
-  long constant;
+  long long constant;
   /* CC code.  */
   unsigned int cc;
   /* Scaled index mode.  */
@@ -433,7 +433,7 @@ typedef long long int LONGLONG;
 typedef unsigned long long ULONGLONG;
 
 /* Data types for opcode handling.  */
-typedef unsigned long dwordU;
+typedef unsigned long long dwordU;
 typedef unsigned short wordU;
 
 /* Prototypes for function in cr16-dis.c.  */
diff --git a/include/opcode/crx.h b/include/opcode/crx.h
index 7e4bac5..03a3ef8 100644
--- a/include/opcode/crx.h
+++ b/include/opcode/crx.h
@@ -260,7 +260,7 @@ typedef struct
     /* Size (in words).  */
     unsigned int size;
     /* Constant prefix (matched by the disassembler).  */
-    unsigned long match;
+    unsigned long long match;
     /* Match size (in bits).  */
     int match_bits;
     /* Attributes.  */
@@ -281,7 +281,7 @@ typedef struct
     /* Coprocessor register.  */
     copreg cr;
     /* Constant/immediate/absolute value.  */
-    long constant;
+    long long constant;
     /* Scaled index mode.  */
     unsigned int scale;
     /* Argument type.  */
diff --git a/include/opcode/d10v.h b/include/opcode/d10v.h
index 7630faa..fc9d70b 100644
--- a/include/opcode/d10v.h
+++ b/include/opcode/d10v.h
@@ -86,10 +86,10 @@ struct d10v_opcode
 #define ALONE  1024	/* short but pack with a NOP if on asm line alone */
 
   /* the opcode */
-  long opcode;
+  long long opcode;
 
   /* mask.  if( (i & mask) == opcode ) then match */
-  long mask;
+  long long mask;
 
   /* An array of operand codes.  Each code is an index into the
      operand table.  They appear in the order which the operands must
diff --git a/include/opcode/d30v.h b/include/opcode/d30v.h
index 9fcea8a..116d429 100644
--- a/include/opcode/d30v.h
+++ b/include/opcode/d30v.h
@@ -140,8 +140,8 @@ struct d30v_opcode
 
   /* this field is used to decide if two instructions */
   /* can be executed in parallel */
-  long flags_used;
-  long flags_set;
+  long long flags_used;
+  long long flags_set;
 #define FLAG_0		(1L<<0)
 #define FLAG_1		(1L<<1)
 #define FLAG_2		(1L<<2)
@@ -201,7 +201,7 @@ struct d30v_operand
   int position;
 
   /* syntax flags.  */
-  long flags;
+  long long flags;
 };
 extern const struct d30v_operand d30v_operand_table[];
 
diff --git a/include/opcode/dlx.h b/include/opcode/dlx.h
index 94ce805..bbd7677 100644
--- a/include/opcode/dlx.h
+++ b/include/opcode/dlx.h
@@ -146,7 +146,7 @@ struct dlx_opcode
   const char *name;
 
   /* Opcode word.  */
-  unsigned long opcode;
+  unsigned long long opcode;
 
   /* A string of characters which describe the operands.
      Valid characters are:
diff --git a/include/opcode/hppa.h b/include/opcode/hppa.h
index 0700686..39503b7 100644
--- a/include/opcode/hppa.h
+++ b/include/opcode/hppa.h
@@ -40,8 +40,8 @@
 struct pa_opcode
 {
     const char *name;
-    unsigned long int match;	/* Bits that must be set...  */
-    unsigned long int mask;	/* ... in these bits. */
+    unsigned long long int match;	/* Bits that must be set...  */
+    unsigned long long int mask;	/* ... in these bits. */
     const char *args;
     enum pa_arch arch;
     char flags;
diff --git a/include/opcode/m68hc11.h b/include/opcode/m68hc11.h
index 7d6a25e..3266599 100644
--- a/include/opcode/m68hc11.h
+++ b/include/opcode/m68hc11.h
@@ -420,7 +420,7 @@
 struct m68hc11_opcode
 {
   const char *   name;     /* Op-code name.  */
-  long           format;
+  long long           format;
   unsigned char  size;
   unsigned int   opcode;
   unsigned char  cycles_low;
diff --git a/include/opcode/m68k.h b/include/opcode/m68k.h
index 39b4373..303572d 100644
--- a/include/opcode/m68k.h
+++ b/include/opcode/m68k.h
@@ -65,9 +65,9 @@ struct m68k_opcode
      number of bytes necessary to disassemble the instruction.  */
   unsigned int size;
   /* The opcode itself.  */
-  unsigned long opcode;
+  unsigned long long opcode;
   /* The mask used by the disassembler.  */
-  unsigned long match;
+  unsigned long long match;
   /* The arguments.  */
   const char *args;
   /* The architectures which support this opcode.  */
diff --git a/include/opcode/mips.h b/include/opcode/mips.h
index 1ab1780..04af115 100644
--- a/include/opcode/mips.h
+++ b/include/opcode/mips.h
@@ -732,28 +732,28 @@ struct mips_opcode
   /* The basic opcode for the instruction.  When assembling, this
      opcode is modified by the arguments to produce the actual opcode
      that is used.  If pinfo is INSN_MACRO, then this is 0.  */
-  unsigned long match;
+  unsigned long long match;
   /* If pinfo is not INSN_MACRO, then this is a bit mask for the
      relevant portions of the opcode when disassembling.  If the
      actual opcode anded with the match field equals the opcode field,
      then we have found the correct instruction.  If pinfo is
      INSN_MACRO, then this field is the macro identifier.  */
-  unsigned long mask;
+  unsigned long long mask;
   /* For a macro, this is INSN_MACRO.  Otherwise, it is a collection
      of bits describing the instruction, notably any relevant hazard
      information.  */
-  unsigned long pinfo;
+  unsigned long long pinfo;
   /* A collection of additional bits describing the instruction. */
-  unsigned long pinfo2;
+  unsigned long long pinfo2;
   /* A collection of bits describing the instruction sets of which this
      instruction or macro is a member. */
-  unsigned long membership;
+  unsigned long long membership;
   /* A collection of bits describing the ASE of which this instruction
      or macro is a member.  */
-  unsigned long ase;
+  unsigned long long ase;
   /* A collection of bits describing the instruction sets of which this
      instruction or macro is not a member.  */
-  unsigned long exclusions;
+  unsigned long long exclusions;
 };
 
 /* Return true if MO is an instruction that requires 32-bit encoding.  */
diff --git a/include/opcode/mmix.h b/include/opcode/mmix.h
index 7505de2..59e35aa 100644
--- a/include/opcode/mmix.h
+++ b/include/opcode/mmix.h
@@ -154,8 +154,8 @@ enum mmix_operands_type
 struct mmix_opcode
  {
    const char *name;
-   unsigned long match;
-   unsigned long lose;
+   unsigned long long match;
+   unsigned long long lose;
    enum mmix_operands_type operands;
 
    /* This is used by the disassembly function.  */
diff --git a/include/opcode/mn10200.h b/include/opcode/mn10200.h
index 35acba3..672305d 100644
--- a/include/opcode/mn10200.h
+++ b/include/opcode/mn10200.h
@@ -31,13 +31,13 @@ struct mn10200_opcode
 
   /* The opcode itself.  Those bits which will be filled in with
      operands are zeroes.  */
-  unsigned long opcode;
+  unsigned long long opcode;
 
   /* The opcode mask.  This is used by the disassembler.  This is a
      mask containing ones indicating those bits which must match the
      opcode field, and zeroes indicating those bits which need not
      match (and are presumably filled in by operands).  */
-  unsigned long mask;
+  unsigned long long mask;
 
   /* The format of this opcode.  */
   unsigned char format;
diff --git a/include/opcode/mn10300.h b/include/opcode/mn10300.h
index 0484669..5f31a8e 100644
--- a/include/opcode/mn10300.h
+++ b/include/opcode/mn10300.h
@@ -32,13 +32,13 @@ struct mn10300_opcode
 
   /* The opcode itself.  Those bits which will be filled in with
      operands are zeroes.  */
-  unsigned long opcode;
+  unsigned long long opcode;
 
   /* The opcode mask.  This is used by the disassembler.  This is a
      mask containing ones indicating those bits which must match the
      opcode field, and zeroes indicating those bits which need not
      match (and are presumably filled in by operands).  */
-  unsigned long mask;
+  unsigned long long mask;
 
   /* A bitmask.  For each operand, nonzero if it must not have the same
      register specification as all other operands with a nonzero bit in
diff --git a/include/opcode/msp430-decode.h b/include/opcode/msp430-decode.h
index b7175e3..79ae0a6 100644
--- a/include/opcode/msp430-decode.h
+++ b/include/opcode/msp430-decode.h
@@ -124,7 +124,7 @@ typedef struct
   MSP430_Opcode_Operand	op[2];
 } MSP430_Opcode_Decoded;
 
-int msp430_decode_opcode (unsigned long, MSP430_Opcode_Decoded *, int (*)(void *), void *);
+int msp430_decode_opcode (unsigned long long, MSP430_Opcode_Decoded *, int (*)(void *), void *);
 
 #ifdef __cplusplus
 }
diff --git a/include/opcode/nios2.h b/include/opcode/nios2.h
index f1ef1ca..12008d9 100644
--- a/include/opcode/nios2.h
+++ b/include/opcode/nios2.h
@@ -146,14 +146,14 @@ struct nios2_opcode
 				   instruction.  */
   const char *args_test;	/* Like args, but with an extra argument for 
 				   the expected opcode.  */
-  unsigned long num_args;	/* The number of arguments the instruction 
+  unsigned long long num_args;	/* The number of arguments the instruction 
 				   takes.  */
   unsigned size;		/* Size in bytes of the instruction.  */
   enum iw_format_type format;	/* Instruction format.  */
-  unsigned long match;		/* The basic opcode for the instruction.  */
-  unsigned long mask;		/* Mask for the opcode field of the 
+  unsigned long long match;		/* The basic opcode for the instruction.  */
+  unsigned long long mask;		/* Mask for the opcode field of the 
 				   instruction.  */
-  unsigned long pinfo;		/* Is this a real instruction or instruction 
+  unsigned long long pinfo;		/* Is this a real instruction or instruction 
 				   macro?  */
   enum overflow_type overflow_msg;  /* Used to generate informative 
 				       message when fixup overflows.  */
@@ -187,7 +187,7 @@ struct nios2_reg
 {
   const char *name;
   const int index;
-  unsigned long regtype;
+  unsigned long long regtype;
 };
 
 /* Pull in the instruction field accessors, opcodes, and masks.  */
@@ -210,7 +210,7 @@ extern int nios2_num_regs;
 
 /* Return the opcode descriptor for a single instruction.  */
 extern const struct nios2_opcode *
-nios2_find_opcode_hash (unsigned long, unsigned long);
+nios2_find_opcode_hash (unsigned long long, unsigned long long);
 
 /* Lookup tables for R2 immediate decodings.  */
 extern unsigned int nios2_r2_asi_n_mappings[];
@@ -225,7 +225,7 @@ extern int nios2_r2_reg3_mappings[];
 extern const int nios2_num_r2_reg3_mappings;
 
 /* Lookup table for REG_RANGE value list decodings.  */
-extern unsigned long nios2_r2_reg_range_mappings[];
+extern unsigned long long nios2_r2_reg_range_mappings[];
 extern const int nios2_num_r2_reg_range_mappings;
 
 #ifdef __cplusplus
diff --git a/include/opcode/np1.h b/include/opcode/np1.h
index 8c9dafe..8c9517f 100644
--- a/include/opcode/np1.h
+++ b/include/opcode/np1.h
@@ -21,8 +21,8 @@
 struct gld_opcode
 {
   char *name;
-  unsigned long opcode;
-  unsigned long mask;
+  unsigned long long opcode;
+  unsigned long long mask;
   char *args;
   int length;
 };
diff --git a/include/opcode/ns32k.h b/include/opcode/ns32k.h
index 4202a8c..cdaff3c 100644
--- a/include/opcode/ns32k.h
+++ b/include/opcode/ns32k.h
@@ -83,7 +83,7 @@ struct ns32k_opcode {
   const char *name;
   unsigned char opcode_id_size; /* not used by the assembler */
   unsigned char opcode_size;
-  unsigned long opcode_seed;
+  unsigned long long opcode_seed;
   const char *operands;
   unsigned char im_size;	/* not used by dissassembler */
   const char *default_args;	/* default to those args when none given */
diff --git a/include/opcode/pn.h b/include/opcode/pn.h
index d1089c5..90bb6ab 100644
--- a/include/opcode/pn.h
+++ b/include/opcode/pn.h
@@ -21,8 +21,8 @@
 struct gld_opcode
 {
   char *name;
-  unsigned long opcode;
-  unsigned long mask;
+  unsigned long long opcode;
+  unsigned long long mask;
   char *args;
   int length;
 };
diff --git a/include/opcode/ppc.h b/include/opcode/ppc.h
index 44445bc..8a805c5 100644
--- a/include/opcode/ppc.h
+++ b/include/opcode/ppc.h
@@ -310,7 +310,7 @@ struct powerpc_operand
   int64_t (*extract) (uint64_t instruction, ppc_cpu_t dialect, int *invalid);
 
   /* One bit syntax flags.  */
-  unsigned long flags;
+  unsigned long long flags;
 };
 
 /* Elements in the table are retrieved by indexing with values from
diff --git a/include/opcode/pru.h b/include/opcode/pru.h
index 77fce09..022e686 100644
--- a/include/opcode/pru.h
+++ b/include/opcode/pru.h
@@ -113,10 +113,10 @@ struct pru_opcode
 				   by the simulator.  */
   const char *args;		/* A string describing the arguments for this
 				   instruction.  */
-  unsigned long match;		/* The basic opcode for the instruction.  */
-  unsigned long mask;		/* Mask for the opcode field of the
+  unsigned long long match;		/* The basic opcode for the instruction.  */
+  unsigned long long mask;		/* Mask for the opcode field of the
 				   instruction.  */
-  unsigned long pinfo;		/* Is this a real instruction or instruction
+  unsigned long long pinfo;		/* Is this a real instruction or instruction
 				   macro?  */
   enum overflow_type overflow_msg;  /* Used to generate informative
 				       message when fixup overflows.  */
@@ -365,7 +365,7 @@ struct pru_reg
   ((GET_INSN_FIELD (BROFF98, i) << 8) | (GET_INSN_FIELD (BROFF70, i) << 0))
 
 #define GET_BROFF_SIGNED(i)	  \
-  ((long)(GET_BROFF_URAW (i) - (!!(GET_BROFF_URAW (i) & (1 << 9)) << 10)))
+  ((long long)(GET_BROFF_URAW (i) - (!!(GET_BROFF_URAW (i) & (1 << 9)) << 10)))
 
 #define SET_BROFF_URAW(i, v)		      \
   do {					      \
@@ -406,6 +406,6 @@ extern const int pru_num_regs;
 
 /* This is made extern so that the assembler can use it to find out
    what instruction caused an error.  */
-extern const struct pru_opcode *pru_find_opcode (unsigned long);
+extern const struct pru_opcode *pru_find_opcode (unsigned long long);
 
 #endif /* _PRU_H */
diff --git a/include/opcode/pyr.h b/include/opcode/pyr.h
index f56afee..973fe54 100644
--- a/include/opcode/pyr.h
+++ b/include/opcode/pyr.h
@@ -24,7 +24,7 @@ struct pyr_datum
 {
   char              nargs;
   char *            args;	/* how to compile said opcode */
-  unsigned long     mask;	/* Bit vector: which operand modes are valid
+  unsigned long long     mask;	/* Bit vector: which operand modes are valid
 				   for this opcode */
   unsigned char     code;	/* op-code (always 6(?) bits */
 };
@@ -88,7 +88,7 @@ typedef struct pyr_insn_format
 /* the first 5,(0x1|0x2|0x4|0x8|0x10) ie (1|2|4|8|16), ie ( 32 -1)*/
 #define GEN_TO_REG (31)
 
-#define	UNKNOWN ((unsigned long)-1)
+#define	UNKNOWN ((unsigned long long)-1)
 #define ANY (GEN_TO_REG | (GEN_TO_REG << 5) | (GEN_TO_REG << 15))
 
 #define CONVERT (1|8|0x10|0x20|0x200)
diff --git a/include/opcode/riscv.h b/include/opcode/riscv.h
index ac6f773..724dc28 100644
--- a/include/opcode/riscv.h
+++ b/include/opcode/riscv.h
@@ -307,7 +307,7 @@ struct riscv_opcode
   /* For a macro, this is INSN_MACRO.  Otherwise, it is a collection
      of bits describing the instruction, notably any relevant hazard
      information.  */
-  unsigned long pinfo;
+  unsigned long long pinfo;
 };
 
 /* Instruction is a simple alias (e.g. "mv" for "addi").  */
diff --git a/include/opcode/rl78.h b/include/opcode/rl78.h
index b061670..5c40c73 100644
--- a/include/opcode/rl78.h
+++ b/include/opcode/rl78.h
@@ -173,7 +173,7 @@ typedef struct
   RL78_Opcode_Operand	op[2];
 } RL78_Opcode_Decoded;
 
-int rl78_decode_opcode (unsigned long, RL78_Opcode_Decoded *, int (*)(void *), void *, RL78_Dis_Isa);
+int rl78_decode_opcode (unsigned long long, RL78_Opcode_Decoded *, int (*)(void *), void *, RL78_Dis_Isa);
 
 #ifdef __cplusplus
 }
diff --git a/include/opcode/rx.h b/include/opcode/rx.h
index 54ff409..c13663a 100644
--- a/include/opcode/rx.h
+++ b/include/opcode/rx.h
@@ -241,7 +241,7 @@ typedef struct
    Register numbers 0..15 are general registers.  16..31 are control
    registers.  32..47 are condition codes.  */
 
-int rx_decode_opcode (unsigned long, RX_Opcode_Decoded *, int (*)(void *), void *);
+int rx_decode_opcode (unsigned long long, RX_Opcode_Decoded *, int (*)(void *), void *);
 
 #ifdef __cplusplus
 }
diff --git a/include/opcode/s390.h b/include/opcode/s390.h
index db42c58..42f24b4 100644
--- a/include/opcode/s390.h
+++ b/include/opcode/s390.h
@@ -112,7 +112,7 @@ struct s390_operand
     int shift;
 
     /* One bit syntax flags.  */
-    unsigned long flags;
+    unsigned long long flags;
   };
 
 /* Elements in the table are retrieved by indexing with values from
diff --git a/include/opcode/sparc.h b/include/opcode/sparc.h
index 794a9d1..7f46497 100644
--- a/include/opcode/sparc.h
+++ b/include/opcode/sparc.h
@@ -108,8 +108,8 @@ extern enum sparc_opcode_arch_val sparc_opcode_lookup_arch (const char *);
 typedef struct sparc_opcode
 {
   const char *name;
-  unsigned long match;	/* Bits that must be set.  */
-  unsigned long lose;	/* Bits that must not be set.  */
+  unsigned long long match;	/* Bits that must be set.  */
+  unsigned long long lose;	/* Bits that must not be set.  */
   const char *args;
   /* This was called "delayed" in versions before the flags.  */
   unsigned int flags;
diff --git a/include/opcode/tic4x.h b/include/opcode/tic4x.h
index 3025412..6ae8543 100644
--- a/include/opcode/tic4x.h
+++ b/include/opcode/tic4x.h
@@ -24,8 +24,8 @@
 
 /* Define some bitfield extraction/insertion macros.  */
 #define EXTR(inst, m, l)          ((inst) << (31 - (m)) >> (31 - ((m) - (l)))) 
-#define EXTRU(inst, m, l)         EXTR ((unsigned long)(inst), (m), (l))
-#define EXTRS(inst, m, l)         EXTR ((long)(inst), (m), (l))
+#define EXTRU(inst, m, l)         EXTR ((unsigned long long)(inst), (m), (l))
+#define EXTRS(inst, m, l)         EXTR ((long long)(inst), (m), (l))
 #define INSERTU(inst, val, m, l)  (inst |= ((val) << (l))) 
 #define INSERTS(inst, val, m, l)  INSERTU (inst, ((val) & ((1 << ((m) - (l) + 1)) - 1)), m, l)
 
@@ -59,7 +59,7 @@ c4x_reg_t;
 struct tic4x_register
 {
   const char *  name;
-  unsigned long regno;
+  unsigned long long regno;
 };
 
 typedef struct tic4x_register tic4x_register_t;
@@ -132,7 +132,7 @@ const unsigned int tic4x_num_registers = (((sizeof tic4x_registers) / (sizeof ti
 struct tic4x_cond
 {
   const char *  name;
-  unsigned long cond;
+  unsigned long long cond;
 };
 
 typedef struct tic4x_cond tic4x_cond_t;
@@ -172,7 +172,7 @@ const unsigned int tic4x_num_conds = (((sizeof tic4x_conds) / (sizeof tic4x_cond
 struct tic4x_indirect
 {
   const char *  name;
-  unsigned long modn;
+  unsigned long long modn;
 };
 
 typedef struct tic4x_indirect tic4x_indirect_t;
@@ -224,10 +224,10 @@ const unsigned int tic4x_num_indirects = (((sizeof tic4x_indirects) / (sizeof ti
 struct tic4x_inst
 {
   const char *  name;
-  unsigned long opcode;
-  unsigned long opmask;
+  unsigned long long opcode;
+  unsigned long long opmask;
   const char *        args;
-  unsigned long oplevel;
+  unsigned long long oplevel;
 };
 
 typedef struct tic4x_inst tic4x_inst_t;
diff --git a/include/opcode/tic80.h b/include/opcode/tic80.h
index 71230e7..f72111c 100644
--- a/include/opcode/tic80.h
+++ b/include/opcode/tic80.h
@@ -33,14 +33,14 @@ struct tic80_opcode
   /* The opcode itself.  Those bits which will be filled in with operands
      are zeroes.  */
 
-  unsigned long opcode;
+  unsigned long long opcode;
 
   /* The opcode mask.  This is used by the disassembler.  This is a mask
      containing ones indicating those bits which must match the opcode
      field, and zeroes indicating those bits which need not match (and are
      presumably filled in by operands).  */
 
-  unsigned long mask;
+  unsigned long long mask;
 
   /* Special purpose flags for this opcode. */
 
@@ -91,8 +91,8 @@ struct tic80_operand
      operand value is legal, *ERRMSG will be unchanged (most operands
      can accept any value).  */
 
-  unsigned long (*insert)
-    (unsigned long instruction, long op, const char **errmsg);
+  unsigned long long (*insert)
+    (unsigned long long instruction, long long op, const char **errmsg);
 
   /* Extraction function.  This is used by the disassembler.  To
      extract this operand type from an instruction, check this field.
@@ -112,11 +112,11 @@ struct tic80_operand
      this operand (i.e., the instruction does not match).  If the
      operand is valid, *INVALID will not be changed.  */
 
-  long (*extract) (unsigned long instruction, int *invalid);
+  long long (*extract) (unsigned long long instruction, int *invalid);
 
   /* One bit syntax flags.  */
 
-  unsigned long flags;
+  unsigned long long flags;
 };
 
 /* Elements in the table are retrieved by indexing with values from
diff --git a/include/opcode/v850.h b/include/opcode/v850.h
index 92a64c9..a0d59ee 100644
--- a/include/opcode/v850.h
+++ b/include/opcode/v850.h
@@ -35,13 +35,13 @@ struct v850_opcode
 
   /* The opcode itself.  Those bits which will be filled in with
      operands are zeroes.  */
-  unsigned long opcode;
+  unsigned long long opcode;
 
   /* The opcode mask.  This is used by the disassembler.  This is a
      mask containing ones indicating those bits which must match the
      opcode field, and zeroes indicating those bits which need not
      match (and are presumably filled in by operands).  */
-  unsigned long mask;
+  unsigned long long mask;
 
   /* An array of operand codes.  Each code is an index into the
      operand table.  They appear in the order which the operands must
@@ -132,8 +132,8 @@ struct v850_operand
      string (the operand will be inserted in any case).  If the
      operand value is legal, *ERRMSG will be unchanged (most operands
      can accept any value).  */
-  unsigned long (* insert)
-    (unsigned long instruction, long op, const char ** errmsg);
+  unsigned long long (* insert)
+    (unsigned long long instruction, long long op, const char ** errmsg);
 
   /* Extraction function.  This is used by the disassembler.  To
      extract this operand type from an instruction, check this field.
@@ -151,7 +151,7 @@ struct v850_operand
      non-zero if this operand type can not actually be extracted from
      this operand (i.e., the instruction does not match).  If the
      operand is valid, *INVALID will not be changed.  */
-  unsigned long (* extract) (unsigned long instruction, int * invalid);
+  unsigned long long (* extract) (unsigned long long instruction, int * invalid);
 
   /* One bit syntax flags.  */
   int flags;
diff --git a/include/sha1.h b/include/sha1.h
index 285d183..0eee3a0 100644
--- a/include/sha1.h
+++ b/include/sha1.h
@@ -62,7 +62,7 @@ typedef uintptr_t sha1_uintptr;
     typedef unsigned short sha1_uint32;
 #  else
 #   if LONG_MAX == INT_MAX_32_BITS
-     typedef unsigned long sha1_uint32;
+     typedef unsigned long long sha1_uint32;
 #   else
      /* The following line is intended to evoke an error.
         Using #error is not portable enough.  */
diff --git a/include/som/internal.h b/include/som/internal.h
index ad834ec..4849534 100644
--- a/include/som/internal.h
+++ b/include/som/internal.h
@@ -119,16 +119,16 @@ struct som_exec_auxhdr
 {
   struct som_aux_id som_auxhdr;
 
-  long exec_tsize;
-  long exec_tmem;
-  long exec_tfile;
-  long exec_dsize;
-  long exec_dmem;
-  long exec_dfile;
-  long exec_bsize;
-  long exec_entry;
-  long exec_flags;
-  long exec_bfill;
+  long long exec_tsize;
+  long long exec_tmem;
+  long long exec_tfile;
+  long long exec_dsize;
+  long long exec_dmem;
+  long long exec_dfile;
+  long long exec_bsize;
+  long long exec_entry;
+  long long exec_flags;
+  long long exec_bfill;
 };
 
 struct som_space_dictionary_record
diff --git a/include/xregex2.h b/include/xregex2.h
index 1f5a456..e890e64 100644
--- a/include/xregex2.h
+++ b/include/xregex2.h
@@ -42,19 +42,19 @@ extern "C" {
    wide enough to hold a value of a pointer.  For most ANSI compilers
    ptrdiff_t and size_t should be likely OK.  Still size of these two
    types is 2 for Microsoft C.  Ugh... */
-typedef long int s_reg_t;
-typedef unsigned long int active_reg_t;
+typedef long long int s_reg_t;
+typedef unsigned long long int active_reg_t;
 
 /* The following bits are used to determine the regexp syntax we
    recognize.  The set/not-set meanings are chosen so that Emacs syntax
    remains the value 0.  The bits are given in alphabetical order, and
    the definitions shifted by one from the previous bit; thus, when we
    add or remove a bit, only one other definition need change.  */
-typedef unsigned long int reg_syntax_t;
+typedef unsigned long long int reg_syntax_t;
 
 /* If this bit is not set, then \ inside a bracket expression is literal.
    If set, then such a \ quotes the following character.  */
-#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)
+#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long long int) 1)
 
 /* If this bit is not set, then + and ? are operators, and \+ and \? are
      literals.
@@ -336,10 +336,10 @@ struct re_pattern_buffer
   unsigned char *buffer;
 
 	/* Number of bytes to which `buffer' points.  */
-  unsigned long int allocated;
+  unsigned long long int allocated;
 
 	/* Number of bytes actually used in `buffer'.  */
-  unsigned long int used;
+  unsigned long long int used;
 
         /* Syntax setting with which the pattern was compiled.  */
   reg_syntax_t syntax;
diff --git a/intl/dcigettext.c b/intl/dcigettext.c
index a8d4a14..8f96dc9 100644
--- a/intl/dcigettext.c
+++ b/intl/dcigettext.c
@@ -305,7 +305,7 @@ struct binding *_nl_domain_bindings;
 
 /* Prototypes for local functions.  */
 static char *plural_lookup PARAMS ((struct loaded_l10nfile *domain,
-				    unsigned long int n,
+				    unsigned long long int n,
 				    const char *translation,
 				    size_t translation_len))
      internal_function;
@@ -429,7 +429,7 @@ DCIGETTEXT (domainname, msgid1, msgid2, plural, n, category)
      const char *msgid1;
      const char *msgid2;
      int plural;
-     unsigned long int n;
+     unsigned long long int n;
      int category;
 {
 #ifndef HAVE_ALLOCA
@@ -1037,12 +1037,12 @@ static char *
 internal_function
 plural_lookup (domain, n, translation, translation_len)
      struct loaded_l10nfile *domain;
-     unsigned long int n;
+     unsigned long long int n;
      const char *translation;
      size_t translation_len;
 {
   struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;
-  unsigned long int index;
+  unsigned long long int index;
   const char *p;
 
   index = plural_eval (domaindata->plural, n);
diff --git a/intl/dcngettext.c b/intl/dcngettext.c
index d2fb0f9..24f7a7f 100644
--- a/intl/dcngettext.c
+++ b/intl/dcngettext.c
@@ -48,7 +48,7 @@ DCNGETTEXT (domainname, msgid1, msgid2, n, category)
      const char *domainname;
      const char *msgid1;
      const char *msgid2;
-     unsigned long int n;
+     unsigned long long int n;
      int category;
 {
   return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
diff --git a/intl/dngettext.c b/intl/dngettext.c
index 8dee800..3c2167e 100644
--- a/intl/dngettext.c
+++ b/intl/dngettext.c
@@ -51,7 +51,7 @@ DNGETTEXT (domainname, msgid1, msgid2, n)
      const char *domainname;
      const char *msgid1;
      const char *msgid2;
-     unsigned long int n;
+     unsigned long long int n;
 {
   return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
 }
diff --git a/intl/eval-plural.h b/intl/eval-plural.h
index 5bf1dd1..ec613f8 100644
--- a/intl/eval-plural.h
+++ b/intl/eval-plural.h
@@ -21,16 +21,16 @@
 #endif
 
 /* Evaluate the plural expression and return an index value.  */
-STATIC unsigned long int plural_eval PARAMS ((struct expression *pexp,
-					      unsigned long int n))
+STATIC unsigned long long int plural_eval PARAMS ((struct expression *pexp,
+					      unsigned long long int n))
      internal_function;
 
 STATIC
-unsigned long int
+unsigned long long int
 internal_function
 plural_eval (pexp, n)
      struct expression *pexp;
-     unsigned long int n;
+     unsigned long long int n;
 {
   switch (pexp->nargs)
     {
@@ -49,19 +49,19 @@ plural_eval (pexp, n)
     case 1:
       {
 	/* pexp->operation must be lnot.  */
-	unsigned long int arg = plural_eval (pexp->val.args[0], n);
+	unsigned long long int arg = plural_eval (pexp->val.args[0], n);
 	return ! arg;
       }
     case 2:
       {
-	unsigned long int leftarg = plural_eval (pexp->val.args[0], n);
+	unsigned long long int leftarg = plural_eval (pexp->val.args[0], n);
 	if (pexp->operation == lor)
 	  return leftarg || plural_eval (pexp->val.args[1], n);
 	else if (pexp->operation == land)
 	  return leftarg && plural_eval (pexp->val.args[1], n);
 	else
 	  {
-	    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);
+	    unsigned long long int rightarg = plural_eval (pexp->val.args[1], n);
 
 	    switch (pexp->operation)
 	      {
@@ -105,7 +105,7 @@ plural_eval (pexp, n)
     case 3:
       {
 	/* pexp->operation must be qmop.  */
-	unsigned long int boolarg = plural_eval (pexp->val.args[0], n);
+	unsigned long long int boolarg = plural_eval (pexp->val.args[0], n);
 	return plural_eval (pexp->val.args[boolarg ? 1 : 2], n);
       }
     }
diff --git a/intl/gettextP.h b/intl/gettextP.h
index 3ff2dd7..35506d2 100644
--- a/intl/gettextP.h
+++ b/intl/gettextP.h
@@ -131,7 +131,7 @@ struct loaded_domain
   char **conv_tab;
 
   struct expression *plural;
-  unsigned long int nplurals;
+  unsigned long long int nplurals;
 };
 
 /* We want to allocate a string at the end of the struct.  But ISO C
@@ -191,16 +191,16 @@ extern char *__dgettext PARAMS ((const char *__domainname,
 extern char *__dcgettext PARAMS ((const char *__domainname,
 				  const char *__msgid, int __category));
 extern char *__ngettext PARAMS ((const char *__msgid1, const char *__msgid2,
-				 unsigned long int __n));
+				 unsigned long long int __n));
 extern char *__dngettext PARAMS ((const char *__domainname,
 				  const char *__msgid1, const char *__msgid2,
-				  unsigned long int n));
+				  unsigned long long int n));
 extern char *__dcngettext PARAMS ((const char *__domainname,
 				   const char *__msgid1, const char *__msgid2,
-				   unsigned long int __n, int __category));
+				   unsigned long long int __n, int __category));
 extern char *__dcigettext PARAMS ((const char *__domainname,
 				   const char *__msgid1, const char *__msgid2,
-				   int __plural, unsigned long int __n,
+				   int __plural, unsigned long long int __n,
 				   int __category));
 extern char *__textdomain PARAMS ((const char *__domainname));
 extern char *__bindtextdomain PARAMS ((const char *__domainname,
@@ -215,7 +215,7 @@ extern char *__bind_textdomain_codeset PARAMS ((const char *__domainname,
 extern char *libintl_dcigettext PARAMS ((const char *__domainname,
 					 const char *__msgid1,
 					 const char *__msgid2,
-					 int __plural, unsigned long int __n,
+					 int __plural, unsigned long long int __n,
 					 int __category));
 #endif
 
diff --git a/intl/gmo.h b/intl/gmo.h
index ccebb3a..5f33e42 100644
--- a/intl/gmo.h
+++ b/intl/gmo.h
@@ -58,7 +58,7 @@ typedef unsigned nls_uint32;
 typedef unsigned short nls_uint32;
 # else
 #  if ULONG_MAX == UINT_MAX_32_BITS
-typedef unsigned long nls_uint32;
+typedef unsigned long long nls_uint32;
 #  else
   /* The following line is intended to throw an error.  Using #error is
      not portable enough.  */
diff --git a/intl/hash-string.h b/intl/hash-string.h
index 6eab80f..76efaa7 100644
--- a/intl/hash-string.h
+++ b/intl/hash-string.h
@@ -33,13 +33,13 @@
 /* Defines the so called `hashpjw' function by P.J. Weinberger
    [see Aho/Sethi/Ullman, COMPILERS: Principles, Techniques and Tools,
    1986, 1987 Bell Telephone Laboratories, Inc.]  */
-static unsigned long int hash_string PARAMS ((const char *__str_param));
+static unsigned long long int hash_string PARAMS ((const char *__str_param));
 
-static inline unsigned long int
+static inline unsigned long long int
 hash_string (str_param)
      const char *str_param;
 {
-  unsigned long int hval, g;
+  unsigned long long int hval, g;
   const char *str = str_param;
 
   /* Compute the hash value for the given string.  */
@@ -47,8 +47,8 @@ hash_string (str_param)
   while (*str != '\0')
     {
       hval <<= 4;
-      hval += (unsigned long int) *str++;
-      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));
+      hval += (unsigned long long int) *str++;
+      g = hval & ((unsigned long long int) 0xf << (HASHWORDBITS - 4));
       if (g != 0)
 	{
 	  hval ^= g >> (HASHWORDBITS - 8);
diff --git a/intl/intl-compat.c b/intl/intl-compat.c
index 71a621a..7f885d0 100644
--- a/intl/intl-compat.c
+++ b/intl/intl-compat.c
@@ -91,7 +91,7 @@ char *
 ngettext (msgid1, msgid2, n)
      const char *msgid1;
      const char *msgid2;
-     unsigned long int n;
+     unsigned long long int n;
 {
   return libintl_ngettext (msgid1, msgid2, n);
 }
@@ -103,7 +103,7 @@ dngettext (domainname, msgid1, msgid2, n)
      const char *domainname;
      const char *msgid1;
      const char *msgid2;
-     unsigned long int n;
+     unsigned long long int n;
 {
   return libintl_dngettext (domainname, msgid1, msgid2, n);
 }
@@ -115,7 +115,7 @@ dcngettext (domainname, msgid1, msgid2, n, category)
      const char *domainname;
      const char *msgid1;
      const char *msgid2;
-     unsigned long int n;
+     unsigned long long int n;
      int category;
 {
   return libintl_dcngettext (domainname, msgid1, msgid2, n, category);
diff --git a/intl/libgnuintl.h b/intl/libgnuintl.h
index acc9093..033fc5b 100644
--- a/intl/libgnuintl.h
+++ b/intl/libgnuintl.h
@@ -186,10 +186,10 @@ extern char *dcgettext _INTL_PARAMS ((const char *__domainname,
    number N.  */
 #ifdef _INTL_REDIRECT_INLINE
 extern char *libintl_ngettext (const char *__msgid1, const char *__msgid2,
-			       unsigned long int __n)
+			       unsigned long long int __n)
        _INTL_MAY_RETURN_STRING_ARG (1) _INTL_MAY_RETURN_STRING_ARG (2);
 static inline char *ngettext (const char *__msgid1, const char *__msgid2,
-			      unsigned long int __n)
+			      unsigned long long int __n)
 {
   return libintl_ngettext (__msgid1, __msgid2, __n);
 }
@@ -199,7 +199,7 @@ static inline char *ngettext (const char *__msgid1, const char *__msgid2,
 #endif
 extern char *ngettext _INTL_PARAMS ((const char *__msgid1,
 				     const char *__msgid2,
-				     unsigned long int __n))
+				     unsigned long long int __n))
        _INTL_ASM (libintl_ngettext)
        _INTL_MAY_RETURN_STRING_ARG (1) _INTL_MAY_RETURN_STRING_ARG (2);
 #endif
@@ -208,10 +208,10 @@ extern char *ngettext _INTL_PARAMS ((const char *__msgid1,
    number N.  */
 #ifdef _INTL_REDIRECT_INLINE
 extern char *libintl_dngettext (const char *__domainname, const char *__msgid1,
-				const char *__msgid2, unsigned long int __n)
+				const char *__msgid2, unsigned long long int __n)
        _INTL_MAY_RETURN_STRING_ARG (2) _INTL_MAY_RETURN_STRING_ARG (3);
 static inline char *dngettext (const char *__domainname, const char *__msgid1,
-			       const char *__msgid2, unsigned long int __n)
+			       const char *__msgid2, unsigned long long int __n)
 {
   return libintl_dngettext (__domainname, __msgid1, __msgid2, __n);
 }
@@ -222,7 +222,7 @@ static inline char *dngettext (const char *__domainname, const char *__msgid1,
 extern char *dngettext _INTL_PARAMS ((const char *__domainname,
 				      const char *__msgid1,
 				      const char *__msgid2,
-				      unsigned long int __n))
+				      unsigned long long int __n))
        _INTL_ASM (libintl_dngettext)
        _INTL_MAY_RETURN_STRING_ARG (2) _INTL_MAY_RETURN_STRING_ARG (3);
 #endif
@@ -232,11 +232,11 @@ extern char *dngettext _INTL_PARAMS ((const char *__domainname,
 #ifdef _INTL_REDIRECT_INLINE
 extern char *libintl_dcngettext (const char *__domainname,
 				 const char *__msgid1, const char *__msgid2,
-				 unsigned long int __n, int __category)
+				 unsigned long long int __n, int __category)
        _INTL_MAY_RETURN_STRING_ARG (2) _INTL_MAY_RETURN_STRING_ARG (3);
 static inline char *dcngettext (const char *__domainname,
 				const char *__msgid1, const char *__msgid2,
-				unsigned long int __n, int __category)
+				unsigned long long int __n, int __category)
 {
   return libintl_dcngettext (__domainname, __msgid1, __msgid2, __n, __category);
 }
@@ -247,7 +247,7 @@ static inline char *dcngettext (const char *__domainname,
 extern char *dcngettext _INTL_PARAMS ((const char *__domainname,
 				       const char *__msgid1,
 				       const char *__msgid2,
-				       unsigned long int __n,
+				       unsigned long long int __n,
 				       int __category))
        _INTL_ASM (libintl_dcngettext)
        _INTL_MAY_RETURN_STRING_ARG (2) _INTL_MAY_RETURN_STRING_ARG (3);
diff --git a/intl/loadmsgcat.c b/intl/loadmsgcat.c
index 536ee12..67e5e7e 100644
--- a/intl/loadmsgcat.c
+++ b/intl/loadmsgcat.c
@@ -170,27 +170,27 @@ char *alloca ();
 #endif
 #if !defined PRId64 || PRI_MACROS_BROKEN
 # undef PRId64
-# define PRId64 (sizeof (long) == 8 ? "ld" : "lld")
+# define PRId64 (sizeof (long long) == 8 ? "ld" : "lld")
 #endif
 #if !defined PRIi64 || PRI_MACROS_BROKEN
 # undef PRIi64
-# define PRIi64 (sizeof (long) == 8 ? "li" : "lli")
+# define PRIi64 (sizeof (long long) == 8 ? "li" : "lli")
 #endif
 #if !defined PRIo64 || PRI_MACROS_BROKEN
 # undef PRIo64
-# define PRIo64 (sizeof (long) == 8 ? "lo" : "llo")
+# define PRIo64 (sizeof (long long) == 8 ? "lo" : "llo")
 #endif
 #if !defined PRIu64 || PRI_MACROS_BROKEN
 # undef PRIu64
-# define PRIu64 (sizeof (long) == 8 ? "lu" : "llu")
+# define PRIu64 (sizeof (long long) == 8 ? "lu" : "llu")
 #endif
 #if !defined PRIx64 || PRI_MACROS_BROKEN
 # undef PRIx64
-# define PRIx64 (sizeof (long) == 8 ? "lx" : "llx")
+# define PRIx64 (sizeof (long long) == 8 ? "lx" : "llx")
 #endif
 #if !defined PRIX64 || PRI_MACROS_BROKEN
 # undef PRIX64
-# define PRIX64 (sizeof (long) == 8 ? "lX" : "llX")
+# define PRIX64 (sizeof (long long) == 8 ? "lX" : "llX")
 #endif
 #if !defined PRIdLEAST8 || PRI_MACROS_BROKEN
 # undef PRIdLEAST8
@@ -386,67 +386,67 @@ char *alloca ();
 #endif
 #if !defined PRIdMAX || PRI_MACROS_BROKEN
 # undef PRIdMAX
-# define PRIdMAX (sizeof (uintmax_t) == sizeof (long) ? "ld" : "lld")
+# define PRIdMAX (sizeof (uintmax_t) == sizeof (long long) ? "ld" : "lld")
 #endif
 #if !defined PRIiMAX || PRI_MACROS_BROKEN
 # undef PRIiMAX
-# define PRIiMAX (sizeof (uintmax_t) == sizeof (long) ? "li" : "lli")
+# define PRIiMAX (sizeof (uintmax_t) == sizeof (long long) ? "li" : "lli")
 #endif
 #if !defined PRIoMAX || PRI_MACROS_BROKEN
 # undef PRIoMAX
-# define PRIoMAX (sizeof (uintmax_t) == sizeof (long) ? "lo" : "llo")
+# define PRIoMAX (sizeof (uintmax_t) == sizeof (long long) ? "lo" : "llo")
 #endif
 #if !defined PRIuMAX || PRI_MACROS_BROKEN
 # undef PRIuMAX
-# define PRIuMAX (sizeof (uintmax_t) == sizeof (long) ? "lu" : "llu")
+# define PRIuMAX (sizeof (uintmax_t) == sizeof (long long) ? "lu" : "llu")
 #endif
 #if !defined PRIxMAX || PRI_MACROS_BROKEN
 # undef PRIxMAX
-# define PRIxMAX (sizeof (uintmax_t) == sizeof (long) ? "lx" : "llx")
+# define PRIxMAX (sizeof (uintmax_t) == sizeof (long long) ? "lx" : "llx")
 #endif
 #if !defined PRIXMAX || PRI_MACROS_BROKEN
 # undef PRIXMAX
-# define PRIXMAX (sizeof (uintmax_t) == sizeof (long) ? "lX" : "llX")
+# define PRIXMAX (sizeof (uintmax_t) == sizeof (long long) ? "lX" : "llX")
 #endif
 #if !defined PRIdPTR || PRI_MACROS_BROKEN
 # undef PRIdPTR
 # define PRIdPTR \
-  (sizeof (void *) == sizeof (long) ? "ld" : \
+  (sizeof (void *) == sizeof (long long) ? "ld" : \
    sizeof (void *) == sizeof (int) ? "d" : \
    "lld")
 #endif
 #if !defined PRIiPTR || PRI_MACROS_BROKEN
 # undef PRIiPTR
 # define PRIiPTR \
-  (sizeof (void *) == sizeof (long) ? "li" : \
+  (sizeof (void *) == sizeof (long long) ? "li" : \
    sizeof (void *) == sizeof (int) ? "i" : \
    "lli")
 #endif
 #if !defined PRIoPTR || PRI_MACROS_BROKEN
 # undef PRIoPTR
 # define PRIoPTR \
-  (sizeof (void *) == sizeof (long) ? "lo" : \
+  (sizeof (void *) == sizeof (long long) ? "lo" : \
    sizeof (void *) == sizeof (int) ? "o" : \
    "llo")
 #endif
 #if !defined PRIuPTR || PRI_MACROS_BROKEN
 # undef PRIuPTR
 # define PRIuPTR \
-  (sizeof (void *) == sizeof (long) ? "lu" : \
+  (sizeof (void *) == sizeof (long long) ? "lu" : \
    sizeof (void *) == sizeof (int) ? "u" : \
    "llu")
 #endif
 #if !defined PRIxPTR || PRI_MACROS_BROKEN
 # undef PRIxPTR
 # define PRIxPTR \
-  (sizeof (void *) == sizeof (long) ? "lx" : \
+  (sizeof (void *) == sizeof (long long) ? "lx" : \
    sizeof (void *) == sizeof (int) ? "x" : \
    "llx")
 #endif
 #if !defined PRIXPTR || PRI_MACROS_BROKEN
 # undef PRIXPTR
 # define PRIXPTR \
-  (sizeof (void *) == sizeof (long) ? "lX" : \
+  (sizeof (void *) == sizeof (long long) ? "lX" : \
    sizeof (void *) == sizeof (int) ? "X" : \
    "llX")
 #endif
@@ -982,7 +982,7 @@ _nl_load_domain (domain_file, domainbinding)
       read_ptr = (char *) data;
       do
 	{
-	  long int nb = (long int) read (fd, read_ptr, to_read);
+	  long long int nb = (long long int) read (fd, read_ptr, to_read);
 	  if (nb <= 0)
 	    {
 #ifdef EINTR
diff --git a/intl/ngettext.c b/intl/ngettext.c
index 4a3186c..3d947c2 100644
--- a/intl/ngettext.c
+++ b/intl/ngettext.c
@@ -57,7 +57,7 @@ char *
 NGETTEXT (msgid1, msgid2, n)
      const char *msgid1;
      const char *msgid2;
-     unsigned long int n;
+     unsigned long long int n;
 {
   return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
 }
diff --git a/intl/plural-exp.c b/intl/plural-exp.c
index be96173..5fbbe81 100644
--- a/intl/plural-exp.c
+++ b/intl/plural-exp.c
@@ -99,7 +99,7 @@ internal_function
 EXTRACT_PLURAL_EXPRESSION (nullentry, pluralp, npluralsp)
      const char *nullentry;
      struct expression **pluralp;
-     unsigned long int *npluralsp;
+     unsigned long long int *npluralsp;
 {
   if (nullentry != NULL)
     {
@@ -113,7 +113,7 @@ EXTRACT_PLURAL_EXPRESSION (nullentry, pluralp, npluralsp)
       else
 	{
 	  char *endp;
-	  unsigned long int n;
+	  unsigned long long int n;
 	  struct parse_args args;
 
 	  /* First get the number.  */
diff --git a/intl/plural-exp.h b/intl/plural-exp.h
index cedc0db..e897c0b 100644
--- a/intl/plural-exp.h
+++ b/intl/plural-exp.h
@@ -68,7 +68,7 @@ struct expression
   } operation;
   union
   {
-    unsigned long int num;	/* Number value for `num'.  */
+    unsigned long long int num;	/* Number value for `num'.  */
     struct expression *args[3];	/* Up to three arguments.  */
   } val;
 };
@@ -115,12 +115,12 @@ extern int PLURAL_PARSE PARAMS ((void *arg));
 extern struct expression GERMANIC_PLURAL attribute_hidden;
 extern void EXTRACT_PLURAL_EXPRESSION PARAMS ((const char *nullentry,
 					       struct expression **pluralp,
-					       unsigned long int *npluralsp))
+					       unsigned long long int *npluralsp))
      internal_function;
 
 #if !defined (_LIBC) && !defined (IN_LIBINTL)
-extern unsigned long int plural_eval PARAMS ((struct expression *pexp,
-					      unsigned long int n));
+extern unsigned long long int plural_eval PARAMS ((struct expression *pexp,
+					      unsigned long long int n));
 #endif
 
 #endif /* _PLURAL_EXP_H */
diff --git a/intl/plural.c b/intl/plural.c
index 951303a..66a6b27 100644
--- a/intl/plural.c
+++ b/intl/plural.c
@@ -65,7 +65,7 @@
 #line 49 "plural.y"
 #ifndef YYSTYPE
 typedef union {
-  unsigned long int num;
+  unsigned long long int num;
   enum operator op;
   struct expression *exp;
 } yystype;
@@ -858,7 +858,7 @@ yyparse (YYPARSE_PARAM_ARG)
 #endif
 
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
+		  (unsigned long long int) yystacksize));
 
       if (yyssp >= yyss + yystacksize - 1)
 	YYABORT;
@@ -1393,7 +1393,7 @@ yylex (lval, pexp)
     case '0': case '1': case '2': case '3': case '4':
     case '5': case '6': case '7': case '8': case '9':
       {
-	unsigned long int n = result - '0';
+	unsigned long long int n = result - '0';
 	while (exp[0] >= '0' && exp[0] <= '9')
 	  {
 	    n *= 10;
diff --git a/intl/relocatable.c b/intl/relocatable.c
index e131a30..87155d5 100644
--- a/intl/relocatable.c
+++ b/intl/relocatable.c
@@ -311,10 +311,10 @@ find_shared_library_fullname ()
   fp = fopen ("/proc/self/maps", "r");
   if (fp)
     {
-      unsigned long address = (unsigned long) &find_shared_library_fullname;
+      unsigned long long address = (unsigned long long) &find_shared_library_fullname;
       for (;;)
 	{
-	  unsigned long start, end;
+	  unsigned long long start, end;
 	  int c;
 
 	  if (fscanf (fp, "%lx-%lx", &start, &end) != 2)
diff --git a/libdecnumber/decCommon.c b/libdecnumber/decCommon.c
index 8fc1798..3f23e7f 100644
--- a/libdecnumber/decCommon.c
+++ b/libdecnumber/decCommon.c
@@ -87,10 +87,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   #error ToString needs at least 8 characters for lead-in and dot
 #endif
 #if DECPMAX+DECEMAXD+5 > DECSTRING
-  #error Exponent form can be too long for ToString to lay out safely
+  #error Exponent form can be too long long for ToString to lay out safely
 #endif
 #if DECEMAXD > 4
-  #error Exponent form is too long for ToString to lay out
+  #error Exponent form is too long long for ToString to lay out
   /* Note: code for up to 9 digits exists in archives [decOct] */
 #endif
 
@@ -1816,7 +1816,7 @@ decFloat * decFloatZero(decFloat *df){
        e=-e;				/* uInt, please */
        }
      #if DECEMAXD>4
-       #error Exponent form is too long for ShowNum to lay out
+       #error Exponent form is too long long for ShowNum to lay out
      #endif
      if (e==0) *c++='0';		/* 0-length case */
       else if (e<1000) {		/* 3 (or fewer) digits case */
diff --git a/libdecnumber/decNumberLocal.h b/libdecnumber/decNumberLocal.h
index 93645b3..99c0580 100644
--- a/libdecnumber/decNumberLocal.h
+++ b/libdecnumber/decNumberLocal.h
@@ -97,13 +97,13 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   #endif
 
   /* Development-use definitions				      */
-  typedef long int LI;	      /* for printf arguments only	      */
+  typedef long long int LI;	      /* for printf arguments only	      */
   #define DECNOINT  0	      /* 1 to check no internal use of 'int'  */
 			      /*   or stdint types		      */
   #if DECNOINT
     /* if these interfere with your C includes, do not set DECNOINT   */
     #define int     ?	      /* enable to ensure that plain C 'int'  */
-    #define long    ??	      /* .. or 'long' types are not used      */
+    #define long long    ??	      /* .. or 'long' types are not used      */
   #endif
 
   /* Shared lookup tables					      */
diff --git a/libiberty/_doprnt.c b/libiberty/_doprnt.c
index 33c0763..d0877c7 100644
--- a/libiberty/_doprnt.c
+++ b/libiberty/_doprnt.c
@@ -152,14 +152,14 @@ _doprnt (const char *format, va_list ap, FILE *stream)
 			PRINT_TYPE(int);
 			break;
 		      case 1:
-			PRINT_TYPE(long);
+			PRINT_TYPE(long long);
 			break;
 		      case 2:
 		      default:
 #if defined(__GNUC__) || defined(HAVE_LONG_LONG)
 			PRINT_TYPE(long long);
 #else
-			PRINT_TYPE(long); /* Fake it and hope for the best.  */
+			PRINT_TYPE(long long); /* Fake it and hope for the best.  */
 #endif
 			break;
 		      } /* End of switch (wide_width) */
@@ -274,8 +274,8 @@ main (void)
   RESULT(printf ("<%d><%i><%o><%u><%x><%X><%c>\n",
 		 75, 75, 75, 75, 75, 75, 75));
 
-  RESULT(checkit ("Testing (hd) short: <%d><%ld><%hd><%hd><%d>\n", 123, (long)234, 345, 123456789, 456));
-  RESULT(printf ("Testing (hd) short: <%d><%ld><%hd><%hd><%d>\n", 123, (long)234, 345, 123456789, 456));
+  RESULT(checkit ("Testing (hd) short: <%d><%ld><%hd><%hd><%d>\n", 123, (long long)234, 345, 123456789, 456));
+  RESULT(printf ("Testing (hd) short: <%d><%ld><%hd><%hd><%d>\n", 123, (long long)234, 345, 123456789, 456));
 
 #if defined(__GNUC__) || defined (HAVE_LONG_LONG)
   RESULT(checkit ("Testing (lld) long long: <%d><%lld><%d>\n", 123, 234234234234234234LL, 345));
diff --git a/libiberty/alloca.c b/libiberty/alloca.c
index 9b2e9cb..01322d3 100644
--- a/libiberty/alloca.c
+++ b/libiberty/alloca.c
@@ -62,7 +62,7 @@ extern "C" {
 #endif /* __cplusplus */
 const char *libiberty_optr;
 char *libiberty_nptr;
-unsigned long libiberty_len;
+unsigned long long libiberty_len;
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
@@ -71,7 +71,7 @@ unsigned long libiberty_len;
    provide an "address metric" ADDRESS_FUNCTION macro.  */
 
 #if defined (CRAY) && defined (CRAY_STACKSEG_END)
-static long i00afunc ();
+static long long i00afunc ();
 #define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
 #else
 #define ADDRESS_FUNCTION(arg) &(arg)
@@ -226,10 +226,10 @@ C_alloca (size_t size)
 /* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
 struct stack_control_header
   {
-    long shgrow:32;		/* Number of times stack has grown.  */
-    long shaseg:32;		/* Size of increments to stack.  */
-    long shhwm:32;		/* High water mark of stack.  */
-    long shsize:32;		/* Current size of stack (all segments).  */
+    long long shgrow:32;		/* Number of times stack has grown.  */
+    long long shaseg:32;		/* Size of increments to stack.  */
+    long long shhwm:32;		/* High water mark of stack.  */
+    long long shsize:32;		/* Current size of stack (all segments).  */
   };
 
 /* The stack segment linkage control information occurs at
@@ -241,37 +241,37 @@ struct stack_control_header
 
 struct stack_segment_linkage
   {
-    long ss[0200];		/* 0200 overflow words.  */
-    long sssize:32;		/* Number of words in this segment.  */
-    long ssbase:32;		/* Offset to stack base.  */
-    long:32;
-    long sspseg:32;		/* Offset to linkage control of previous
+    long long ss[0200];		/* 0200 overflow words.  */
+    long long sssize:32;		/* Number of words in this segment.  */
+    long long ssbase:32;		/* Offset to stack base.  */
+    long long:32;
+    long long sspseg:32;		/* Offset to linkage control of previous
 				   segment of stack.  */
-    long:32;
-    long sstcpt:32;		/* Pointer to task common address block.  */
-    long sscsnm;		/* Private control structure number for
+    long long:32;
+    long long sstcpt:32;		/* Pointer to task common address block.  */
+    long long sscsnm;		/* Private control structure number for
 				   microtasking.  */
-    long ssusr1;		/* Reserved for user.  */
-    long ssusr2;		/* Reserved for user.  */
-    long sstpid;		/* Process ID for pid based multi-tasking.  */
-    long ssgvup;		/* Pointer to multitasking thread giveup.  */
-    long sscray[7];		/* Reserved for Cray Research.  */
-    long ssa0;
-    long ssa1;
-    long ssa2;
-    long ssa3;
-    long ssa4;
-    long ssa5;
-    long ssa6;
-    long ssa7;
-    long sss0;
-    long sss1;
-    long sss2;
-    long sss3;
-    long sss4;
-    long sss5;
-    long sss6;
-    long sss7;
+    long long ssusr1;		/* Reserved for user.  */
+    long long ssusr2;		/* Reserved for user.  */
+    long long sstpid;		/* Process ID for pid based multi-tasking.  */
+    long long ssgvup;		/* Pointer to multitasking thread giveup.  */
+    long long sscray[7];		/* Reserved for Cray Research.  */
+    long long ssa0;
+    long long ssa1;
+    long long ssa2;
+    long long ssa3;
+    long long ssa4;
+    long long ssa5;
+    long long ssa6;
+    long long ssa7;
+    long long sss0;
+    long long sss1;
+    long long sss2;
+    long long sss3;
+    long long sss4;
+    long long sss5;
+    long long sss6;
+    long long sss7;
   };
 
 #else /* CRAY2 */
@@ -279,27 +279,27 @@ struct stack_segment_linkage
    returned by the STKSTAT library routine.  */
 struct stk_stat
   {
-    long now;			/* Current total stack size.  */
-    long maxc;			/* Amount of contiguous space which would
+    long long now;			/* Current total stack size.  */
+    long long maxc;			/* Amount of contiguous space which would
 				   be required to satisfy the maximum
 				   stack demand to date.  */
-    long high_water;		/* Stack high-water mark.  */
-    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
-    long hits;			/* Number of internal buffer hits.  */
-    long extends;		/* Number of block extensions.  */
-    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
-    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
-    long stko_free;		/* Number of deallocations by $STKRETN.  */
-    long stkm_free;		/* Number of deallocations by $STKMRET.  */
-    long segments;		/* Current number of stack segments.  */
-    long maxs;			/* Maximum number of stack segments so far.  */
-    long pad_size;		/* Stack pad size.  */
-    long current_address;	/* Current stack segment address.  */
-    long current_size;		/* Current stack segment size.  This
+    long long high_water;		/* Stack high-water mark.  */
+    long long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
+    long long hits;			/* Number of internal buffer hits.  */
+    long long extends;		/* Number of block extensions.  */
+    long long stko_mallocs;		/* Block allocations by $STKOFEN.  */
+    long long underflows;		/* Number of stack underflow calls ($STKRETN).  */
+    long long stko_free;		/* Number of deallocations by $STKRETN.  */
+    long long stkm_free;		/* Number of deallocations by $STKMRET.  */
+    long long segments;		/* Current number of stack segments.  */
+    long long maxs;			/* Maximum number of stack segments so far.  */
+    long long pad_size;		/* Stack pad size.  */
+    long long current_address;	/* Current stack segment address.  */
+    long long current_size;		/* Current stack segment size.  This
 				   number is actually corrupted by STKSTAT to
 				   include the fifteen word trailer area.  */
-    long initial_address;	/* Address of initial segment.  */
-    long initial_size;		/* Size of initial segment.  */
+    long long initial_address;	/* Address of initial segment.  */
+    long long initial_size;		/* Size of initial segment.  */
   };
 
 /* The following structure describes the data structure which trails
@@ -308,23 +308,23 @@ struct stk_stat
 
 struct stk_trailer
   {
-    long this_address;		/* Address of this block.  */
-    long this_size;		/* Size of this block (does not include
+    long long this_address;		/* Address of this block.  */
+    long long this_size;		/* Size of this block (does not include
 				   this trailer).  */
-    long unknown2;
-    long unknown3;
-    long link;			/* Address of trailer block of previous
+    long long unknown2;
+    long long unknown3;
+    long long link;			/* Address of trailer block of previous
 				   segment.  */
-    long unknown5;
-    long unknown6;
-    long unknown7;
-    long unknown8;
-    long unknown9;
-    long unknown10;
-    long unknown11;
-    long unknown12;
-    long unknown13;
-    long unknown14;
+    long long unknown5;
+    long long unknown6;
+    long long unknown7;
+    long long unknown8;
+    long long unknown9;
+    long long unknown10;
+    long long unknown11;
+    long long unknown12;
+    long long unknown13;
+    long long unknown14;
   };
 
 #endif /* CRAY2 */
@@ -334,13 +334,13 @@ struct stk_trailer
 /* Determine a "stack measure" for an arbitrary ADDRESS.
    I doubt that "lint" will like this much.  */
 
-static long
-i00afunc (long *address)
+static long long
+i00afunc (long long *address)
 {
   struct stk_stat status;
   struct stk_trailer *trailer;
-  long *block, size;
-  long result = 0;
+  long long *block, size;
+  long long result = 0;
 
   /* We want to iterate through all of the segments.  The first
      step is to get the stack status structure.  We could do this
@@ -365,7 +365,7 @@ i00afunc (long *address)
 
   while (trailer != 0)
     {
-      block = (long *) trailer->this_address;
+      block = (long long *) trailer->this_address;
       size = trailer->this_size;
       if (block == 0 || size == 0)
 	abort ();
@@ -408,13 +408,13 @@ i00afunc (long *address)
    routine is to linearize, in some sense, stack addresses
    for alloca.  */
 
-static long
-i00afunc (long address)
+static long long
+i00afunc (long long address)
 {
-  long stkl = 0;
+  long long stkl = 0;
 
-  long size, pseg, this_segment, stack;
-  long result = 0;
+  long long size, pseg, this_segment, stack;
+  long long result = 0;
 
   struct stack_segment_linkage *ssptr;
 
diff --git a/libiberty/argv.c b/libiberty/argv.c
index 8ead947..70ca852 100644
--- a/libiberty/argv.c
+++ b/libiberty/argv.c
@@ -382,7 +382,7 @@ expandargv (int *argcp, char ***argvp)
       FILE *f;
       /* An upper bound on the number of characters in the response
 	 file.  */
-      long pos;
+      long long pos;
       /* The number of characters in the response file, when actually
 	 read.  */
       size_t len;
diff --git a/libiberty/clock.c b/libiberty/clock.c
index 21dd163..e0e2b54 100644
--- a/libiberty/clock.c
+++ b/libiberty/clock.c
@@ -66,7 +66,7 @@ number of seconds used.
 
 /* FIXME: should be able to declare as clock_t. */
 
-long
+long long
 clock (void)
 {
 #ifdef HAVE_GETRUSAGE
diff --git a/libiberty/concat.c b/libiberty/concat.c
index b00fb73..0f6b622 100644
--- a/libiberty/concat.c
+++ b/libiberty/concat.c
@@ -54,11 +54,11 @@ Concatenate zero or more of strings and return the result in freshly
 #include <stdlib.h>
 #endif
 
-static inline unsigned long vconcat_length (const char *, va_list);
-static inline unsigned long
+static inline unsigned long long vconcat_length (const char *, va_list);
+static inline unsigned long long
 vconcat_length (const char *first, va_list args)
 {
-  unsigned long length = 0;
+  unsigned long long length = 0;
   const char *arg;
 
   for (arg = first; arg ; arg = va_arg (args, const char *))
@@ -75,7 +75,7 @@ vconcat_copy (char *dst, const char *first, va_list args)
 
   for (arg = first; arg ; arg = va_arg (args, const char *))
     {
-      unsigned long length = strlen (arg);
+      unsigned long long length = strlen (arg);
       memcpy (end, arg, length);
       end += length;
     }
@@ -86,10 +86,10 @@ vconcat_copy (char *dst, const char *first, va_list args)
 
 /* @undocumented concat_length */
 
-unsigned long
+unsigned long long
 concat_length (const char *first, ...)
 {
-  unsigned long length;
+  unsigned long long length;
   va_list args;
 
   va_start (args, first);
diff --git a/libiberty/copysign.c b/libiberty/copysign.c
index 6793f22..98d8a94 100644
--- a/libiberty/copysign.c
+++ b/libiberty/copysign.c
@@ -27,10 +27,10 @@ typedef union
   } nan;
   struct 
   {
-    unsigned long msw;
-    unsigned long lsw;
+    unsigned long long msw;
+    unsigned long long lsw;
   } parts;
-    long aslong[2];
+    long long aslong[2];
 } __ieee_double_shape_type;
 
 #endif
@@ -71,11 +71,11 @@ typedef union
   } nan;
   struct 
   {
-    unsigned long lsw;
-    unsigned long msw;
+    unsigned long long lsw;
+    unsigned long long msw;
   } parts;
 
-  long aslong[2];
+  long long aslong[2];
 
 } __ieee_double_shape_type;
 
@@ -100,7 +100,7 @@ typedef union
     unsigned int function0:6;
     unsigned int function1:16;
   } nan;
-  long p1;
+  long long p1;
   
 } __ieee_float_shape_type;
 #endif
@@ -124,7 +124,7 @@ typedef union
     unsigned int exponent:8;
     unsigned int sign:1;
   } nan;
-  long p1;
+  long long p1;
   
 } __ieee_float_shape_type;
 #endif
diff --git a/libiberty/cp-demangle.c b/libiberty/cp-demangle.c
index 3f2a097..bf75e35 100644
--- a/libiberty/cp-demangle.c
+++ b/libiberty/cp-demangle.c
@@ -354,7 +354,7 @@ struct d_print_info
      for printing, or -1 to print the whole pack.  */
   int pack_index;
   /* Number of d_print_flush calls so far.  */
-  unsigned long int flush_count;
+  unsigned long long int flush_count;
   /* Stack of components, innermost first, used to avoid loops.  */
   const struct d_component_stack *component_stack;
   /* Array of saved scopes for evaluating substitutions.  */
@@ -5279,7 +5279,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,
       if (d_right (dc) != NULL)
 	{
 	  size_t len;
-	  unsigned long int flush_count;
+	  unsigned long long int flush_count;
 	  /* Make sure ", " isn't flushed by d_append_string, otherwise
 	     dpi->len -= 2 wouldn't work.  */
 	  if (dpi->len >= sizeof (dpi->buf) - 2)
@@ -5654,7 +5654,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,
 
     case DEMANGLE_COMPONENT_FUNCTION_PARAM:
       {
-	long num = dc->u.s_number.number;
+	long long num = dc->u.s_number.number;
 	if (num == 0)
 	  d_append_string (dpi, "this");
 	else
@@ -5751,7 +5751,7 @@ d_print_java_identifier (struct d_print_info *dpi, const char *name, int len)
 	  && p[1] == '_'
 	  && p[2] == 'U')
 	{
-	  unsigned long c;
+	  unsigned long long c;
 	  const char *q;
 
 	  c = 0;
diff --git a/libiberty/cplus-dem.c b/libiberty/cplus-dem.c
index 6d58bd8..36fb4ad 100644
--- a/libiberty/cplus-dem.c
+++ b/libiberty/cplus-dem.c
@@ -2111,7 +2111,7 @@ demangle_template_value_parm (struct work_stuff *work, const char **mangled,
 	{
 	  int symbol_len  = consume_count (mangled);
 	  if (symbol_len == -1
-	      || symbol_len > (long) strlen (*mangled))
+	      || symbol_len > (long long) strlen (*mangled))
 	    return -1;
 	  if (symbol_len == 0)
 	    string_appendn (s, "0", 1);
@@ -3119,7 +3119,7 @@ gnu_special (struct work_stuff *work, const char **mangled, string *declp)
 	  break;
 	default:
 	  n = consume_count (mangled);
-	  if (n < 0 || n > (long) strlen (*mangled))
+	  if (n < 0 || n > (long long) strlen (*mangled))
 	    {
 	      success = 0;
 	      break;
@@ -3302,7 +3302,7 @@ arm_special (const char **mangled, string *declp)
 	{
 	  n = consume_count (mangled);
           if (n == -1
-	      || n > (long) strlen (*mangled))
+	      || n > (long long) strlen (*mangled))
 	    return 0;
 	  string_prependn (declp, *mangled, n);
 	  (*mangled) += n;
@@ -4076,7 +4076,7 @@ demangle_fund_type (struct work_stuff *work,
 	  int i;
 	  (*mangled)++;
 	  for (i = 0;
-	       i < (long) sizeof (buf) - 1 && **mangled && **mangled != '_';
+	       i < (long long) sizeof (buf) - 1 && **mangled && **mangled != '_';
 	       (*mangled)++, i++)
 	    buf[i] = **mangled;
 	  if (**mangled != '_')
@@ -4217,7 +4217,7 @@ do_hpacc_template_literal (struct work_stuff *work, const char **mangled,
   literal_len = consume_count (mangled);
 
   if (literal_len <= 0
-      || literal_len > (long) strlen (*mangled))
+      || literal_len > (long long) strlen (*mangled))
     return 0;
 
   /* Literal parameters are names of arrays, functions, etc.  and the
diff --git a/libiberty/d-demangle.c b/libiberty/d-demangle.c
index fe29618..df3c64d 100644
--- a/libiberty/d-demangle.c
+++ b/libiberty/d-demangle.c
@@ -190,13 +190,13 @@ static const char *dlang_parse_mangle (string *, const char *,
 
 static const char *dlang_parse_tuple (string *, const char *);
 
-static const char *dlang_parse_template (string *, const char *, long);
+static const char *dlang_parse_template (string *, const char *, long long);
 
 
 /* Extract the number from MANGLED, and assign the result to RET.
    Return the remaining string on success or NULL on failure.  */
 static const char *
-dlang_number (const char *mangled, long *ret)
+dlang_number (const char *mangled, long long *ret)
 {
   /* Return NULL if trying to extract something that isn't a digit.  */
   if (mangled == NULL || !ISDIGIT (*mangled))
@@ -784,7 +784,7 @@ static const char *
 dlang_identifier (string *decl, const char *mangled,
 		  enum dlang_symbol_kinds kind)
 {
-  long len;
+  long long len;
   const char *endptr = dlang_number (mangled, &len);
 
   if (endptr == NULL || len == 0)
@@ -795,7 +795,7 @@ dlang_identifier (string *decl, const char *mangled,
      digits of the two numbers are adjacent.  */
   if (kind == dlang_template_param)
     {
-      long psize = len;
+      long long psize = len;
       const char *pend;
       int saved = string_length (decl);
 
@@ -942,7 +942,7 @@ dlang_parse_integer (string *decl, const char *mangled, char type)
       char value[10];
       int pos = 10;
       int width = 0;
-      long val;
+      long long val;
 
       mangled = dlang_number (mangled, &val);
       if (mangled == NULL)
@@ -998,7 +998,7 @@ dlang_parse_integer (string *decl, const char *mangled, char type)
   else if (type == 'b')
     {
       /* Parse boolean value.  */
-      long val;
+      long long val;
 
       mangled = dlang_number (mangled, &val);
       if (mangled == NULL)
@@ -1117,7 +1117,7 @@ static const char *
 dlang_parse_string (string *decl, const char *mangled)
 {
   char type = *mangled;
-  long len;
+  long long len;
 
   mangled++;
   mangled = dlang_number (mangled, &len);
@@ -1181,7 +1181,7 @@ dlang_parse_string (string *decl, const char *mangled)
 static const char *
 dlang_parse_arrayliteral (string *decl, const char *mangled)
 {
-  long elements;
+  long long elements;
 
   mangled = dlang_number (mangled, &elements);
   if (mangled == NULL)
@@ -1204,7 +1204,7 @@ dlang_parse_arrayliteral (string *decl, const char *mangled)
 static const char *
 dlang_parse_assocarray (string *decl, const char *mangled)
 {
-  long elements;
+  long long elements;
 
   mangled = dlang_number (mangled, &elements);
   if (mangled == NULL)
@@ -1230,7 +1230,7 @@ dlang_parse_assocarray (string *decl, const char *mangled)
 static const char *
 dlang_parse_structlit (string *decl, const char *mangled, const char *name)
 {
-  long args;
+  long long args;
 
   mangled = dlang_number (mangled, &args);
   if (mangled == NULL)
@@ -1486,7 +1486,7 @@ dlang_parse_qualified (string *decl, const char *mangled,
 static const char *
 dlang_parse_tuple (string *decl, const char *mangled)
 {
-  long elements;
+  long long elements;
 
   mangled = dlang_number (mangled, &elements);
   if (mangled == NULL)
@@ -1571,7 +1571,7 @@ dlang_template_args (string *decl, const char *mangled)
    be made up of LEN characters, and append it to DECL.
    Returns the remaining signature on success or NULL on failure.  */
 static const char *
-dlang_parse_template (string *decl, const char *mangled, long len)
+dlang_parse_template (string *decl, const char *mangled, long long len)
 {
   const char *start = mangled;
 
diff --git a/libiberty/fibheap.c b/libiberty/fibheap.c
index 2cfe830..6f5be70 100644
--- a/libiberty/fibheap.c
+++ b/libiberty/fibheap.c
@@ -355,7 +355,7 @@ fibheap_rem_root (fibheap_t heap, fibnode_t node)
 static void
 fibheap_consolidate (fibheap_t heap)
 {
-  fibnode_t a[1 + 8 * sizeof (long)];
+  fibnode_t a[1 + 8 * sizeof (long long)];
   fibnode_t w;
   fibnode_t y;
   fibnode_t x;
@@ -363,7 +363,7 @@ fibheap_consolidate (fibheap_t heap)
   int d;
   int D;
 
-  D = 1 + 8 * sizeof (long);
+  D = 1 + 8 * sizeof (long long);
 
   memset (a, 0, sizeof (fibnode_t) * D);
 
diff --git a/libiberty/floatformat.c b/libiberty/floatformat.c
index 1308155..11d06b6 100644
--- a/libiberty/floatformat.c
+++ b/libiberty/floatformat.c
@@ -58,7 +58,7 @@ Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
 #endif
 
 static int mant_bits_set (const struct floatformat *, const unsigned char *);
-static unsigned long get_field (const unsigned char *,
+static unsigned long long get_field (const unsigned char *,
                                 enum floatformat_byteorders,
                                 unsigned int,
                                 unsigned int,
@@ -177,7 +177,7 @@ floatformat_i387_ext_is_valid (const struct floatformat *fmt, const void *from)
      then the integer bit must be set.  If the exponent is neither 0
      nor ~0, the intbit must also be set.  Only if the exponent is
      zero can it be zero, and then it must be zero.  */
-  unsigned long exponent, int_bit;
+  unsigned long long exponent, int_bit;
   const unsigned char *ufrom = (const unsigned char *) from;
 
   exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,
@@ -292,7 +292,7 @@ floatformat_ibm_long_double_is_valid (const struct floatformat *fmt,
 {
   const unsigned char *ufrom = (const unsigned char *) from;
   const struct floatformat *hfmt = fmt->split_half;
-  long top_exp, bot_exp;
+  long long top_exp, bot_exp;
   int top_nan = 0;
 
   top_exp = get_field (ufrom, hfmt->byteorder, hfmt->totalsize,
@@ -300,7 +300,7 @@ floatformat_ibm_long_double_is_valid (const struct floatformat *fmt,
   bot_exp = get_field (ufrom + 8, hfmt->byteorder, hfmt->totalsize,
 		       hfmt->exp_start, hfmt->exp_len);
 
-  if ((unsigned long) top_exp == hfmt->exp_nan)
+  if ((unsigned long long) top_exp == hfmt->exp_nan)
     top_nan = mant_bits_set (hfmt, ufrom);
 
   /* A NaN is valid with any low part.  */
@@ -309,7 +309,7 @@ floatformat_ibm_long_double_is_valid (const struct floatformat *fmt,
 
   /* An infinity, zero or denormal requires low part 0 (positive or
      negative).  */
-  if ((unsigned long) top_exp == hfmt->exp_nan || top_exp == 0)
+  if ((unsigned long long) top_exp == hfmt->exp_nan || top_exp == 0)
     {
       if (bot_exp != 0)
 	return 0;
@@ -421,11 +421,11 @@ mant_bits_set (const struct floatformat *fmt, const unsigned char *ufrom)
 
 /* Extract a field which starts at START and is LEN bits long.  DATA and
    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
-static unsigned long
+static unsigned long long
 get_field (const unsigned char *data, enum floatformat_byteorders order,
            unsigned int total_len, unsigned int start, unsigned int len)
 {
-  unsigned long result = 0;
+  unsigned long long result = 0;
   unsigned int cur_byte;
   int lo_bit, hi_bit, cur_bitshift = 0;
   int nextbyte = (order == floatformat_little) ? 1 : -1;
@@ -469,8 +469,8 @@ floatformat_to_double (const struct floatformat *fmt,
 {
   const unsigned char *ufrom = (const unsigned char *) from;
   double dto;
-  long exponent;
-  unsigned long mant;
+  long long exponent;
+  unsigned long long mant;
   unsigned int mant_bits, mant_off;
   int mant_bits_left;
 
@@ -484,7 +484,7 @@ floatformat_to_double (const struct floatformat *fmt,
   /* If the exponent indicates a NaN, we don't have information to
      decide what to do.  So we handle it like IEEE, except that we
      don't try to preserve the type of NaN.  FIXME.  */
-  if ((unsigned long) exponent == fmt->exp_nan)
+  if ((unsigned long long) exponent == fmt->exp_nan)
     {
       int nan = mant_bits_set (fmt, ufrom);
 
@@ -555,14 +555,14 @@ static void put_field (unsigned char *, enum floatformat_byteorders,
                        unsigned int,
                        unsigned int,
                        unsigned int,
-                       unsigned long);
+                       unsigned long long);
 
 /* Set a field which starts at START and is LEN bits long.  DATA and
    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
 static void
 put_field (unsigned char *data, enum floatformat_byteorders order,
            unsigned int total_len, unsigned int start, unsigned int len,
-           unsigned long stuff_to_put)
+           unsigned long long stuff_to_put)
 {
   unsigned int cur_byte;
   int lo_bit, hi_bit;
@@ -667,11 +667,11 @@ floatformat_from_double (const struct floatformat *fmt,
   mant_off = fmt->man_start;
   while (mant_bits_left > 0)
     {
-      unsigned long mant_long;
+      unsigned long long mant_long;
       mant_bits = mant_bits_left < 32 ? mant_bits_left : 32;
 
       mant *= 4294967296.0;
-      mant_long = (unsigned long)mant;
+      mant_long = (unsigned long long)mant;
       mant -= mant_long;
 
       /* If the integer bit is implicit, and we are not creating a
diff --git a/libiberty/getpagesize.c b/libiberty/getpagesize.c
index 1c3a263..e39a651 100644
--- a/libiberty/getpagesize.c
+++ b/libiberty/getpagesize.c
@@ -74,11 +74,11 @@ getpagesize (void)
 #ifndef SYI$_PAGE_SIZE	/* VMS V5.4 and earlier didn't have this yet */
 #define SYI$_PAGE_SIZE 4452
 #endif
-extern unsigned long lib$getsyi(const unsigned short *,...);
+extern unsigned long long lib$getsyi(const unsigned short *,...);
 
 int getpagesize (void)
 {
-  long pagsiz = 0L;
+  long long pagsiz = 0L;
   unsigned short itmcod = SYI$_PAGE_SIZE;
 
   (void) lib$getsyi (&itmcod, (void *) &pagsiz);
diff --git a/libiberty/getruntime.c b/libiberty/getruntime.c
index 7bf1c05..7627024 100644
--- a/libiberty/getruntime.c
+++ b/libiberty/getruntime.c
@@ -93,7 +93,7 @@ process started.
 
 */
 
-long
+long long
 get_run_time (void)
 {
 #if defined (HAVE_GETRUSAGE) && defined (HAVE_SYS_RESOURCE_H)
@@ -110,7 +110,7 @@ get_run_time (void)
   return (tms.tms_utime + tms.tms_stime) * (1000000 / GNU_HZ);
 #else /* ! HAVE_TIMES */
   /* Fall back on clock and hope it's correctly implemented. */
-  const long clocks_per_sec = CLOCKS_PER_SEC;
+  const long long clocks_per_sec = CLOCKS_PER_SEC;
   if (clocks_per_sec <= 1000000)
     return clock () * (1000000 / clocks_per_sec);
   else
diff --git a/libiberty/hashtab.c b/libiberty/hashtab.c
index ca39264..5fc8da3 100644
--- a/libiberty/hashtab.c
+++ b/libiberty/hashtab.c
@@ -66,7 +66,7 @@ Boston, MA 02110-1301, USA.  */
 #define CHAR_BIT 8
 #endif
 
-static unsigned int higher_prime_index (unsigned long);
+static unsigned int higher_prime_index (unsigned long long);
 static hashval_t htab_mod_1 (hashval_t, hashval_t, hashval_t, int);
 static hashval_t htab_mod (hashval_t, htab_t);
 static hashval_t htab_mod_m2 (hashval_t, htab_t);
@@ -169,7 +169,7 @@ static struct prime_ent const prime_tab[] = {
    nearest prime number which is greater than N, and near a power of two. */
 
 static unsigned int
-higher_prime_index (unsigned long n)
+higher_prime_index (unsigned long long n)
 {
   unsigned int low = 0;
   unsigned int high = sizeof(prime_tab) / sizeof(prime_tab[0]);
diff --git a/libiberty/lrealpath.c b/libiberty/lrealpath.c
index 5fe4f16..988edaa 100644
--- a/libiberty/lrealpath.c
+++ b/libiberty/lrealpath.c
@@ -112,7 +112,7 @@ lrealpath (const char *filename)
 #if defined (HAVE_REALPATH) && defined (HAVE_UNISTD_H)
   {
     /* Find out the max path size.  */
-    long path_max = pathconf ("/", _PC_PATH_MAX);
+    long long path_max = pathconf ("/", _PC_PATH_MAX);
     if (path_max > 0)
       {
 	/* PATH_MAX is bounded.  */
diff --git a/libiberty/mkstemps.c b/libiberty/mkstemps.c
index 1c20807..459bec1 100644
--- a/libiberty/mkstemps.c
+++ b/libiberty/mkstemps.c
@@ -44,7 +44,7 @@
 #ifdef __GNUC__
 __extension__ typedef unsigned long long gcc_uint64_t;
 #else
-typedef unsigned long gcc_uint64_t;
+typedef unsigned long long gcc_uint64_t;
 #endif
 
 #ifndef TMP_MAX
diff --git a/libiberty/objalloc.c b/libiberty/objalloc.c
index 72ccaab..fc26d5a 100644
--- a/libiberty/objalloc.c
+++ b/libiberty/objalloc.c
@@ -112,9 +112,9 @@ objalloc_create (void)
 /* Allocate space from an objalloc structure.  */
 
 PTR
-_objalloc_alloc (struct objalloc *o, unsigned long original_len)
+_objalloc_alloc (struct objalloc *o, unsigned long long original_len)
 {
-  unsigned long len = original_len;
+  unsigned long long len = original_len;
 
   /* We avoid confusion from zero sized objects by always allocating
      at least 1 byte.  */
diff --git a/libiberty/pex-win32.c b/libiberty/pex-win32.c
index 7cd0770..7f9fae7 100644
--- a/libiberty/pex-win32.c
+++ b/libiberty/pex-win32.c
@@ -978,7 +978,7 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)
   char const *errmsg;
   int err;
   argv++;
-  printf ("%ld\n", (long) pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, NULL, 0, 0, 1, 2, &errmsg, &err));
+  printf ("%ld\n", (long long) pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, NULL, 0, 0, 1, 2, &errmsg, &err));
   exit (0);
 }
 #endif
diff --git a/libiberty/random.c b/libiberty/random.c
index b1d3c6c..f04e270 100644
--- a/libiberty/random.c
+++ b/libiberty/random.c
@@ -64,8 +64,8 @@ control over the state of the random number generator.
 
 #else
 
-#define	ULONG_MAX  ((unsigned long)(~0L))     /* 0xFFFFFFFF for 32-bits */
-#define	LONG_MAX   ((long)(ULONG_MAX >> 1))   /* 0x7FFFFFFF for 32-bits*/
+#define	ULONG_MAX  ((unsigned long long)(~0L))     /* 0xFFFFFFFF for 32-bits */
+#define	LONG_MAX   ((long long)(ULONG_MAX >> 1))   /* 0x7FFFFFFF for 32-bits*/
 
 #ifdef __STDC__
 #  define PTR void *
@@ -81,7 +81,7 @@ control over the state of the random number generator.
 
 #endif
 
-long int random (void);
+long long int random (void);
 
 /* An improved random number generation package.  In addition to the standard
    rand()/srand() like interface, this package also has a special state info
@@ -174,7 +174,7 @@ static int seps[MAX_TYPES] = { SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 };
    position of the rear pointer is just
 	(MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3.  */
 
-static long int randtbl[DEG_3 + 1] =
+static long long int randtbl[DEG_3 + 1] =
   { TYPE_3,
       0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342, 
       0xde3b81e0, 0xdf0a6fb5, 0xf103bc02, 0x48f340fb, 
@@ -196,8 +196,8 @@ static long int randtbl[DEG_3 + 1] =
    in the initialization of randtbl) because the state table pointer is set
    to point to randtbl[1] (as explained below).)  */
 
-static long int *fptr = &randtbl[SEP_3 + 1];
-static long int *rptr = &randtbl[1];
+static long long int *fptr = &randtbl[SEP_3 + 1];
+static long long int *rptr = &randtbl[1];
 
 
 
@@ -211,13 +211,13 @@ static long int *rptr = &randtbl[1];
    indexing every time to find the address of the last element to see if
    the front and rear pointers have wrapped.  */
 
-static long int *state = &randtbl[1];
+static long long int *state = &randtbl[1];
 
 static int rand_type = TYPE_3;
 static int rand_deg = DEG_3;
 static int rand_sep = SEP_3;
 
-static long int *end_ptr = &randtbl[sizeof(randtbl) / sizeof(randtbl[0])];
+static long long int *end_ptr = &randtbl[sizeof(randtbl) / sizeof(randtbl[0])];
 
 /* Initialize the random number generator based on the given seed.  If the
    type is the trivial no-state-information type, just remember the seed.
@@ -233,7 +233,7 @@ srandom (unsigned int x)
   state[0] = x;
   if (rand_type != TYPE_0)
     {
-      register long int i;
+      register long long int i;
       for (i = 1; i < rand_deg; ++i)
 	state[i] = (1103515145 * state[i - 1]) + 12345;
       fptr = &state[rand_sep];
@@ -255,7 +255,7 @@ srandom (unsigned int x)
    setstate so that it doesn't matter when initstate is called.
    Returns a pointer to the old state.  */
 PTR
-initstate (unsigned int seed, PTR arg_state, unsigned long n)
+initstate (unsigned int seed, PTR arg_state, unsigned long long n)
 {
   PTR ostate = (PTR) &state[-1];
 
@@ -299,7 +299,7 @@ initstate (unsigned int seed, PTR arg_state, unsigned long n)
       rand_sep = SEP_4;
     }
 
-  state = &((long int *) arg_state)[1];	/* First location.  */
+  state = &((long long int *) arg_state)[1];	/* First location.  */
   /* Must set END_PTR before srandom.  */
   end_ptr = &state[rand_deg];
   srandom(seed);
@@ -323,7 +323,7 @@ initstate (unsigned int seed, PTR arg_state, unsigned long n)
 PTR
 setstate (PTR arg_state)
 {
-  register long int *new_state = (long int *) arg_state;
+  register long long int *new_state = (long long int *) arg_state;
   register int type = new_state[0] % MAX_TYPES;
   register int rear = new_state[0] / MAX_TYPES;
   PTR ostate = (PTR) &state[-1];
@@ -373,7 +373,7 @@ setstate (PTR arg_state)
    rear pointers can't wrap on the same call by not testing the rear
    pointer if the front one has wrapped.  Returns a 31-bit random number.  */
 
-long int
+long long int
 random (void)
 {
   if (rand_type == TYPE_0)
@@ -383,7 +383,7 @@ random (void)
     }
   else
     {
-      long int i;
+      long long int i;
       *fptr += *rptr;
       /* Chucking least random bit.  */
       i = (*fptr >> 1) & LONG_MAX;
diff --git a/libiberty/regex.c b/libiberty/regex.c
index b3dd5b0..ae85ca5 100644
--- a/libiberty/regex.c
+++ b/libiberty/regex.c
@@ -49,7 +49,7 @@
 # else
 /* We need this for `regex.h', and perhaps for the Emacs include files.  */
 #  include <sys/types.h>
-#  define PTR_INT_TYPE long
+#  define PTR_INT_TYPE long long
 # endif
 
 # define WIDE_CHAR_SUPPORT (HAVE_WCTYPE_H && HAVE_WCHAR_H && HAVE_BTOWC)
@@ -301,7 +301,7 @@ init_syntax_once (void)
 
 /* Integer type for pointers.  */
 # if !defined _LIBC && !defined HAVE_UINTPTR_T
-typedef unsigned long int uintptr_t;
+typedef unsigned long long int uintptr_t;
 # endif
 
 /* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
@@ -824,7 +824,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 #  ifdef _LIBC
       printf ("%td:\t", p - start);
 #  else
-      printf ("%ld:\t", (long int) (p - start));
+      printf ("%ld:\t", (long long int) (p - start));
 #  endif
 
       switch ((re_opcode_t) *p++)
@@ -850,7 +850,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 	  printf ("/exactn_bin/%d", mcnt);
           do
 	    {
-	      printf("/%lx", (long int) *p++);
+	      printf("/%lx", (long long int) *p++);
             }
           while (--mcnt);
           break;
@@ -858,16 +858,16 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 
 	case start_memory:
           mcnt = *p++;
-          printf ("/start_memory/%d/%ld", mcnt, (long int) *p++);
+          printf ("/start_memory/%d/%ld", mcnt, (long long int) *p++);
           break;
 
 	case stop_memory:
           mcnt = *p++;
-	  printf ("/stop_memory/%d/%ld", mcnt, (long int) *p++);
+	  printf ("/stop_memory/%d/%ld", mcnt, (long long int) *p++);
           break;
 
 	case duplicate:
-	  printf ("/duplicate/%ld", (long int) *p++);
+	  printf ("/duplicate/%ld", (long long int) *p++);
 	  break;
 
 	case anychar:
@@ -885,7 +885,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 	    p += 5;
 	    length = *workp++; /* the length of char_classes */
 	    for (i=0 ; i<length ; i++)
-	      printf("[:%lx:]", (long int) *p++);
+	      printf("[:%lx:]", (long long int) *p++);
 	    length = *workp++; /* the length of collating_symbol */
 	    for (i=0 ; i<length ;)
 	      {
@@ -970,7 +970,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 #  ifdef _LIBC
   	  printf ("/on_failure_jump to %td", p + mcnt - start);
 #  else
-  	  printf ("/on_failure_jump to %ld", (long int) (p + mcnt - start));
+  	  printf ("/on_failure_jump to %ld", (long long int) (p + mcnt - start));
 #  endif
           break;
 
@@ -980,7 +980,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
   	  printf ("/on_failure_keep_string_jump to %td", p + mcnt - start);
 #  else
   	  printf ("/on_failure_keep_string_jump to %ld",
-		  (long int) (p + mcnt - start));
+		  (long long int) (p + mcnt - start));
 #  endif
           break;
 
@@ -989,7 +989,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 #  ifdef _LIBC
   	  printf ("/dummy_failure_jump to %td", p + mcnt - start);
 #  else
-  	  printf ("/dummy_failure_jump to %ld", (long int) (p + mcnt - start));
+  	  printf ("/dummy_failure_jump to %ld", (long long int) (p + mcnt - start));
 #  endif
           break;
 
@@ -1002,7 +1002,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 #  ifdef _LIBC
   	  printf ("/maybe_pop_jump to %td", p + mcnt - start);
 #  else
-  	  printf ("/maybe_pop_jump to %ld", (long int) (p + mcnt - start));
+  	  printf ("/maybe_pop_jump to %ld", (long long int) (p + mcnt - start));
 #  endif
 	  break;
 
@@ -1011,7 +1011,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 #  ifdef _LIBC
   	  printf ("/pop_failure_jump to %td", p + mcnt - start);
 #  else
-  	  printf ("/pop_failure_jump to %ld", (long int) (p + mcnt - start));
+  	  printf ("/pop_failure_jump to %ld", (long long int) (p + mcnt - start));
 #  endif
 	  break;
 
@@ -1020,7 +1020,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 #  ifdef _LIBC
   	  printf ("/jump_past_alt to %td", p + mcnt - start);
 #  else
-  	  printf ("/jump_past_alt to %ld", (long int) (p + mcnt - start));
+  	  printf ("/jump_past_alt to %ld", (long long int) (p + mcnt - start));
 #  endif
 	  break;
 
@@ -1029,7 +1029,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 #  ifdef _LIBC
   	  printf ("/jump to %td", p + mcnt - start);
 #  else
-  	  printf ("/jump to %ld", (long int) (p + mcnt - start));
+  	  printf ("/jump to %ld", (long long int) (p + mcnt - start));
 #  endif
 	  break;
 
@@ -1041,7 +1041,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 	  printf ("/succeed_n to %td, %d times", p1 - start, mcnt2);
 #  else
 	  printf ("/succeed_n to %ld, %d times",
-		  (long int) (p1 - start), mcnt2);
+		  (long long int) (p1 - start), mcnt2);
 #  endif
           break;
 
@@ -1060,7 +1060,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 	  printf ("/set_number_at location %td to %d", p1 - start, mcnt2);
 #  else
 	  printf ("/set_number_at location %ld to %d",
-		  (long int) (p1 - start), mcnt2);
+		  (long long int) (p1 - start), mcnt2);
 #  endif
           break;
 
@@ -1123,7 +1123,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
           break;
 
         default:
-          printf ("?%ld", (long int) *(p-1));
+          printf ("?%ld", (long long int) *(p-1));
 	}
 
       putchar ('\n');
@@ -1132,7 +1132,7 @@ PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
 #  ifdef _LIBC
   printf ("%td:\tend of pattern.\n", p - start);
 #  else
-  printf ("%ld:\tend of pattern.\n", (long int) (p - start));
+  printf ("%ld:\tend of pattern.\n", (long long int) (p - start));
 #  endif
 }
 
@@ -1156,7 +1156,7 @@ PREFIX(print_compiled_pattern) (struct re_pattern_buffer *bufp)
 #  ifdef _LIBC
   printf ("re_nsub: %Zd\t", bufp->re_nsub);
 #  else
-  printf ("re_nsub: %ld\t", (long int) bufp->re_nsub);
+  printf ("re_nsub: %ld\t", (long long int) bufp->re_nsub);
 #  endif
   printf ("regs_alloc: %d\t", bufp->regs_allocated);
   printf ("can_be_null: %d\t", bufp->can_be_null);
@@ -1430,16 +1430,16 @@ static const char *re_error_msgid[] =
 #   if defined MATCH_MAY_ALLOCATE
 /* 4400 was enough to cause a crash on Alpha OSF/1,
    whose default stack limit is 2mb.  */
-long int re_max_failures = 4000;
+long long int re_max_failures = 4000;
 #   else
-long int re_max_failures = 2000;
+long long int re_max_failures = 2000;
 #   endif
 #  endif
 
 union PREFIX(fail_stack_elt)
 {
   UCHAR_T *pointer;
-  long int integer;
+  long long int integer;
 };
 
 typedef union PREFIX(fail_stack_elt) PREFIX(fail_stack_elt_t);
@@ -1447,8 +1447,8 @@ typedef union PREFIX(fail_stack_elt) PREFIX(fail_stack_elt_t);
 typedef struct
 {
   PREFIX(fail_stack_elt_t) *stack;
-  unsigned long int size;
-  unsigned long int avail;		/* Offset of next open position.  */
+  unsigned long long int size;
+  unsigned long long int avail;		/* Offset of next open position.  */
 } PREFIX(fail_stack_type);
 
 # else /* not INT_IS_16BIT */
@@ -1934,12 +1934,12 @@ static reg_errcode_t byte_compile_range (unsigned int range_start,
 /* Make sure we have at least N more bytes of space in buffer.  */
 # ifdef WCHAR
 #  define GET_BUFFER_SPACE(n)						\
-    while (((unsigned long)b - (unsigned long)COMPILED_BUFFER_VAR	\
+    while (((unsigned long long)b - (unsigned long long)COMPILED_BUFFER_VAR	\
             + (n)*sizeof(CHAR_T)) > bufp->allocated)			\
       EXTEND_BUFFER ()
 # else /* BYTE */
 #  define GET_BUFFER_SPACE(n)						\
-    while ((unsigned long) (b - bufp->buffer + (n)) > bufp->allocated)	\
+    while ((unsigned long long) (b - bufp->buffer + (n)) > bufp->allocated)	\
       EXTEND_BUFFER ()
 # endif /* WCHAR */
 
@@ -2113,7 +2113,7 @@ typedef unsigned regnum_t;
 /* Since offsets can go either forwards or backwards, this type needs to
    be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
 /* int may be not enough when sizeof(int) == 2.  */
-typedef long pattern_offset_t;
+typedef long long pattern_offset_t;
 
 typedef struct
 {
@@ -6160,7 +6160,7 @@ byte_re_match_2_internal (struct re_pattern_buffer *bufp,
 	    goto fail;
 
           SET_REGS_MATCHED ();
-          DEBUG_PRINT2 ("  Matched `%ld'.\n", (long int) *d);
+          DEBUG_PRINT2 ("  Matched `%ld'.\n", (long long int) *d);
           d++;
 	  break;
 
@@ -6577,7 +6577,7 @@ byte_re_match_2_internal (struct re_pattern_buffer *bufp,
            registers data structure) under the register number.  */
         case start_memory:
 	  DEBUG_PRINT3 ("EXECUTING start_memory %ld (%ld):\n",
-			(long int) *p, (long int) p[1]);
+			(long long int) *p, (long long int) p[1]);
 
           /* Find out if this group can match the empty string.  */
 	  p1 = p;		/* To send to group_match_null_string_p.  */
@@ -6626,7 +6626,7 @@ byte_re_match_2_internal (struct re_pattern_buffer *bufp,
            number, and the number of inner groups.  */
 	case stop_memory:
 	  DEBUG_PRINT3 ("EXECUTING stop_memory %ld (%ld):\n",
-			(long int) *p, (long int) p[1]);
+			(long long int) *p, (long long int) p[1]);
 
           /* We need to save the string position the last time we were at
              this close-group operator in case the group is operated
diff --git a/libiberty/simple-object-coff.c b/libiberty/simple-object-coff.c
index 3205afc..7256439 100644
--- a/libiberty/simple-object-coff.c
+++ b/libiberty/simple-object-coff.c
@@ -568,7 +568,7 @@ simple_object_coff_write_scnhdr (simple_object_write *sobj, int descriptor,
   else
     {
       snprintf ((char *) hdr + offsetof (struct external_scnhdr, s_name),
-		SCNNMLEN, "/%lu", (unsigned long) *name_offset);
+		SCNNMLEN, "/%lu", (unsigned long long) *name_offset);
       *name_offset += namelen + 1;
     }
 
diff --git a/libiberty/simple-object-common.h b/libiberty/simple-object-common.h
index 858209f..c3eaea4 100644
--- a/libiberty/simple-object-common.h
+++ b/libiberty/simple-object-common.h
@@ -180,7 +180,7 @@ simple_object_internal_write (int descriptor, off_t offset,
 #ifdef UNSIGNED_64BIT_TYPE
 __extension__ typedef UNSIGNED_64BIT_TYPE ulong_type;
 #else
-typedef unsigned long ulong_type;
+typedef unsigned long long ulong_type;
 #endif
 
 /* Fetch a big-endian 16-bit value.  */
diff --git a/libiberty/simple-object-mach-o.c b/libiberty/simple-object-mach-o.c
index cd96efd..4b9a3ce 100644
--- a/libiberty/simple-object-mach-o.c
+++ b/libiberty/simple-object-mach-o.c
@@ -677,7 +677,7 @@ simple_object_mach_o_segment (simple_object_read *sobj, off_t offset,
 	  name = &namebuf[0];
 	  if (strtab != NULL && name[0] == '_' && name[1] == '_')
 	    {
-	      unsigned long stringoffset;
+	      unsigned long long stringoffset;
 
 	      if (sscanf (name + 2, "%08lX", &stringoffset) == 1)
 		{
diff --git a/libiberty/simple-object-xcoff.c b/libiberty/simple-object-xcoff.c
index 1e3d9e0..0fd8335 100644
--- a/libiberty/simple-object-xcoff.c
+++ b/libiberty/simple-object-xcoff.c
@@ -815,7 +815,7 @@ simple_object_xcoff_write_scnhdr (simple_object_write *sobj,
   else
     {
       snprintf ((char *) hdr + offsetof (struct external_scnhdr, s_name),
-		SCNNMLEN, "/%lu", (unsigned long) *name_offset);
+		SCNNMLEN, "/%lu", (unsigned long long) *name_offset);
       *name_offset += namelen + 1;
     }
 
diff --git a/libiberty/stack-limit.c b/libiberty/stack-limit.c
index 036e3bb..8a006bc 100644
--- a/libiberty/stack-limit.c
+++ b/libiberty/stack-limit.c
@@ -44,7 +44,7 @@ Attempt to increase stack size limit to @var{pref} bytes if possible.
 #endif
 
 void
-stack_limit_increase (unsigned long pref ATTRIBUTE_UNUSED)
+stack_limit_increase (unsigned long long pref ATTRIBUTE_UNUSED)
 {
 #if defined(HAVE_SETRLIMIT) && defined(HAVE_GETRLIMIT) \
     && defined(RLIMIT_STACK) && defined(RLIM_INFINITY)
diff --git a/libiberty/strtol.c b/libiberty/strtol.c
index bde5647..2a1158c 100644
--- a/libiberty/strtol.c
+++ b/libiberty/strtol.c
@@ -69,15 +69,15 @@ extern int errno;
    constants. */
 
 #ifndef ULONG_MAX
-#define	ULONG_MAX	((unsigned long)(~0L))		/* 0xFFFFFFFF */
+#define	ULONG_MAX	((unsigned long long)(~0L))		/* 0xFFFFFFFF */
 #endif
 
 #ifndef LONG_MAX
-#define	LONG_MAX	((long)(ULONG_MAX >> 1))	/* 0x7FFFFFFF */
+#define	LONG_MAX	((long long)(ULONG_MAX >> 1))	/* 0x7FFFFFFF */
 #endif
 
 #ifndef LONG_MIN
-#define	LONG_MIN	((long)(~LONG_MAX))		/* 0x80000000 */
+#define	LONG_MIN	((long long)(~LONG_MAX))		/* 0x80000000 */
 #endif
 
 /*
@@ -86,13 +86,13 @@ extern int errno;
  * Ignores `locale' stuff.  Assumes that the upper and lower case
  * alphabets and digits are each contiguous.
  */
-long
+long long
 strtol(const char *nptr, char **endptr, register int base)
 {
 	register const char *s = nptr;
-	register unsigned long acc;
+	register unsigned long long acc;
 	register int c;
-	register unsigned long cutoff;
+	register unsigned long long cutoff;
 	register int neg = 0, any, cutlim;
 
 	/*
@@ -134,9 +134,9 @@ strtol(const char *nptr, char **endptr, register int base)
 	 * Set any if any `digits' consumed; make it negative to indicate
 	 * overflow.
 	 */
-	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
-	cutlim = cutoff % (unsigned long)base;
-	cutoff /= (unsigned long)base;
+	cutoff = neg ? -(unsigned long long)LONG_MIN : LONG_MAX;
+	cutlim = cutoff % (unsigned long long)base;
+	cutoff /= (unsigned long long)base;
 	for (acc = 0, any = 0;; c = *s++) {
 		if (ISDIGIT(c))
 			c -= '0';
diff --git a/libiberty/strtoul.c b/libiberty/strtoul.c
index ba80063..e6d331d 100644
--- a/libiberty/strtoul.c
+++ b/libiberty/strtoul.c
@@ -48,7 +48,7 @@ extern int errno;
 #include "safe-ctype.h"
 
 #ifndef ULONG_MAX
-#define	ULONG_MAX	((unsigned long)(~0L))		/* 0xFFFFFFFF */
+#define	ULONG_MAX	((unsigned long long)(~0L))		/* 0xFFFFFFFF */
 #endif
 
 /*
@@ -57,13 +57,13 @@ extern int errno;
  * Ignores `locale' stuff.  Assumes that the upper and lower case
  * alphabets and digits are each contiguous.
  */
-unsigned long
+unsigned long long
 strtoul(const char *nptr, char **endptr, register int base)
 {
 	register const char *s = nptr;
-	register unsigned long acc;
+	register unsigned long long acc;
 	register int c;
-	register unsigned long cutoff;
+	register unsigned long long cutoff;
 	register int neg = 0, any, cutlim;
 
 	/*
@@ -85,8 +85,8 @@ strtoul(const char *nptr, char **endptr, register int base)
 	}
 	if (base == 0)
 		base = c == '0' ? 8 : 10;
-	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
-	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
+	cutoff = (unsigned long long)ULONG_MAX / (unsigned long long)base;
+	cutlim = (unsigned long long)ULONG_MAX % (unsigned long long)base;
 	for (acc = 0, any = 0;; c = *s++) {
 		if (ISDIGIT(c))
 			c -= '0';
diff --git a/libiberty/vprintf-support.c b/libiberty/vprintf-support.c
index c1057dd..90e1c7b 100644
--- a/libiberty/vprintf-support.c
+++ b/libiberty/vprintf-support.c
@@ -33,7 +33,7 @@ Floor, Boston, MA 02110-1301, USA.  */
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #else
-extern unsigned long strtoul ();
+extern unsigned long long strtoul ();
 #endif
 #include "libiberty.h"
 
diff --git a/libiberty/vsnprintf.c b/libiberty/vsnprintf.c
index 481156a..ca128d3 100644
--- a/libiberty/vsnprintf.c
+++ b/libiberty/vsnprintf.c
@@ -73,7 +73,7 @@ vsnprintf (char *s, size_t n, const char *format, va_list ap)
   result = strlen (buf);
   if (n > 0)
     {
-      if ((long) n > result)
+      if ((long long) n > result)
 	memcpy (s, buf, result+1);
       else
         {
diff --git a/libiberty/xmalloc.c b/libiberty/xmalloc.c
index d54022c..7e3815a 100644
--- a/libiberty/xmalloc.c
+++ b/libiberty/xmalloc.c
@@ -127,12 +127,12 @@ xmalloc_failed (size_t size)
   fprintf (stderr,
 	   "\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\n",
 	   name, *name ? ": " : "",
-	   (unsigned long) size, (unsigned long) allocated);
+	   (unsigned long long) size, (unsigned long long) allocated);
 #else /* HAVE_SBRK */
   fprintf (stderr,
 	   "\n%s%sout of memory allocating %lu bytes\n",
 	   name, *name ? ": " : "",
-	   (unsigned long) size);
+	   (unsigned long long) size);
 #endif /* HAVE_SBRK */
   xexit (1);
 }  
diff --git a/opcodes/aarch64-dis.c b/opcodes/aarch64-dis.c
index f7092b0..f704212 100644
--- a/opcodes/aarch64-dis.c
+++ b/opcodes/aarch64-dis.c
@@ -3241,7 +3241,7 @@ print_insn_aarch64 (bfd_vma pc,
 			    aarch64_operand_error *);
   bfd_boolean   found = FALSE;
   unsigned int	size = 4;
-  unsigned long	data;
+  unsigned long long	data;
   aarch64_operand_error errors;
 
   if (info->disassembler_options)
diff --git a/opcodes/arc-dis.c b/opcodes/arc-dis.c
index feb4ca8..3cdc6d9 100644
--- a/opcodes/arc-dis.c
+++ b/opcodes/arc-dis.c
@@ -1036,7 +1036,7 @@ print_insn_arc (bfd_vma memaddr,
       && !(info->section->flags & SEC_CODE))
     {
       /* Data section.  */
-      unsigned long data;
+      unsigned long long data;
 
       data = bfd_get_bits (buffer, size * 8,
 			   info->display_endian == BFD_ENDIAN_BIG);
diff --git a/opcodes/arc-dis.h b/opcodes/arc-dis.h
index c788856..0b2ab76 100644
--- a/opcodes/arc-dis.h
+++ b/opcodes/arc-dis.h
@@ -103,7 +103,7 @@ enum arc_operand_kind
 struct arc_insn_operand
 {
   /* Operand value as encoded in instruction.  */
-  unsigned long value;
+  unsigned long long value;
 
   enum arc_operand_kind kind;
 };
diff --git a/opcodes/arc-ext.c b/opcodes/arc-ext.c
index d792079..3aea82d 100644
--- a/opcodes/arc-ext.c
+++ b/opcodes/arc-ext.c
@@ -53,7 +53,7 @@
 
 struct ExtAuxRegister
 {
-  long			  address;
+  long long			  address;
   char *		  name;
   struct ExtAuxRegister * next;
 };
@@ -90,7 +90,7 @@ static struct arcExtMap arc_extension_map;
 
 static void
 create_map (unsigned char *block,
-	    unsigned long length)
+	    unsigned long long length)
 {
   unsigned char *p = block;
 
@@ -406,7 +406,7 @@ arcExtMap_condCodeName (int code)
 /* Get the name of an extension auxiliary register.  */
 
 const char *
-arcExtMap_auxRegName (long address)
+arcExtMap_auxRegName (long long address)
 {
   /* Walk the list of auxiliary register names and find the name.  */
   struct ExtAuxRegister *r;
diff --git a/opcodes/arc-ext.h b/opcodes/arc-ext.h
index 50b2ecb..74453b9 100644
--- a/opcodes/arc-ext.h
+++ b/opcodes/arc-ext.h
@@ -125,7 +125,7 @@ extern void build_ARC_extmap (bfd *);
 /* Accessor functions.  */
 extern enum ExtReadWrite arcExtMap_coreReadWrite (int);
 extern const char * arcExtMap_coreRegName (int);
-extern const char * arcExtMap_auxRegName (long);
+extern const char * arcExtMap_auxRegName (long long);
 extern const char * arcExtMap_condCodeName (int);
 extern const extInstruction_t *arcExtMap_insn (int, unsigned long long);
 extern struct arc_opcode *arcExtMap_genOpcode (const extInstruction_t *,
diff --git a/opcodes/arm-dis.c b/opcodes/arm-dis.c
index 8bcec13..5ead075 100644
--- a/opcodes/arm-dis.c
+++ b/opcodes/arm-dis.c
@@ -70,8 +70,8 @@ struct arm_private_data
 struct opcode32
 {
   arm_feature_set arch;		/* Architecture defining this insn.  */
-  unsigned long value;		/* If arch is 0 then value is a sentinel.  */
-  unsigned long mask;		/* Recognise insn if (op & mask) == value.  */
+  unsigned long long value;		/* If arch is 0 then value is a sentinel.  */
+  unsigned long long mask;		/* Recognise insn if (op & mask) == value.  */
   const char *  assembler;	/* How to disassemble this insn.  */
 };
 
@@ -3292,11 +3292,11 @@ static bfd_vma ifthen_address;
 
 static const char *
 arm_decode_bitfield (const char *ptr,
-		     unsigned long insn,
-		     unsigned long *valuep,
+		     unsigned long long insn,
+		     unsigned long long *valuep,
 		     int *widthp)
 {
-  unsigned long value = 0;
+  unsigned long long value = 0;
   int width = 0;
 
   do
@@ -3325,7 +3325,7 @@ arm_decode_bitfield (const char *ptr,
 }
 
 static void
-arm_decode_shift (long given, fprintf_ftype func, void *stream,
+arm_decode_shift (long long given, fprintf_ftype func, void *stream,
 		  bfd_boolean print_shift)
 {
   func (stream, "%s", arm_regnames[given & 0xf]);
@@ -3380,14 +3380,14 @@ arm_decode_shift (long given, fprintf_ftype func, void *stream,
 static bfd_boolean
 print_insn_coprocessor (bfd_vma pc,
 			struct disassemble_info *info,
-			long given,
+			long long given,
 			bfd_boolean thumb)
 {
   const struct opcode32 *insn;
   void *stream = info->stream;
   fprintf_ftype func = info->fprintf_func;
-  unsigned long mask;
-  unsigned long value = 0;
+  unsigned long long mask;
+  unsigned long long value = 0;
   int cond;
   int cp_num;
   struct arm_private_data *private_data = info->private_data;
@@ -3397,9 +3397,9 @@ print_insn_coprocessor (bfd_vma pc,
 
   for (insn = coprocessor_opcodes; insn->assembler; insn++)
     {
-      unsigned long u_reg = 16;
+      unsigned long long u_reg = 16;
       bfd_boolean is_unpredictable = FALSE;
-      signed long value_in_comment = 0;
+      signed long long value_in_comment = 0;
       const char *c;
 
       if (ARM_FEATURE_ZERO (insn->arch))
@@ -3998,7 +3998,7 @@ print_insn_coprocessor (bfd_vma pc,
 
 		  case 'i':
 		    {
-		      long imm5;
+		      long long imm5;
 		      imm5 = ((given & 0x100) >> 4) | (given & 0xf);
 		      func (stream, "%ld", (imm5 == 0) ? 32 : imm5);
 		    }
@@ -4029,8 +4029,8 @@ print_insn_coprocessor (bfd_vma pc,
    offset as a hexadecimal value in a comment at the end of the
    line of disassembly.  */
 
-static signed long
-print_arm_address (bfd_vma pc, struct disassemble_info *info, long given)
+static signed long long
+print_arm_address (bfd_vma pc, struct disassemble_info *info, long long given)
 {
   void *stream = info->stream;
   fprintf_ftype func = info->fprintf_func;
@@ -4116,7 +4116,7 @@ print_arm_address (bfd_vma pc, struct disassemble_info *info, long given)
 	offset = -offset;
     }
 
-  return (signed long) offset;
+  return (signed long long) offset;
 }
 
 /* Print one neon instruction on INFO->STREAM.
@@ -4124,7 +4124,7 @@ print_arm_address (bfd_vma pc, struct disassemble_info *info, long given)
    recognised neon instruction.  */
 
 static bfd_boolean
-print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
+print_insn_neon (struct disassemble_info *info, long long given, bfd_boolean thumb)
 {
   const struct opcode32 *insn;
   void *stream = info->stream;
@@ -4135,7 +4135,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
       if ((given & 0xef000000) == 0xef000000)
 	{
 	  /* Move bit 28 to bit 24 to translate Thumb2 to ARM encoding.  */
-	  unsigned long bit28 = given & (1 << 28);
+	  unsigned long long bit28 = given & (1 << 28);
 
 	  given &= 0x00ffffff;
 	  if (bit28)
@@ -4153,7 +4153,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
     {
       if ((given & insn->mask) == insn->value)
 	{
-	  signed long value_in_comment = 0;
+	  signed long long value_in_comment = 0;
 	  bfd_boolean is_unpredictable = FALSE;
 	  const char *c;
 
@@ -4357,7 +4357,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			int bits = 0;
 			int cmode = (given >> 8) & 0xf;
 			int op = (given >> 5) & 0x1;
-			unsigned long value = 0, hival = 0;
+			unsigned long long value = 0, hival = 0;
 			unsigned shift;
                         int size = 0;
                         int isfloat = 0;
@@ -4369,19 +4369,19 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			if (cmode < 8)
 			  {
 			    shift = (cmode >> 1) & 3;
-			    value = (unsigned long) bits << (8 * shift);
+			    value = (unsigned long long) bits << (8 * shift);
                             size = 32;
 			  }
 			else if (cmode < 12)
 			  {
 			    shift = (cmode >> 1) & 1;
-			    value = (unsigned long) bits << (8 * shift);
+			    value = (unsigned long long) bits << (8 * shift);
                             size = 16;
 			  }
 			else if (cmode < 14)
 			  {
 			    shift = (cmode & 1) + 1;
-			    value = (unsigned long) bits << (8 * shift);
+			    value = (unsigned long long) bits << (8 * shift);
 			    value |= (1ul << (8 * shift)) - 1;
                             size = 32;
 			  }
@@ -4391,7 +4391,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			      {
 				/* Bit replication into bytes.  */
 				int ix;
-				unsigned long mask;
+				unsigned long long mask;
 
 				value = 0;
                                 hival = 0;
@@ -4408,7 +4408,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
                             else
                               {
                                 /* Byte replication.  */
-                                value = (unsigned long) bits;
+                                value = (unsigned long long) bits;
                                 size = 8;
                               }
 			  }
@@ -4417,10 +4417,10 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			    /* Floating point encoding.  */
 			    int tmp;
 
-			    value = (unsigned long)  (bits & 0x7f) << 19;
-			    value |= (unsigned long) (bits & 0x80) << 24;
+			    value = (unsigned long long)  (bits & 0x7f) << 19;
+			    value |= (unsigned long long) (bits & 0x80) << 24;
 			    tmp = bits & 0x40 ? 0x3c : 0x40;
-			    value |= (unsigned long) tmp << 24;
+			    value |= (unsigned long long) tmp << 24;
                             size = 32;
                             isfloat = 1;
 			  }
@@ -4463,7 +4463,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
                               }
                             else
                               func (stream, "#%ld\t; 0x%.8lx",
-				    (long) (((value & 0x80000000L) != 0)
+				    (long long) (((value & 0x80000000L) != 0)
 					    ? value | ~0xffffffffL : value),
 				    value);
                             break;
@@ -4497,7 +4497,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 		    case '5': case '6': case '7': case '8': case '9':
 		      {
 			int width;
-			unsigned long value;
+			unsigned long long value;
 
 			c = arm_decode_bitfield (c, given, &value, &width);
 
@@ -4665,7 +4665,7 @@ data_barrier_option (unsigned option)
 /* Print one ARM instruction from PC on INFO->STREAM.  */
 
 static void
-print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
+print_insn_arm (bfd_vma pc, struct disassemble_info *info, long long given)
 {
   const struct opcode32 *insn;
   void *stream = info->stream;
@@ -4693,10 +4693,10 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 	  || (insn->mask & 0xF0000000) == 0xF0000000
 	  || (insn->mask == 0 && insn->value == 0))
 	{
-	  unsigned long u_reg = 16;
-	  unsigned long U_reg = 16;
+	  unsigned long long u_reg = 16;
+	  unsigned long long U_reg = 16;
 	  bfd_boolean is_unpredictable = FALSE;
-	  signed long value_in_comment = 0;
+	  signed long long value_in_comment = 0;
 	  const char *c;
 
 	  for (c = insn->assembler; *c; c++)
@@ -4989,7 +4989,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 			  if (name != NULL)
 			    func (stream, "%s", name);
 			  else
-			    func (stream, "(UNDEF: %lu)", (unsigned long) sysm);
+			    func (stream, "(UNDEF: %lu)", (unsigned long long) sysm);
 			}
 		      else
 			{
@@ -5031,7 +5031,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 		    case '5': case '6': case '7': case '8': case '9':
 		      {
 			int width;
-			unsigned long value;
+			unsigned long long value;
 
 			c = arm_decode_bitfield (c, given, &value, &width);
 
@@ -5126,9 +5126,9 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 			/* LSB and WIDTH fields of BFI or BFC.  The machine-
 			   language instruction encodes LSB and MSB.  */
 			{
-			  long msb = (given & 0x001f0000) >> 16;
-			  long lsb = (given & 0x00000f80) >> 7;
-			  long w = msb - lsb + 1;
+			  long long msb = (given & 0x001f0000) >> 16;
+			  long long lsb = (given & 0x00000f80) >> 7;
+			  long long w = msb - lsb + 1;
 
 			  if (w > 0)
 			    func (stream, "#%lu, #%lu", lsb, w);
@@ -5149,7 +5149,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 			  if (name != NULL)
 			    func (stream, "%s", name);
 			  else
-			    func (stream, "(UNDEF: %lu)", (unsigned long) sysm);
+			    func (stream, "(UNDEF: %lu)", (unsigned long long) sysm);
 			}
 			break;
 
@@ -5157,9 +5157,9 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 			/* 16-bit unsigned immediate from a MOVT or MOVW
 			   instruction, encoded in bits 0:11 and 15:19.  */
 			{
-			  long hi = (given & 0x000f0000) >> 4;
-			  long lo = (given & 0x00000fff);
-			  long imm16 = hi | lo;
+			  long long hi = (given & 0x000f0000) >> 4;
+			  long long lo = (given & 0x00000fff);
+			  long long imm16 = hi | lo;
 
 			  func (stream, "#%lu", imm16);
 			  value_in_comment = imm16;
@@ -5190,7 +5190,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 /* Print one 16-bit Thumb instruction from PC on INFO->STREAM.  */
 
 static void
-print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)
+print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long long given)
 {
   const struct opcode16 *insn;
   void *stream = info->stream;
@@ -5199,7 +5199,7 @@ print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)
   for (insn = thumb_opcodes; insn->assembler; insn++)
     if ((given & insn->mask) == insn->value)
       {
-	signed long value_in_comment = 0;
+	signed long long value_in_comment = 0;
 	const char *c = insn->assembler;
 
 	for (; *c; c++)
@@ -5255,7 +5255,7 @@ print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)
 
 	      case 'S':
 		{
-		  long reg;
+		  long long reg;
 
 		  reg = (given >> 3) & 0x7;
 		  if (given & (1 << 6))
@@ -5267,7 +5267,7 @@ print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)
 
 	      case 'D':
 		{
-		  long reg;
+		  long long reg;
 
 		  reg = given & 0x7;
 		  if (given & (1 << 7))
@@ -5344,7 +5344,7 @@ print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)
 		/* Right shift immediate -- bits 6..10; 1-31 print
 		   as themselves, 0 prints as 32.  */
 		{
-		  long imm = (given & 0x07c0) >> 6;
+		  long long imm = (given & 0x07c0) >> 6;
 		  if (imm == 0)
 		    imm = 32;
 		  func (stream, "#%ld", imm);
@@ -5381,17 +5381,17 @@ print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)
 			    break;
 
 			  case 'd':
-			    func (stream, "%ld", (long) reg);
+			    func (stream, "%ld", (long long) reg);
 			    value_in_comment = reg;
 			    break;
 
 			  case 'H':
-			    func (stream, "%ld", (long) (reg << 1));
+			    func (stream, "%ld", (long long) (reg << 1));
 			    value_in_comment = reg << 1;
 			    break;
 
 			  case 'W':
-			    func (stream, "%ld", (long) (reg << 2));
+			    func (stream, "%ld", (long long) (reg << 2));
 			    value_in_comment = reg << 2;
 			    break;
 
@@ -5405,7 +5405,7 @@ print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)
 			    break;
 
 			  case 'x':
-			    func (stream, "0x%04lx", (long) reg);
+			    func (stream, "0x%04lx", (long long) reg);
 			    break;
 
 			  case 'B':
@@ -5497,7 +5497,7 @@ psr_name (int regno)
 /* Print one 32-bit Thumb instruction from PC on INFO->STREAM.  */
 
 static void
-print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
+print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long long given)
 {
   const struct opcode32 *insn;
   void *stream = info->stream;
@@ -5513,7 +5513,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
     if ((given & insn->mask) == insn->value)
       {
 	bfd_boolean is_unpredictable = FALSE;
-	signed long value_in_comment = 0;
+	signed long long value_in_comment = 0;
 	const char *c = insn->assembler;
 
 	for (; *c; c++)
@@ -5957,7 +5957,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 		    if (name != NULL)
 		      func (stream, "%s", name);
 		    else
-		      func (stream, "(UNDEF: %lu)", (unsigned long) sysm);
+		      func (stream, "(UNDEF: %lu)", (unsigned long long) sysm);
 		  }
 		else
 		  {
@@ -5979,7 +5979,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 		    if (name != NULL)
 		      func (stream, "%s", name);
 		    else
-		      func (stream, "(UNDEF: %lu)", (unsigned long) sm);
+		      func (stream, "(UNDEF: %lu)", (unsigned long long) sm);
 		  }
 		else
 		  func (stream, "%s", psr_name (given & 0xff));
@@ -5989,7 +5989,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 	      case '5': case '6': case '7': case '8': case '9':
 		{
 		  int width;
-		  unsigned long val;
+		  unsigned long long val;
 
 		  c = arm_decode_bitfield (c, given, &val, &width);
 
@@ -6087,7 +6087,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 static void
 print_insn_data (bfd_vma pc ATTRIBUTE_UNUSED,
 		 struct disassemble_info *info,
-		 long given)
+		 long long given)
 {
   switch (info->bytes_per_chunk)
     {
@@ -6393,7 +6393,7 @@ mapping_symbol_for_insn (bfd_vma pc, struct disassemble_info *info,
    although it would also be less robust.  */
 
 static void
-select_arm_features (unsigned long mach,
+select_arm_features (unsigned long long mach,
 		     arm_feature_set * features)
 {
   arm_feature_set arch_fset;
@@ -6469,13 +6469,13 @@ static int
 print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
 {
   unsigned char b[4];
-  long		given;
+  long long		given;
   int           status;
   int           is_thumb = FALSE;
   int           is_data = FALSE;
   int           little_code;
   unsigned int	size = 4;
-  void	 	(*printer) (bfd_vma, struct disassemble_info *, long);
+  void	 	(*printer) (bfd_vma, struct disassemble_info *, long long);
   bfd_boolean   found = FALSE;
   struct arm_private_data *private_data;
 
diff --git a/opcodes/avr-dis.c b/opcodes/avr-dis.c
index 6a37c6e..8d4dfde 100644
--- a/opcodes/avr-dis.c
+++ b/opcodes/avr-dis.c
@@ -159,7 +159,7 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
       /* See PR binutils/2454.  Ideally we would like to display the hex
 	 value of the address only once, but this would mean recoding
 	 objdump_print_address() which would affect many targets.  */
-      sprintf (buf, "%#lx", (unsigned long) *sym_addr);
+      sprintf (buf, "%#lx", (unsigned long long) *sym_addr);
       strcpy (comment, comment_start);
       break;
 
diff --git a/opcodes/bfin-dis.c b/opcodes/bfin-dis.c
index 82bedbc..6c2bace 100644
--- a/opcodes/bfin-dis.c
+++ b/opcodes/bfin-dis.c
@@ -31,9 +31,9 @@
 #define EXIT exit
 #endif
 
-typedef long TIword;
+typedef long long TIword;
 
-#define HOST_LONG_WORD_SIZE (sizeof (long) * 8)
+#define HOST_LONG_WORD_SIZE (sizeof (long long) * 8)
 #define XFIELD(w,p,s)       (((w) & ((1 << (s)) - 1) << (p)) >> (p))
 #define SIGNEXTEND(v, n)    ((v << (HOST_LONG_WORD_SIZE - (n))) >> (HOST_LONG_WORD_SIZE - (n)))
 #define MASKBITS(val, bits) (val & ((1 << bits) - 1))
@@ -140,7 +140,7 @@ fmtconst (const_forms_t cf, TIword x, bfd_vma pc, disassemble_info *outf)
 	}
       else
 	{
-	  sprintf (buf, "%lx", (unsigned long) x);
+	  sprintf (buf, "%lx", (unsigned long long) x);
 	  return buf;
 	}
     }
@@ -167,9 +167,9 @@ fmtconst (const_forms_t cf, TIword x, bfd_vma pc, disassemble_info *outf)
   else
     {
       if (constant_formats[cf].issigned && x < 0)
-	sprintf (buf, "-0x%lx", (unsigned long)(- x));
+	sprintf (buf, "-0x%lx", (unsigned long long)(- x));
       else
-	sprintf (buf, "0x%lx", (unsigned long) x);
+	sprintf (buf, "0x%lx", (unsigned long long) x);
     }
 
   return buf;
diff --git a/opcodes/cgen-asm.c b/opcodes/cgen-asm.c
index a7347ce..4630084 100644
--- a/opcodes/cgen-asm.c
+++ b/opcodes/cgen-asm.c
@@ -196,7 +196,7 @@ const char *
 cgen_parse_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		    const char **strp,
 		    CGEN_KEYWORD *keyword_table,
-		    long *valuep)
+		    long long *valuep)
 {
   const CGEN_KEYWORD_ENTRY *ke;
   char buf[256];
@@ -256,7 +256,7 @@ const char *
 cgen_parse_signed_integer (CGEN_CPU_DESC cd,
 			   const char **strp,
 			   int opindex,
-			   long *valuep)
+			   long long *valuep)
 {
   bfd_vma value;
   enum cgen_parse_operand_result result;
@@ -296,7 +296,7 @@ const char *
 cgen_parse_unsigned_integer (CGEN_CPU_DESC cd,
 			     const char **strp,
 			     int opindex,
-			     unsigned long *valuep)
+			     unsigned long long *valuep)
 {
   bfd_vma value;
   enum cgen_parse_operand_result result;
@@ -341,7 +341,7 @@ cgen_parse_address (CGEN_CPU_DESC cd,
 /* Signed integer validation routine.  */
 
 const char *
-cgen_validate_signed_integer (long value, long min, long max)
+cgen_validate_signed_integer (long long value, long long min, long long max)
 {
   if (value < min || value > max)
     {
@@ -361,9 +361,9 @@ cgen_validate_signed_integer (long value, long min, long max)
    cases where min != 0 (and max > LONG_MAX).  */
 
 const char *
-cgen_validate_unsigned_integer (unsigned long value,
-				unsigned long min,
-				unsigned long max)
+cgen_validate_unsigned_integer (unsigned long long value,
+				unsigned long long min,
+				unsigned long long max)
 {
   if (value < min || value > max)
     {
diff --git a/opcodes/cgen-dis.c b/opcodes/cgen-dis.c
index 0de0629..8c351d7 100644
--- a/opcodes/cgen-dis.c
+++ b/opcodes/cgen-dis.c
@@ -111,7 +111,7 @@ hash_insn_array (CGEN_CPU_DESC cd,
     {
       unsigned int hash;
       char buf [4];
-      unsigned long value;
+      unsigned long long value;
       const CGEN_INSN *insn = &insns[i];
 
       if (! (* cd->dis_hash_p) (insn))
@@ -149,7 +149,7 @@ hash_insn_list (CGEN_CPU_DESC cd,
     {
       unsigned int hash;
       char buf[4];
-      unsigned long value;
+      unsigned long long value;
 
       if (! (* cd->dis_hash_p) (ilist->insn))
 	continue;
diff --git a/opcodes/cr16-dis.c b/opcodes/cr16-dis.c
index b19eed0..3cc1ff1 100644
--- a/opcodes/cr16-dis.c
+++ b/opcodes/cr16-dis.c
@@ -300,10 +300,10 @@ makelongparameter (ULONGLONG val, int start, int end)
 /* Build a mask of the instruction's 'constant' opcode,
    based on the instruction's printing flags.  */
 
-static unsigned long
+static unsigned long long
 build_mask (void)
 {
-  unsigned long mask = SBM (instruction->match_bits);
+  unsigned long long mask = SBM (instruction->match_bits);
 
   /* Adjust mask for bcond with 32-bit size instruction.  */
   if ((IS_INSN_MNEMONIC("b") && instruction->size == 2))
@@ -317,9 +317,9 @@ build_mask (void)
 int
 cr16_match_opcode (void)
 {
-  unsigned long mask;
+  unsigned long long mask;
   /* The instruction 'constant' opcode doesn't exceed 32 bits.  */
-  unsigned long doubleWord = (cr16_words[1]
+  unsigned long long doubleWord = (cr16_words[1]
 			     + (cr16_words[0] << 16)) & 0xffffffff;
 
   /* Start searching from end of instruction table.  */
@@ -592,7 +592,7 @@ print_arg (argument *a, bfd_vma memaddr, struct disassemble_info *info)
 	      sign_flag = 1;
 	      longdisp = ~(longdisp) + 1;
 	    }
-	  a->constant = (unsigned long int) (longdisp & mask);
+	  a->constant = (unsigned long long int) (longdisp & mask);
 	  func (stream, "$%d", ((int)(sign_flag ? -a->constant :
 				      a->constant)));
 	}
@@ -677,7 +677,7 @@ print_arg (argument *a, bfd_vma memaddr, struct disassemble_info *info)
 	      func (stream, "Wrong offset used in branch/bal instruction");
 	      break;
 	    }
-	  a->constant = (unsigned long int) (longdisp & mask);
+	  a->constant = (unsigned long long int) (longdisp & mask);
 	}
       /* For branch Neq instruction it is 2*offset + 2.  */
       else if (IS_INSN_TYPE (BRANCH_NEQ_INS))
@@ -796,7 +796,7 @@ get_words_at_PC (bfd_vma memaddr, struct disassemble_info *info)
     cr16_words[i] = get_word_at_PC (mem, info);
 
   cr16_allWords =  ((ULONGLONG) cr16_words[0] << 32)
-		   + ((unsigned long) cr16_words[1] << 16) + cr16_words[2];
+		   + ((unsigned long long) cr16_words[1] << 16) + cr16_words[2];
 }
 
 /* Prints the instruction by calling print_arguments after proper matching.  */
diff --git a/opcodes/cris-dis.c b/opcodes/cris-dis.c
index 3e67d01..b2ad48e 100644
--- a/opcodes/cris-dis.c
+++ b/opcodes/cris-dis.c
@@ -82,16 +82,16 @@ struct cris_disasm_data
 };
 
 /* Value of first element in switch.  */
-static long case_offset = 0;
+static long long case_offset = 0;
 
 /* How many more case-offsets to print.  */
-static long case_offset_counter = 0;
+static long long case_offset_counter = 0;
 
 /* Number of case offsets.  */
-static long no_of_case_offsets = 0;
+static long long no_of_case_offsets = 0;
 
 /* Candidate for next case_offset.  */
-static long last_immediate = 0;
+static long long last_immediate = 0;
 
 static int cris_constraint
   (const char *, unsigned, unsigned, struct cris_disasm_data *);
@@ -556,7 +556,7 @@ cris_constraint (const char *cs,
 /* Format number as hex with a leading "0x" into outbuffer.  */
 
 static char *
-format_hex (unsigned long number,
+format_hex (unsigned long long number,
 	    char *outbuffer,
 	    struct cris_disasm_data *disdata)
 {
@@ -577,13 +577,13 @@ format_hex (unsigned long number,
    unsigned (== 0).  */
 
 static char *
-format_dec (long number, char *outbuffer, int signedp)
+format_dec (long long number, char *outbuffer, int signedp)
 {
   last_immediate = number;
   if (signedp)
     sprintf (outbuffer, "%ld", number);
   else
-    sprintf (outbuffer, "%lu", (unsigned long) number);
+    sprintf (outbuffer, "%lu", (unsigned long long) number);
 
   return outbuffer + strlen (outbuffer);
 }
@@ -850,7 +850,7 @@ print_with_operands (const struct cris_opcode *opcodep,
       case 'n':
 	{
 	  /* Like N but pc-relative to the start of the insn.  */
-	  unsigned long number
+	  unsigned long long number
 	    = (buffer[2] + buffer[3] * 256 + buffer[4] * 65536
 	       + buffer[5] * 0x1000000 + addr);
 
@@ -867,7 +867,7 @@ print_with_operands (const struct cris_opcode *opcodep,
       case 'u':
 	{
 	  /* Like n but the offset is bits <3:0> in the instruction.  */
-	  unsigned long number = (buffer[0] & 0xf) * 2 + addr;
+	  unsigned long long number = (buffer[0] & 0xf) * 2 + addr;
 
 	  /* Finish off and output previous formatted bytes.  */
 	  *tp = 0;
@@ -889,7 +889,7 @@ print_with_operands (const struct cris_opcode *opcodep,
 	  {
 	    /* We're looking at [pc+], i.e. we need to output an immediate
 	       number, where the size can depend on different things.  */
-	    long number;
+	    long long number;
 	    int signedp
 	      = ((*cs == 'z' && (insn & 0x20))
 		 || opcodep->match == BDAP_QUICK_OPCODE);
@@ -1042,7 +1042,7 @@ print_with_operands (const struct cris_opcode *opcodep,
 		      {
 			/* It's [pc+].  This cannot possibly be anything
 			   but an address.  */
-			unsigned long number
+			unsigned long long number
 			  = prefix_buffer[2] + prefix_buffer[3] * 256
 			  + prefix_buffer[4] * 65536
 			  + prefix_buffer[5] * 0x1000000;
@@ -1131,7 +1131,7 @@ print_with_operands (const struct cris_opcode *opcodep,
 
 		    if ((prefix_insn & 0x400) && (prefix_insn & 15) == 15)
 		      {
-			long number;
+			long long number;
 			unsigned int nbytes;
 
 			/* It's a value.  Get its size.  */
@@ -1284,7 +1284,7 @@ print_with_operands (const struct cris_opcode *opcodep,
 
     case 'o':
       {
-	long offset = insn & 0xfe;
+	long long offset = insn & 0xfe;
 	bfd_vma target;
 
 	if (insn & 1)
@@ -1307,7 +1307,7 @@ print_with_operands (const struct cris_opcode *opcodep,
     case 'Q':
     case 'O':
       {
-	long number = buffer[0];
+	long long number = buffer[0];
 
 	if (number > 127)
 	  number = number - 256;
@@ -1461,7 +1461,7 @@ print_insn_cris_generic (bfd_vma memaddr,
 
 	  (*info->print_address_func) ((bfd_vma)
 				       ((short) (insn)
-					+ (long) (addr
+					+ (long long) (addr
 						  - (no_of_case_offsets
 						     - case_offset_counter)
 						  * 2)), info);
diff --git a/opcodes/crx-dis.c b/opcodes/crx-dis.c
index 27a2aa8..c849d49 100644
--- a/opcodes/crx-dis.c
+++ b/opcodes/crx-dis.c
@@ -37,7 +37,7 @@
 /* Set Bit Mask - a mask to set all bits starting from offset 'offs'.  */
 #define SBM(offs)  ((((1 << (32 - offs)) -1) << (offs)))
 
-typedef unsigned long dwordU;
+typedef unsigned long long dwordU;
 typedef unsigned short wordU;
 
 typedef struct
@@ -109,7 +109,7 @@ static char *getcinvstring    (unsigned);
 static void getregliststring  (int, char *, enum REG_ARG_TYPE);
 static wordU get_word_at_PC   (bfd_vma, struct disassemble_info *);
 static void get_words_at_PC   (bfd_vma, struct disassemble_info *);
-static unsigned long build_mask (void);
+static unsigned long long build_mask (void);
 static int powerof2	      (int);
 static int match_opcode	      (void);
 static void make_instruction  (void);
@@ -315,11 +315,11 @@ makelongparameter (ULONGLONG val, int start, int end)
 /* Build a mask of the instruction's 'constant' opcode,
    based on the instruction's printing flags.  */
 
-static unsigned long
+static unsigned long long
 build_mask (void)
 {
   unsigned int print_flags;
-  unsigned long mask;
+  unsigned long long mask;
 
   print_flags = instruction->flags & FMT_CRX;
   switch (print_flags)
@@ -352,10 +352,10 @@ build_mask (void)
 static int
 match_opcode (void)
 {
-  unsigned long mask;
+  unsigned long long mask;
 
   /* The instruction 'constant' opcode doewsn't exceed 32 bits.  */
-  unsigned long doubleWord = (words[1] + (words[0] << 16)) & 0xffffffff;
+  unsigned long long doubleWord = (words[1] + (words[0] << 16)) & 0xffffffff;
 
   /* Start searching from end of instruction table.  */
   instruction = &crx_instruction[NUMOPCODES - 2];
@@ -600,7 +600,7 @@ print_arg (argument *a, bfd_vma memaddr, struct disassemble_info *info)
                   sign_flag = 1;
                   longdisp = ~(longdisp) + 1;
                 }
-              a->constant = (unsigned long int) (longdisp & mask);
+              a->constant = (unsigned long long int) (longdisp & mask);
               break;
             default:
 	      func (stream,
@@ -708,7 +708,7 @@ get_words_at_PC (bfd_vma memaddr, struct disassemble_info *info)
     words[i] = get_word_at_PC (mem, info);
 
   allWords =
-    ((ULONGLONG) words[0] << 32) + ((unsigned long) words[1] << 16) + words[2];
+    ((ULONGLONG) words[0] << 32) + ((unsigned long long) words[1] << 16) + words[2];
 }
 
 /* Prints the instruction by calling print_arguments after proper matching.  */
diff --git a/opcodes/d10v-dis.c b/opcodes/d10v-dis.c
index 3cec1a5..f61fdc1 100644
--- a/opcodes/d10v-dis.c
+++ b/opcodes/d10v-dis.c
@@ -29,7 +29,7 @@
 
 static void
 print_operand (struct d10v_operand *oper,
-	       unsigned long insn,
+	       unsigned long long insn,
 	       struct d10v_opcode *op,
 	       bfd_vma memaddr,
 	       struct disassemble_info *info)
@@ -111,7 +111,7 @@ print_operand (struct d10v_operand *oper,
       /* Addresses are right-shifted by 2.  */
       if (oper->flags & OPERAND_ADDR)
 	{
-	  long max;
+	  long long max;
 	  int neg = 0;
 
 	  max = (1 << (oper->bits - 1));
@@ -148,7 +148,7 @@ print_operand (struct d10v_operand *oper,
 }
 
 static void
-dis_long (unsigned long insn,
+dis_long (unsigned long long insn,
 	  bfd_vma memaddr,
 	  struct disassemble_info *info)
 {
@@ -161,7 +161,7 @@ dis_long (unsigned long insn,
   while (op->name)
     {
       if ((op->format & LONG_OPCODE)
-	  && ((op->mask & insn) == (unsigned long) op->opcode))
+	  && ((op->mask & insn) == (unsigned long long) op->opcode))
 	{
 	  match = 1;
 	  (*info->fprintf_func) (info->stream, "%s\t", op->name);
@@ -190,7 +190,7 @@ dis_long (unsigned long insn,
 }
 
 static void
-dis_2_short (unsigned long insn,
+dis_2_short (unsigned long long insn,
 	     bfd_vma memaddr,
 	     struct disassemble_info *info,
 	     int order)
@@ -267,7 +267,7 @@ print_insn_d10v (bfd_vma memaddr, struct disassemble_info *info)
 {
   int status;
   bfd_byte buffer[4];
-  unsigned long insn;
+  unsigned long long insn;
 
   status = (*info->read_memory_func) (memaddr, buffer, 4, info);
   if (status != 0)
diff --git a/opcodes/d30v-dis.c b/opcodes/d30v-dis.c
index f878343..e39e46e 100644
--- a/opcodes/d30v-dis.c
+++ b/opcodes/d30v-dis.c
@@ -31,7 +31,7 @@
    2 if found and there are short and long forms.  */
 
 static int
-lookup_opcode (struct d30v_insn *insn, long num, int is_long)
+lookup_opcode (struct d30v_insn *insn, long long num, int is_long)
 {
   int i = 0, op_index;
   struct d30v_format *f;
@@ -268,7 +268,7 @@ print_insn (struct disassemble_info *info,
 	  /* IMM6S3 is unsigned.  */
 	  if (oper->flags & OPERAND_SIGNED || bits == 32)
 	    {
-	      long max;
+	      long long max;
 	      max = (1 << (bits - 1));
 	      if (val & max)
 		{
@@ -325,7 +325,7 @@ print_insn_d30v (bfd_vma memaddr, struct disassemble_info *info)
 {
   int status, result;
   bfd_byte buffer[12];
-  unsigned long in1, in2;
+  unsigned long long in1, in2;
   struct d30v_insn insn;
   long long num;
 
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index c8fda59..4d39dc2 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -107,7 +107,7 @@
 disassembler_ftype
 disassembler (enum bfd_architecture a,
 	      bfd_boolean big ATTRIBUTE_UNUSED,
-	      unsigned long mach ATTRIBUTE_UNUSED,
+	      unsigned long long mach ATTRIBUTE_UNUSED,
 	      bfd *abfd ATTRIBUTE_UNUSED)
 {
   disassembler_ftype disassemble;
diff --git a/opcodes/dlx-dis.c b/opcodes/dlx-dis.c
index 7278122..683ebd2 100644
--- a/opcodes/dlx-dis.c
+++ b/opcodes/dlx-dis.c
@@ -37,51 +37,51 @@
 #define FUNC(x)     (x & 0x7FF)
 
 unsigned char opc, rs1, rs2, rd;
-unsigned long imm26, imm16, func, current_insn_addr;
+unsigned long long imm26, imm16, func, current_insn_addr;
 
 /* Print one instruction from MEMADDR on INFO->STREAM.
    Return the size of the instruction (always 4 on dlx).  */
 
 static unsigned char
-dlx_get_opcode (unsigned long opcode)
+dlx_get_opcode (unsigned long long opcode)
 {
   return (unsigned char) ((opcode >> 26) & 0x3F);
 }
 
 static unsigned char
-dlx_get_rs1 (unsigned long opcode)
+dlx_get_rs1 (unsigned long long opcode)
 {
   return (unsigned char) ((opcode >> 21) & 0x1F);
 }
 
 static unsigned char
-dlx_get_rs2 (unsigned long opcode)
+dlx_get_rs2 (unsigned long long opcode)
 {
   return (unsigned char) ((opcode >> 16) & 0x1F);
 }
 
 static unsigned char
-dlx_get_rdR (unsigned long opcode)
+dlx_get_rdR (unsigned long long opcode)
 {
   return (unsigned char) ((opcode >> 11) & 0x1F);
 }
 
-static unsigned long
-dlx_get_func (unsigned long opcode)
+static unsigned long long
+dlx_get_func (unsigned long long opcode)
 {
   return (unsigned char) (opcode & 0x7FF);
 }
 
-static unsigned long
-dlx_get_imm16 (unsigned long opcode)
+static unsigned long long
+dlx_get_imm16 (unsigned long long opcode)
 {
-  return (unsigned long) (opcode & 0xFFFF);
+  return (unsigned long long) (opcode & 0xFFFF);
 }
 
-static unsigned long
-dlx_get_imm26 (unsigned long opcode)
+static unsigned long long
+dlx_get_imm26 (unsigned long long opcode)
 {
-  return (unsigned long) (opcode & 0x03FFFFFF);
+  return (unsigned long long) (opcode & 0x03FFFFFF);
 }
 
 /* Fill the opcode to the max length.  */
@@ -107,7 +107,7 @@ dlx_r_type (struct disassemble_info *info)
   int r_opc_num = (sizeof r_opc) / (sizeof (char));
   struct _r_opcode
   {
-    unsigned long func;
+    unsigned long long func;
     char *name;
   }
   dlx_r_opcode[] =
@@ -185,7 +185,7 @@ dlx_load_type (struct disassemble_info* info)
 {
   struct _load_opcode
   {
-    unsigned long opcode;
+    unsigned long long opcode;
     char *name;
   }
   dlx_load_opcode[] =
@@ -235,7 +235,7 @@ dlx_store_type (struct disassemble_info* info)
 {
   struct _store_opcode
   {
-    unsigned long opcode;
+    unsigned long long opcode;
     char *name;
   }
   dlx_store_opcode[] =
@@ -268,7 +268,7 @@ dlx_aluI_type (struct disassemble_info* info)
 {
   struct _aluI_opcode
   {
-    unsigned long opcode;
+    unsigned long long opcode;
     char *name;
   }
   dlx_aluI_opcode[] =
@@ -326,7 +326,7 @@ dlx_br_type (struct disassemble_info* info)
 {
   struct _br_opcode
   {
-    unsigned long opcode;
+    unsigned long long opcode;
     char *name;
   }
   dlx_br_opcode[] =
@@ -363,7 +363,7 @@ dlx_jmp_type (struct disassemble_info* info)
 {
   struct _jmp_opcode
   {
-    unsigned long opcode;
+    unsigned long long opcode;
     char *name;
   }
   dlx_jmp_opcode[] =
@@ -403,7 +403,7 @@ dlx_jr_type (struct disassemble_info* info)
 {
   struct _jr_opcode
   {
-    unsigned long opcode;
+    unsigned long long opcode;
     char *name;
   }
   dlx_jr_opcode[] =
@@ -436,7 +436,7 @@ print_insn_dlx (bfd_vma memaddr, struct disassemble_info* info)
 {
   bfd_byte buffer[4];
   int insn_idx;
-  unsigned long insn_word;
+  unsigned long long insn_word;
   dlx_insn dlx_insn_type[] =
   {
     dlx_r_type,
@@ -480,7 +480,7 @@ print_insn_dlx (bfd_vma memaddr, struct disassemble_info* info)
 #endif
 
   /* Scan through all the insn type and print the insn out.  */
-  current_insn_addr = (unsigned long) memaddr;
+  current_insn_addr = (unsigned long long) memaddr;
 
   for (insn_idx = 0; dlx_insn_type[insn_idx] != 0x0; insn_idx++)
     switch ((dlx_insn_type[insn_idx]) (info))
diff --git a/opcodes/epiphany-asm.c b/opcodes/epiphany-asm.c
index 6fa49c0..3632cde 100644
--- a/opcodes/epiphany-asm.c
+++ b/opcodes/epiphany-asm.c
@@ -54,7 +54,7 @@ const char *
 parse_shortregs (CGEN_CPU_DESC cd,
 		 const char ** strp,
 		 CGEN_KEYWORD * keywords,
-		 long * regno)
+		 long long * regno)
 {
   const char * errmsg;
 
@@ -71,15 +71,15 @@ parse_shortregs (CGEN_CPU_DESC cd,
 }
 
 static const char * parse_simm_not_reg (CGEN_CPU_DESC, const char **, int,
-					long *);
+					long long *);
 
 static const char *
 parse_uimm_not_reg (CGEN_CPU_DESC cd,
 		    const char ** strp,
 		    int opindex,
-		    unsigned long * valuep)
+		    unsigned long long * valuep)
 {
-  long * svalp = (void *) valuep;
+  long long * svalp = (void *) valuep;
   return parse_simm_not_reg (cd, strp, opindex, svalp);
 }
 
@@ -89,7 +89,7 @@ static const char *
 parse_simm_not_reg (CGEN_CPU_DESC cd,
 		   const char ** strp,
 		   int opindex,
-		   long * valuep)
+		   long long * valuep)
 {
   const char * errmsg;
 
@@ -116,7 +116,7 @@ parse_simm_not_reg (CGEN_CPU_DESC cd,
 
   errmsg = (sign ? cgen_parse_signed_integer (cd, strp, opindex, valuep)
 	    : cgen_parse_unsigned_integer (cd, strp, opindex,
-					  (unsigned long *) valuep));
+					  (unsigned long long *) valuep));
   if (errmsg)
     return errmsg;
 
@@ -133,7 +133,7 @@ static const char *
 parse_postindex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		 const char ** strp,
 		 int opindex ATTRIBUTE_UNUSED,
-		 unsigned long *valuep)
+		 unsigned long long *valuep)
 {
   if (**strp == '#')
     ++*strp;			/* Skip leading hashes.  */
@@ -164,7 +164,7 @@ parse_imm8 (CGEN_CPU_DESC cd,
 {
   const char * errmsg;
   enum cgen_parse_operand_result rt;
-  long dummyval;
+  long long dummyval;
 
   if (!result_type)
     result_type = &rt;
@@ -202,7 +202,7 @@ parse_imm16 (CGEN_CPU_DESC cd,
 {
   const char * errmsg;
   enum cgen_parse_operand_result rt;
-  long dummyval;
+  long long dummyval;
 
   if (!result_type)
     result_type = &rt;
@@ -281,7 +281,7 @@ parse_branch_addr (CGEN_CPU_DESC cd,
 	  char buf[20];
 	  const char * bufp = (const char *) buf;
 
-	  sprintf (buf, ".+%ld", (long) value);
+	  sprintf (buf, ".+%ld", (long long) value);
 	  errmsg = cgen_parse_address (cd, &bufp, opindex, code, &result_type,
 				       &value);
 	}
@@ -324,21 +324,21 @@ epiphany_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
     case EPIPHANY_OPERAND_DIRECTION :
-      errmsg = parse_postindex (cd, strp, EPIPHANY_OPERAND_DIRECTION, (unsigned long *) (& fields->f_addsubx));
+      errmsg = parse_postindex (cd, strp, EPIPHANY_OPERAND_DIRECTION, (unsigned long long *) (& fields->f_addsubx));
       break;
     case EPIPHANY_OPERAND_DISP11 :
-      errmsg = parse_uimm_not_reg (cd, strp, EPIPHANY_OPERAND_DISP11, (unsigned long *) (& fields->f_disp11));
+      errmsg = parse_uimm_not_reg (cd, strp, EPIPHANY_OPERAND_DISP11, (unsigned long long *) (& fields->f_disp11));
       break;
     case EPIPHANY_OPERAND_DISP3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, EPIPHANY_OPERAND_DISP3, (unsigned long *) (& fields->f_disp3));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, EPIPHANY_OPERAND_DISP3, (unsigned long long *) (& fields->f_disp3));
       break;
     case EPIPHANY_OPERAND_DPMI :
-      errmsg = parse_postindex (cd, strp, EPIPHANY_OPERAND_DPMI, (unsigned long *) (& fields->f_subd));
+      errmsg = parse_postindex (cd, strp, EPIPHANY_OPERAND_DPMI, (unsigned long long *) (& fields->f_subd));
       break;
     case EPIPHANY_OPERAND_FRD :
       errmsg = parse_shortregs (cd, strp, & epiphany_cgen_opval_gr_names, & fields->f_rd);
@@ -406,10 +406,10 @@ epiphany_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & epiphany_cgen_opval_crmesh_names, & fields->f_sd6);
       break;
     case EPIPHANY_OPERAND_SHIFT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, EPIPHANY_OPERAND_SHIFT, (unsigned long *) (& fields->f_shift));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, EPIPHANY_OPERAND_SHIFT, (unsigned long long *) (& fields->f_shift));
       break;
     case EPIPHANY_OPERAND_SIMM11 :
-      errmsg = parse_simm_not_reg (cd, strp, EPIPHANY_OPERAND_SIMM11, (long *) (& fields->f_sdisp11));
+      errmsg = parse_simm_not_reg (cd, strp, EPIPHANY_OPERAND_SIMM11, (long long *) (& fields->f_sdisp11));
       break;
     case EPIPHANY_OPERAND_SIMM24 :
       {
@@ -419,7 +419,7 @@ epiphany_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case EPIPHANY_OPERAND_SIMM3 :
-      errmsg = parse_simm_not_reg (cd, strp, EPIPHANY_OPERAND_SIMM3, (long *) (& fields->f_sdisp3));
+      errmsg = parse_simm_not_reg (cd, strp, EPIPHANY_OPERAND_SIMM3, (long long *) (& fields->f_sdisp3));
       break;
     case EPIPHANY_OPERAND_SIMM8 :
       {
@@ -444,10 +444,10 @@ epiphany_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & epiphany_cgen_opval_crmesh_names, & fields->f_sn6);
       break;
     case EPIPHANY_OPERAND_SWI_NUM :
-      errmsg = parse_uimm_not_reg (cd, strp, EPIPHANY_OPERAND_SWI_NUM, (unsigned long *) (& fields->f_trap_num));
+      errmsg = parse_uimm_not_reg (cd, strp, EPIPHANY_OPERAND_SWI_NUM, (unsigned long long *) (& fields->f_trap_num));
       break;
     case EPIPHANY_OPERAND_TRAPNUM6 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, EPIPHANY_OPERAND_TRAPNUM6, (unsigned long *) (& fields->f_trap_num));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, EPIPHANY_OPERAND_TRAPNUM6, (unsigned long long *) (& fields->f_trap_num));
       break;
 
     default :
diff --git a/opcodes/epiphany-dis.c b/opcodes/epiphany-dis.c
index d4ad501..e133c8c 100644
--- a/opcodes/epiphany-dis.c
+++ b/opcodes/epiphany-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -96,7 +96,7 @@ epiphany_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
 static void
 print_postindex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		 void * dis_info,
-		 long value,
+		 long long value,
 		 unsigned int attrs ATTRIBUTE_UNUSED,
 		 bfd_vma pc ATTRIBUTE_UNUSED,
 		 int length ATTRIBUTE_UNUSED)
@@ -108,7 +108,7 @@ print_postindex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_simm_not_reg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		    void * dis_info,
-		    long value,
+		    long long value,
 		    unsigned int attrs ATTRIBUTE_UNUSED,
 		    bfd_vma pc ATTRIBUTE_UNUSED,
 		    int length ATTRIBUTE_UNUSED)
@@ -119,7 +119,7 @@ print_simm_not_reg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_uimm_not_reg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		    void * dis_info,
-		    unsigned long value,
+		    unsigned long long value,
 		    unsigned int attrs ATTRIBUTE_UNUSED,
 		    bfd_vma pc ATTRIBUTE_UNUSED,
 		    int length ATTRIBUTE_UNUSED)
@@ -303,7 +303,7 @@ epiphany_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -339,9 +339,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -350,7 +350,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -412,7 +412,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -470,7 +470,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -489,7 +489,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -505,9 +505,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/epiphany-ibld.c b/opcodes/epiphany-ibld.c
index 37cbe39..39daff3 100644
--- a/opcodes/epiphany-ibld.c
+++ b/opcodes/epiphany-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -793,7 +793,7 @@ epiphany_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case EPIPHANY_OPERAND_SIMM24 :
       {
-        long value = fields->f_simm24;
+        long long value = fields->f_simm24;
         value = ((SI) (((value) - (pc))) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 31, 24, 32, total_length, buffer);
       }
@@ -803,7 +803,7 @@ epiphany_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case EPIPHANY_OPERAND_SIMM8 :
       {
-        long value = fields->f_simm8;
+        long long value = fields->f_simm8;
         value = ((SI) (((value) - (pc))) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 8, 32, total_length, buffer);
       }
@@ -1098,7 +1098,7 @@ epiphany_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case EPIPHANY_OPERAND_SIMM24 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 31, 24, 32, total_length, pc, & value);
         value = ((((value) << (1))) + (pc));
         fields->f_simm24 = value;
@@ -1109,7 +1109,7 @@ epiphany_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case EPIPHANY_OPERAND_SIMM8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 8, 32, total_length, pc, & value);
         value = ((((value) << (1))) + (pc));
         fields->f_simm8 = value;
diff --git a/opcodes/epiphany-opc.h b/opcodes/epiphany-opc.h
index 5fe39bb..62e8713 100644
--- a/opcodes/epiphany-opc.h
+++ b/opcodes/epiphany-opc.h
@@ -71,7 +71,7 @@ typedef enum epiphany_relax_types
 extern const char * parse_shortregs (CGEN_CPU_DESC cd,
 				     const char ** strp,
 				     CGEN_KEYWORD * keywords,
-				     long * valuep);
+				     long long * valuep);
 
 extern const char * parse_branch_addr (CGEN_CPU_DESC cd,
 				       const char ** strp,
@@ -150,68 +150,68 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_opc;
-  long f_opc_4_1;
-  long f_opc_6_3;
-  long f_opc_8_5;
-  long f_opc_19_4;
-  long f_condcode;
-  long f_secondary_ccs;
-  long f_shift;
-  long f_wordsize;
-  long f_store;
-  long f_opc_8_1;
-  long f_opc_31_32;
-  long f_simm8;
-  long f_simm24;
-  long f_sdisp3;
-  long f_disp3;
-  long f_disp8;
-  long f_imm8;
-  long f_imm_27_8;
-  long f_addsubx;
-  long f_subd;
-  long f_pm;
-  long f_rm;
-  long f_rn;
-  long f_rd;
-  long f_rm_x;
-  long f_rn_x;
-  long f_rd_x;
-  long f_dc_9_1;
-  long f_sn;
-  long f_sd;
-  long f_sn_x;
-  long f_sd_x;
-  long f_dc_7_4;
-  long f_trap_swi_9_1;
-  long f_gien_gidis_9_1;
-  long f_dc_15_3;
-  long f_dc_15_7;
-  long f_dc_15_6;
-  long f_trap_num;
-  long f_dc_20_1;
-  long f_dc_21_1;
-  long f_dc_21_2;
-  long f_dc_22_3;
-  long f_dc_22_2;
-  long f_dc_22_1;
-  long f_dc_25_6;
-  long f_dc_25_4;
-  long f_dc_25_2;
-  long f_dc_25_1;
-  long f_dc_28_1;
-  long f_dc_31_3;
-  long f_disp11;
-  long f_sdisp11;
-  long f_imm16;
-  long f_rd6;
-  long f_rn6;
-  long f_rm6;
-  long f_sd6;
-  long f_sn6;
+  long long f_nil;
+  long long f_anyof;
+  long long f_opc;
+  long long f_opc_4_1;
+  long long f_opc_6_3;
+  long long f_opc_8_5;
+  long long f_opc_19_4;
+  long long f_condcode;
+  long long f_secondary_ccs;
+  long long f_shift;
+  long long f_wordsize;
+  long long f_store;
+  long long f_opc_8_1;
+  long long f_opc_31_32;
+  long long f_simm8;
+  long long f_simm24;
+  long long f_sdisp3;
+  long long f_disp3;
+  long long f_disp8;
+  long long f_imm8;
+  long long f_imm_27_8;
+  long long f_addsubx;
+  long long f_subd;
+  long long f_pm;
+  long long f_rm;
+  long long f_rn;
+  long long f_rd;
+  long long f_rm_x;
+  long long f_rn_x;
+  long long f_rd_x;
+  long long f_dc_9_1;
+  long long f_sn;
+  long long f_sd;
+  long long f_sn_x;
+  long long f_sd_x;
+  long long f_dc_7_4;
+  long long f_trap_swi_9_1;
+  long long f_gien_gidis_9_1;
+  long long f_dc_15_3;
+  long long f_dc_15_7;
+  long long f_dc_15_6;
+  long long f_trap_num;
+  long long f_dc_20_1;
+  long long f_dc_21_1;
+  long long f_dc_21_2;
+  long long f_dc_22_3;
+  long long f_dc_22_2;
+  long long f_dc_22_1;
+  long long f_dc_25_6;
+  long long f_dc_25_4;
+  long long f_dc_25_2;
+  long long f_dc_25_1;
+  long long f_dc_28_1;
+  long long f_dc_31_3;
+  long long f_disp11;
+  long long f_sdisp11;
+  long long f_imm16;
+  long long f_rd6;
+  long long f_rn6;
+  long long f_rm6;
+  long long f_sd6;
+  long long f_sn6;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/fr30-asm.c b/opcodes/fr30-asm.c
index a52a780..d7a3b8a 100644
--- a/opcodes/fr30-asm.c
+++ b/opcodes/fr30-asm.c
@@ -75,7 +75,7 @@ static const char *
 parse_register_list (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		     const char **strp,
 		     int opindex ATTRIBUTE_UNUSED,
-		     unsigned long *valuep,
+		     unsigned long long *valuep,
 		     int high_low,   /* 0 == high, 1 == low.  */
 		     int load_store) /* 0 == load, 1 == store.  */
 {
@@ -122,7 +122,7 @@ static const char *
 parse_low_register_list_ld (CGEN_CPU_DESC cd,
 			    const char **strp,
 			    int opindex,
-			    unsigned long *valuep)
+			    unsigned long long *valuep)
 {
   return parse_register_list (cd, strp, opindex, valuep,
 			      0 /* Low.  */, 0 /* Load.  */);
@@ -132,7 +132,7 @@ static const char *
 parse_hi_register_list_ld (CGEN_CPU_DESC cd,
 			   const char **strp,
 			   int opindex,
-			   unsigned long *valuep)
+			   unsigned long long *valuep)
 {
   return parse_register_list (cd, strp, opindex, valuep,
 			      1 /* High.  */, 0 /* Load.  */);
@@ -142,7 +142,7 @@ static const char *
 parse_low_register_list_st (CGEN_CPU_DESC cd,
 			    const char **strp,
 			    int opindex,
-			    unsigned long *valuep)
+			    unsigned long long *valuep)
 {
   return parse_register_list (cd, strp, opindex, valuep,
 			      0 /* Low.  */, 1 /* Store.  */);
@@ -152,7 +152,7 @@ static const char *
 parse_hi_register_list_st (CGEN_CPU_DESC cd,
 			   const char **strp,
 			   int opindex,
-			   unsigned long *valuep)
+			   unsigned long long *valuep)
 {
   return parse_register_list (cd, strp, opindex, valuep,
 			      1 /* High.  */, 1 /* Store.  */);
@@ -184,7 +184,7 @@ fr30_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
@@ -222,37 +222,37 @@ fr30_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & fr30_cgen_opval_dr_names, & fields->f_Rs2);
       break;
     case FR30_OPERAND_CC :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_CC, (unsigned long *) (& fields->f_cc));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_CC, (unsigned long long *) (& fields->f_cc));
       break;
     case FR30_OPERAND_CCC :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_CCC, (unsigned long *) (& fields->f_ccc));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_CCC, (unsigned long long *) (& fields->f_ccc));
       break;
     case FR30_OPERAND_DIR10 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_DIR10, (unsigned long *) (& fields->f_dir10));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_DIR10, (unsigned long long *) (& fields->f_dir10));
       break;
     case FR30_OPERAND_DIR8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_DIR8, (unsigned long *) (& fields->f_dir8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_DIR8, (unsigned long long *) (& fields->f_dir8));
       break;
     case FR30_OPERAND_DIR9 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_DIR9, (unsigned long *) (& fields->f_dir9));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_DIR9, (unsigned long long *) (& fields->f_dir9));
       break;
     case FR30_OPERAND_DISP10 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_DISP10, (long *) (& fields->f_disp10));
+      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_DISP10, (long long *) (& fields->f_disp10));
       break;
     case FR30_OPERAND_DISP8 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_DISP8, (long *) (& fields->f_disp8));
+      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_DISP8, (long long *) (& fields->f_disp8));
       break;
     case FR30_OPERAND_DISP9 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_DISP9, (long *) (& fields->f_disp9));
+      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_DISP9, (long long *) (& fields->f_disp9));
       break;
     case FR30_OPERAND_I20 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_I20, (unsigned long *) (& fields->f_i20));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_I20, (unsigned long long *) (& fields->f_i20));
       break;
     case FR30_OPERAND_I32 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_I32, (unsigned long *) (& fields->f_i32));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_I32, (unsigned long long *) (& fields->f_i32));
       break;
     case FR30_OPERAND_I8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_I8, (unsigned long *) (& fields->f_i8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_I8, (unsigned long long *) (& fields->f_i8));
       break;
     case FR30_OPERAND_LABEL12 :
       {
@@ -269,40 +269,40 @@ fr30_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case FR30_OPERAND_M4 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_M4, (long *) (& fields->f_m4));
+      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_M4, (long long *) (& fields->f_m4));
       break;
     case FR30_OPERAND_PS :
       errmsg = cgen_parse_keyword (cd, strp, & fr30_cgen_opval_h_ps, & junk);
       break;
     case FR30_OPERAND_REGLIST_HI_LD :
-      errmsg = parse_hi_register_list_ld (cd, strp, FR30_OPERAND_REGLIST_HI_LD, (unsigned long *) (& fields->f_reglist_hi_ld));
+      errmsg = parse_hi_register_list_ld (cd, strp, FR30_OPERAND_REGLIST_HI_LD, (unsigned long long *) (& fields->f_reglist_hi_ld));
       break;
     case FR30_OPERAND_REGLIST_HI_ST :
-      errmsg = parse_hi_register_list_st (cd, strp, FR30_OPERAND_REGLIST_HI_ST, (unsigned long *) (& fields->f_reglist_hi_st));
+      errmsg = parse_hi_register_list_st (cd, strp, FR30_OPERAND_REGLIST_HI_ST, (unsigned long long *) (& fields->f_reglist_hi_st));
       break;
     case FR30_OPERAND_REGLIST_LOW_LD :
-      errmsg = parse_low_register_list_ld (cd, strp, FR30_OPERAND_REGLIST_LOW_LD, (unsigned long *) (& fields->f_reglist_low_ld));
+      errmsg = parse_low_register_list_ld (cd, strp, FR30_OPERAND_REGLIST_LOW_LD, (unsigned long long *) (& fields->f_reglist_low_ld));
       break;
     case FR30_OPERAND_REGLIST_LOW_ST :
-      errmsg = parse_low_register_list_st (cd, strp, FR30_OPERAND_REGLIST_LOW_ST, (unsigned long *) (& fields->f_reglist_low_st));
+      errmsg = parse_low_register_list_st (cd, strp, FR30_OPERAND_REGLIST_LOW_ST, (unsigned long long *) (& fields->f_reglist_low_st));
       break;
     case FR30_OPERAND_S10 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_S10, (long *) (& fields->f_s10));
+      errmsg = cgen_parse_signed_integer (cd, strp, FR30_OPERAND_S10, (long long *) (& fields->f_s10));
       break;
     case FR30_OPERAND_U10 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_U10, (unsigned long *) (& fields->f_u10));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_U10, (unsigned long long *) (& fields->f_u10));
       break;
     case FR30_OPERAND_U4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_U4, (unsigned long *) (& fields->f_u4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_U4, (unsigned long long *) (& fields->f_u4));
       break;
     case FR30_OPERAND_U4C :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_U4C, (unsigned long *) (& fields->f_u4c));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_U4C, (unsigned long long *) (& fields->f_u4c));
       break;
     case FR30_OPERAND_U8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_U8, (unsigned long *) (& fields->f_u8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_U8, (unsigned long long *) (& fields->f_u8));
       break;
     case FR30_OPERAND_UDISP6 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_UDISP6, (unsigned long *) (& fields->f_udisp6));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FR30_OPERAND_UDISP6, (unsigned long long *) (& fields->f_udisp6));
       break;
 
     default :
diff --git a/opcodes/fr30-dis.c b/opcodes/fr30-dis.c
index 6a60eef..00dd6e1 100644
--- a/opcodes/fr30-dis.c
+++ b/opcodes/fr30-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,15 +54,15 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
 /* -- dis.c */
 static void
 print_register_list (void * dis_info,
-		     long value,
-		     long offset,
+		     long long value,
+		     long long offset,
 		     int load_store) /* 0 == load, 1 == store.  */
 {
   disassemble_info *info = dis_info;
@@ -99,7 +99,7 @@ print_register_list (void * dis_info,
 static void
 print_hi_register_list_ld (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 			   void * dis_info,
-			   long value,
+			   long long value,
 			   unsigned int attrs ATTRIBUTE_UNUSED,
 			   bfd_vma pc ATTRIBUTE_UNUSED,
 			   int length ATTRIBUTE_UNUSED)
@@ -110,7 +110,7 @@ print_hi_register_list_ld (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_low_register_list_ld (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 			    void * dis_info,
-			    long value,
+			    long long value,
 			    unsigned int attrs ATTRIBUTE_UNUSED,
 			    bfd_vma pc ATTRIBUTE_UNUSED,
 			    int length ATTRIBUTE_UNUSED)
@@ -121,7 +121,7 @@ print_low_register_list_ld (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_hi_register_list_st (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 			   void * dis_info,
-			   long value,
+			   long long value,
 			   unsigned int attrs ATTRIBUTE_UNUSED,
 			   bfd_vma pc ATTRIBUTE_UNUSED,
 			   int length ATTRIBUTE_UNUSED)
@@ -132,7 +132,7 @@ print_hi_register_list_st (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_low_register_list_st (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 			    void * dis_info,
-			    long value,
+			    long long value,
 			    unsigned int attrs ATTRIBUTE_UNUSED,
 			    bfd_vma pc ATTRIBUTE_UNUSED,
 			    int length ATTRIBUTE_UNUSED)
@@ -143,7 +143,7 @@ print_low_register_list_st (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_m4 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	  void * dis_info,
-	  long value,
+	  long long value,
 	  unsigned int attrs ATTRIBUTE_UNUSED,
 	  bfd_vma pc ATTRIBUTE_UNUSED,
 	  int length ATTRIBUTE_UNUSED)
@@ -324,7 +324,7 @@ fr30_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -360,9 +360,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -371,7 +371,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -433,7 +433,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -491,7 +491,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -510,7 +510,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -526,9 +526,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/fr30-ibld.c b/opcodes/fr30-ibld.c
index 25d0e07..57000b9 100644
--- a/opcodes/fr30-ibld.c
+++ b/opcodes/fr30-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -611,7 +611,7 @@ fr30_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_DIR10 :
       {
-        long value = fields->f_dir10;
+        long long value = fields->f_dir10;
         value = ((USI) (value) >> (2));
         errmsg = insert_normal (cd, value, 0, 0, 8, 8, 16, total_length, buffer);
       }
@@ -621,14 +621,14 @@ fr30_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_DIR9 :
       {
-        long value = fields->f_dir9;
+        long long value = fields->f_dir9;
         value = ((USI) (value) >> (1));
         errmsg = insert_normal (cd, value, 0, 0, 8, 8, 16, total_length, buffer);
       }
       break;
     case FR30_OPERAND_DISP10 :
       {
-        long value = fields->f_disp10;
+        long long value = fields->f_disp10;
         value = ((SI) (value) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 4, 8, 16, total_length, buffer);
       }
@@ -638,7 +638,7 @@ fr30_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_DISP9 :
       {
-        long value = fields->f_disp9;
+        long long value = fields->f_disp9;
         value = ((SI) (value) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 4, 8, 16, total_length, buffer);
       }
@@ -665,21 +665,21 @@ fr30_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_LABEL12 :
       {
-        long value = fields->f_rel12;
+        long long value = fields->f_rel12;
         value = ((SI) (((value) - (((pc) + (2))))) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 5, 11, 16, total_length, buffer);
       }
       break;
     case FR30_OPERAND_LABEL9 :
       {
-        long value = fields->f_rel9;
+        long long value = fields->f_rel9;
         value = ((SI) (((value) - (((pc) + (2))))) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 16, total_length, buffer);
       }
       break;
     case FR30_OPERAND_M4 :
       {
-        long value = fields->f_m4;
+        long long value = fields->f_m4;
         value = ((value) & (15));
         errmsg = insert_normal (cd, value, 0, 0, 8, 4, 16, total_length, buffer);
       }
@@ -700,14 +700,14 @@ fr30_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_S10 :
       {
-        long value = fields->f_s10;
+        long long value = fields->f_s10;
         value = ((SI) (value) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 8, 8, 16, total_length, buffer);
       }
       break;
     case FR30_OPERAND_U10 :
       {
-        long value = fields->f_u10;
+        long long value = fields->f_u10;
         value = ((USI) (value) >> (2));
         errmsg = insert_normal (cd, value, 0, 0, 8, 8, 16, total_length, buffer);
       }
@@ -723,7 +723,7 @@ fr30_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_UDISP6 :
       {
-        long value = fields->f_udisp6;
+        long long value = fields->f_udisp6;
         value = ((USI) (value) >> (2));
         errmsg = insert_normal (cd, value, 0, 0, 8, 4, 16, total_length, buffer);
       }
@@ -810,7 +810,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_DIR10 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 8, 16, total_length, pc, & value);
         value = ((value) << (2));
         fields->f_dir10 = value;
@@ -821,7 +821,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_DIR9 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 8, 16, total_length, pc, & value);
         value = ((value) << (1));
         fields->f_dir9 = value;
@@ -829,7 +829,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_DISP10 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 4, 8, 16, total_length, pc, & value);
         value = ((value) << (2));
         fields->f_disp10 = value;
@@ -840,7 +840,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_DISP9 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 4, 8, 16, total_length, pc, & value);
         value = ((value) << (1));
         fields->f_disp9 = value;
@@ -865,7 +865,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_LABEL12 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 5, 11, 16, total_length, pc, & value);
         value = ((((value) << (1))) + (((pc) + (2))));
         fields->f_rel12 = value;
@@ -873,7 +873,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_LABEL9 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 16, total_length, pc, & value);
         value = ((((value) << (1))) + (((pc) + (2))));
         fields->f_rel9 = value;
@@ -881,7 +881,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_M4 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 4, 16, total_length, pc, & value);
         value = ((value) | (-16));
         fields->f_m4 = value;
@@ -903,7 +903,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_S10 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 8, 8, 16, total_length, pc, & value);
         value = ((value) << (2));
         fields->f_s10 = value;
@@ -911,7 +911,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_U10 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 8, 16, total_length, pc, & value);
         value = ((value) << (2));
         fields->f_u10 = value;
@@ -928,7 +928,7 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FR30_OPERAND_UDISP6 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 4, 16, total_length, pc, & value);
         value = ((value) << (2));
         fields->f_udisp6 = value;
diff --git a/opcodes/fr30-opc.h b/opcodes/fr30-opc.h
index 395bfc5..b698802 100644
--- a/opcodes/fr30-opc.h
+++ b/opcodes/fr30-opc.h
@@ -95,48 +95,48 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_op1;
-  long f_op2;
-  long f_op3;
-  long f_op4;
-  long f_op5;
-  long f_cc;
-  long f_ccc;
-  long f_Rj;
-  long f_Ri;
-  long f_Rs1;
-  long f_Rs2;
-  long f_Rjc;
-  long f_Ric;
-  long f_CRj;
-  long f_CRi;
-  long f_u4;
-  long f_u4c;
-  long f_i4;
-  long f_m4;
-  long f_u8;
-  long f_i8;
-  long f_i20_4;
-  long f_i20_16;
-  long f_i20;
-  long f_i32;
-  long f_udisp6;
-  long f_disp8;
-  long f_disp9;
-  long f_disp10;
-  long f_s10;
-  long f_u10;
-  long f_rel9;
-  long f_dir8;
-  long f_dir9;
-  long f_dir10;
-  long f_rel12;
-  long f_reglist_hi_st;
-  long f_reglist_low_st;
-  long f_reglist_hi_ld;
-  long f_reglist_low_ld;
+  long long f_nil;
+  long long f_anyof;
+  long long f_op1;
+  long long f_op2;
+  long long f_op3;
+  long long f_op4;
+  long long f_op5;
+  long long f_cc;
+  long long f_ccc;
+  long long f_Rj;
+  long long f_Ri;
+  long long f_Rs1;
+  long long f_Rs2;
+  long long f_Rjc;
+  long long f_Ric;
+  long long f_CRj;
+  long long f_CRi;
+  long long f_u4;
+  long long f_u4c;
+  long long f_i4;
+  long long f_m4;
+  long long f_u8;
+  long long f_i8;
+  long long f_i20_4;
+  long long f_i20_16;
+  long long f_i20;
+  long long f_i32;
+  long long f_udisp6;
+  long long f_disp8;
+  long long f_disp9;
+  long long f_disp10;
+  long long f_s10;
+  long long f_u10;
+  long long f_rel9;
+  long long f_dir8;
+  long long f_dir9;
+  long long f_dir10;
+  long long f_rel12;
+  long long f_reglist_hi_st;
+  long long f_reglist_low_st;
+  long long f_reglist_hi_ld;
+  long long f_reglist_low_ld;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/frv-asm.c b/opcodes/frv-asm.c
index 12b8ee2..259474e 100644
--- a/opcodes/frv-asm.c
+++ b/opcodes/frv-asm.c
@@ -77,7 +77,7 @@ static const char *
 parse_ldd_annotation (CGEN_CPU_DESC cd,
 		      const char **strp,
 		      int opindex,
-		      unsigned long *valuep)
+		      unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -116,7 +116,7 @@ static const char *
 parse_call_annotation (CGEN_CPU_DESC cd,
 		       const char **strp,
 		       int opindex,
-		       unsigned long *valuep)
+		       unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -155,7 +155,7 @@ static const char *
 parse_ld_annotation (CGEN_CPU_DESC cd,
 		     const char **strp,
 		     int opindex,
-		     unsigned long *valuep)
+		     unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -194,7 +194,7 @@ static const char *
 parse_ulo16 (CGEN_CPU_DESC cd,
 	     const char **strp,
 	     int opindex,
-	     unsigned long *valuep)
+	     unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -320,7 +320,7 @@ static const char *
 parse_uslo16 (CGEN_CPU_DESC cd,
 	      const char **strp,
 	      int opindex,
-	      signed long *valuep)
+	      signed long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -446,7 +446,7 @@ static const char *
 parse_uhi16 (CGEN_CPU_DESC cd,
 	     const char **strp,
 	     int opindex,
-	     unsigned long *valuep)
+	     unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -575,7 +575,7 @@ parse_uhi16 (CGEN_CPU_DESC cd,
   return cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
 }
 
-static long
+static long long
 parse_register_number (const char **strp)
 {
   int regno;
@@ -594,10 +594,10 @@ static const char *
 parse_spr (CGEN_CPU_DESC cd,
 	   const char **strp,
 	   CGEN_KEYWORD * table,
-	   long *valuep)
+	   long long *valuep)
 {
   const char *save_strp;
-  long regno;
+  long long regno;
 
   /* Check for spr index notation.  */
   if (strncasecmp (*strp, "spr[", 4) == 0)
@@ -631,7 +631,7 @@ static const char *
 parse_d12 (CGEN_CPU_DESC cd,
 	   const char **strp,
 	   int opindex,
-	   long *valuep)
+	   long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -744,7 +744,7 @@ static const char *
 parse_s12 (CGEN_CPU_DESC cd,
 	   const char **strp,
 	   int opindex,
-	   long *valuep)
+	   long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -860,7 +860,7 @@ static const char *
 parse_u12 (CGEN_CPU_DESC cd,
 	   const char **strp,
 	   int opindex,
-	   long *valuep)
+	   long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -892,8 +892,8 @@ static const char *
 parse_A (CGEN_CPU_DESC cd,
 	 const char **strp,
 	 int opindex,
-	 unsigned long *valuep,
-	 unsigned long A)
+	 unsigned long long *valuep,
+	 unsigned long long A)
 {
   const char *errmsg;
 
@@ -914,7 +914,7 @@ static const char *
 parse_A0 (CGEN_CPU_DESC cd,
 	  const char **strp,
 	  int opindex,
-	  unsigned long *valuep)
+	  unsigned long long *valuep)
 {
   return parse_A (cd, strp, opindex, valuep, 0);
 }
@@ -923,7 +923,7 @@ static const char *
 parse_A1 (CGEN_CPU_DESC cd,
 	  const char **strp,
 	  int opindex,
-	  unsigned long *valuep)
+	  unsigned long long *valuep)
 {
   return parse_A (cd, strp, opindex, valuep, 1);
 }
@@ -932,7 +932,7 @@ static const char *
 parse_even_register (CGEN_CPU_DESC  cd,
 		     const char **  strP,
 		     CGEN_KEYWORD * tableP,
-		     long *         valueP)
+		     long long *         valueP)
 {
   const char * errmsg;
   const char * saved_star_strP = * strP;
@@ -1005,15 +1005,15 @@ frv_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
     case FRV_OPERAND_A0 :
-      errmsg = parse_A0 (cd, strp, FRV_OPERAND_A0, (unsigned long *) (& fields->f_A));
+      errmsg = parse_A0 (cd, strp, FRV_OPERAND_A0, (unsigned long long *) (& fields->f_A));
       break;
     case FRV_OPERAND_A1 :
-      errmsg = parse_A1 (cd, strp, FRV_OPERAND_A1, (unsigned long *) (& fields->f_A));
+      errmsg = parse_A1 (cd, strp, FRV_OPERAND_A1, (unsigned long long *) (& fields->f_A));
       break;
     case FRV_OPERAND_ACC40SI :
       errmsg = cgen_parse_keyword (cd, strp, & frv_cgen_opval_acc_names, & fields->f_ACC40Si);
@@ -1145,46 +1145,46 @@ frv_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & frv_cgen_opval_iccr_names, & fields->f_ICCi_3);
       break;
     case FRV_OPERAND_LI :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LI, (unsigned long *) (& fields->f_LI));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LI, (unsigned long long *) (& fields->f_LI));
       break;
     case FRV_OPERAND_LRAD :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LRAD, (unsigned long *) (& fields->f_LRAD));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LRAD, (unsigned long long *) (& fields->f_LRAD));
       break;
     case FRV_OPERAND_LRAE :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LRAE, (unsigned long *) (& fields->f_LRAE));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LRAE, (unsigned long long *) (& fields->f_LRAE));
       break;
     case FRV_OPERAND_LRAS :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LRAS, (unsigned long *) (& fields->f_LRAS));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LRAS, (unsigned long long *) (& fields->f_LRAS));
       break;
     case FRV_OPERAND_TLBPRL :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_TLBPRL, (unsigned long *) (& fields->f_TLBPRL));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_TLBPRL, (unsigned long long *) (& fields->f_TLBPRL));
       break;
     case FRV_OPERAND_TLBPROPX :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_TLBPROPX, (unsigned long *) (& fields->f_TLBPRopx));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_TLBPROPX, (unsigned long long *) (& fields->f_TLBPRopx));
       break;
     case FRV_OPERAND_AE :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_AE, (unsigned long *) (& fields->f_ae));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_AE, (unsigned long long *) (& fields->f_ae));
       break;
     case FRV_OPERAND_CALLANN :
-      errmsg = parse_call_annotation (cd, strp, FRV_OPERAND_CALLANN, (unsigned long *) (& fields->f_reloc_ann));
+      errmsg = parse_call_annotation (cd, strp, FRV_OPERAND_CALLANN, (unsigned long long *) (& fields->f_reloc_ann));
       break;
     case FRV_OPERAND_CCOND :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_CCOND, (unsigned long *) (& fields->f_ccond));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_CCOND, (unsigned long long *) (& fields->f_ccond));
       break;
     case FRV_OPERAND_COND :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_COND, (unsigned long *) (& fields->f_cond));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_COND, (unsigned long long *) (& fields->f_cond));
       break;
     case FRV_OPERAND_D12 :
-      errmsg = parse_d12 (cd, strp, FRV_OPERAND_D12, (long *) (& fields->f_d12));
+      errmsg = parse_d12 (cd, strp, FRV_OPERAND_D12, (long long *) (& fields->f_d12));
       break;
     case FRV_OPERAND_DEBUG :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_DEBUG, (unsigned long *) (& fields->f_debug));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_DEBUG, (unsigned long long *) (& fields->f_debug));
       break;
     case FRV_OPERAND_EIR :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_EIR, (unsigned long *) (& fields->f_eir));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_EIR, (unsigned long long *) (& fields->f_eir));
       break;
     case FRV_OPERAND_HINT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_HINT, (unsigned long *) (& fields->f_hint));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_HINT, (unsigned long long *) (& fields->f_hint));
       break;
     case FRV_OPERAND_HINT_NOT_TAKEN :
       errmsg = cgen_parse_keyword (cd, strp, & frv_cgen_opval_h_hint_not_taken, & fields->f_hint);
@@ -1207,55 +1207,55 @@ frv_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case FRV_OPERAND_LDANN :
-      errmsg = parse_ld_annotation (cd, strp, FRV_OPERAND_LDANN, (unsigned long *) (& fields->f_reloc_ann));
+      errmsg = parse_ld_annotation (cd, strp, FRV_OPERAND_LDANN, (unsigned long long *) (& fields->f_reloc_ann));
       break;
     case FRV_OPERAND_LDDANN :
-      errmsg = parse_ldd_annotation (cd, strp, FRV_OPERAND_LDDANN, (unsigned long *) (& fields->f_reloc_ann));
+      errmsg = parse_ldd_annotation (cd, strp, FRV_OPERAND_LDDANN, (unsigned long long *) (& fields->f_reloc_ann));
       break;
     case FRV_OPERAND_LOCK :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LOCK, (unsigned long *) (& fields->f_lock));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_LOCK, (unsigned long long *) (& fields->f_lock));
       break;
     case FRV_OPERAND_PACK :
       errmsg = cgen_parse_keyword (cd, strp, & frv_cgen_opval_h_pack, & fields->f_pack);
       break;
     case FRV_OPERAND_S10 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S10, (long *) (& fields->f_s10));
+      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S10, (long long *) (& fields->f_s10));
       break;
     case FRV_OPERAND_S12 :
-      errmsg = parse_s12 (cd, strp, FRV_OPERAND_S12, (long *) (& fields->f_d12));
+      errmsg = parse_s12 (cd, strp, FRV_OPERAND_S12, (long long *) (& fields->f_d12));
       break;
     case FRV_OPERAND_S16 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S16, (long *) (& fields->f_s16));
+      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S16, (long long *) (& fields->f_s16));
       break;
     case FRV_OPERAND_S5 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S5, (long *) (& fields->f_s5));
+      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S5, (long long *) (& fields->f_s5));
       break;
     case FRV_OPERAND_S6 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S6, (long *) (& fields->f_s6));
+      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S6, (long long *) (& fields->f_s6));
       break;
     case FRV_OPERAND_S6_1 :
-      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S6_1, (long *) (& fields->f_s6_1));
+      errmsg = cgen_parse_signed_integer (cd, strp, FRV_OPERAND_S6_1, (long long *) (& fields->f_s6_1));
       break;
     case FRV_OPERAND_SLO16 :
-      errmsg = parse_uslo16 (cd, strp, FRV_OPERAND_SLO16, (long *) (& fields->f_s16));
+      errmsg = parse_uslo16 (cd, strp, FRV_OPERAND_SLO16, (long long *) (& fields->f_s16));
       break;
     case FRV_OPERAND_SPR :
       errmsg = parse_spr (cd, strp, & frv_cgen_opval_spr_names, & fields->f_spr);
       break;
     case FRV_OPERAND_U12 :
-      errmsg = parse_u12 (cd, strp, FRV_OPERAND_U12, (long *) (& fields->f_u12));
+      errmsg = parse_u12 (cd, strp, FRV_OPERAND_U12, (long long *) (& fields->f_u12));
       break;
     case FRV_OPERAND_U16 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_U16, (unsigned long *) (& fields->f_u16));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_U16, (unsigned long long *) (& fields->f_u16));
       break;
     case FRV_OPERAND_U6 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_U6, (unsigned long *) (& fields->f_u6));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, FRV_OPERAND_U6, (unsigned long long *) (& fields->f_u6));
       break;
     case FRV_OPERAND_UHI16 :
-      errmsg = parse_uhi16 (cd, strp, FRV_OPERAND_UHI16, (unsigned long *) (& fields->f_u16));
+      errmsg = parse_uhi16 (cd, strp, FRV_OPERAND_UHI16, (unsigned long long *) (& fields->f_u16));
       break;
     case FRV_OPERAND_ULO16 :
-      errmsg = parse_ulo16 (cd, strp, FRV_OPERAND_ULO16, (unsigned long *) (& fields->f_u16));
+      errmsg = parse_ulo16 (cd, strp, FRV_OPERAND_ULO16, (unsigned long long *) (& fields->f_u16));
       break;
 
     default :
diff --git a/opcodes/frv-dis.c b/opcodes/frv-dis.c
index af844f7..9be9fb8 100644
--- a/opcodes/frv-dis.c
+++ b/opcodes/frv-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -62,8 +62,8 @@ static int read_insn
 static void
 print_at (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	  void * dis_info,
-	  long reloc_ann ATTRIBUTE_UNUSED,
-	  long value ATTRIBUTE_UNUSED,
+	  long long reloc_ann ATTRIBUTE_UNUSED,
+	  long long value ATTRIBUTE_UNUSED,
 	  bfd_vma pc ATTRIBUTE_UNUSED,
 	  int length ATTRIBUTE_UNUSED)
 {
@@ -76,7 +76,7 @@ static void
 print_spr (CGEN_CPU_DESC cd,
 	   void * dis_info,
 	   CGEN_KEYWORD *names,
-	   long regno,
+	   long long regno,
 	   unsigned int attrs)
 {
   /* Use the register index format for any unnamed registers.  */
@@ -92,7 +92,7 @@ print_spr (CGEN_CPU_DESC cd,
 static void
 print_hi (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	  void * dis_info,
-	  long value,
+	  long long value,
 	  unsigned int attrs ATTRIBUTE_UNUSED,
 	  bfd_vma pc ATTRIBUTE_UNUSED,
 	  int length ATTRIBUTE_UNUSED)
@@ -105,7 +105,7 @@ print_hi (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_lo (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	  void * dis_info,
-	  long value,
+	  long long value,
 	  unsigned int attrs ATTRIBUTE_UNUSED,
 	  bfd_vma pc ATTRIBUTE_UNUSED,
 	  int length ATTRIBUTE_UNUSED)
@@ -421,7 +421,7 @@ frv_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -457,9 +457,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -468,7 +468,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -530,7 +530,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -588,7 +588,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -607,7 +607,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -623,9 +623,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/frv-ibld.c b/opcodes/frv-ibld.c
index bf6f962..54b0175 100644
--- a/opcodes/frv-ibld.c
+++ b/opcodes/frv-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -623,7 +623,7 @@ frv_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case FRV_OPERAND_CRJ_INT :
       {
-        long value = fields->f_CRj_int;
+        long long value = fields->f_CRj_int;
         value = ((value) - (4));
         errmsg = insert_normal (cd, value, 0, 0, 26, 2, 32, total_length, buffer);
       }
@@ -762,7 +762,7 @@ frv_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case FRV_OPERAND_LABEL16 :
       {
-        long value = fields->f_label16;
+        long long value = fields->f_label16;
         value = ((SI) (((value) - (pc))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 16, 32, total_length, buffer);
       }
@@ -948,7 +948,7 @@ frv_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FRV_OPERAND_CRJ_INT :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 26, 2, 32, total_length, pc, & value);
         value = ((value) + (4));
         fields->f_CRj_int = value;
@@ -1088,7 +1088,7 @@ frv_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case FRV_OPERAND_LABEL16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 16, 32, total_length, pc, & value);
         value = ((((value) << (2))) + (pc));
         fields->f_label16 = value;
diff --git a/opcodes/frv-opc.c b/opcodes/frv-opc.c
index 67628c2..659e32b 100644
--- a/opcodes/frv-opc.c
+++ b/opcodes/frv-opc.c
@@ -43,7 +43,7 @@ This file is part of the GNU Binutils and/or GDB, the GNU debugger.
    development tree.  */
 
 bfd_boolean
-frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)
+frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long long mach)
 {
   switch (mach)
     {
@@ -67,7 +67,7 @@ frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)
 /* Returns TRUE if {MAJOR,MACH} supports floating point insns.  */
 
 bfd_boolean
-frv_is_float_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)
+frv_is_float_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long long mach)
 {
   switch (mach)
     {
@@ -86,7 +86,7 @@ frv_is_float_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)
 /* Returns TRUE if {MAJOR,MACH} supports media insns.  */
 
 bfd_boolean
-frv_is_media_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)
+frv_is_media_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long long mach)
 {
   switch (mach)
     {
@@ -362,7 +362,7 @@ static CGEN_ATTR_VALUE_ENUM_TYPE fr550_unit_mapping[] =
 };
 
 void
-frv_vliw_reset (FRV_VLIW *vliw, unsigned long mach, unsigned long elf_flags)
+frv_vliw_reset (FRV_VLIW *vliw, unsigned long long mach, unsigned long long elf_flags)
 {
   vliw->next_slot = 0;
   vliw->constraint_violation = 0;
@@ -874,7 +874,7 @@ frv_vliw_add_insn (FRV_VLIW *vliw, const CGEN_INSN *insn)
 }
 
 bfd_boolean
-spr_valid (long regno)
+spr_valid (long long regno)
 {
   if (regno < 0)     return FALSE;
   if (regno <= 4095) return TRUE;
diff --git a/opcodes/frv-opc.h b/opcodes/frv-opc.h
index 195a95f..4ac7028 100644
--- a/opcodes/frv-opc.h
+++ b/opcodes/frv-opc.h
@@ -50,23 +50,23 @@ typedef struct
 {
   int                    next_slot;
   int                    constraint_violation;
-  unsigned long          mach;
-  unsigned long          elf_flags;
+  unsigned long long          mach;
+  unsigned long long          elf_flags;
   CGEN_ATTR_VALUE_ENUM_TYPE * unit_mapping;
   VLIW_COMBO *           current_vliw;
   CGEN_ATTR_VALUE_ENUM_TYPE   major[FRV_VLIW_SIZE];
   const CGEN_INSN *      insn[FRV_VLIW_SIZE];
 } FRV_VLIW;
 
-int frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);
-int frv_is_float_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);
-int frv_is_media_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);
+int frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long long);
+int frv_is_float_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long long);
+int frv_is_media_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long long);
 int frv_is_branch_insn  (const CGEN_INSN *);
 int frv_is_float_insn   (const CGEN_INSN *);
 int frv_is_media_insn   (const CGEN_INSN *);
-void frv_vliw_reset     (FRV_VLIW *, unsigned long, unsigned long);
+void frv_vliw_reset     (FRV_VLIW *, unsigned long long, unsigned long long);
 int frv_vliw_add_insn   (FRV_VLIW *, const CGEN_INSN *);
-int spr_valid           (long);
+int spr_valid           (long long);
 /* -- */
 /* Enum declaration for frv instruction types.  */
 typedef enum cgen_insn_type {
@@ -268,111 +268,111 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_pack;
-  long f_op;
-  long f_ope1;
-  long f_ope2;
-  long f_ope3;
-  long f_ope4;
-  long f_GRi;
-  long f_GRj;
-  long f_GRk;
-  long f_FRi;
-  long f_FRj;
-  long f_FRk;
-  long f_CPRi;
-  long f_CPRj;
-  long f_CPRk;
-  long f_ACCGi;
-  long f_ACCGk;
-  long f_ACC40Si;
-  long f_ACC40Ui;
-  long f_ACC40Sk;
-  long f_ACC40Uk;
-  long f_CRi;
-  long f_CRj;
-  long f_CRk;
-  long f_CCi;
-  long f_CRj_int;
-  long f_CRj_float;
-  long f_ICCi_1;
-  long f_ICCi_2;
-  long f_ICCi_3;
-  long f_FCCi_1;
-  long f_FCCi_2;
-  long f_FCCi_3;
-  long f_FCCk;
-  long f_eir;
-  long f_s10;
-  long f_s12;
-  long f_d12;
-  long f_u16;
-  long f_s16;
-  long f_s6;
-  long f_s6_1;
-  long f_u6;
-  long f_s5;
-  long f_u12_h;
-  long f_u12_l;
-  long f_u12;
-  long f_int_cc;
-  long f_flt_cc;
-  long f_cond;
-  long f_ccond;
-  long f_hint;
-  long f_LI;
-  long f_lock;
-  long f_debug;
-  long f_A;
-  long f_ae;
-  long f_spr_h;
-  long f_spr_l;
-  long f_spr;
-  long f_label16;
-  long f_labelH6;
-  long f_labelL18;
-  long f_label24;
-  long f_LRAE;
-  long f_LRAD;
-  long f_LRAS;
-  long f_TLBPRopx;
-  long f_TLBPRL;
-  long f_ICCi_1_null;
-  long f_ICCi_2_null;
-  long f_ICCi_3_null;
-  long f_FCCi_1_null;
-  long f_FCCi_2_null;
-  long f_FCCi_3_null;
-  long f_rs_null;
-  long f_GRi_null;
-  long f_GRj_null;
-  long f_GRk_null;
-  long f_FRi_null;
-  long f_FRj_null;
-  long f_ACCj_null;
-  long f_rd_null;
-  long f_cond_null;
-  long f_ccond_null;
-  long f_s12_null;
-  long f_label16_null;
-  long f_misc_null_1;
-  long f_misc_null_2;
-  long f_misc_null_3;
-  long f_misc_null_4;
-  long f_misc_null_5;
-  long f_misc_null_6;
-  long f_misc_null_7;
-  long f_misc_null_8;
-  long f_misc_null_9;
-  long f_misc_null_10;
-  long f_misc_null_11;
-  long f_LRA_null;
-  long f_TLBPR_null;
-  long f_LI_off;
-  long f_LI_on;
-  long f_reloc_ann;
+  long long f_nil;
+  long long f_anyof;
+  long long f_pack;
+  long long f_op;
+  long long f_ope1;
+  long long f_ope2;
+  long long f_ope3;
+  long long f_ope4;
+  long long f_GRi;
+  long long f_GRj;
+  long long f_GRk;
+  long long f_FRi;
+  long long f_FRj;
+  long long f_FRk;
+  long long f_CPRi;
+  long long f_CPRj;
+  long long f_CPRk;
+  long long f_ACCGi;
+  long long f_ACCGk;
+  long long f_ACC40Si;
+  long long f_ACC40Ui;
+  long long f_ACC40Sk;
+  long long f_ACC40Uk;
+  long long f_CRi;
+  long long f_CRj;
+  long long f_CRk;
+  long long f_CCi;
+  long long f_CRj_int;
+  long long f_CRj_float;
+  long long f_ICCi_1;
+  long long f_ICCi_2;
+  long long f_ICCi_3;
+  long long f_FCCi_1;
+  long long f_FCCi_2;
+  long long f_FCCi_3;
+  long long f_FCCk;
+  long long f_eir;
+  long long f_s10;
+  long long f_s12;
+  long long f_d12;
+  long long f_u16;
+  long long f_s16;
+  long long f_s6;
+  long long f_s6_1;
+  long long f_u6;
+  long long f_s5;
+  long long f_u12_h;
+  long long f_u12_l;
+  long long f_u12;
+  long long f_int_cc;
+  long long f_flt_cc;
+  long long f_cond;
+  long long f_ccond;
+  long long f_hint;
+  long long f_LI;
+  long long f_lock;
+  long long f_debug;
+  long long f_A;
+  long long f_ae;
+  long long f_spr_h;
+  long long f_spr_l;
+  long long f_spr;
+  long long f_label16;
+  long long f_labelH6;
+  long long f_labelL18;
+  long long f_label24;
+  long long f_LRAE;
+  long long f_LRAD;
+  long long f_LRAS;
+  long long f_TLBPRopx;
+  long long f_TLBPRL;
+  long long f_ICCi_1_null;
+  long long f_ICCi_2_null;
+  long long f_ICCi_3_null;
+  long long f_FCCi_1_null;
+  long long f_FCCi_2_null;
+  long long f_FCCi_3_null;
+  long long f_rs_null;
+  long long f_GRi_null;
+  long long f_GRj_null;
+  long long f_GRk_null;
+  long long f_FRi_null;
+  long long f_FRj_null;
+  long long f_ACCj_null;
+  long long f_rd_null;
+  long long f_cond_null;
+  long long f_ccond_null;
+  long long f_s12_null;
+  long long f_label16_null;
+  long long f_misc_null_1;
+  long long f_misc_null_2;
+  long long f_misc_null_3;
+  long long f_misc_null_4;
+  long long f_misc_null_5;
+  long long f_misc_null_6;
+  long long f_misc_null_7;
+  long long f_misc_null_8;
+  long long f_misc_null_9;
+  long long f_misc_null_10;
+  long long f_misc_null_11;
+  long long f_LRA_null;
+  long long f_TLBPR_null;
+  long long f_LI_off;
+  long long f_LI_on;
+  long long f_reloc_ann;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/h8300-dis.c b/opcodes/h8300-dis.c
index d9e5c9d..062f6f6 100644
--- a/opcodes/h8300-dis.c
+++ b/opcodes/h8300-dis.c
@@ -271,14 +271,14 @@ print_one_arg (disassemble_info *info,
 	  outfn (stream, ".%s%d (0x%lx)",
 		   (short) cst > 0 ? "+" : "",
 		   (short) cst,
-		   (long)(addr + (short) cst + len));
+		   (long long)(addr + (short) cst + len));
 	}
       else
 	{
 	  outfn (stream, ".%s%d (0x%lx)",
 		   (char) cst > 0 ? "+" : "",
 		   (char) cst,
-		   (long)(addr + (char) cst + len));
+		   (long long)(addr + (char) cst + len));
 	}
     }
   else if ((x & MODE) == DISP)
diff --git a/opcodes/ia64-dis.c b/opcodes/ia64-dis.c
index 1f37144..6b5fcd8 100644
--- a/opcodes/ia64-dis.c
+++ b/opcodes/ia64-dis.c
@@ -85,7 +85,7 @@ print_insn_ia64 (bfd_vma memaddr, struct disassemble_info *info)
   slot_multiplier = info->bytes_per_line;
   retval = slot_multiplier;
 
-  slotnum = (((long) memaddr) & 0xf) / slot_multiplier;
+  slotnum = (((long long) memaddr) & 0xf) / slot_multiplier;
   if (slotnum > 2)
     return -1;
 
diff --git a/opcodes/ia64-gen.c b/opcodes/ia64-gen.c
index 384e573..39391c6 100644
--- a/opcodes/ia64-gen.c
+++ b/opcodes/ia64-gen.c
@@ -57,8 +57,8 @@
    always, because we might be compiled without BFD64 defined, if configured
    for a 32-bit target and --enable-targets=all is used.  This will work for
    both 32-bit and 64-bit hosts.  */
-#define _opcode_int64_low(x) ((unsigned long) (((x) & 0xffffffff)))
-#define _opcode_int64_high(x) ((unsigned long) (((x) >> 32) & 0xffffffff))
+#define _opcode_int64_low(x) ((unsigned long long) (((x) & 0xffffffff)))
+#define _opcode_int64_high(x) ((unsigned long long) (((x) >> 32) & 0xffffffff))
 #define opcode_fprintf_vma(s,x) \
   fprintf ((s), "%08lx%08lx", _opcode_int64_high (x), _opcode_int64_low (x))
 
@@ -2141,7 +2141,7 @@ print_dis_table (void)
 
       while (ent != NULL)
 	{
-	  printf ("{ 0x%lx, %d, %d, %d },\n", ( long ) ent->completer_index,
+	  printf ("{ 0x%lx, %d, %d, %d },\n", ( long long ) ent->completer_index,
 		  ent->insn, (ent->nexte != NULL ? 1 : 0),
                   ent->priority);
 	  ent = ent->nexte;
diff --git a/opcodes/ip2k-asm.c b/opcodes/ip2k-asm.c
index 3b2d1d1..d508dde 100644
--- a/opcodes/ip2k-asm.c
+++ b/opcodes/ip2k-asm.c
@@ -55,7 +55,7 @@ static const char *
 parse_fr (CGEN_CPU_DESC cd,
 	  const char **strp,
 	  int opindex,
-	  unsigned long *valuep)
+	  unsigned long long *valuep)
 {
   const char *errmsg;
   const char *old_strp;
@@ -86,7 +86,7 @@ parse_fr (CGEN_CPU_DESC cd,
 
   /* Attempt parse as register keyword. */
   errmsg = cgen_parse_keyword (cd, strp, & ip2k_cgen_opval_register_names,
-			       (long *) valuep);
+			       (long long *) valuep);
   if (*strp != NULL
       && errmsg == NULL)
     return errmsg;
@@ -225,7 +225,7 @@ static const char *
 parse_addr16 (CGEN_CPU_DESC cd,
 	      const char **strp,
 	      int opindex,
-	      unsigned long *valuep)
+	      unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -267,7 +267,7 @@ static const char *
 parse_addr16_cjp (CGEN_CPU_DESC cd,
 		  const char **strp,
 		  int opindex,
-		  unsigned long *valuep)
+		  unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -311,7 +311,7 @@ static const char *
 parse_lit8 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    long *valuep)
+	    long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -378,12 +378,12 @@ static const char *
 parse_bit3 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   const char *errmsg;
   char mode = 0;
-  long count = 0;
-  unsigned long value;
+  long long count = 0;
+  unsigned long long value;
 
   if (strncmp (*strp, "%bit", 4) == 0)
     {
@@ -465,45 +465,45 @@ ip2k_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
     case IP2K_OPERAND_ADDR16CJP :
-      errmsg = parse_addr16_cjp (cd, strp, IP2K_OPERAND_ADDR16CJP, (unsigned long *) (& fields->f_addr16cjp));
+      errmsg = parse_addr16_cjp (cd, strp, IP2K_OPERAND_ADDR16CJP, (unsigned long long *) (& fields->f_addr16cjp));
       break;
     case IP2K_OPERAND_ADDR16H :
-      errmsg = parse_addr16 (cd, strp, IP2K_OPERAND_ADDR16H, (unsigned long *) (& fields->f_imm8));
+      errmsg = parse_addr16 (cd, strp, IP2K_OPERAND_ADDR16H, (unsigned long long *) (& fields->f_imm8));
       break;
     case IP2K_OPERAND_ADDR16L :
-      errmsg = parse_addr16 (cd, strp, IP2K_OPERAND_ADDR16L, (unsigned long *) (& fields->f_imm8));
+      errmsg = parse_addr16 (cd, strp, IP2K_OPERAND_ADDR16L, (unsigned long long *) (& fields->f_imm8));
       break;
     case IP2K_OPERAND_ADDR16P :
-      errmsg = parse_addr16_cjp (cd, strp, IP2K_OPERAND_ADDR16P, (unsigned long *) (& fields->f_page3));
+      errmsg = parse_addr16_cjp (cd, strp, IP2K_OPERAND_ADDR16P, (unsigned long long *) (& fields->f_page3));
       break;
     case IP2K_OPERAND_BITNO :
-      errmsg = parse_bit3 (cd, strp, IP2K_OPERAND_BITNO, (unsigned long *) (& fields->f_bitno));
+      errmsg = parse_bit3 (cd, strp, IP2K_OPERAND_BITNO, (unsigned long long *) (& fields->f_bitno));
       break;
     case IP2K_OPERAND_CBIT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_CBIT, (unsigned long *) (& junk));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_CBIT, (unsigned long long *) (& junk));
       break;
     case IP2K_OPERAND_DCBIT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_DCBIT, (unsigned long *) (& junk));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_DCBIT, (unsigned long long *) (& junk));
       break;
     case IP2K_OPERAND_FR :
-      errmsg = parse_fr (cd, strp, IP2K_OPERAND_FR, (unsigned long *) (& fields->f_reg));
+      errmsg = parse_fr (cd, strp, IP2K_OPERAND_FR, (unsigned long long *) (& fields->f_reg));
       break;
     case IP2K_OPERAND_LIT8 :
-      errmsg = parse_lit8 (cd, strp, IP2K_OPERAND_LIT8, (long *) (& fields->f_imm8));
+      errmsg = parse_lit8 (cd, strp, IP2K_OPERAND_LIT8, (long long *) (& fields->f_imm8));
       break;
     case IP2K_OPERAND_PABITS :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_PABITS, (unsigned long *) (& junk));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_PABITS, (unsigned long long *) (& junk));
       break;
     case IP2K_OPERAND_RETI3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_RETI3, (unsigned long *) (& fields->f_reti3));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_RETI3, (unsigned long long *) (& fields->f_reti3));
       break;
     case IP2K_OPERAND_ZBIT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_ZBIT, (unsigned long *) (& junk));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IP2K_OPERAND_ZBIT, (unsigned long long *) (& junk));
       break;
 
     default :
diff --git a/opcodes/ip2k-dis.c b/opcodes/ip2k-dis.c
index 5e32903..7e0faed 100644
--- a/opcodes/ip2k-dis.c
+++ b/opcodes/ip2k-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -63,7 +63,7 @@ static int read_insn
 static void
 print_fr (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	  void * dis_info,
-	  long value,
+	  long long value,
 	  unsigned int attrs ATTRIBUTE_UNUSED,
 	  bfd_vma pc ATTRIBUTE_UNUSED,
 	  int length ATTRIBUTE_UNUSED)
@@ -71,8 +71,8 @@ print_fr (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   disassemble_info *info = (disassemble_info *) dis_info;
   const CGEN_KEYWORD_ENTRY *ke;
   extern CGEN_KEYWORD ip2k_cgen_opval_register_names;
-  long offsettest;
-  long offsetvalue;
+  long long offsettest;
+  long long offsetvalue;
 
   if (value == 0) /* This is (IP).  */
     {
@@ -116,7 +116,7 @@ print_fr (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_dollarhex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		 void * dis_info,
-		 long value,
+		 long long value,
 		 unsigned int attrs ATTRIBUTE_UNUSED,
 		 bfd_vma pc ATTRIBUTE_UNUSED,
 		 int length ATTRIBUTE_UNUSED)
@@ -129,7 +129,7 @@ print_dollarhex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_dollarhex8 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		  void * dis_info,
-		  long value,
+		  long long value,
 		  unsigned int attrs ATTRIBUTE_UNUSED,
 		  bfd_vma pc ATTRIBUTE_UNUSED,
 		  int length ATTRIBUTE_UNUSED)
@@ -142,7 +142,7 @@ print_dollarhex8 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_dollarhex_addr16h (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 			 void * dis_info,
-			 long value,
+			 long long value,
 			 unsigned int attrs ATTRIBUTE_UNUSED,
 			 bfd_vma pc ATTRIBUTE_UNUSED,
 			 int length ATTRIBUTE_UNUSED)
@@ -159,7 +159,7 @@ print_dollarhex_addr16h (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_dollarhex_addr16l (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 			 void * dis_info,
-			 long value,
+			 long long value,
 			 unsigned int attrs ATTRIBUTE_UNUSED,
 			 bfd_vma pc ATTRIBUTE_UNUSED,
 			 int length ATTRIBUTE_UNUSED)
@@ -172,7 +172,7 @@ print_dollarhex_addr16l (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_dollarhex_p (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		   void * dis_info,
-		   long value,
+		   long long value,
 		   unsigned int attrs ATTRIBUTE_UNUSED,
 		   bfd_vma pc ATTRIBUTE_UNUSED,
 		   int length ATTRIBUTE_UNUSED)
@@ -187,7 +187,7 @@ print_dollarhex_p (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_dollarhex_cj (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		    void * dis_info,
-		    long value,
+		    long long value,
 		    unsigned int attrs ATTRIBUTE_UNUSED,
 		    bfd_vma pc ATTRIBUTE_UNUSED,
 		    int length ATTRIBUTE_UNUSED)
@@ -201,7 +201,7 @@ print_dollarhex_cj (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_decimal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void * dis_info,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED,
 	       bfd_vma pc ATTRIBUTE_UNUSED,
 	       int length ATTRIBUTE_UNUSED)
@@ -313,7 +313,7 @@ ip2k_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -349,9 +349,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -360,7 +360,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -422,7 +422,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -480,7 +480,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -499,7 +499,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -515,9 +515,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/ip2k-ibld.c b/opcodes/ip2k-ibld.c
index 49b8439..0688b87 100644
--- a/opcodes/ip2k-ibld.c
+++ b/opcodes/ip2k-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
diff --git a/opcodes/ip2k-opc.h b/opcodes/ip2k-opc.h
index 805dbf9..18e214f 100644
--- a/opcodes/ip2k-opc.h
+++ b/opcodes/ip2k-opc.h
@@ -87,23 +87,23 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_imm8;
-  long f_reg;
-  long f_addr16cjp;
-  long f_dir;
-  long f_bitno;
-  long f_op3;
-  long f_op4;
-  long f_op4mid;
-  long f_op6;
-  long f_op8;
-  long f_op6_10low;
-  long f_op6_7low;
-  long f_reti3;
-  long f_skipb;
-  long f_page3;
+  long long f_nil;
+  long long f_anyof;
+  long long f_imm8;
+  long long f_reg;
+  long long f_addr16cjp;
+  long long f_dir;
+  long long f_bitno;
+  long long f_op3;
+  long long f_op4;
+  long long f_op4mid;
+  long long f_op6;
+  long long f_op8;
+  long long f_op6_10low;
+  long long f_op6_7low;
+  long long f_reti3;
+  long long f_skipb;
+  long long f_page3;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/iq2000-asm.c b/opcodes/iq2000-asm.c
index 284acce..be3730c 100644
--- a/opcodes/iq2000-asm.c
+++ b/opcodes/iq2000-asm.c
@@ -103,7 +103,7 @@ static const char *
 parse_mimm (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   const char *errmsg;
 
@@ -112,14 +112,14 @@ parse_mimm (CGEN_CPU_DESC cd,
     errmsg = _("immediate value cannot be register");
   else
     {
-      long value;
+      long long value;
 
       errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
       if (errmsg == NULL)
 	{
-	  long x = (-value) & 0xFFFF0000;
+	  long long x = (-value) & 0xFFFF0000;
 
-	  if (x != 0 && x != (long) 0xFFFF0000)
+	  if (x != 0 && x != (long long) 0xFFFF0000)
 	    errmsg = _("immediate value out of range");
 	  else
 	    *valuep = (-value & 0xFFFF);
@@ -134,7 +134,7 @@ static const char *
 parse_imm (CGEN_CPU_DESC cd,
 	   const char **strp,
 	   int opindex,
-	   unsigned long *valuep)
+	   unsigned long long *valuep)
 {
   const char *errmsg;
 
@@ -142,14 +142,14 @@ parse_imm (CGEN_CPU_DESC cd,
     errmsg = _("immediate value cannot be register");
   else
     {
-      long value;
+      long long value;
 
       errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
       if (errmsg == NULL)
 	{
-	  long x = value & 0xFFFF0000;
+	  long long x = value & 0xFFFF0000;
 
-	  if (x != 0 && x != (long) 0xFFFF0000)
+	  if (x != 0 && x != (long long) 0xFFFF0000)
 	    errmsg = _("immediate value out of range");
 	  else
 	    *valuep = (value & 0xFFFF);
@@ -191,7 +191,7 @@ static const char *
 parse_hi16 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   if (strncasecmp (*strp, "%hi(", 4) == 0)
     {
@@ -258,7 +258,7 @@ static const char *
 parse_lo16 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   if (strncasecmp (*strp, "%lo(", 4) == 0)
     {
@@ -290,7 +290,7 @@ static const char *
 parse_mlo16 (CGEN_CPU_DESC cd,
 	     const char **strp,
 	     int opindex,
-	     unsigned long *valuep)
+	     unsigned long long *valuep)
 {
   if (strncasecmp (*strp, "%lo(", 4) == 0)
     {
@@ -340,12 +340,12 @@ iq2000_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
     case IQ2000_OPERAND__INDEX :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND__INDEX, (unsigned long *) (& fields->f_index));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND__INDEX, (unsigned long long *) (& fields->f_index));
       break;
     case IQ2000_OPERAND_BASE :
       errmsg = cgen_parse_keyword (cd, strp, & iq2000_cgen_opval_gr_names, & fields->f_rs);
@@ -358,40 +358,40 @@ iq2000_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case IQ2000_OPERAND_BITNUM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_BITNUM, (unsigned long *) (& fields->f_rt));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_BITNUM, (unsigned long long *) (& fields->f_rt));
       break;
     case IQ2000_OPERAND_BYTECOUNT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_BYTECOUNT, (unsigned long *) (& fields->f_bytecount));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_BYTECOUNT, (unsigned long long *) (& fields->f_bytecount));
       break;
     case IQ2000_OPERAND_CAM_Y :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CAM_Y, (unsigned long *) (& fields->f_cam_y));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CAM_Y, (unsigned long long *) (& fields->f_cam_y));
       break;
     case IQ2000_OPERAND_CAM_Z :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CAM_Z, (unsigned long *) (& fields->f_cam_z));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CAM_Z, (unsigned long long *) (& fields->f_cam_z));
       break;
     case IQ2000_OPERAND_CM_3FUNC :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CM_3FUNC, (unsigned long *) (& fields->f_cm_3func));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CM_3FUNC, (unsigned long long *) (& fields->f_cm_3func));
       break;
     case IQ2000_OPERAND_CM_3Z :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CM_3Z, (unsigned long *) (& fields->f_cm_3z));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CM_3Z, (unsigned long long *) (& fields->f_cm_3z));
       break;
     case IQ2000_OPERAND_CM_4FUNC :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CM_4FUNC, (unsigned long *) (& fields->f_cm_4func));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CM_4FUNC, (unsigned long long *) (& fields->f_cm_4func));
       break;
     case IQ2000_OPERAND_CM_4Z :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CM_4Z, (unsigned long *) (& fields->f_cm_4z));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_CM_4Z, (unsigned long long *) (& fields->f_cm_4z));
       break;
     case IQ2000_OPERAND_COUNT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_COUNT, (unsigned long *) (& fields->f_count));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_COUNT, (unsigned long long *) (& fields->f_count));
       break;
     case IQ2000_OPERAND_EXECODE :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_EXECODE, (unsigned long *) (& fields->f_excode));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_EXECODE, (unsigned long long *) (& fields->f_excode));
       break;
     case IQ2000_OPERAND_HI16 :
-      errmsg = parse_hi16 (cd, strp, IQ2000_OPERAND_HI16, (unsigned long *) (& fields->f_imm));
+      errmsg = parse_hi16 (cd, strp, IQ2000_OPERAND_HI16, (unsigned long long *) (& fields->f_imm));
       break;
     case IQ2000_OPERAND_IMM :
-      errmsg = parse_imm (cd, strp, IQ2000_OPERAND_IMM, (unsigned long *) (& fields->f_imm));
+      errmsg = parse_imm (cd, strp, IQ2000_OPERAND_IMM, (unsigned long long *) (& fields->f_imm));
       break;
     case IQ2000_OPERAND_JMPTARG :
       {
@@ -408,22 +408,22 @@ iq2000_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case IQ2000_OPERAND_LO16 :
-      errmsg = parse_lo16 (cd, strp, IQ2000_OPERAND_LO16, (unsigned long *) (& fields->f_imm));
+      errmsg = parse_lo16 (cd, strp, IQ2000_OPERAND_LO16, (unsigned long long *) (& fields->f_imm));
       break;
     case IQ2000_OPERAND_MASK :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_MASK, (unsigned long *) (& fields->f_mask));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_MASK, (unsigned long long *) (& fields->f_mask));
       break;
     case IQ2000_OPERAND_MASKL :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_MASKL, (unsigned long *) (& fields->f_maskl));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_MASKL, (unsigned long long *) (& fields->f_maskl));
       break;
     case IQ2000_OPERAND_MASKQ10 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_MASKQ10, (unsigned long *) (& fields->f_maskq10));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_MASKQ10, (unsigned long long *) (& fields->f_maskq10));
       break;
     case IQ2000_OPERAND_MASKR :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_MASKR, (unsigned long *) (& fields->f_rs));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_MASKR, (unsigned long long *) (& fields->f_rs));
       break;
     case IQ2000_OPERAND_MLO16 :
-      errmsg = parse_mlo16 (cd, strp, IQ2000_OPERAND_MLO16, (unsigned long *) (& fields->f_imm));
+      errmsg = parse_mlo16 (cd, strp, IQ2000_OPERAND_MLO16, (unsigned long long *) (& fields->f_imm));
       break;
     case IQ2000_OPERAND_OFFSET :
       {
@@ -451,7 +451,7 @@ iq2000_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & iq2000_cgen_opval_gr_names, & fields->f_rt_rs);
       break;
     case IQ2000_OPERAND_SHAMT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_SHAMT, (unsigned long *) (& fields->f_shamt));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, IQ2000_OPERAND_SHAMT, (unsigned long long *) (& fields->f_shamt));
       break;
 
     default :
diff --git a/opcodes/iq2000-dis.c b/opcodes/iq2000-dis.c
index d173333..298697d 100644
--- a/opcodes/iq2000-dis.c
+++ b/opcodes/iq2000-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -214,7 +214,7 @@ iq2000_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -250,9 +250,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -261,7 +261,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -323,7 +323,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -381,7 +381,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -400,7 +400,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -416,9 +416,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/iq2000-ibld.c b/opcodes/iq2000-ibld.c
index 023a2cb..a3816c7 100644
--- a/opcodes/iq2000-ibld.c
+++ b/opcodes/iq2000-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -620,14 +620,14 @@ iq2000_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case IQ2000_OPERAND_JMPTARG :
       {
-        long value = fields->f_jtarg;
+        long long value = fields->f_jtarg;
         value = ((USI) (((value) & (262143))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_ABS_ADDR), 0, 15, 16, 32, total_length, buffer);
       }
       break;
     case IQ2000_OPERAND_JMPTARGQ10 :
       {
-        long value = fields->f_jtargq10;
+        long long value = fields->f_jtargq10;
         value = ((USI) (((value) & (8388607))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_ABS_ADDR), 0, 20, 21, 32, total_length, buffer);
       }
@@ -652,7 +652,7 @@ iq2000_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case IQ2000_OPERAND_OFFSET :
       {
-        long value = fields->f_offset;
+        long long value = fields->f_offset;
         value = ((SI) (((value) - (pc))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 16, 32, total_length, buffer);
       }
@@ -802,7 +802,7 @@ iq2000_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case IQ2000_OPERAND_JMPTARG :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_ABS_ADDR), 0, 15, 16, 32, total_length, pc, & value);
         value = ((((pc) & (0xf0000000))) | (((value) << (2))));
         fields->f_jtarg = value;
@@ -810,7 +810,7 @@ iq2000_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case IQ2000_OPERAND_JMPTARGQ10 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_ABS_ADDR), 0, 20, 21, 32, total_length, pc, & value);
         value = ((((pc) & (0xf0000000))) | (((value) << (2))));
         fields->f_jtargq10 = value;
@@ -836,7 +836,7 @@ iq2000_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case IQ2000_OPERAND_OFFSET :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 16, 32, total_length, pc, & value);
         value = ((((value) << (2))) + (((pc) + (4))));
         fields->f_offset = value;
diff --git a/opcodes/iq2000-opc.h b/opcodes/iq2000-opc.h
index 597d587..706c201 100644
--- a/opcodes/iq2000-opc.h
+++ b/opcodes/iq2000-opc.h
@@ -130,43 +130,43 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_opcode;
-  long f_rs;
-  long f_rt;
-  long f_rd;
-  long f_shamt;
-  long f_cp_op;
-  long f_cp_op_10;
-  long f_cp_grp;
-  long f_func;
-  long f_imm;
-  long f_rd_rs;
-  long f_rd_rt;
-  long f_rt_rs;
-  long f_jtarg;
-  long f_jtargq10;
-  long f_offset;
-  long f_count;
-  long f_bytecount;
-  long f_index;
-  long f_mask;
-  long f_maskq10;
-  long f_maskl;
-  long f_excode;
-  long f_rsrvd;
-  long f_10_11;
-  long f_24_19;
-  long f_5;
-  long f_10;
-  long f_25;
-  long f_cam_z;
-  long f_cam_y;
-  long f_cm_3func;
-  long f_cm_4func;
-  long f_cm_3z;
-  long f_cm_4z;
+  long long f_nil;
+  long long f_anyof;
+  long long f_opcode;
+  long long f_rs;
+  long long f_rt;
+  long long f_rd;
+  long long f_shamt;
+  long long f_cp_op;
+  long long f_cp_op_10;
+  long long f_cp_grp;
+  long long f_func;
+  long long f_imm;
+  long long f_rd_rs;
+  long long f_rd_rt;
+  long long f_rt_rs;
+  long long f_jtarg;
+  long long f_jtargq10;
+  long long f_offset;
+  long long f_count;
+  long long f_bytecount;
+  long long f_index;
+  long long f_mask;
+  long long f_maskq10;
+  long long f_maskl;
+  long long f_excode;
+  long long f_rsrvd;
+  long long f_10_11;
+  long long f_24_19;
+  long long f_5;
+  long long f_10;
+  long long f_25;
+  long long f_cam_z;
+  long long f_cam_y;
+  long long f_cm_3func;
+  long long f_cm_4func;
+  long long f_cm_3z;
+  long long f_cm_4z;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/lm32-asm.c b/opcodes/lm32-asm.c
index 46c1a83..e85c252 100644
--- a/opcodes/lm32-asm.c
+++ b/opcodes/lm32-asm.c
@@ -57,15 +57,15 @@ static const char *
 parse_imm (CGEN_CPU_DESC cd,
 	   const char **strp,
 	   int opindex,
-	   unsigned long *valuep)
+	   unsigned long long *valuep)
 {
   const char *errmsg;
-  signed long value;
+  signed long long value;
 
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg == NULL)
     {
-      unsigned long x = value & 0xFFFF0000;
+      unsigned long long x = value & 0xFFFF0000;
       if (x != 0 && x != 0xFFFF0000)
         errmsg = _("immediate value out of range");
       else
@@ -80,7 +80,7 @@ static const char *
 parse_hi16 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   if (strncasecmp (*strp, "hi(", 3) == 0)
     {
@@ -112,7 +112,7 @@ static const char *
 parse_lo16 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   if (strncasecmp (*strp, "lo(", 3) == 0)
     {
@@ -142,7 +142,7 @@ static const char *
 parse_gp16 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    long *valuep)
+	    long long *valuep)
 {
   if (strncasecmp (*strp, "gp(", 3) == 0)
     {
@@ -172,7 +172,7 @@ static const char *
 parse_got16 (CGEN_CPU_DESC cd,
 	     const char **strp,
 	     int opindex,
-	     long *valuep)
+	     long long *valuep)
 {
   if (strncasecmp (*strp, "got(", 4) == 0)
     {
@@ -202,7 +202,7 @@ static const char *
 parse_gotoff_hi16 (CGEN_CPU_DESC cd,
 		   const char **strp,
 		   int opindex,
-		   long *valuep)
+		   long long *valuep)
 {
   if (strncasecmp (*strp, "gotoffhi16(", 11) == 0)
     {
@@ -232,7 +232,7 @@ static const char *
 parse_gotoff_lo16 (CGEN_CPU_DESC cd,
 		   const char **strp,
 		   int opindex,
-		   long *valuep)
+		   long long *valuep)
 {
   if (strncasecmp (*strp, "gotofflo16(", 11) == 0)
     {
@@ -280,7 +280,7 @@ lm32_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
@@ -302,28 +302,28 @@ lm32_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & lm32_cgen_opval_h_csr, & fields->f_csr);
       break;
     case LM32_OPERAND_EXCEPTION :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_EXCEPTION, (unsigned long *) (& fields->f_exception));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_EXCEPTION, (unsigned long long *) (& fields->f_exception));
       break;
     case LM32_OPERAND_GOT16 :
-      errmsg = parse_got16 (cd, strp, LM32_OPERAND_GOT16, (long *) (& fields->f_imm));
+      errmsg = parse_got16 (cd, strp, LM32_OPERAND_GOT16, (long long *) (& fields->f_imm));
       break;
     case LM32_OPERAND_GOTOFFHI16 :
-      errmsg = parse_gotoff_hi16 (cd, strp, LM32_OPERAND_GOTOFFHI16, (long *) (& fields->f_imm));
+      errmsg = parse_gotoff_hi16 (cd, strp, LM32_OPERAND_GOTOFFHI16, (long long *) (& fields->f_imm));
       break;
     case LM32_OPERAND_GOTOFFLO16 :
-      errmsg = parse_gotoff_lo16 (cd, strp, LM32_OPERAND_GOTOFFLO16, (long *) (& fields->f_imm));
+      errmsg = parse_gotoff_lo16 (cd, strp, LM32_OPERAND_GOTOFFLO16, (long long *) (& fields->f_imm));
       break;
     case LM32_OPERAND_GP16 :
-      errmsg = parse_gp16 (cd, strp, LM32_OPERAND_GP16, (long *) (& fields->f_imm));
+      errmsg = parse_gp16 (cd, strp, LM32_OPERAND_GP16, (long long *) (& fields->f_imm));
       break;
     case LM32_OPERAND_HI16 :
-      errmsg = parse_hi16 (cd, strp, LM32_OPERAND_HI16, (unsigned long *) (& fields->f_uimm));
+      errmsg = parse_hi16 (cd, strp, LM32_OPERAND_HI16, (unsigned long long *) (& fields->f_uimm));
       break;
     case LM32_OPERAND_IMM :
-      errmsg = cgen_parse_signed_integer (cd, strp, LM32_OPERAND_IMM, (long *) (& fields->f_imm));
+      errmsg = cgen_parse_signed_integer (cd, strp, LM32_OPERAND_IMM, (long long *) (& fields->f_imm));
       break;
     case LM32_OPERAND_LO16 :
-      errmsg = parse_lo16 (cd, strp, LM32_OPERAND_LO16, (unsigned long *) (& fields->f_uimm));
+      errmsg = parse_lo16 (cd, strp, LM32_OPERAND_LO16, (unsigned long long *) (& fields->f_uimm));
       break;
     case LM32_OPERAND_R0 :
       errmsg = cgen_parse_keyword (cd, strp, & lm32_cgen_opval_h_gr, & fields->f_r0);
@@ -335,13 +335,13 @@ lm32_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & lm32_cgen_opval_h_gr, & fields->f_r2);
       break;
     case LM32_OPERAND_SHIFT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_SHIFT, (unsigned long *) (& fields->f_shift));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_SHIFT, (unsigned long long *) (& fields->f_shift));
       break;
     case LM32_OPERAND_UIMM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_UIMM, (unsigned long *) (& fields->f_uimm));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_UIMM, (unsigned long long *) (& fields->f_uimm));
       break;
     case LM32_OPERAND_USER :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_USER, (unsigned long *) (& fields->f_user));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_USER, (unsigned long long *) (& fields->f_user));
       break;
 
     default :
diff --git a/opcodes/lm32-dis.c b/opcodes/lm32-dis.c
index 90e67c7..e00b2c0 100644
--- a/opcodes/lm32-dis.c
+++ b/opcodes/lm32-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -172,7 +172,7 @@ lm32_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -208,9 +208,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -219,7 +219,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -281,7 +281,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -339,7 +339,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -358,7 +358,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -374,9 +374,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/lm32-ibld.c b/opcodes/lm32-ibld.c
index ecddfbd..73e4420 100644
--- a/opcodes/lm32-ibld.c
+++ b/opcodes/lm32-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -575,14 +575,14 @@ lm32_cgen_insert_operand (CGEN_CPU_DESC cd,
     {
     case LM32_OPERAND_BRANCH :
       {
-        long value = fields->f_branch;
+        long long value = fields->f_branch;
         value = ((SI) (((value) - (pc))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 16, 32, total_length, buffer);
       }
       break;
     case LM32_OPERAND_CALL :
       {
-        long value = fields->f_call;
+        long long value = fields->f_call;
         value = ((SI) (((value) - (pc))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, buffer);
       }
@@ -678,7 +678,7 @@ lm32_cgen_extract_operand (CGEN_CPU_DESC cd,
     {
     case LM32_OPERAND_BRANCH :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 16, 32, total_length, pc, & value);
         value = ((pc) + (((SI) (((value) << (16))) >> (14))));
         fields->f_branch = value;
@@ -686,7 +686,7 @@ lm32_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case LM32_OPERAND_CALL :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, pc, & value);
         value = ((pc) + (((SI) (((value) << (6))) >> (4))));
         fields->f_call = value;
diff --git a/opcodes/lm32-opc.h b/opcodes/lm32-opc.h
index 5cf33ba..e0ba9cc 100644
--- a/opcodes/lm32-opc.h
+++ b/opcodes/lm32-opc.h
@@ -76,21 +76,21 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_opcode;
-  long f_r0;
-  long f_r1;
-  long f_r2;
-  long f_resv0;
-  long f_shift;
-  long f_imm;
-  long f_uimm;
-  long f_csr;
-  long f_user;
-  long f_exception;
-  long f_branch;
-  long f_call;
+  long long f_nil;
+  long long f_anyof;
+  long long f_opcode;
+  long long f_r0;
+  long long f_r1;
+  long long f_r2;
+  long long f_resv0;
+  long long f_shift;
+  long long f_imm;
+  long long f_uimm;
+  long long f_csr;
+  long long f_user;
+  long long f_exception;
+  long long f_branch;
+  long long f_call;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/m10200-dis.c b/opcodes/m10200-dis.c
index 501ba71..1a4ed3b 100644
--- a/opcodes/m10200-dis.c
+++ b/opcodes/m10200-dis.c
@@ -27,8 +27,8 @@
 static void
 disassemble (bfd_vma memaddr,
 	     struct disassemble_info *info,
-	     unsigned long insn,
-	     unsigned long extension,
+	     unsigned long long insn,
+	     unsigned long long extension,
 	     unsigned int size)
 {
   struct mn10200_opcode *op = (struct mn10200_opcode *)mn10200_opcodes;
@@ -79,7 +79,7 @@ disassemble (bfd_vma memaddr,
 	       *opindex_ptr != 0;
 	       opindex_ptr++)
 	    {
-	      unsigned long value;
+	      unsigned long long value;
 
 	      operand = &mn10200_operands[*opindex_ptr];
 
@@ -95,7 +95,7 @@ disassemble (bfd_vma memaddr,
 		}
 
 	      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
-		value = ((long)(value << (32 - operand->bits))
+		value = ((long long)(value << (32 - operand->bits))
 			  >> (32 - operand->bits));
 
 	      if (!nocomma
@@ -162,8 +162,8 @@ print_insn_mn10200 (bfd_vma memaddr, struct disassemble_info *info)
 {
   int status;
   bfd_byte buffer[4];
-  unsigned long insn;
-  unsigned long extension = 0;
+  unsigned long long insn;
+  unsigned long long extension = 0;
   unsigned int consume;
 
   /* First figure out how big the opcode is.  */
diff --git a/opcodes/m10300-dis.c b/opcodes/m10300-dis.c
index 38bd520..4729aea 100644
--- a/opcodes/m10300-dis.c
+++ b/opcodes/m10300-dis.c
@@ -31,13 +31,13 @@
 static void
 disassemble (bfd_vma memaddr,
 	     struct disassemble_info *info,
-	     unsigned long insn,
+	     unsigned long long insn,
 	     unsigned int size)
 {
   struct mn10300_opcode *op = (struct mn10300_opcode *) mn10300_opcodes;
   const struct mn10300_operand *operand;
   bfd_byte buffer[4];
-  unsigned long extension = 0;
+  unsigned long long extension = 0;
   int status, match = 0;
 
   /* Find the opcode.  */
@@ -148,7 +148,7 @@ disassemble (bfd_vma memaddr,
 	    }
 	  else if (size == 5 && op->opcode == 0xdc000000)
 	    {
-	      unsigned long temp = 0;
+	      unsigned long long temp = 0;
 
 	      status = (*info->read_memory_func) (memaddr + 1, buffer, 4, info);
 	      if (status != 0)
@@ -183,7 +183,7 @@ disassemble (bfd_vma memaddr,
 	    }
 	  else if (size == 5)
 	    {
-	      unsigned long temp = 0;
+	      unsigned long long temp = 0;
 
 	      status = (*info->read_memory_func) (memaddr + 1, buffer, 2, info);
 	      if (status != 0)
@@ -225,7 +225,7 @@ disassemble (bfd_vma memaddr,
 	    }
 	  else if (size == 6)
 	    {
-	      unsigned long temp = 0;
+	      unsigned long long temp = 0;
 
 	      status = (*info->read_memory_func) (memaddr + 2, buffer, 4, info);
 	      if (status != 0)
@@ -254,7 +254,7 @@ disassemble (bfd_vma memaddr,
 	    }
 	  else if (size == 7 && op->opcode == 0xdd000000)
 	    {
-	      unsigned long temp = 0;
+	      unsigned long long temp = 0;
 
 	      status = (*info->read_memory_func) (memaddr + 1, buffer, 4, info);
 	      if (status != 0)
@@ -278,7 +278,7 @@ disassemble (bfd_vma memaddr,
 	    }
 	  else if (size == 7)
 	    {
-	      unsigned long temp = 0;
+	      unsigned long long temp = 0;
 
 	      status = (*info->read_memory_func) (memaddr + 2, buffer, 4, info);
 	      if (status != 0)
@@ -309,7 +309,7 @@ disassemble (bfd_vma memaddr,
 	       *opindex_ptr != 0;
 	       opindex_ptr++)
 	    {
-	      unsigned long value;
+	      unsigned long long value;
 
 	      operand = &mn10300_operands[*opindex_ptr];
 
@@ -320,19 +320,19 @@ disassemble (bfd_vma memaddr,
 
 	      if ((operand->flags & MN10300_OPERAND_SPLIT) != 0)
 		{
-		  unsigned long temp;
+		  unsigned long long temp;
 
 		  value = insn & ((1 << operand->bits) - 1);
 		  value <<= (32 - operand->bits);
 		  temp = extension >> operand->shift;
 		  temp &= ((1 << (32 - operand->bits)) - 1);
 		  value |= temp;
-		  value = ((value ^ (((unsigned long) 1) << 31))
-			   - (((unsigned long) 1) << 31));
+		  value = ((value ^ (((unsigned long long) 1) << 31))
+			   - (((unsigned long long) 1) << 31));
 		}
 	      else if ((operand->flags & MN10300_OPERAND_24BIT) != 0)
 		{
-		  unsigned long temp;
+		  unsigned long long temp;
 
 		  value = insn & ((1 << operand->bits) - 1);
 		  value <<= (24 - operand->bits);
@@ -349,7 +349,7 @@ disassemble (bfd_vma memaddr,
 		     explanation of these variables.  Note that
 		     FMT-implied shifts are not taken into account for
 		     FP registers.  */
-		  unsigned long mask_low, mask_high;
+		  unsigned long long mask_low, mask_high;
 		  int shl_low, shr_high, shl_high;
 
 		  switch (operand->bits)
@@ -399,8 +399,8 @@ disassemble (bfd_vma memaddr,
 	      if ((operand->flags & MN10300_OPERAND_SIGNED) != 0
 		  /* These are properly extended by the code above.  */
 		  && ((operand->flags & MN10300_OPERAND_24BIT) == 0))
-		value = ((value ^ (((unsigned long) 1) << (operand->bits - 1)))
-			 - (((unsigned long) 1) << (operand->bits - 1)));
+		value = ((value ^ (((unsigned long long) 1) << (operand->bits - 1)))
+			 - (((unsigned long long) 1) << (operand->bits - 1)));
 
 	      if (!nocomma
 		  && (!paren
@@ -494,7 +494,7 @@ disassemble (bfd_vma memaddr,
 		}
 
 	      else if ((operand->flags & MN10300_OPERAND_PCREL) != 0)
-		(*info->print_address_func) ((long) value + memaddr, info);
+		(*info->print_address_func) ((long long) value + memaddr, info);
 
 	      else if ((operand->flags & MN10300_OPERAND_MEMADDR) != 0)
 		(*info->print_address_func) (value, info);
@@ -567,7 +567,7 @@ disassemble (bfd_vma memaddr,
 		}
 
 	      else
-		(*info->fprintf_func) (info->stream, "%ld", (long) value);
+		(*info->fprintf_func) (info->stream, "%ld", (long long) value);
 	    }
 	  /* All done. */
 	  break;
@@ -585,7 +585,7 @@ print_insn_mn10300 (bfd_vma memaddr, struct disassemble_info *info)
 {
   int status;
   bfd_byte buffer[4];
-  unsigned long insn;
+  unsigned long long insn;
   unsigned int consume;
 
   /* First figure out how big the opcode is.  */
diff --git a/opcodes/m32c-asm.c b/opcodes/m32c-asm.c
index 206eaaf..960cdab 100644
--- a/opcodes/m32c-asm.c
+++ b/opcodes/m32c-asm.c
@@ -106,10 +106,10 @@ m32c_cgen_isa_register (const char **strp)
 
 static const char *
 parse_unsigned6 (CGEN_CPU_DESC cd, const char **strp,
-		 int opindex, unsigned long *valuep)
+		 int opindex, unsigned long long *valuep)
 {
   const char *errmsg = 0;
-  unsigned long value;
+  unsigned long long value;
 
   PARSE_UNSIGNED;
 
@@ -122,11 +122,11 @@ parse_unsigned6 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_unsigned8 (CGEN_CPU_DESC cd, const char **strp,
-		 int opindex, unsigned long *valuep)
+		 int opindex, unsigned long long *valuep)
 {
   const char *errmsg = 0;
-  unsigned long value = 0;
-  long have_zero = 0;
+  unsigned long long value = 0;
+  long long have_zero = 0;
 
   if (strncasecmp (*strp, "%dsp8(", 6) == 0)
     {
@@ -168,11 +168,11 @@ parse_unsigned8 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_signed4 (CGEN_CPU_DESC cd, const char **strp,
-	       int opindex, signed long *valuep)
+	       int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
-  long have_zero = 0;
+  signed long long value;
+  long long have_zero = 0;
 
   if (strncmp (*strp, "0x0", 3) == 0
       || (**strp == '0' && *(*strp + 1) != 'x'))
@@ -193,11 +193,11 @@ parse_signed4 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_signed4n (CGEN_CPU_DESC cd, const char **strp,
-		int opindex, signed long *valuep)
+		int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
-  long have_zero = 0;
+  signed long long value;
+  long long have_zero = 0;
 
   if (strncmp (*strp, "0x0", 3) == 0
       || (**strp == '0' && *(*strp + 1) != 'x'))
@@ -218,10 +218,10 @@ parse_signed4n (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_signed8 (CGEN_CPU_DESC cd, const char **strp,
-	       int opindex, signed long *valuep)
+	       int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value = 0;
+  signed long long value = 0;
 
   if (strncasecmp (*strp, "%hi8(", 5) == 0)
     {
@@ -258,11 +258,11 @@ parse_signed8 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_unsigned16 (CGEN_CPU_DESC cd, const char **strp,
-		 int opindex, unsigned long *valuep)
+		 int opindex, unsigned long long *valuep)
 {
   const char *errmsg = 0;
-  unsigned long value = 0;
-  long have_zero = 0;
+  unsigned long long value = 0;
+  long long have_zero = 0;
 
   if (strncasecmp (*strp, "%dsp16(", 7) == 0)
     {
@@ -317,10 +317,10 @@ parse_unsigned16 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_signed16 (CGEN_CPU_DESC cd, const char **strp,
-	       int opindex, signed long *valuep)
+	       int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value = 0;
+  signed long long value = 0;
 
   if (strncasecmp (*strp, "%lo16(", 6) == 0)
     {
@@ -378,10 +378,10 @@ parse_signed16 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_unsigned20 (CGEN_CPU_DESC cd, const char **strp,
-		 int opindex, unsigned long *valuep)
+		 int opindex, unsigned long long *valuep)
 {
   const char *errmsg = 0;
-  unsigned long value;
+  unsigned long long value;
 
   /* Don't successfully parse literals beginning with '['.  */
   if (**strp == '[')
@@ -404,10 +404,10 @@ parse_unsigned20 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_unsigned24 (CGEN_CPU_DESC cd, const char **strp,
-		 int opindex, unsigned long *valuep)
+		 int opindex, unsigned long long *valuep)
 {
   const char *errmsg = 0;
-  unsigned long value;
+  unsigned long long value;
 
   /* Don't successfully parse literals beginning with '['.  */
   if (**strp == '[')
@@ -431,10 +431,10 @@ parse_unsigned24 (CGEN_CPU_DESC cd, const char **strp,
 /* This should only be used for #imm->reg.  */
 static const char *
 parse_signed24 (CGEN_CPU_DESC cd, const char **strp,
-		 int opindex, signed long *valuep)
+		 int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
+  signed long long value;
 
   PARSE_SIGNED;
 
@@ -450,10 +450,10 @@ parse_signed24 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_signed32 (CGEN_CPU_DESC cd, const char **strp,
-		int opindex, signed long *valuep)
+		int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
+  signed long long value;
 
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg)
@@ -465,10 +465,10 @@ parse_signed32 (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_imm1_S (CGEN_CPU_DESC cd, const char **strp,
-	     int opindex, signed long *valuep)
+	     int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
+  signed long long value;
 
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg)
@@ -483,10 +483,10 @@ parse_imm1_S (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_imm3_S (CGEN_CPU_DESC cd, const char **strp,
-	     int opindex, signed long *valuep)
+	     int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
+  signed long long value;
 
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg)
@@ -501,10 +501,10 @@ parse_imm3_S (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_bit3_S (CGEN_CPU_DESC cd, const char **strp,
-	     int opindex, signed long *valuep)
+	     int opindex, signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
+  signed long long value;
 
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg)
@@ -555,10 +555,10 @@ parse_lab_5_3 (CGEN_CPU_DESC cd,
 
 static const char *
 parse_Bitno16R (CGEN_CPU_DESC cd, const char **strp,
-		int opindex, unsigned long *valuep)
+		int opindex, unsigned long long *valuep)
 {
   const char *errmsg = 0;
-  unsigned long value;
+  unsigned long long value;
 
   errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
   if (errmsg)
@@ -573,15 +573,15 @@ parse_Bitno16R (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_unsigned_bitbase (CGEN_CPU_DESC cd, const char **strp,
-			int opindex, unsigned long *valuep,
+			int opindex, unsigned long long *valuep,
 			unsigned bits, int allow_syms)
 {
   const char *errmsg = 0;
-  unsigned long bit;
-  unsigned long base;
+  unsigned long long bit;
+  unsigned long long base;
   const char *newp = *strp;
   unsigned long long bitbase;
-  long have_zero = 0;
+  long long have_zero = 0;
 
   errmsg = cgen_parse_unsigned_integer (cd, & newp, opindex, & bit);
   if (errmsg)
@@ -627,16 +627,16 @@ parse_unsigned_bitbase (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_signed_bitbase (CGEN_CPU_DESC cd, const char **strp,
-		      int opindex, signed long *valuep,
+		      int opindex, signed long long *valuep,
 		      unsigned bits, int allow_syms)
 {
   const char *errmsg = 0;
-  unsigned long bit;
-  signed long base;
+  unsigned long long bit;
+  signed long long base;
   const char *newp = *strp;
   long long bitbase;
   long long limit;
-  long have_zero = 0;
+  long long have_zero = 0;
 
   errmsg = cgen_parse_unsigned_integer (cd, & newp, opindex, & bit);
   if (errmsg)
@@ -672,56 +672,56 @@ parse_signed_bitbase (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_unsigned_bitbase8 (CGEN_CPU_DESC cd, const char **strp,
-			 int opindex, unsigned long *valuep)
+			 int opindex, unsigned long long *valuep)
 {
   return parse_unsigned_bitbase (cd, strp, opindex, valuep, 8, 0);
 }
 
 static const char *
 parse_unsigned_bitbase11 (CGEN_CPU_DESC cd, const char **strp,
-			 int opindex, unsigned long *valuep)
+			 int opindex, unsigned long long *valuep)
 {
   return parse_unsigned_bitbase (cd, strp, opindex, valuep, 11, 0);
 }
 
 static const char *
 parse_unsigned_bitbase16 (CGEN_CPU_DESC cd, const char **strp,
-			  int opindex, unsigned long *valuep)
+			  int opindex, unsigned long long *valuep)
 {
   return parse_unsigned_bitbase (cd, strp, opindex, valuep, 16, 1);
 }
 
 static const char *
 parse_unsigned_bitbase19 (CGEN_CPU_DESC cd, const char **strp,
-			 int opindex, unsigned long *valuep)
+			 int opindex, unsigned long long *valuep)
 {
   return parse_unsigned_bitbase (cd, strp, opindex, valuep, 19, 2);
 }
 
 static const char *
 parse_unsigned_bitbase27 (CGEN_CPU_DESC cd, const char **strp,
-			 int opindex, unsigned long *valuep)
+			 int opindex, unsigned long long *valuep)
 {
   return parse_unsigned_bitbase (cd, strp, opindex, valuep, 27, 1);
 }
 
 static const char *
 parse_signed_bitbase8 (CGEN_CPU_DESC cd, const char **strp,
-		       int opindex, signed long *valuep)
+		       int opindex, signed long long *valuep)
 {
   return parse_signed_bitbase (cd, strp, opindex, valuep, 8, 1);
 }
 
 static const char *
 parse_signed_bitbase11 (CGEN_CPU_DESC cd, const char **strp,
-		       int opindex, signed long *valuep)
+		       int opindex, signed long long *valuep)
 {
   return parse_signed_bitbase (cd, strp, opindex, valuep, 11, 0);
 }
 
 static const char *
 parse_signed_bitbase19 (CGEN_CPU_DESC cd, const char **strp,
-		       int opindex, signed long *valuep)
+		       int opindex, signed long long *valuep)
 {
   return parse_signed_bitbase (cd, strp, opindex, valuep, 19, 1);
 }
@@ -747,28 +747,28 @@ parse_suffix (const char **strp, char suffix)
 
 static const char *
 parse_S (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
-	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
+	 int opindex ATTRIBUTE_UNUSED, signed long long *valuep ATTRIBUTE_UNUSED)
 {
   return parse_suffix (strp, 's');
 }
 
 static const char *
 parse_G (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
-	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
+	 int opindex ATTRIBUTE_UNUSED, signed long long *valuep ATTRIBUTE_UNUSED)
 {
   return parse_suffix (strp, 'g');
 }
 
 static const char *
 parse_Q (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
-	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
+	 int opindex ATTRIBUTE_UNUSED, signed long long *valuep ATTRIBUTE_UNUSED)
 {
   return parse_suffix (strp, 'q');
 }
 
 static const char *
 parse_Z (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
-	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
+	 int opindex ATTRIBUTE_UNUSED, signed long long *valuep ATTRIBUTE_UNUSED)
 {
   return parse_suffix (strp, 'z');
 }
@@ -777,7 +777,7 @@ parse_Z (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
 
 static const char *
 parse_X (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
-	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
+	 int opindex ATTRIBUTE_UNUSED, signed long long *valuep ATTRIBUTE_UNUSED)
 {
   if (**strp == ':')
     return "Unexpected suffix";
@@ -786,11 +786,11 @@ parse_X (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
 
 static const char *
 parse_r0l_r0h (CGEN_CPU_DESC cd, const char **strp,
-	       int opindex ATTRIBUTE_UNUSED, signed long *valuep)
+	       int opindex ATTRIBUTE_UNUSED, signed long long *valuep)
 {
   const char *errmsg;
-  signed long value;
-  signed long junk;
+  signed long long value;
+  signed long long junk;
   const char *newp = *strp;
 
   /* Parse r0[hl].  */
@@ -819,7 +819,7 @@ parse_r0l_r0h (CGEN_CPU_DESC cd, const char **strp,
 
 static const char *
 parse_size (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
-	    int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
+	    int opindex ATTRIBUTE_UNUSED, signed long long *valuep ATTRIBUTE_UNUSED)
 {
   if (**strp == '.'
       && (*(*strp + 1) == 'b' || *(*strp + 1) == 'B'
@@ -855,7 +855,7 @@ static const char *
 parse_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      const char **strp,
 	      int opindex ATTRIBUTE_UNUSED,
-	      unsigned long *valuep,
+	      unsigned long long *valuep,
 	      int push)
 {
   const char *errmsg = 0;
@@ -919,7 +919,7 @@ static const char *
 parse_pop_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		  const char **strp,
 		  int opindex ATTRIBUTE_UNUSED,
-		  unsigned long *valuep)
+		  unsigned long long *valuep)
 {
   return parse_regset (cd, strp, opindex, valuep, POP);
 }
@@ -928,7 +928,7 @@ static const char *
 parse_push_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		   const char **strp,
 		   int opindex ATTRIBUTE_UNUSED,
-		   unsigned long *valuep)
+		   unsigned long long *valuep)
 {
   return parse_regset (cd, strp, opindex, valuep, PUSH);
 }
@@ -959,7 +959,7 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
@@ -979,7 +979,7 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_gr_HI, & fields->f_dst16_rn);
       break;
     case M32C_OPERAND_BIT3_S :
-      errmsg = parse_bit3_S (cd, strp, M32C_OPERAND_BIT3_S, (long *) (& fields->f_imm3_S));
+      errmsg = parse_bit3_S (cd, strp, M32C_OPERAND_BIT3_S, (long long *) (& fields->f_imm3_S));
       break;
     case M32C_OPERAND_BIT32ANPREFIXED :
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_ar, & fields->f_dst32_an_prefixed);
@@ -994,166 +994,166 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_gr_QI, & fields->f_dst32_rn_unprefixed_QI);
       break;
     case M32C_OPERAND_BITBASE16_16_S8 :
-      errmsg = parse_signed_bitbase8 (cd, strp, M32C_OPERAND_BITBASE16_16_S8, (long *) (& fields->f_dsp_16_s8));
+      errmsg = parse_signed_bitbase8 (cd, strp, M32C_OPERAND_BITBASE16_16_S8, (long long *) (& fields->f_dsp_16_s8));
       break;
     case M32C_OPERAND_BITBASE16_16_U16 :
-      errmsg = parse_unsigned_bitbase16 (cd, strp, M32C_OPERAND_BITBASE16_16_U16, (unsigned long *) (& fields->f_dsp_16_u16));
+      errmsg = parse_unsigned_bitbase16 (cd, strp, M32C_OPERAND_BITBASE16_16_U16, (unsigned long long *) (& fields->f_dsp_16_u16));
       break;
     case M32C_OPERAND_BITBASE16_16_U8 :
-      errmsg = parse_unsigned_bitbase8 (cd, strp, M32C_OPERAND_BITBASE16_16_U8, (unsigned long *) (& fields->f_dsp_16_u8));
+      errmsg = parse_unsigned_bitbase8 (cd, strp, M32C_OPERAND_BITBASE16_16_U8, (unsigned long long *) (& fields->f_dsp_16_u8));
       break;
     case M32C_OPERAND_BITBASE16_8_U11_S :
-      errmsg = parse_unsigned_bitbase11 (cd, strp, M32C_OPERAND_BITBASE16_8_U11_S, (unsigned long *) (& fields->f_bitbase16_u11_S));
+      errmsg = parse_unsigned_bitbase11 (cd, strp, M32C_OPERAND_BITBASE16_8_U11_S, (unsigned long long *) (& fields->f_bitbase16_u11_S));
       break;
     case M32C_OPERAND_BITBASE32_16_S11_UNPREFIXED :
-      errmsg = parse_signed_bitbase11 (cd, strp, M32C_OPERAND_BITBASE32_16_S11_UNPREFIXED, (long *) (& fields->f_bitbase32_16_s11_unprefixed));
+      errmsg = parse_signed_bitbase11 (cd, strp, M32C_OPERAND_BITBASE32_16_S11_UNPREFIXED, (long long *) (& fields->f_bitbase32_16_s11_unprefixed));
       break;
     case M32C_OPERAND_BITBASE32_16_S19_UNPREFIXED :
-      errmsg = parse_signed_bitbase19 (cd, strp, M32C_OPERAND_BITBASE32_16_S19_UNPREFIXED, (long *) (& fields->f_bitbase32_16_s19_unprefixed));
+      errmsg = parse_signed_bitbase19 (cd, strp, M32C_OPERAND_BITBASE32_16_S19_UNPREFIXED, (long long *) (& fields->f_bitbase32_16_s19_unprefixed));
       break;
     case M32C_OPERAND_BITBASE32_16_U11_UNPREFIXED :
-      errmsg = parse_unsigned_bitbase11 (cd, strp, M32C_OPERAND_BITBASE32_16_U11_UNPREFIXED, (unsigned long *) (& fields->f_bitbase32_16_u11_unprefixed));
+      errmsg = parse_unsigned_bitbase11 (cd, strp, M32C_OPERAND_BITBASE32_16_U11_UNPREFIXED, (unsigned long long *) (& fields->f_bitbase32_16_u11_unprefixed));
       break;
     case M32C_OPERAND_BITBASE32_16_U19_UNPREFIXED :
-      errmsg = parse_unsigned_bitbase19 (cd, strp, M32C_OPERAND_BITBASE32_16_U19_UNPREFIXED, (unsigned long *) (& fields->f_bitbase32_16_u19_unprefixed));
+      errmsg = parse_unsigned_bitbase19 (cd, strp, M32C_OPERAND_BITBASE32_16_U19_UNPREFIXED, (unsigned long long *) (& fields->f_bitbase32_16_u19_unprefixed));
       break;
     case M32C_OPERAND_BITBASE32_16_U27_UNPREFIXED :
-      errmsg = parse_unsigned_bitbase27 (cd, strp, M32C_OPERAND_BITBASE32_16_U27_UNPREFIXED, (unsigned long *) (& fields->f_bitbase32_16_u27_unprefixed));
+      errmsg = parse_unsigned_bitbase27 (cd, strp, M32C_OPERAND_BITBASE32_16_U27_UNPREFIXED, (unsigned long long *) (& fields->f_bitbase32_16_u27_unprefixed));
       break;
     case M32C_OPERAND_BITBASE32_24_S11_PREFIXED :
-      errmsg = parse_signed_bitbase11 (cd, strp, M32C_OPERAND_BITBASE32_24_S11_PREFIXED, (long *) (& fields->f_bitbase32_24_s11_prefixed));
+      errmsg = parse_signed_bitbase11 (cd, strp, M32C_OPERAND_BITBASE32_24_S11_PREFIXED, (long long *) (& fields->f_bitbase32_24_s11_prefixed));
       break;
     case M32C_OPERAND_BITBASE32_24_S19_PREFIXED :
-      errmsg = parse_signed_bitbase19 (cd, strp, M32C_OPERAND_BITBASE32_24_S19_PREFIXED, (long *) (& fields->f_bitbase32_24_s19_prefixed));
+      errmsg = parse_signed_bitbase19 (cd, strp, M32C_OPERAND_BITBASE32_24_S19_PREFIXED, (long long *) (& fields->f_bitbase32_24_s19_prefixed));
       break;
     case M32C_OPERAND_BITBASE32_24_U11_PREFIXED :
-      errmsg = parse_unsigned_bitbase11 (cd, strp, M32C_OPERAND_BITBASE32_24_U11_PREFIXED, (unsigned long *) (& fields->f_bitbase32_24_u11_prefixed));
+      errmsg = parse_unsigned_bitbase11 (cd, strp, M32C_OPERAND_BITBASE32_24_U11_PREFIXED, (unsigned long long *) (& fields->f_bitbase32_24_u11_prefixed));
       break;
     case M32C_OPERAND_BITBASE32_24_U19_PREFIXED :
-      errmsg = parse_unsigned_bitbase19 (cd, strp, M32C_OPERAND_BITBASE32_24_U19_PREFIXED, (unsigned long *) (& fields->f_bitbase32_24_u19_prefixed));
+      errmsg = parse_unsigned_bitbase19 (cd, strp, M32C_OPERAND_BITBASE32_24_U19_PREFIXED, (unsigned long long *) (& fields->f_bitbase32_24_u19_prefixed));
       break;
     case M32C_OPERAND_BITBASE32_24_U27_PREFIXED :
-      errmsg = parse_unsigned_bitbase27 (cd, strp, M32C_OPERAND_BITBASE32_24_U27_PREFIXED, (unsigned long *) (& fields->f_bitbase32_24_u27_prefixed));
+      errmsg = parse_unsigned_bitbase27 (cd, strp, M32C_OPERAND_BITBASE32_24_U27_PREFIXED, (unsigned long long *) (& fields->f_bitbase32_24_u27_prefixed));
       break;
     case M32C_OPERAND_BITNO16R :
-      errmsg = parse_Bitno16R (cd, strp, M32C_OPERAND_BITNO16R, (unsigned long *) (& fields->f_dsp_16_u8));
+      errmsg = parse_Bitno16R (cd, strp, M32C_OPERAND_BITNO16R, (unsigned long long *) (& fields->f_dsp_16_u8));
       break;
     case M32C_OPERAND_BITNO32PREFIXED :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, M32C_OPERAND_BITNO32PREFIXED, (unsigned long *) (& fields->f_bitno32_prefixed));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, M32C_OPERAND_BITNO32PREFIXED, (unsigned long long *) (& fields->f_bitno32_prefixed));
       break;
     case M32C_OPERAND_BITNO32UNPREFIXED :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, M32C_OPERAND_BITNO32UNPREFIXED, (unsigned long *) (& fields->f_bitno32_unprefixed));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, M32C_OPERAND_BITNO32UNPREFIXED, (unsigned long long *) (& fields->f_bitno32_unprefixed));
       break;
     case M32C_OPERAND_DSP_10_U6 :
-      errmsg = parse_unsigned6 (cd, strp, M32C_OPERAND_DSP_10_U6, (unsigned long *) (& fields->f_dsp_10_u6));
+      errmsg = parse_unsigned6 (cd, strp, M32C_OPERAND_DSP_10_U6, (unsigned long long *) (& fields->f_dsp_10_u6));
       break;
     case M32C_OPERAND_DSP_16_S16 :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_16_S16, (long *) (& fields->f_dsp_16_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_16_S16, (long long *) (& fields->f_dsp_16_s16));
       break;
     case M32C_OPERAND_DSP_16_S8 :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_16_S8, (long *) (& fields->f_dsp_16_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_16_S8, (long long *) (& fields->f_dsp_16_s8));
       break;
     case M32C_OPERAND_DSP_16_U16 :
-      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_16_U16, (unsigned long *) (& fields->f_dsp_16_u16));
+      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_16_U16, (unsigned long long *) (& fields->f_dsp_16_u16));
       break;
     case M32C_OPERAND_DSP_16_U20 :
-      errmsg = parse_unsigned20 (cd, strp, M32C_OPERAND_DSP_16_U20, (unsigned long *) (& fields->f_dsp_16_u24));
+      errmsg = parse_unsigned20 (cd, strp, M32C_OPERAND_DSP_16_U20, (unsigned long long *) (& fields->f_dsp_16_u24));
       break;
     case M32C_OPERAND_DSP_16_U24 :
-      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_16_U24, (unsigned long *) (& fields->f_dsp_16_u24));
+      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_16_U24, (unsigned long long *) (& fields->f_dsp_16_u24));
       break;
     case M32C_OPERAND_DSP_16_U8 :
-      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_16_U8, (unsigned long *) (& fields->f_dsp_16_u8));
+      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_16_U8, (unsigned long long *) (& fields->f_dsp_16_u8));
       break;
     case M32C_OPERAND_DSP_24_S16 :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_24_S16, (long *) (& fields->f_dsp_24_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_24_S16, (long long *) (& fields->f_dsp_24_s16));
       break;
     case M32C_OPERAND_DSP_24_S8 :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_24_S8, (long *) (& fields->f_dsp_24_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_24_S8, (long long *) (& fields->f_dsp_24_s8));
       break;
     case M32C_OPERAND_DSP_24_U16 :
-      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_24_U16, (unsigned long *) (& fields->f_dsp_24_u16));
+      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_24_U16, (unsigned long long *) (& fields->f_dsp_24_u16));
       break;
     case M32C_OPERAND_DSP_24_U20 :
-      errmsg = parse_unsigned20 (cd, strp, M32C_OPERAND_DSP_24_U20, (unsigned long *) (& fields->f_dsp_24_u24));
+      errmsg = parse_unsigned20 (cd, strp, M32C_OPERAND_DSP_24_U20, (unsigned long long *) (& fields->f_dsp_24_u24));
       break;
     case M32C_OPERAND_DSP_24_U24 :
-      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_24_U24, (unsigned long *) (& fields->f_dsp_24_u24));
+      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_24_U24, (unsigned long long *) (& fields->f_dsp_24_u24));
       break;
     case M32C_OPERAND_DSP_24_U8 :
-      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_24_U8, (unsigned long *) (& fields->f_dsp_24_u8));
+      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_24_U8, (unsigned long long *) (& fields->f_dsp_24_u8));
       break;
     case M32C_OPERAND_DSP_32_S16 :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_32_S16, (long *) (& fields->f_dsp_32_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_32_S16, (long long *) (& fields->f_dsp_32_s16));
       break;
     case M32C_OPERAND_DSP_32_S8 :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_32_S8, (long *) (& fields->f_dsp_32_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_32_S8, (long long *) (& fields->f_dsp_32_s8));
       break;
     case M32C_OPERAND_DSP_32_U16 :
-      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_32_U16, (unsigned long *) (& fields->f_dsp_32_u16));
+      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_32_U16, (unsigned long long *) (& fields->f_dsp_32_u16));
       break;
     case M32C_OPERAND_DSP_32_U20 :
-      errmsg = parse_unsigned20 (cd, strp, M32C_OPERAND_DSP_32_U20, (unsigned long *) (& fields->f_dsp_32_u24));
+      errmsg = parse_unsigned20 (cd, strp, M32C_OPERAND_DSP_32_U20, (unsigned long long *) (& fields->f_dsp_32_u24));
       break;
     case M32C_OPERAND_DSP_32_U24 :
-      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_32_U24, (unsigned long *) (& fields->f_dsp_32_u24));
+      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_32_U24, (unsigned long long *) (& fields->f_dsp_32_u24));
       break;
     case M32C_OPERAND_DSP_32_U8 :
-      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_32_U8, (unsigned long *) (& fields->f_dsp_32_u8));
+      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_32_U8, (unsigned long long *) (& fields->f_dsp_32_u8));
       break;
     case M32C_OPERAND_DSP_40_S16 :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_40_S16, (long *) (& fields->f_dsp_40_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_40_S16, (long long *) (& fields->f_dsp_40_s16));
       break;
     case M32C_OPERAND_DSP_40_S8 :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_40_S8, (long *) (& fields->f_dsp_40_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_40_S8, (long long *) (& fields->f_dsp_40_s8));
       break;
     case M32C_OPERAND_DSP_40_U16 :
-      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_40_U16, (unsigned long *) (& fields->f_dsp_40_u16));
+      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_40_U16, (unsigned long long *) (& fields->f_dsp_40_u16));
       break;
     case M32C_OPERAND_DSP_40_U20 :
-      errmsg = parse_unsigned20 (cd, strp, M32C_OPERAND_DSP_40_U20, (unsigned long *) (& fields->f_dsp_40_u20));
+      errmsg = parse_unsigned20 (cd, strp, M32C_OPERAND_DSP_40_U20, (unsigned long long *) (& fields->f_dsp_40_u20));
       break;
     case M32C_OPERAND_DSP_40_U24 :
-      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_40_U24, (unsigned long *) (& fields->f_dsp_40_u24));
+      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_40_U24, (unsigned long long *) (& fields->f_dsp_40_u24));
       break;
     case M32C_OPERAND_DSP_40_U8 :
-      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_40_U8, (unsigned long *) (& fields->f_dsp_40_u8));
+      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_40_U8, (unsigned long long *) (& fields->f_dsp_40_u8));
       break;
     case M32C_OPERAND_DSP_48_S16 :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_48_S16, (long *) (& fields->f_dsp_48_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_DSP_48_S16, (long long *) (& fields->f_dsp_48_s16));
       break;
     case M32C_OPERAND_DSP_48_S8 :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_48_S8, (long *) (& fields->f_dsp_48_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_48_S8, (long long *) (& fields->f_dsp_48_s8));
       break;
     case M32C_OPERAND_DSP_48_U16 :
-      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_48_U16, (unsigned long *) (& fields->f_dsp_48_u16));
+      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_48_U16, (unsigned long long *) (& fields->f_dsp_48_u16));
       break;
     case M32C_OPERAND_DSP_48_U20 :
-      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_48_U20, (unsigned long *) (& fields->f_dsp_48_u20));
+      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_48_U20, (unsigned long long *) (& fields->f_dsp_48_u20));
       break;
     case M32C_OPERAND_DSP_48_U24 :
-      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_48_U24, (unsigned long *) (& fields->f_dsp_48_u24));
+      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_48_U24, (unsigned long long *) (& fields->f_dsp_48_u24));
       break;
     case M32C_OPERAND_DSP_48_U8 :
-      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_48_U8, (unsigned long *) (& fields->f_dsp_48_u8));
+      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_48_U8, (unsigned long long *) (& fields->f_dsp_48_u8));
       break;
     case M32C_OPERAND_DSP_8_S24 :
-      errmsg = parse_signed24 (cd, strp, M32C_OPERAND_DSP_8_S24, (long *) (& fields->f_dsp_8_s24));
+      errmsg = parse_signed24 (cd, strp, M32C_OPERAND_DSP_8_S24, (long long *) (& fields->f_dsp_8_s24));
       break;
     case M32C_OPERAND_DSP_8_S8 :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_8_S8, (long *) (& fields->f_dsp_8_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_DSP_8_S8, (long long *) (& fields->f_dsp_8_s8));
       break;
     case M32C_OPERAND_DSP_8_U16 :
-      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_8_U16, (unsigned long *) (& fields->f_dsp_8_u16));
+      errmsg = parse_unsigned16 (cd, strp, M32C_OPERAND_DSP_8_U16, (unsigned long long *) (& fields->f_dsp_8_u16));
       break;
     case M32C_OPERAND_DSP_8_U24 :
-      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_8_U24, (unsigned long *) (& fields->f_dsp_8_u24));
+      errmsg = parse_unsigned24 (cd, strp, M32C_OPERAND_DSP_8_U24, (unsigned long long *) (& fields->f_dsp_8_u24));
       break;
     case M32C_OPERAND_DSP_8_U6 :
-      errmsg = parse_unsigned6 (cd, strp, M32C_OPERAND_DSP_8_U6, (unsigned long *) (& fields->f_dsp_8_u6));
+      errmsg = parse_unsigned6 (cd, strp, M32C_OPERAND_DSP_8_U6, (unsigned long long *) (& fields->f_dsp_8_u6));
       break;
     case M32C_OPERAND_DSP_8_U8 :
-      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_8_U8, (unsigned long *) (& fields->f_dsp_8_u8));
+      errmsg = parse_unsigned8 (cd, strp, M32C_OPERAND_DSP_8_U8, (unsigned long long *) (& fields->f_dsp_8_u8));
       break;
     case M32C_OPERAND_DST16AN :
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_ar, & fields->f_dst16_an);
@@ -1246,85 +1246,85 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_gr_SI, & fields->f_dst32_rn_unprefixed_SI);
       break;
     case M32C_OPERAND_G :
-      errmsg = parse_G (cd, strp, M32C_OPERAND_G, (long *) (& junk));
+      errmsg = parse_G (cd, strp, M32C_OPERAND_G, (long long *) (& junk));
       break;
     case M32C_OPERAND_IMM_12_S4 :
-      errmsg = parse_signed4 (cd, strp, M32C_OPERAND_IMM_12_S4, (long *) (& fields->f_imm_12_s4));
+      errmsg = parse_signed4 (cd, strp, M32C_OPERAND_IMM_12_S4, (long long *) (& fields->f_imm_12_s4));
       break;
     case M32C_OPERAND_IMM_12_S4N :
-      errmsg = parse_signed4n (cd, strp, M32C_OPERAND_IMM_12_S4N, (long *) (& fields->f_imm_12_s4));
+      errmsg = parse_signed4n (cd, strp, M32C_OPERAND_IMM_12_S4N, (long long *) (& fields->f_imm_12_s4));
       break;
     case M32C_OPERAND_IMM_13_U3 :
-      errmsg = parse_signed4 (cd, strp, M32C_OPERAND_IMM_13_U3, (long *) (& fields->f_imm_13_u3));
+      errmsg = parse_signed4 (cd, strp, M32C_OPERAND_IMM_13_U3, (long long *) (& fields->f_imm_13_u3));
       break;
     case M32C_OPERAND_IMM_16_HI :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_16_HI, (long *) (& fields->f_dsp_16_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_16_HI, (long long *) (& fields->f_dsp_16_s16));
       break;
     case M32C_OPERAND_IMM_16_QI :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_16_QI, (long *) (& fields->f_dsp_16_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_16_QI, (long long *) (& fields->f_dsp_16_s8));
       break;
     case M32C_OPERAND_IMM_16_SI :
-      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_16_SI, (long *) (& fields->f_dsp_16_s32));
+      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_16_SI, (long long *) (& fields->f_dsp_16_s32));
       break;
     case M32C_OPERAND_IMM_20_S4 :
-      errmsg = parse_signed4 (cd, strp, M32C_OPERAND_IMM_20_S4, (long *) (& fields->f_imm_20_s4));
+      errmsg = parse_signed4 (cd, strp, M32C_OPERAND_IMM_20_S4, (long long *) (& fields->f_imm_20_s4));
       break;
     case M32C_OPERAND_IMM_24_HI :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_24_HI, (long *) (& fields->f_dsp_24_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_24_HI, (long long *) (& fields->f_dsp_24_s16));
       break;
     case M32C_OPERAND_IMM_24_QI :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_24_QI, (long *) (& fields->f_dsp_24_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_24_QI, (long long *) (& fields->f_dsp_24_s8));
       break;
     case M32C_OPERAND_IMM_24_SI :
-      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_24_SI, (long *) (& fields->f_dsp_24_s32));
+      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_24_SI, (long long *) (& fields->f_dsp_24_s32));
       break;
     case M32C_OPERAND_IMM_32_HI :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_32_HI, (long *) (& fields->f_dsp_32_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_32_HI, (long long *) (& fields->f_dsp_32_s16));
       break;
     case M32C_OPERAND_IMM_32_QI :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_32_QI, (long *) (& fields->f_dsp_32_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_32_QI, (long long *) (& fields->f_dsp_32_s8));
       break;
     case M32C_OPERAND_IMM_32_SI :
-      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_32_SI, (long *) (& fields->f_dsp_32_s32));
+      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_32_SI, (long long *) (& fields->f_dsp_32_s32));
       break;
     case M32C_OPERAND_IMM_40_HI :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_40_HI, (long *) (& fields->f_dsp_40_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_40_HI, (long long *) (& fields->f_dsp_40_s16));
       break;
     case M32C_OPERAND_IMM_40_QI :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_40_QI, (long *) (& fields->f_dsp_40_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_40_QI, (long long *) (& fields->f_dsp_40_s8));
       break;
     case M32C_OPERAND_IMM_40_SI :
-      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_40_SI, (long *) (& fields->f_dsp_40_s32));
+      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_40_SI, (long long *) (& fields->f_dsp_40_s32));
       break;
     case M32C_OPERAND_IMM_48_HI :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_48_HI, (long *) (& fields->f_dsp_48_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_48_HI, (long long *) (& fields->f_dsp_48_s16));
       break;
     case M32C_OPERAND_IMM_48_QI :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_48_QI, (long *) (& fields->f_dsp_48_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_48_QI, (long long *) (& fields->f_dsp_48_s8));
       break;
     case M32C_OPERAND_IMM_48_SI :
-      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_48_SI, (long *) (& fields->f_dsp_48_s32));
+      errmsg = parse_signed32 (cd, strp, M32C_OPERAND_IMM_48_SI, (long long *) (& fields->f_dsp_48_s32));
       break;
     case M32C_OPERAND_IMM_56_HI :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_56_HI, (long *) (& fields->f_dsp_56_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_56_HI, (long long *) (& fields->f_dsp_56_s16));
       break;
     case M32C_OPERAND_IMM_56_QI :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_56_QI, (long *) (& fields->f_dsp_56_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_56_QI, (long long *) (& fields->f_dsp_56_s8));
       break;
     case M32C_OPERAND_IMM_64_HI :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_64_HI, (long *) (& fields->f_dsp_64_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_64_HI, (long long *) (& fields->f_dsp_64_s16));
       break;
     case M32C_OPERAND_IMM_8_HI :
-      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_8_HI, (long *) (& fields->f_dsp_8_s16));
+      errmsg = parse_signed16 (cd, strp, M32C_OPERAND_IMM_8_HI, (long long *) (& fields->f_dsp_8_s16));
       break;
     case M32C_OPERAND_IMM_8_QI :
-      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_8_QI, (long *) (& fields->f_dsp_8_s8));
+      errmsg = parse_signed8 (cd, strp, M32C_OPERAND_IMM_8_QI, (long long *) (& fields->f_dsp_8_s8));
       break;
     case M32C_OPERAND_IMM_8_S4 :
-      errmsg = parse_signed4 (cd, strp, M32C_OPERAND_IMM_8_S4, (long *) (& fields->f_imm_8_s4));
+      errmsg = parse_signed4 (cd, strp, M32C_OPERAND_IMM_8_S4, (long long *) (& fields->f_imm_8_s4));
       break;
     case M32C_OPERAND_IMM_8_S4N :
-      errmsg = parse_signed4n (cd, strp, M32C_OPERAND_IMM_8_S4N, (long *) (& fields->f_imm_8_s4));
+      errmsg = parse_signed4n (cd, strp, M32C_OPERAND_IMM_8_S4N, (long long *) (& fields->f_imm_8_s4));
       break;
     case M32C_OPERAND_IMM_SH_12_S4 :
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_shimm, & fields->f_imm_12_s4);
@@ -1336,10 +1336,10 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_shimm, & fields->f_imm_8_s4);
       break;
     case M32C_OPERAND_IMM1_S :
-      errmsg = parse_imm1_S (cd, strp, M32C_OPERAND_IMM1_S, (long *) (& fields->f_imm1_S));
+      errmsg = parse_imm1_S (cd, strp, M32C_OPERAND_IMM1_S, (long long *) (& fields->f_imm1_S));
       break;
     case M32C_OPERAND_IMM3_S :
-      errmsg = parse_imm3_S (cd, strp, M32C_OPERAND_IMM3_S, (long *) (& fields->f_imm3_S));
+      errmsg = parse_imm3_S (cd, strp, M32C_OPERAND_IMM3_S, (long long *) (& fields->f_imm3_S));
       break;
     case M32C_OPERAND_LAB_16_8 :
       {
@@ -1405,7 +1405,7 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case M32C_OPERAND_Q :
-      errmsg = parse_Q (cd, strp, M32C_OPERAND_Q, (long *) (& junk));
+      errmsg = parse_Q (cd, strp, M32C_OPERAND_Q, (long long *) (& junk));
       break;
     case M32C_OPERAND_R0 :
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_r0, & junk);
@@ -1435,16 +1435,16 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_r3r1, & junk);
       break;
     case M32C_OPERAND_REGSETPOP :
-      errmsg = parse_pop_regset (cd, strp, M32C_OPERAND_REGSETPOP, (unsigned long *) (& fields->f_8_8));
+      errmsg = parse_pop_regset (cd, strp, M32C_OPERAND_REGSETPOP, (unsigned long long *) (& fields->f_8_8));
       break;
     case M32C_OPERAND_REGSETPUSH :
-      errmsg = parse_push_regset (cd, strp, M32C_OPERAND_REGSETPUSH, (unsigned long *) (& fields->f_8_8));
+      errmsg = parse_push_regset (cd, strp, M32C_OPERAND_REGSETPUSH, (unsigned long long *) (& fields->f_8_8));
       break;
     case M32C_OPERAND_RN16_PUSH_S :
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_gr_QI, & fields->f_4_1);
       break;
     case M32C_OPERAND_S :
-      errmsg = parse_S (cd, strp, M32C_OPERAND_S, (long *) (& junk));
+      errmsg = parse_S (cd, strp, M32C_OPERAND_S, (long long *) (& junk));
       break;
     case M32C_OPERAND_SRC16AN :
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_ar, & fields->f_src16_an);
@@ -1504,13 +1504,13 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_gr_SI, & fields->f_src32_rn_unprefixed_SI);
       break;
     case M32C_OPERAND_SRCDST16_R0L_R0H_S_NORMAL :
-      errmsg = parse_r0l_r0h (cd, strp, M32C_OPERAND_SRCDST16_R0L_R0H_S_NORMAL, (long *) (& fields->f_5_1));
+      errmsg = parse_r0l_r0h (cd, strp, M32C_OPERAND_SRCDST16_R0L_R0H_S_NORMAL, (long long *) (& fields->f_5_1));
       break;
     case M32C_OPERAND_X :
-      errmsg = parse_X (cd, strp, M32C_OPERAND_X, (long *) (& junk));
+      errmsg = parse_X (cd, strp, M32C_OPERAND_X, (long long *) (& junk));
       break;
     case M32C_OPERAND_Z :
-      errmsg = parse_Z (cd, strp, M32C_OPERAND_Z, (long *) (& junk));
+      errmsg = parse_Z (cd, strp, M32C_OPERAND_Z, (long long *) (& junk));
       break;
     case M32C_OPERAND_COND16_16 :
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_cond16, & fields->f_dsp_16_u8);
@@ -1576,7 +1576,7 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32c_cgen_opval_h_cond32, & fields->f_cond16);
       break;
     case M32C_OPERAND_SIZE :
-      errmsg = parse_size (cd, strp, M32C_OPERAND_SIZE, (long *) (& junk));
+      errmsg = parse_size (cd, strp, M32C_OPERAND_SIZE, (long long *) (& junk));
       break;
 
     default :
diff --git a/opcodes/m32c-dis.c b/opcodes/m32c-dis.c
index fc8ee0b..f9556c2 100644
--- a/opcodes/m32c-dis.c
+++ b/opcodes/m32c-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -76,7 +76,7 @@ print_suffix (void * dis_info, char suffix)
 static void
 print_S (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	 void * dis_info,
-	 long value ATTRIBUTE_UNUSED,
+	 long long value ATTRIBUTE_UNUSED,
 	 unsigned int attrs ATTRIBUTE_UNUSED,
 	 bfd_vma pc ATTRIBUTE_UNUSED,
 	 int length ATTRIBUTE_UNUSED)
@@ -88,7 +88,7 @@ print_S (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_G (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	 void * dis_info,
-	 long value ATTRIBUTE_UNUSED,
+	 long long value ATTRIBUTE_UNUSED,
 	 unsigned int attrs ATTRIBUTE_UNUSED,
 	 bfd_vma pc ATTRIBUTE_UNUSED,
 	 int length ATTRIBUTE_UNUSED)
@@ -99,7 +99,7 @@ print_G (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_Q (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	 void * dis_info,
-	 long value ATTRIBUTE_UNUSED,
+	 long long value ATTRIBUTE_UNUSED,
 	 unsigned int attrs ATTRIBUTE_UNUSED,
 	 bfd_vma pc ATTRIBUTE_UNUSED,
 	 int length ATTRIBUTE_UNUSED)
@@ -110,7 +110,7 @@ print_Q (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_Z (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	 void * dis_info,
-	 long value ATTRIBUTE_UNUSED,
+	 long long value ATTRIBUTE_UNUSED,
 	 unsigned int attrs ATTRIBUTE_UNUSED,
 	 bfd_vma pc ATTRIBUTE_UNUSED,
 	 int length ATTRIBUTE_UNUSED)
@@ -123,7 +123,7 @@ print_Z (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_X (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	 void * dis_info ATTRIBUTE_UNUSED,
-	 long value ATTRIBUTE_UNUSED,
+	 long long value ATTRIBUTE_UNUSED,
 	 unsigned int attrs ATTRIBUTE_UNUSED,
 	 bfd_vma pc ATTRIBUTE_UNUSED,
 	 int length ATTRIBUTE_UNUSED)
@@ -134,7 +134,7 @@ print_X (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_r0l_r0h (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void * dis_info,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED,
 	       bfd_vma pc ATTRIBUTE_UNUSED,
 	       int length ATTRIBUTE_UNUSED)
@@ -150,7 +150,7 @@ print_r0l_r0h (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_unsigned_bitbase (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 			void * dis_info,
-			unsigned long value,
+			unsigned long long value,
 			unsigned int attrs ATTRIBUTE_UNUSED,
 			bfd_vma pc ATTRIBUTE_UNUSED,
 			int length ATTRIBUTE_UNUSED)
@@ -163,7 +163,7 @@ print_unsigned_bitbase (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_signed_bitbase (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		      void * dis_info,
-		      signed long value,
+		      signed long long value,
 		      unsigned int attrs ATTRIBUTE_UNUSED,
 		      bfd_vma pc ATTRIBUTE_UNUSED,
 		      int length ATTRIBUTE_UNUSED)
@@ -176,7 +176,7 @@ print_signed_bitbase (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_size (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	    void * dis_info,
-	    long value ATTRIBUTE_UNUSED,
+	    long long value ATTRIBUTE_UNUSED,
 	    unsigned int attrs ATTRIBUTE_UNUSED,
 	    bfd_vma pc ATTRIBUTE_UNUSED,
 	    int length ATTRIBUTE_UNUSED)
@@ -190,15 +190,15 @@ print_size (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 #define POP  0
 #define PUSH 1
 
-static void print_pop_regset  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
-static void print_push_regset (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+static void print_pop_regset  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
+static void print_push_regset (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 
 /* Print a set of registers, R0,R1,A0,A1,SB,FB.  */
 
 static void
 print_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void * dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs ATTRIBUTE_UNUSED,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED,
@@ -243,7 +243,7 @@ print_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_pop_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		  void * dis_info,
-		  long value,
+		  long long value,
 		  unsigned int attrs ATTRIBUTE_UNUSED,
 		  bfd_vma pc ATTRIBUTE_UNUSED,
 		  int length ATTRIBUTE_UNUSED)
@@ -254,7 +254,7 @@ print_pop_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_push_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		   void * dis_info,
-		   long value,
+		   long long value,
 		   unsigned int attrs ATTRIBUTE_UNUSED,
 		   bfd_vma pc ATTRIBUTE_UNUSED,
 		   int length ATTRIBUTE_UNUSED)
@@ -265,7 +265,7 @@ print_push_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_signed4n (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		void * dis_info,
-		signed long value,
+		signed long long value,
 		unsigned int attrs ATTRIBUTE_UNUSED,
 		bfd_vma pc ATTRIBUTE_UNUSED,
 		int length ATTRIBUTE_UNUSED)
@@ -916,7 +916,7 @@ m32c_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -952,9 +952,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -963,7 +963,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -1025,7 +1025,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -1083,7 +1083,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -1102,7 +1102,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -1118,9 +1118,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/m32c-ibld.c b/opcodes/m32c-ibld.c
index ab35e51..8c91359 100644
--- a/opcodes/m32c-ibld.c
+++ b/opcodes/m32c-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -608,14 +608,14 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_BIT32RNPREFIXED :
       {
-        long value = fields->f_dst32_rn_prefixed_QI;
+        long long value = fields->f_dst32_rn_prefixed_QI;
         value = (((((((~ (value))) << (1))) & (2))) | (((((USI) (value) >> (1))) & (1))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_BIT32RNUNPREFIXED :
       {
-        long value = fields->f_dst32_rn_unprefixed_QI;
+        long long value = fields->f_dst32_rn_unprefixed_QI;
         value = (((((((~ (value))) << (1))) & (2))) | (((((USI) (value) >> (1))) & (1))));
         errmsg = insert_normal (cd, value, 0, 0, 8, 2, 32, total_length, buffer);
       }
@@ -625,7 +625,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_BITBASE16_16_U16 :
       {
-        long value = fields->f_dsp_16_u16;
+        long long value = fields->f_dsp_16_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 16, 32, total_length, buffer);
       }
@@ -671,7 +671,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_16_s16;
+        long long value = fields->f_dsp_16_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 16, 16, 32, total_length, buffer);
       }
@@ -703,7 +703,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_16_u16;
+        long long value = fields->f_dsp_16_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 16, 32, total_length, buffer);
       }
@@ -722,7 +722,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_16_u16;
+        long long value = fields->f_dsp_16_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 16, 32, total_length, buffer);
       }
@@ -811,7 +811,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_32_u16;
+        long long value = fields->f_dsp_32_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 0, 16, 32, total_length, buffer);
       }
@@ -833,7 +833,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_16_S16 :
       {
-        long value = fields->f_dsp_16_s16;
+        long long value = fields->f_dsp_16_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 16, 16, 32, total_length, buffer);
       }
@@ -843,7 +843,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_16_U16 :
       {
-        long value = fields->f_dsp_16_u16;
+        long long value = fields->f_dsp_16_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 16, 32, total_length, buffer);
       }
@@ -855,7 +855,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
   FLD (f_dsp_32_u8) = ((((UINT) (FLD (f_dsp_16_u24)) >> (16))) & (255));
 }
         {
-        long value = fields->f_dsp_16_u16;
+        long long value = fields->f_dsp_16_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 16, 32, total_length, buffer);
       }
@@ -873,7 +873,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
   FLD (f_dsp_32_u8) = ((((UINT) (FLD (f_dsp_16_u24)) >> (16))) & (255));
 }
         {
-        long value = fields->f_dsp_16_u16;
+        long long value = fields->f_dsp_16_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 16, 32, total_length, buffer);
       }
@@ -928,7 +928,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_32_u16;
+        long long value = fields->f_dsp_32_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 0, 16, 32, total_length, buffer);
       }
@@ -946,7 +946,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_32_u16;
+        long long value = fields->f_dsp_32_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 0, 16, 32, total_length, buffer);
       }
@@ -959,7 +959,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_32_S16 :
       {
-        long value = fields->f_dsp_32_s16;
+        long long value = fields->f_dsp_32_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 32, 0, 16, 32, total_length, buffer);
       }
@@ -969,21 +969,21 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_32_U16 :
       {
-        long value = fields->f_dsp_32_u16;
+        long long value = fields->f_dsp_32_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 0, 16, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DSP_32_U20 :
       {
-        long value = fields->f_dsp_32_u24;
+        long long value = fields->f_dsp_32_u24;
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         errmsg = insert_normal (cd, value, 0, 32, 0, 24, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DSP_32_U24 :
       {
-        long value = fields->f_dsp_32_u24;
+        long long value = fields->f_dsp_32_u24;
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         errmsg = insert_normal (cd, value, 0, 32, 0, 24, 32, total_length, buffer);
       }
@@ -993,7 +993,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_40_S16 :
       {
-        long value = fields->f_dsp_40_s16;
+        long long value = fields->f_dsp_40_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 32, 8, 16, 32, total_length, buffer);
       }
@@ -1003,21 +1003,21 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_40_U16 :
       {
-        long value = fields->f_dsp_40_u16;
+        long long value = fields->f_dsp_40_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 8, 16, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DSP_40_U20 :
       {
-        long value = fields->f_dsp_40_u20;
+        long long value = fields->f_dsp_40_u20;
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (983040))));
         errmsg = insert_normal (cd, value, 0, 32, 8, 20, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DSP_40_U24 :
       {
-        long value = fields->f_dsp_40_u24;
+        long long value = fields->f_dsp_40_u24;
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         errmsg = insert_normal (cd, value, 0, 32, 8, 24, 32, total_length, buffer);
       }
@@ -1027,7 +1027,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_48_S16 :
       {
-        long value = fields->f_dsp_48_s16;
+        long long value = fields->f_dsp_48_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 32, 16, 16, 32, total_length, buffer);
       }
@@ -1037,7 +1037,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_48_U16 :
       {
-        long value = fields->f_dsp_48_u16;
+        long long value = fields->f_dsp_48_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 16, 16, 32, total_length, buffer);
       }
@@ -1049,7 +1049,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
   FLD (f_dsp_48_u16) = ((FLD (f_dsp_48_u20)) & (65535));
 }
         {
-        long value = fields->f_dsp_48_u16;
+        long long value = fields->f_dsp_48_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 16, 16, 32, total_length, buffer);
       }
@@ -1067,7 +1067,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
   FLD (f_dsp_48_u16) = ((FLD (f_dsp_48_u24)) & (65535));
 }
         {
-        long value = fields->f_dsp_48_u16;
+        long long value = fields->f_dsp_48_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 16, 16, 32, total_length, buffer);
       }
@@ -1083,7 +1083,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_8_S24 :
       {
-        long value = fields->f_dsp_8_s24;
+        long long value = fields->f_dsp_8_s24;
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((EXTQISI (TRUNCSIQI (((value) & (255))))) << (16))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 8, 24, 32, total_length, buffer);
       }
@@ -1093,14 +1093,14 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_8_U16 :
       {
-        long value = fields->f_dsp_8_u16;
+        long long value = fields->f_dsp_8_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 0, 8, 16, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DSP_8_U24 :
       {
-        long value = fields->f_dsp_8_u24;
+        long long value = fields->f_dsp_8_u24;
         value = ((((((USI) (value) >> (16))) | (((value) & (65280))))) | (((((value) & (255))) << (16))));
         errmsg = insert_normal (cd, value, 0, 0, 8, 24, 32, total_length, buffer);
       }
@@ -1183,42 +1183,42 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DST32RNPREFIXEDHI :
       {
-        long value = fields->f_dst32_rn_prefixed_HI;
+        long long value = fields->f_dst32_rn_prefixed_HI;
         value = ((((value) + (2))) % (4));
         errmsg = insert_normal (cd, value, 0, 0, 16, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DST32RNPREFIXEDQI :
       {
-        long value = fields->f_dst32_rn_prefixed_QI;
+        long long value = fields->f_dst32_rn_prefixed_QI;
         value = (((((((~ (value))) << (1))) & (2))) | (((((USI) (value) >> (1))) & (1))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DST32RNPREFIXEDSI :
       {
-        long value = fields->f_dst32_rn_prefixed_SI;
+        long long value = fields->f_dst32_rn_prefixed_SI;
         value = ((value) + (2));
         errmsg = insert_normal (cd, value, 0, 0, 16, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DST32RNUNPREFIXEDHI :
       {
-        long value = fields->f_dst32_rn_unprefixed_HI;
+        long long value = fields->f_dst32_rn_unprefixed_HI;
         value = ((((value) + (2))) % (4));
         errmsg = insert_normal (cd, value, 0, 0, 8, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DST32RNUNPREFIXEDQI :
       {
-        long value = fields->f_dst32_rn_unprefixed_QI;
+        long long value = fields->f_dst32_rn_unprefixed_QI;
         value = (((((((~ (value))) << (1))) & (2))) | (((((USI) (value) >> (1))) & (1))));
         errmsg = insert_normal (cd, value, 0, 0, 8, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_DST32RNUNPREFIXEDSI :
       {
-        long value = fields->f_dst32_rn_unprefixed_SI;
+        long long value = fields->f_dst32_rn_unprefixed_SI;
         value = ((value) + (2));
         errmsg = insert_normal (cd, value, 0, 0, 8, 2, 32, total_length, buffer);
       }
@@ -1236,7 +1236,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_16_HI :
       {
-        long value = fields->f_dsp_16_s16;
+        long long value = fields->f_dsp_16_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 16, 16, 32, total_length, buffer);
       }
@@ -1251,14 +1251,14 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
   FLD (f_dsp_16_u16) = ((FLD (f_dsp_16_s32)) & (65535));
 }
         {
-        long value = fields->f_dsp_16_u16;
+        long long value = fields->f_dsp_16_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 0, 16, 16, 32, total_length, buffer);
       }
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_32_u16;
+        long long value = fields->f_dsp_32_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 0, 16, 32, total_length, buffer);
       }
@@ -1296,7 +1296,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_32_u24;
+        long long value = fields->f_dsp_32_u24;
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         errmsg = insert_normal (cd, value, 0, 32, 0, 24, 32, total_length, buffer);
       }
@@ -1306,7 +1306,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_32_HI :
       {
-        long value = fields->f_dsp_32_s16;
+        long long value = fields->f_dsp_32_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 32, 0, 16, 32, total_length, buffer);
       }
@@ -1316,14 +1316,14 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_32_SI :
       {
-        long value = fields->f_dsp_32_s32;
+        long long value = fields->f_dsp_32_s32;
         value = EXTSISI (((((((((UINT) (value) >> (24))) & (255))) | (((((UINT) (value) >> (8))) & (65280))))) | (((((((value) << (8))) & (16711680))) | (((((value) << (24))) & (0xff000000)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 32, 0, 32, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_IMM_40_HI :
       {
-        long value = fields->f_dsp_40_s16;
+        long long value = fields->f_dsp_40_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 32, 8, 16, 32, total_length, buffer);
       }
@@ -1338,7 +1338,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
   FLD (f_dsp_40_u24) = ((FLD (f_dsp_40_s32)) & (16777215));
 }
         {
-        long value = fields->f_dsp_40_u24;
+        long long value = fields->f_dsp_40_u24;
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         errmsg = insert_normal (cd, value, 0, 32, 8, 24, 32, total_length, buffer);
       }
@@ -1351,7 +1351,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_48_HI :
       {
-        long value = fields->f_dsp_48_s16;
+        long long value = fields->f_dsp_48_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 32, 16, 16, 32, total_length, buffer);
       }
@@ -1366,14 +1366,14 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
   FLD (f_dsp_48_u16) = ((FLD (f_dsp_48_s32)) & (65535));
 }
         {
-        long value = fields->f_dsp_48_u16;
+        long long value = fields->f_dsp_48_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 32, 16, 16, 32, total_length, buffer);
       }
         if (errmsg)
           break;
         {
-        long value = fields->f_dsp_64_u16;
+        long long value = fields->f_dsp_64_u16;
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         errmsg = insert_normal (cd, value, 0, 64, 0, 16, 32, total_length, buffer);
       }
@@ -1400,14 +1400,14 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_64_HI :
       {
-        long value = fields->f_dsp_64_s16;
+        long long value = fields->f_dsp_64_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 64, 0, 16, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_IMM_8_HI :
       {
-        long value = fields->f_dsp_8_s16;
+        long long value = fields->f_dsp_8_s16;
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 8, 16, 32, total_length, buffer);
       }
@@ -1432,7 +1432,7 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM1_S :
       {
-        long value = fields->f_imm1_S;
+        long long value = fields->f_imm1_S;
         value = ((value) - (1));
         errmsg = insert_normal (cd, value, 0, 0, 2, 1, 32, total_length, buffer);
       }
@@ -1453,56 +1453,56 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_16_8 :
       {
-        long value = fields->f_lab_16_8;
+        long long value = fields->f_lab_16_8;
         value = ((value) - (((pc) + (2))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 16, 8, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_LAB_24_8 :
       {
-        long value = fields->f_lab_24_8;
+        long long value = fields->f_lab_24_8;
         value = ((value) - (((pc) + (2))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 24, 8, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_LAB_32_8 :
       {
-        long value = fields->f_lab_32_8;
+        long long value = fields->f_lab_32_8;
         value = ((value) - (((pc) + (2))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 32, 0, 8, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_LAB_40_8 :
       {
-        long value = fields->f_lab_40_8;
+        long long value = fields->f_lab_40_8;
         value = ((value) - (((pc) + (2))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 32, 8, 8, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_LAB_5_3 :
       {
-        long value = fields->f_lab_5_3;
+        long long value = fields->f_lab_5_3;
         value = ((value) - (((pc) + (2))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_PCREL_ADDR), 0, 5, 3, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_LAB_8_16 :
       {
-        long value = fields->f_lab_8_16;
+        long long value = fields->f_lab_8_16;
         value = ((((((((value) - (((pc) + (1))))) & (255))) << (8))) | (((USI) (((((value) - (((pc) + (1))))) & (65535))) >> (8))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGN_OPT)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 16, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_LAB_8_24 :
       {
-        long value = fields->f_lab_8_24;
+        long long value = fields->f_lab_8_24;
         value = ((((((USI) (value) >> (16))) | (((value) & (65280))))) | (((((value) & (255))) << (16))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_ABS_ADDR), 0, 8, 24, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_LAB_8_8 :
       {
-        long value = fields->f_lab_8_8;
+        long long value = fields->f_lab_8_8;
         value = ((value) - (((pc) + (1))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 32, total_length, buffer);
       }
@@ -1595,42 +1595,42 @@ m32c_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_SRC32RNPREFIXEDHI :
       {
-        long value = fields->f_src32_rn_prefixed_HI;
+        long long value = fields->f_src32_rn_prefixed_HI;
         value = ((((value) + (2))) % (4));
         errmsg = insert_normal (cd, value, 0, 0, 18, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_SRC32RNPREFIXEDQI :
       {
-        long value = fields->f_src32_rn_prefixed_QI;
+        long long value = fields->f_src32_rn_prefixed_QI;
         value = (((((((~ (value))) << (1))) & (2))) | (((((USI) (value) >> (1))) & (1))));
         errmsg = insert_normal (cd, value, 0, 0, 18, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_SRC32RNPREFIXEDSI :
       {
-        long value = fields->f_src32_rn_prefixed_SI;
+        long long value = fields->f_src32_rn_prefixed_SI;
         value = ((value) + (2));
         errmsg = insert_normal (cd, value, 0, 0, 18, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_SRC32RNUNPREFIXEDHI :
       {
-        long value = fields->f_src32_rn_unprefixed_HI;
+        long long value = fields->f_src32_rn_unprefixed_HI;
         value = ((((value) + (2))) % (4));
         errmsg = insert_normal (cd, value, 0, 0, 10, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_SRC32RNUNPREFIXEDQI :
       {
-        long value = fields->f_src32_rn_unprefixed_QI;
+        long long value = fields->f_src32_rn_unprefixed_QI;
         value = (((((((~ (value))) << (1))) & (2))) | (((((USI) (value) >> (1))) & (1))));
         errmsg = insert_normal (cd, value, 0, 0, 10, 2, 32, total_length, buffer);
       }
       break;
     case M32C_OPERAND_SRC32RNUNPREFIXEDSI :
       {
-        long value = fields->f_src32_rn_unprefixed_SI;
+        long long value = fields->f_src32_rn_unprefixed_SI;
         value = ((value) + (2));
         errmsg = insert_normal (cd, value, 0, 0, 10, 2, 32, total_length, buffer);
       }
@@ -1805,7 +1805,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_BIT32RNPREFIXED :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 2, 32, total_length, pc, & value);
         value = (((((~ (((USI) (value) >> (1))))) & (1))) | (((((value) << (1))) & (2))));
         fields->f_dst32_rn_prefixed_QI = value;
@@ -1813,7 +1813,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_BIT32RNUNPREFIXED :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 2, 32, total_length, pc, & value);
         value = (((((~ (((USI) (value) >> (1))))) & (1))) | (((((value) << (1))) & (2))));
         fields->f_dst32_rn_unprefixed_QI = value;
@@ -1824,7 +1824,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_BITBASE16_16_U16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_16_u16 = value;
@@ -1860,7 +1860,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 13, 3, 32, total_length, pc, & fields->f_bitno32_unprefixed);
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 16, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_16_s16 = value;
@@ -1887,7 +1887,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 13, 3, 32, total_length, pc, & fields->f_bitno32_unprefixed);
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_16_u16 = value;
@@ -1903,7 +1903,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 13, 3, 32, total_length, pc, & fields->f_bitno32_unprefixed);
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_16_u16 = value;
@@ -1971,7 +1971,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 24, 8, 32, total_length, pc, & fields->f_dsp_24_u8);
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 0, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_32_u16 = value;
@@ -1996,7 +1996,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_16_S16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 16, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_16_s16 = value;
@@ -2007,7 +2007,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_16_U16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_16_u16 = value;
@@ -2016,7 +2016,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
     case M32C_OPERAND_DSP_16_U20 :
       {
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_16_u16 = value;
@@ -2032,7 +2032,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
     case M32C_OPERAND_DSP_16_U24 :
       {
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_16_u16 = value;
@@ -2078,7 +2078,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 24, 8, 32, total_length, pc, & fields->f_dsp_24_u8);
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 0, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_32_u16 = value;
@@ -2094,7 +2094,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 24, 8, 32, total_length, pc, & fields->f_dsp_24_u8);
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 0, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_32_u16 = value;
@@ -2110,7 +2110,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_32_S16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 0, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_32_s16 = value;
@@ -2121,7 +2121,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_32_U16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 0, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_32_u16 = value;
@@ -2129,7 +2129,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_32_U20 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 0, 24, 32, total_length, pc, & value);
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         fields->f_dsp_32_u24 = value;
@@ -2137,7 +2137,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_32_U24 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 0, 24, 32, total_length, pc, & value);
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         fields->f_dsp_32_u24 = value;
@@ -2148,7 +2148,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_40_S16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 8, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_40_s16 = value;
@@ -2159,7 +2159,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_40_U16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 8, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_40_u16 = value;
@@ -2167,7 +2167,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_40_U20 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 8, 20, 32, total_length, pc, & value);
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (983040))));
         fields->f_dsp_40_u20 = value;
@@ -2175,7 +2175,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_40_U24 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 8, 24, 32, total_length, pc, & value);
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         fields->f_dsp_40_u24 = value;
@@ -2186,7 +2186,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_48_S16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 16, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_48_s16 = value;
@@ -2197,7 +2197,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_48_U16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_48_u16 = value;
@@ -2206,7 +2206,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
     case M32C_OPERAND_DSP_48_U20 :
       {
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_48_u16 = value;
@@ -2222,7 +2222,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
     case M32C_OPERAND_DSP_48_U24 :
       {
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_48_u16 = value;
@@ -2240,7 +2240,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_8_S24 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 8, 24, 32, total_length, pc, & value);
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((EXTQISI (TRUNCSIQI (((value) & (255))))) << (16))));
         fields->f_dsp_8_s24 = value;
@@ -2251,7 +2251,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_8_U16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_8_u16 = value;
@@ -2259,7 +2259,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DSP_8_U24 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 24, 32, total_length, pc, & value);
         value = ((((((USI) (value) >> (16))) | (((value) & (65280))))) | (((((value) & (255))) << (16))));
         fields->f_dsp_8_u24 = value;
@@ -2343,7 +2343,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DST32RNPREFIXEDHI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 2, 32, total_length, pc, & value);
         value = ((((value) + (2))) % (4));
         fields->f_dst32_rn_prefixed_HI = value;
@@ -2351,7 +2351,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DST32RNPREFIXEDQI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 2, 32, total_length, pc, & value);
         value = (((((~ (((USI) (value) >> (1))))) & (1))) | (((((value) << (1))) & (2))));
         fields->f_dst32_rn_prefixed_QI = value;
@@ -2359,7 +2359,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DST32RNPREFIXEDSI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 2, 32, total_length, pc, & value);
         value = ((value) - (2));
         fields->f_dst32_rn_prefixed_SI = value;
@@ -2367,7 +2367,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DST32RNUNPREFIXEDHI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 2, 32, total_length, pc, & value);
         value = ((((value) + (2))) % (4));
         fields->f_dst32_rn_unprefixed_HI = value;
@@ -2375,7 +2375,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DST32RNUNPREFIXEDQI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 2, 32, total_length, pc, & value);
         value = (((((~ (((USI) (value) >> (1))))) & (1))) | (((((value) << (1))) & (2))));
         fields->f_dst32_rn_unprefixed_QI = value;
@@ -2383,7 +2383,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_DST32RNUNPREFIXEDSI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 8, 2, 32, total_length, pc, & value);
         value = ((value) - (2));
         fields->f_dst32_rn_unprefixed_SI = value;
@@ -2402,7 +2402,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_16_HI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 16, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_16_s16 = value;
@@ -2414,14 +2414,14 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
     case M32C_OPERAND_IMM_16_SI :
       {
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_16_u16 = value;
       }
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 0, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_32_u16 = value;
@@ -2454,7 +2454,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 24, 8, 32, total_length, pc, & fields->f_dsp_24_u8);
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 0, 24, 32, total_length, pc, & value);
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         fields->f_dsp_32_u24 = value;
@@ -2467,7 +2467,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_32_HI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 0, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_32_s16 = value;
@@ -2478,7 +2478,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_32_SI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 0, 32, 32, total_length, pc, & value);
         value = EXTSISI (((((((((UINT) (value) >> (24))) & (255))) | (((((UINT) (value) >> (8))) & (65280))))) | (((((((value) << (8))) & (16711680))) | (((((value) << (24))) & (0xff000000)))))));
         fields->f_dsp_32_s32 = value;
@@ -2486,7 +2486,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_40_HI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 8, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_40_s16 = value;
@@ -2498,7 +2498,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
     case M32C_OPERAND_IMM_40_SI :
       {
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 8, 24, 32, total_length, pc, & value);
         value = ((((((((USI) (value) >> (16))) & (255))) | (((value) & (65280))))) | (((((value) << (16))) & (16711680))));
         fields->f_dsp_40_u24 = value;
@@ -2513,7 +2513,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_48_HI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 16, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_48_s16 = value;
@@ -2525,14 +2525,14 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
     case M32C_OPERAND_IMM_48_SI :
       {
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 32, 16, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_48_u16 = value;
       }
         if (length <= 0) break;
         {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 64, 0, 16, 32, total_length, pc, & value);
         value = ((((((UHI) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280))));
         fields->f_dsp_64_u16 = value;
@@ -2559,7 +2559,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_64_HI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 64, 0, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_64_s16 = value;
@@ -2567,7 +2567,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM_8_HI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 8, 16, 32, total_length, pc, & value);
         value = EXTHISI (((HI) (INT) (((((((UINT) (value) >> (8))) & (255))) | (((((value) << (8))) & (65280)))))));
         fields->f_dsp_8_s16 = value;
@@ -2593,7 +2593,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_IMM1_S :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 2, 1, 32, total_length, pc, & value);
         value = ((value) + (1));
         fields->f_imm1_S = value;
@@ -2612,7 +2612,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_16_8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 16, 8, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (2))));
         fields->f_lab_16_8 = value;
@@ -2620,7 +2620,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_24_8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 24, 8, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (2))));
         fields->f_lab_24_8 = value;
@@ -2628,7 +2628,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_32_8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 32, 0, 8, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (2))));
         fields->f_lab_32_8 = value;
@@ -2636,7 +2636,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_40_8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 32, 8, 8, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (2))));
         fields->f_lab_40_8 = value;
@@ -2644,7 +2644,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_5_3 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_PCREL_ADDR), 0, 5, 3, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (2))));
         fields->f_lab_5_3 = value;
@@ -2652,7 +2652,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_8_16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGN_OPT)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 16, 32, total_length, pc, & value);
         value = ((((((USI) (((value) & (65535))) >> (8))) | (((SI) (((((value) & (255))) << (24))) >> (16))))) + (((pc) + (1))));
         fields->f_lab_8_16 = value;
@@ -2660,7 +2660,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_8_24 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_ABS_ADDR), 0, 8, 24, 32, total_length, pc, & value);
         value = ((((((USI) (value) >> (16))) | (((value) & (65280))))) | (((((value) & (255))) << (16))));
         fields->f_lab_8_24 = value;
@@ -2668,7 +2668,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_LAB_8_8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (1))));
         fields->f_lab_8_8 = value;
@@ -2757,7 +2757,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_SRC32RNPREFIXEDHI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 18, 2, 32, total_length, pc, & value);
         value = ((((value) + (2))) % (4));
         fields->f_src32_rn_prefixed_HI = value;
@@ -2765,7 +2765,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_SRC32RNPREFIXEDQI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 18, 2, 32, total_length, pc, & value);
         value = (((((~ (((USI) (value) >> (1))))) & (1))) | (((((value) << (1))) & (2))));
         fields->f_src32_rn_prefixed_QI = value;
@@ -2773,7 +2773,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_SRC32RNPREFIXEDSI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 18, 2, 32, total_length, pc, & value);
         value = ((value) - (2));
         fields->f_src32_rn_prefixed_SI = value;
@@ -2781,7 +2781,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_SRC32RNUNPREFIXEDHI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 10, 2, 32, total_length, pc, & value);
         value = ((((value) + (2))) % (4));
         fields->f_src32_rn_unprefixed_HI = value;
@@ -2789,7 +2789,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_SRC32RNUNPREFIXEDQI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 10, 2, 32, total_length, pc, & value);
         value = (((((~ (((USI) (value) >> (1))))) & (1))) | (((((value) << (1))) & (2))));
         fields->f_src32_rn_unprefixed_QI = value;
@@ -2797,7 +2797,7 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32C_OPERAND_SRC32RNUNPREFIXEDSI :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 10, 2, 32, total_length, pc, & value);
         value = ((value) - (2));
         fields->f_src32_rn_unprefixed_SI = value;
diff --git a/opcodes/m32c-opc.h b/opcodes/m32c-opc.h
index 62ef3b7..210af3f 100644
--- a/opcodes/m32c-opc.h
+++ b/opcodes/m32c-opc.h
@@ -3071,165 +3071,165 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_0_1;
-  long f_0_2;
-  long f_0_3;
-  long f_0_4;
-  long f_1_3;
-  long f_2_2;
-  long f_3_4;
-  long f_3_1;
-  long f_4_1;
-  long f_4_3;
-  long f_4_4;
-  long f_4_6;
-  long f_5_1;
-  long f_5_3;
-  long f_6_2;
-  long f_7_1;
-  long f_8_1;
-  long f_8_2;
-  long f_8_3;
-  long f_8_4;
-  long f_8_8;
-  long f_9_3;
-  long f_9_1;
-  long f_10_1;
-  long f_10_2;
-  long f_10_3;
-  long f_11_1;
-  long f_12_1;
-  long f_12_2;
-  long f_12_3;
-  long f_12_4;
-  long f_12_6;
-  long f_13_3;
-  long f_14_1;
-  long f_14_2;
-  long f_15_1;
-  long f_16_1;
-  long f_16_2;
-  long f_16_4;
-  long f_16_8;
-  long f_18_1;
-  long f_18_2;
-  long f_18_3;
-  long f_20_1;
-  long f_20_3;
-  long f_20_2;
-  long f_20_4;
-  long f_21_3;
-  long f_24_2;
-  long f_24_8;
-  long f_32_16;
-  long f_src16_rn;
-  long f_src16_an;
-  long f_src32_an_unprefixed;
-  long f_src32_an_prefixed;
-  long f_src32_rn_unprefixed_QI;
-  long f_src32_rn_prefixed_QI;
-  long f_src32_rn_unprefixed_HI;
-  long f_src32_rn_prefixed_HI;
-  long f_src32_rn_unprefixed_SI;
-  long f_src32_rn_prefixed_SI;
-  long f_dst32_rn_ext_unprefixed;
-  long f_dst16_rn;
-  long f_dst16_rn_ext;
-  long f_dst16_rn_QI_s;
-  long f_dst16_an;
-  long f_dst16_an_s;
-  long f_dst32_an_unprefixed;
-  long f_dst32_an_prefixed;
-  long f_dst32_rn_unprefixed_QI;
-  long f_dst32_rn_prefixed_QI;
-  long f_dst32_rn_unprefixed_HI;
-  long f_dst32_rn_prefixed_HI;
-  long f_dst32_rn_unprefixed_SI;
-  long f_dst32_rn_prefixed_SI;
-  long f_dst16_1_S;
-  long f_imm_8_s4;
-  long f_imm_12_s4;
-  long f_imm_13_u3;
-  long f_imm_20_s4;
-  long f_imm1_S;
-  long f_imm3_S;
-  long f_dsp_8_u6;
-  long f_dsp_8_u8;
-  long f_dsp_8_s8;
-  long f_dsp_10_u6;
-  long f_dsp_16_u8;
-  long f_dsp_16_s8;
-  long f_dsp_24_u8;
-  long f_dsp_24_s8;
-  long f_dsp_32_u8;
-  long f_dsp_32_s8;
-  long f_dsp_40_u8;
-  long f_dsp_40_s8;
-  long f_dsp_48_u8;
-  long f_dsp_48_s8;
-  long f_dsp_56_u8;
-  long f_dsp_56_s8;
-  long f_dsp_64_u8;
-  long f_dsp_64_s8;
-  long f_dsp_8_u16;
-  long f_dsp_8_s16;
-  long f_dsp_16_u16;
-  long f_dsp_16_s16;
-  long f_dsp_24_u16;
-  long f_dsp_24_s16;
-  long f_dsp_32_u16;
-  long f_dsp_32_s16;
-  long f_dsp_40_u16;
-  long f_dsp_40_s16;
-  long f_dsp_48_u16;
-  long f_dsp_48_s16;
-  long f_dsp_64_u16;
-  long f_dsp_8_s24;
-  long f_dsp_8_u24;
-  long f_dsp_16_u24;
-  long f_dsp_24_u24;
-  long f_dsp_32_u24;
-  long f_dsp_40_u20;
-  long f_dsp_40_u24;
-  long f_dsp_40_s32;
-  long f_dsp_48_u20;
-  long f_dsp_48_u24;
-  long f_dsp_16_s32;
-  long f_dsp_24_s32;
-  long f_dsp_32_s32;
-  long f_dsp_48_u32;
-  long f_dsp_48_s32;
-  long f_dsp_56_s16;
-  long f_dsp_64_s16;
-  long f_bitno16_S;
-  long f_bitno32_prefixed;
-  long f_bitno32_unprefixed;
-  long f_bitbase16_u11_S;
-  long f_bitbase32_16_u11_unprefixed;
-  long f_bitbase32_16_s11_unprefixed;
-  long f_bitbase32_16_u19_unprefixed;
-  long f_bitbase32_16_s19_unprefixed;
-  long f_bitbase32_16_u27_unprefixed;
-  long f_bitbase32_24_u11_prefixed;
-  long f_bitbase32_24_s11_prefixed;
-  long f_bitbase32_24_u19_prefixed;
-  long f_bitbase32_24_s19_prefixed;
-  long f_bitbase32_24_u27_prefixed;
-  long f_lab_5_3;
-  long f_lab32_jmp_s;
-  long f_lab_8_8;
-  long f_lab_8_16;
-  long f_lab_8_24;
-  long f_lab_16_8;
-  long f_lab_24_8;
-  long f_lab_32_8;
-  long f_lab_40_8;
-  long f_cond16;
-  long f_cond16j_5;
-  long f_cond32;
-  long f_cond32j;
+  long long f_nil;
+  long long f_anyof;
+  long long f_0_1;
+  long long f_0_2;
+  long long f_0_3;
+  long long f_0_4;
+  long long f_1_3;
+  long long f_2_2;
+  long long f_3_4;
+  long long f_3_1;
+  long long f_4_1;
+  long long f_4_3;
+  long long f_4_4;
+  long long f_4_6;
+  long long f_5_1;
+  long long f_5_3;
+  long long f_6_2;
+  long long f_7_1;
+  long long f_8_1;
+  long long f_8_2;
+  long long f_8_3;
+  long long f_8_4;
+  long long f_8_8;
+  long long f_9_3;
+  long long f_9_1;
+  long long f_10_1;
+  long long f_10_2;
+  long long f_10_3;
+  long long f_11_1;
+  long long f_12_1;
+  long long f_12_2;
+  long long f_12_3;
+  long long f_12_4;
+  long long f_12_6;
+  long long f_13_3;
+  long long f_14_1;
+  long long f_14_2;
+  long long f_15_1;
+  long long f_16_1;
+  long long f_16_2;
+  long long f_16_4;
+  long long f_16_8;
+  long long f_18_1;
+  long long f_18_2;
+  long long f_18_3;
+  long long f_20_1;
+  long long f_20_3;
+  long long f_20_2;
+  long long f_20_4;
+  long long f_21_3;
+  long long f_24_2;
+  long long f_24_8;
+  long long f_32_16;
+  long long f_src16_rn;
+  long long f_src16_an;
+  long long f_src32_an_unprefixed;
+  long long f_src32_an_prefixed;
+  long long f_src32_rn_unprefixed_QI;
+  long long f_src32_rn_prefixed_QI;
+  long long f_src32_rn_unprefixed_HI;
+  long long f_src32_rn_prefixed_HI;
+  long long f_src32_rn_unprefixed_SI;
+  long long f_src32_rn_prefixed_SI;
+  long long f_dst32_rn_ext_unprefixed;
+  long long f_dst16_rn;
+  long long f_dst16_rn_ext;
+  long long f_dst16_rn_QI_s;
+  long long f_dst16_an;
+  long long f_dst16_an_s;
+  long long f_dst32_an_unprefixed;
+  long long f_dst32_an_prefixed;
+  long long f_dst32_rn_unprefixed_QI;
+  long long f_dst32_rn_prefixed_QI;
+  long long f_dst32_rn_unprefixed_HI;
+  long long f_dst32_rn_prefixed_HI;
+  long long f_dst32_rn_unprefixed_SI;
+  long long f_dst32_rn_prefixed_SI;
+  long long f_dst16_1_S;
+  long long f_imm_8_s4;
+  long long f_imm_12_s4;
+  long long f_imm_13_u3;
+  long long f_imm_20_s4;
+  long long f_imm1_S;
+  long long f_imm3_S;
+  long long f_dsp_8_u6;
+  long long f_dsp_8_u8;
+  long long f_dsp_8_s8;
+  long long f_dsp_10_u6;
+  long long f_dsp_16_u8;
+  long long f_dsp_16_s8;
+  long long f_dsp_24_u8;
+  long long f_dsp_24_s8;
+  long long f_dsp_32_u8;
+  long long f_dsp_32_s8;
+  long long f_dsp_40_u8;
+  long long f_dsp_40_s8;
+  long long f_dsp_48_u8;
+  long long f_dsp_48_s8;
+  long long f_dsp_56_u8;
+  long long f_dsp_56_s8;
+  long long f_dsp_64_u8;
+  long long f_dsp_64_s8;
+  long long f_dsp_8_u16;
+  long long f_dsp_8_s16;
+  long long f_dsp_16_u16;
+  long long f_dsp_16_s16;
+  long long f_dsp_24_u16;
+  long long f_dsp_24_s16;
+  long long f_dsp_32_u16;
+  long long f_dsp_32_s16;
+  long long f_dsp_40_u16;
+  long long f_dsp_40_s16;
+  long long f_dsp_48_u16;
+  long long f_dsp_48_s16;
+  long long f_dsp_64_u16;
+  long long f_dsp_8_s24;
+  long long f_dsp_8_u24;
+  long long f_dsp_16_u24;
+  long long f_dsp_24_u24;
+  long long f_dsp_32_u24;
+  long long f_dsp_40_u20;
+  long long f_dsp_40_u24;
+  long long f_dsp_40_s32;
+  long long f_dsp_48_u20;
+  long long f_dsp_48_u24;
+  long long f_dsp_16_s32;
+  long long f_dsp_24_s32;
+  long long f_dsp_32_s32;
+  long long f_dsp_48_u32;
+  long long f_dsp_48_s32;
+  long long f_dsp_56_s16;
+  long long f_dsp_64_s16;
+  long long f_bitno16_S;
+  long long f_bitno32_prefixed;
+  long long f_bitno32_unprefixed;
+  long long f_bitbase16_u11_S;
+  long long f_bitbase32_16_u11_unprefixed;
+  long long f_bitbase32_16_s11_unprefixed;
+  long long f_bitbase32_16_u19_unprefixed;
+  long long f_bitbase32_16_s19_unprefixed;
+  long long f_bitbase32_16_u27_unprefixed;
+  long long f_bitbase32_24_u11_prefixed;
+  long long f_bitbase32_24_s11_prefixed;
+  long long f_bitbase32_24_u19_prefixed;
+  long long f_bitbase32_24_s19_prefixed;
+  long long f_bitbase32_24_u27_prefixed;
+  long long f_lab_5_3;
+  long long f_lab32_jmp_s;
+  long long f_lab_8_8;
+  long long f_lab_8_16;
+  long long f_lab_8_24;
+  long long f_lab_16_8;
+  long long f_lab_24_8;
+  long long f_lab_32_8;
+  long long f_lab_40_8;
+  long long f_cond16;
+  long long f_cond16j_5;
+  long long f_cond32;
+  long long f_cond32j;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/m32r-asm.c b/opcodes/m32r-asm.c
index 6404516..ed346fe 100644
--- a/opcodes/m32r-asm.c
+++ b/opcodes/m32r-asm.c
@@ -58,7 +58,7 @@ static const char *
 parse_hash (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	    const char **strp,
 	    int opindex ATTRIBUTE_UNUSED,
-	    long *valuep ATTRIBUTE_UNUSED)
+	    long long *valuep ATTRIBUTE_UNUSED)
 {
   if (**strp == '#')
     ++*strp;
@@ -71,7 +71,7 @@ static const char *
 parse_hi16 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -127,7 +127,7 @@ static const char *
 parse_slo16 (CGEN_CPU_DESC cd,
 	     const char ** strp,
 	     int opindex,
-	     long * valuep)
+	     long long * valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -174,7 +174,7 @@ static const char *
 parse_ulo16 (CGEN_CPU_DESC cd,
 	     const char **strp,
 	     int opindex,
-	     unsigned long *valuep)
+	     unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -227,7 +227,7 @@ m32r_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
@@ -268,25 +268,25 @@ m32r_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32r_cgen_opval_gr_names, & fields->f_r1);
       break;
     case M32R_OPERAND_HASH :
-      errmsg = parse_hash (cd, strp, M32R_OPERAND_HASH, (long *) (& junk));
+      errmsg = parse_hash (cd, strp, M32R_OPERAND_HASH, (long long *) (& junk));
       break;
     case M32R_OPERAND_HI16 :
-      errmsg = parse_hi16 (cd, strp, M32R_OPERAND_HI16, (unsigned long *) (& fields->f_hi16));
+      errmsg = parse_hi16 (cd, strp, M32R_OPERAND_HI16, (unsigned long long *) (& fields->f_hi16));
       break;
     case M32R_OPERAND_IMM1 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_IMM1, (unsigned long *) (& fields->f_imm1));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_IMM1, (unsigned long long *) (& fields->f_imm1));
       break;
     case M32R_OPERAND_SCR :
       errmsg = cgen_parse_keyword (cd, strp, & m32r_cgen_opval_cr_names, & fields->f_r2);
       break;
     case M32R_OPERAND_SIMM16 :
-      errmsg = cgen_parse_signed_integer (cd, strp, M32R_OPERAND_SIMM16, (long *) (& fields->f_simm16));
+      errmsg = cgen_parse_signed_integer (cd, strp, M32R_OPERAND_SIMM16, (long long *) (& fields->f_simm16));
       break;
     case M32R_OPERAND_SIMM8 :
-      errmsg = cgen_parse_signed_integer (cd, strp, M32R_OPERAND_SIMM8, (long *) (& fields->f_simm8));
+      errmsg = cgen_parse_signed_integer (cd, strp, M32R_OPERAND_SIMM8, (long long *) (& fields->f_simm8));
       break;
     case M32R_OPERAND_SLO16 :
-      errmsg = parse_slo16 (cd, strp, M32R_OPERAND_SLO16, (long *) (& fields->f_simm16));
+      errmsg = parse_slo16 (cd, strp, M32R_OPERAND_SLO16, (long long *) (& fields->f_simm16));
       break;
     case M32R_OPERAND_SR :
       errmsg = cgen_parse_keyword (cd, strp, & m32r_cgen_opval_gr_names, & fields->f_r2);
@@ -298,7 +298,7 @@ m32r_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & m32r_cgen_opval_gr_names, & fields->f_r2);
       break;
     case M32R_OPERAND_UIMM16 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM16, (unsigned long *) (& fields->f_uimm16));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM16, (unsigned long long *) (& fields->f_uimm16));
       break;
     case M32R_OPERAND_UIMM24 :
       {
@@ -308,19 +308,19 @@ m32r_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case M32R_OPERAND_UIMM3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM3, (unsigned long *) (& fields->f_uimm3));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM3, (unsigned long long *) (& fields->f_uimm3));
       break;
     case M32R_OPERAND_UIMM4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM4, (unsigned long *) (& fields->f_uimm4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM4, (unsigned long long *) (& fields->f_uimm4));
       break;
     case M32R_OPERAND_UIMM5 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM5, (unsigned long *) (& fields->f_uimm5));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM5, (unsigned long long *) (& fields->f_uimm5));
       break;
     case M32R_OPERAND_UIMM8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM8, (unsigned long *) (& fields->f_uimm8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, M32R_OPERAND_UIMM8, (unsigned long long *) (& fields->f_uimm8));
       break;
     case M32R_OPERAND_ULO16 :
-      errmsg = parse_ulo16 (cd, strp, M32R_OPERAND_ULO16, (unsigned long *) (& fields->f_uimm16));
+      errmsg = parse_ulo16 (cd, strp, M32R_OPERAND_ULO16, (unsigned long long *) (& fields->f_uimm16));
       break;
 
     default :
diff --git a/opcodes/m32r-dis.c b/opcodes/m32r-dis.c
index cd3349c..3c04d3f 100644
--- a/opcodes/m32r-dis.c
+++ b/opcodes/m32r-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -65,7 +65,7 @@ static int read_insn
 static void
 print_signed_with_hash_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 			       void * dis_info,
-			       long value,
+			       long long value,
 			       unsigned int attrs ATTRIBUTE_UNUSED,
 			       bfd_vma pc ATTRIBUTE_UNUSED,
 			       int length ATTRIBUTE_UNUSED)
@@ -81,7 +81,7 @@ print_signed_with_hash_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_unsigned_with_hash_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 				 void * dis_info,
-				 long value,
+				 long long value,
 				 unsigned int attrs ATTRIBUTE_UNUSED,
 				 bfd_vma pc ATTRIBUTE_UNUSED,
 				 int length ATTRIBUTE_UNUSED)
@@ -97,7 +97,7 @@ print_unsigned_with_hash_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_hash (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	    void * dis_info,
-	    long value ATTRIBUTE_UNUSED,
+	    long long value ATTRIBUTE_UNUSED,
 	    unsigned int attrs ATTRIBUTE_UNUSED,
 	    bfd_vma pc ATTRIBUTE_UNUSED,
 	    int length ATTRIBUTE_UNUSED)
@@ -304,7 +304,7 @@ m32r_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -340,9 +340,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -351,7 +351,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -413,7 +413,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -471,7 +471,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -490,7 +490,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -506,9 +506,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/m32r-ibld.c b/opcodes/m32r-ibld.c
index a6e6d51..7095189 100644
--- a/opcodes/m32r-ibld.c
+++ b/opcodes/m32r-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -587,21 +587,21 @@ m32r_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32R_OPERAND_DISP16 :
       {
-        long value = fields->f_disp16;
+        long long value = fields->f_disp16;
         value = ((SI) (((value) - (pc))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 16, 16, 32, total_length, buffer);
       }
       break;
     case M32R_OPERAND_DISP24 :
       {
-        long value = fields->f_disp24;
+        long long value = fields->f_disp24;
         value = ((SI) (((value) - (pc))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 24, 32, total_length, buffer);
       }
       break;
     case M32R_OPERAND_DISP8 :
       {
-        long value = fields->f_disp8;
+        long long value = fields->f_disp8;
         value = ((SI) (((value) - (((pc) & (-4))))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 32, total_length, buffer);
       }
@@ -616,7 +616,7 @@ m32r_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case M32R_OPERAND_IMM1 :
       {
-        long value = fields->f_imm1;
+        long long value = fields->f_imm1;
         value = ((value) - (1));
         errmsg = insert_normal (cd, value, 0, 0, 15, 1, 32, total_length, buffer);
       }
@@ -721,7 +721,7 @@ m32r_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32R_OPERAND_DISP16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 16, 16, 32, total_length, pc, & value);
         value = ((((value) << (2))) + (pc));
         fields->f_disp16 = value;
@@ -729,7 +729,7 @@ m32r_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32R_OPERAND_DISP24 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 24, 32, total_length, pc, & value);
         value = ((((value) << (2))) + (pc));
         fields->f_disp24 = value;
@@ -737,7 +737,7 @@ m32r_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32R_OPERAND_DISP8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_RELOC)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 32, total_length, pc, & value);
         value = ((((value) << (2))) + (((pc) & (-4))));
         fields->f_disp8 = value;
@@ -753,7 +753,7 @@ m32r_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case M32R_OPERAND_IMM1 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 1, 32, total_length, pc, & value);
         value = ((value) + (1));
         fields->f_imm1 = value;
diff --git a/opcodes/m32r-opc.h b/opcodes/m32r-opc.h
index 8efeada..c43fdae 100644
--- a/opcodes/m32r-opc.h
+++ b/opcodes/m32r-opc.h
@@ -101,35 +101,35 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_op1;
-  long f_op2;
-  long f_cond;
-  long f_r1;
-  long f_r2;
-  long f_simm8;
-  long f_simm16;
-  long f_shift_op2;
-  long f_uimm3;
-  long f_uimm4;
-  long f_uimm5;
-  long f_uimm8;
-  long f_uimm16;
-  long f_uimm24;
-  long f_hi16;
-  long f_disp8;
-  long f_disp16;
-  long f_disp24;
-  long f_op23;
-  long f_op3;
-  long f_acc;
-  long f_accs;
-  long f_accd;
-  long f_bits67;
-  long f_bit4;
-  long f_bit14;
-  long f_imm1;
+  long long f_nil;
+  long long f_anyof;
+  long long f_op1;
+  long long f_op2;
+  long long f_cond;
+  long long f_r1;
+  long long f_r2;
+  long long f_simm8;
+  long long f_simm16;
+  long long f_shift_op2;
+  long long f_uimm3;
+  long long f_uimm4;
+  long long f_uimm5;
+  long long f_uimm8;
+  long long f_uimm16;
+  long long f_uimm24;
+  long long f_hi16;
+  long long f_disp8;
+  long long f_disp16;
+  long long f_disp24;
+  long long f_op23;
+  long long f_op3;
+  long long f_acc;
+  long long f_accs;
+  long long f_accd;
+  long long f_bits67;
+  long long f_bit4;
+  long long f_bit14;
+  long long f_imm1;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/m68hc11-dis.c b/opcodes/m68hc11-dis.c
index c25d11f..75a3821 100644
--- a/opcodes/m68hc11-dis.c
+++ b/opcodes/m68hc11-dis.c
@@ -237,7 +237,7 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
   int status;
   bfd_byte buffer[4];
   unsigned int code;
-  long format, pos, i;
+  long long format, pos, i;
   short sval;
   const struct m68hc11_opcode *opcode;
 
diff --git a/opcodes/m68k-dis.c b/opcodes/m68k-dis.c
index be21e70..2a91be8 100644
--- a/opcodes/m68k-dis.c
+++ b/opcodes/m68k-dis.c
@@ -1534,8 +1534,8 @@ m68k_scan_mask (bfd_vma memaddr, disassemble_info *info,
   for (i = 0; i < numopcodes[major_opcode]; i++)
     {
       const struct m68k_opcode *opc = opcodes[major_opcode][i];
-      unsigned long opcode = opc->opcode;
-      unsigned long match = opc->match;
+      unsigned long long opcode = opc->opcode;
+      unsigned long long match = opc->match;
       const char *args = opc->args;
 
       if (*args == '.')
diff --git a/opcodes/mcore-dis.c b/opcodes/mcore-dis.c
index c56ee83..561d62e 100644
--- a/opcodes/mcore-dis.c
+++ b/opcodes/mcore-dis.c
@@ -196,12 +196,12 @@ print_insn_mcore (bfd_vma memaddr,
 
 	case BR:
 	  {
-	    long val = inst & 0x3FF;
+	    long long val = inst & 0x3FF;
 
 	    if (inst & 0x400)
 	      val |= 0xFFFFFC00;
 
-	    (*print_func) (stream, "\t0x%lx", (long)(memaddr + 2 + (val << 1)));
+	    (*print_func) (stream, "\t0x%lx", (long long)(memaddr + 2 + (val << 1)));
 
 	    if (strcmp (mcore_table[i].name, "bsr") == 0)
 	      {
@@ -219,17 +219,17 @@ print_insn_mcore (bfd_vma memaddr,
 
 	case BL:
 	  {
-	    long val;
+	    long long val;
 	    val = (inst & 0x000F);
 	    (*print_func) (stream, "\t%s, 0x%lx",
 			   grname[(inst >> 4) & 0xF],
-			   (long) (memaddr - (val << 1)));
+			   (long long) (memaddr - (val << 1)));
 	  }
 	  break;
 
 	case LR:
 	  {
-	    unsigned long val;
+	    unsigned long long val;
 
 	    val = (memaddr + 2 + ((inst & 0xFF) << 2)) & 0xFFFFFFFC;
 
@@ -255,14 +255,14 @@ print_insn_mcore (bfd_vma memaddr,
 
 	    if (val == 0)
 	      (*print_func) (stream, "\t// from address pool at 0x%lx",
-			     (long) (memaddr + 2
+			     (long long) (memaddr + 2
 				     + ((inst & 0xFF) << 2)) & 0xFFFFFFFC);
 	  }
 	  break;
 
 	case LJ:
 	  {
-	    unsigned long val;
+	    unsigned long long val;
 
 	    val = (memaddr + 2 + ((inst & 0xFF) << 2)) & 0xFFFFFFFC;
 
@@ -294,7 +294,7 @@ print_insn_mcore (bfd_vma memaddr,
 	    else
 	      {
 		(*print_func) (stream, "\t// from address pool at 0x%lx",
-			       (long) (memaddr + 2
+			       (long long) (memaddr + 2
 				       + ((inst & 0xFF) << 2)) & 0xFFFFFFFC);
 	      }
 	  }
diff --git a/opcodes/mep-asm.c b/opcodes/mep-asm.c
index 09e747a..33b93d9 100644
--- a/opcodes/mep-asm.c
+++ b/opcodes/mep-asm.c
@@ -56,25 +56,25 @@ static const char * parse_insn_normal
 #define CGEN_VALIDATE_INSN_SUPPORTED
 #define mep_cgen_insn_supported mep_cgen_insn_supported_asm
 
-       const char * parse_csrn       (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
-       const char * parse_tpreg      (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
-       const char * parse_spreg      (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
-       const char * parse_mep_align  (CGEN_CPU_DESC, const char **, enum cgen_operand_type, long *);
-       const char * parse_mep_alignu (CGEN_CPU_DESC, const char **, enum cgen_operand_type, unsigned long *);
-static const char * parse_signed16   (CGEN_CPU_DESC, const char **, int, long *);
-static const char * parse_signed16_range   (CGEN_CPU_DESC, const char **, int, long *) ATTRIBUTE_UNUSED;
-static const char * parse_unsigned16 (CGEN_CPU_DESC, const char **, int, unsigned long *);
-static const char * parse_unsigned16_range (CGEN_CPU_DESC, const char **, int, unsigned long *) ATTRIBUTE_UNUSED;
-static const char * parse_lo16       (CGEN_CPU_DESC, const char **, int, long *, long);
-static const char * parse_unsigned7  (CGEN_CPU_DESC, const char **, enum cgen_operand_type, unsigned long *);
-static const char * parse_zero       (CGEN_CPU_DESC, const char **, int, long *);
+       const char * parse_csrn       (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long long *);
+       const char * parse_tpreg      (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long long *);
+       const char * parse_spreg      (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long long *);
+       const char * parse_mep_align  (CGEN_CPU_DESC, const char **, enum cgen_operand_type, long long *);
+       const char * parse_mep_alignu (CGEN_CPU_DESC, const char **, enum cgen_operand_type, unsigned long long *);
+static const char * parse_signed16   (CGEN_CPU_DESC, const char **, int, long long *);
+static const char * parse_signed16_range   (CGEN_CPU_DESC, const char **, int, long long *) ATTRIBUTE_UNUSED;
+static const char * parse_unsigned16 (CGEN_CPU_DESC, const char **, int, unsigned long long *);
+static const char * parse_unsigned16_range (CGEN_CPU_DESC, const char **, int, unsigned long long *) ATTRIBUTE_UNUSED;
+static const char * parse_lo16       (CGEN_CPU_DESC, const char **, int, long long *, long long);
+static const char * parse_unsigned7  (CGEN_CPU_DESC, const char **, enum cgen_operand_type, unsigned long long *);
+static const char * parse_zero       (CGEN_CPU_DESC, const char **, int, long long *);
 
 const char *
 parse_csrn (CGEN_CPU_DESC cd, const char **strp,
-	    CGEN_KEYWORD *keyword_table, long *field)
+	    CGEN_KEYWORD *keyword_table, long long *field)
 {
   const char *err;
-  unsigned long value;
+  unsigned long long value;
 
   err = cgen_parse_keyword (cd, strp, keyword_table, field);
   if (!err)
@@ -92,12 +92,12 @@ static const char *
 parse_ivc2_cr (CGEN_CPU_DESC,
 	const char **,
 	CGEN_KEYWORD *,
-	long *) ATTRIBUTE_UNUSED;
+	long long *) ATTRIBUTE_UNUSED;
 static const char *
 parse_ivc2_cr (CGEN_CPU_DESC cd,
 	const char **strp,
 	CGEN_KEYWORD *keyword_table  ATTRIBUTE_UNUSED,
-	long *field)
+	long long *field)
 {
   return cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_cr_ivc2, field);
 }
@@ -105,12 +105,12 @@ static const char *
 parse_ivc2_ccr (CGEN_CPU_DESC,
 	const char **,
 	CGEN_KEYWORD *,
-	long *) ATTRIBUTE_UNUSED;
+	long long *) ATTRIBUTE_UNUSED;
 static const char *
 parse_ivc2_ccr (CGEN_CPU_DESC cd,
 	const char **strp,
 	CGEN_KEYWORD *keyword_table  ATTRIBUTE_UNUSED,
-	long *field)
+	long long *field)
 {
   return cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_ccr_ivc2, field);
 }
@@ -118,7 +118,7 @@ parse_ivc2_ccr (CGEN_CPU_DESC cd,
 
 const char *
 parse_tpreg (CGEN_CPU_DESC cd, const char ** strp,
-	     CGEN_KEYWORD *keyword_table, long *field)
+	     CGEN_KEYWORD *keyword_table, long long *field)
 {
   const char *err;
 
@@ -132,7 +132,7 @@ parse_tpreg (CGEN_CPU_DESC cd, const char ** strp,
 
 const char *
 parse_spreg (CGEN_CPU_DESC cd, const char ** strp,
-	     CGEN_KEYWORD *keyword_table, long *field)
+	     CGEN_KEYWORD *keyword_table, long long *field)
 {
   const char *err;
 
@@ -146,9 +146,9 @@ parse_spreg (CGEN_CPU_DESC cd, const char ** strp,
 
 const char *
 parse_mep_align (CGEN_CPU_DESC cd, const char ** strp,
-		 enum cgen_operand_type type, long *field)
+		 enum cgen_operand_type type, long long *field)
 {
-  long lsbs = 0;
+  long long lsbs = 0;
   const char *err;
 
   switch (type)
@@ -165,7 +165,7 @@ parse_mep_align (CGEN_CPU_DESC cd, const char ** strp,
     case MEP_OPERAND_UDISP7A4:
     case MEP_OPERAND_UIMM7A4:
     case MEP_OPERAND_ADDR24A4:
-      err = cgen_parse_unsigned_integer (cd, strp, type, (unsigned long *) field);
+      err = cgen_parse_unsigned_integer (cd, strp, type, (unsigned long long *) field);
       break;
     default:
       abort();
@@ -203,9 +203,9 @@ parse_mep_align (CGEN_CPU_DESC cd, const char ** strp,
 
 const char *
 parse_mep_alignu (CGEN_CPU_DESC cd, const char ** strp,
-		 enum cgen_operand_type type, unsigned long *field)
+		 enum cgen_operand_type type, unsigned long long *field)
 {
-  return parse_mep_align (cd, strp, type, (long *) field);
+  return parse_mep_align (cd, strp, type, (long long *) field);
 }
 
 
@@ -216,7 +216,7 @@ static const char *
 parse_signed16 (CGEN_CPU_DESC cd,
 		const char **strp,
 		int opindex,
-		long *valuep)
+		long long *valuep)
 {
   return parse_lo16 (cd, strp, opindex, valuep, 1);
 }
@@ -225,8 +225,8 @@ static const char *
 parse_lo16 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    long *valuep,
-	    long signedp)
+	    long long *valuep,
+	    long long signedp)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -244,7 +244,7 @@ parse_lo16 (CGEN_CPU_DESC cd,
 	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
 	value &= 0xffff;
       if (signedp)
-	*valuep = (long)(short) value;
+	*valuep = (long long)(short) value;
       else
 	*valuep = value;
       return errmsg;
@@ -314,19 +314,19 @@ static const char *
 parse_unsigned16 (CGEN_CPU_DESC cd,
 		  const char **strp,
 		  int opindex,
-		  unsigned long *valuep)
+		  unsigned long long *valuep)
 {
-  return parse_lo16 (cd, strp, opindex, (long *) valuep, 0);
+  return parse_lo16 (cd, strp, opindex, (long long *) valuep, 0);
 }
 
 static const char *
 parse_signed16_range (CGEN_CPU_DESC cd,
 		      const char **strp,
 		      int opindex,
-		      signed long *valuep)
+		      signed long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
+  signed long long value;
 
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg)
@@ -343,10 +343,10 @@ static const char *
 parse_unsigned16_range (CGEN_CPU_DESC cd,
 			const char **strp,
 			int opindex,
-			unsigned long *valuep)
+			unsigned long long *valuep)
 {
   const char *errmsg = 0;
-  unsigned long value;
+  unsigned long long value;
 
   errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
   if (errmsg)
@@ -362,7 +362,7 @@ parse_unsigned16_range (CGEN_CPU_DESC cd,
 /* A special case of parse_signed16 which accepts only the value zero.  */
 
 static const char *
-parse_zero (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
+parse_zero (CGEN_CPU_DESC cd, const char **strp, int opindex, long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
@@ -465,7 +465,7 @@ parse_zero (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
 
 static const char *
 parse_unsigned7 (CGEN_CPU_DESC cd, const char **strp,
-		 enum cgen_operand_type opindex, unsigned long *valuep)
+		 enum cgen_operand_type opindex, unsigned long long *valuep)
 {
   const char *errmsg;
   bfd_vma value;
@@ -510,11 +510,11 @@ static ATTRIBUTE_UNUSED const char *
 parse_cdisp10 (CGEN_CPU_DESC cd,
 	       const char **strp,
 	       int opindex,
-	       long *valuep)
+	       long long *valuep)
 {
   const char *errmsg = 0;
-  signed long value;
-  long have_zero = 0;
+  signed long long value;
+  long long have_zero = 0;
   int wide = 0;
   int alignment;
 
@@ -845,54 +845,54 @@ mep_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
     case MEP_OPERAND_ADDR24A4 :
-      errmsg = parse_mep_alignu (cd, strp, MEP_OPERAND_ADDR24A4, (unsigned long *) (& fields->f_24u8a4n));
+      errmsg = parse_mep_alignu (cd, strp, MEP_OPERAND_ADDR24A4, (unsigned long long *) (& fields->f_24u8a4n));
       break;
     case MEP_OPERAND_C5RMUIMM20 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_C5RMUIMM20, (unsigned long *) (& fields->f_c5_rmuimm20));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_C5RMUIMM20, (unsigned long long *) (& fields->f_c5_rmuimm20));
       break;
     case MEP_OPERAND_C5RNMUIMM24 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_C5RNMUIMM24, (unsigned long *) (& fields->f_c5_rnmuimm24));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_C5RNMUIMM24, (unsigned long long *) (& fields->f_c5_rnmuimm24));
       break;
     case MEP_OPERAND_CALLNUM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CALLNUM, (unsigned long *) (& fields->f_callnum));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CALLNUM, (unsigned long long *) (& fields->f_callnum));
       break;
     case MEP_OPERAND_CCCC :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CCCC, (unsigned long *) (& fields->f_rm));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CCCC, (unsigned long long *) (& fields->f_rm));
       break;
     case MEP_OPERAND_CCRN :
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_ccr, & fields->f_ccrn);
       break;
     case MEP_OPERAND_CDISP10 :
-      errmsg = parse_cdisp10 (cd, strp, MEP_OPERAND_CDISP10, (long *) (& fields->f_cdisp10));
+      errmsg = parse_cdisp10 (cd, strp, MEP_OPERAND_CDISP10, (long long *) (& fields->f_cdisp10));
       break;
     case MEP_OPERAND_CDISP10A2 :
-      errmsg = parse_cdisp10 (cd, strp, MEP_OPERAND_CDISP10A2, (long *) (& fields->f_cdisp10));
+      errmsg = parse_cdisp10 (cd, strp, MEP_OPERAND_CDISP10A2, (long long *) (& fields->f_cdisp10));
       break;
     case MEP_OPERAND_CDISP10A4 :
-      errmsg = parse_cdisp10 (cd, strp, MEP_OPERAND_CDISP10A4, (long *) (& fields->f_cdisp10));
+      errmsg = parse_cdisp10 (cd, strp, MEP_OPERAND_CDISP10A4, (long long *) (& fields->f_cdisp10));
       break;
     case MEP_OPERAND_CDISP10A8 :
-      errmsg = parse_cdisp10 (cd, strp, MEP_OPERAND_CDISP10A8, (long *) (& fields->f_cdisp10));
+      errmsg = parse_cdisp10 (cd, strp, MEP_OPERAND_CDISP10A8, (long long *) (& fields->f_cdisp10));
       break;
     case MEP_OPERAND_CDISP12 :
-      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_CDISP12, (long *) (& fields->f_12s20));
+      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_CDISP12, (long long *) (& fields->f_12s20));
       break;
     case MEP_OPERAND_CIMM4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CIMM4, (unsigned long *) (& fields->f_rn));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CIMM4, (unsigned long long *) (& fields->f_rn));
       break;
     case MEP_OPERAND_CIMM5 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CIMM5, (unsigned long *) (& fields->f_5u24));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CIMM5, (unsigned long long *) (& fields->f_5u24));
       break;
     case MEP_OPERAND_CODE16 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CODE16, (unsigned long *) (& fields->f_16u16));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CODE16, (unsigned long long *) (& fields->f_16u16));
       break;
     case MEP_OPERAND_CODE24 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CODE24, (unsigned long *) (& fields->f_24u4n));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CODE24, (unsigned long long *) (& fields->f_24u4n));
       break;
     case MEP_OPERAND_CP_FLAG :
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_ccr, & junk);
@@ -931,7 +931,7 @@ mep_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = parse_csrn (cd, strp, & mep_cgen_opval_h_csr, & fields->f_csrn);
       break;
     case MEP_OPERAND_CSRN_IDX :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CSRN_IDX, (unsigned long *) (& fields->f_csrn));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CSRN_IDX, (unsigned long long *) (& fields->f_csrn));
       break;
     case MEP_OPERAND_DBG :
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_csr, & junk);
@@ -949,79 +949,79 @@ mep_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_csr, & junk);
       break;
     case MEP_OPERAND_IMM16P0 :
-      errmsg = parse_unsigned16_range (cd, strp, MEP_OPERAND_IMM16P0, (unsigned long *) (& fields->f_ivc2_imm16p0));
+      errmsg = parse_unsigned16_range (cd, strp, MEP_OPERAND_IMM16P0, (unsigned long long *) (& fields->f_ivc2_imm16p0));
       break;
     case MEP_OPERAND_IMM3P12 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P12, (unsigned long *) (& fields->f_ivc2_3u12));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P12, (unsigned long long *) (& fields->f_ivc2_3u12));
       break;
     case MEP_OPERAND_IMM3P25 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P25, (unsigned long *) (& fields->f_ivc2_3u25));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P25, (unsigned long long *) (& fields->f_ivc2_3u25));
       break;
     case MEP_OPERAND_IMM3P4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P4, (unsigned long *) (& fields->f_ivc2_3u4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P4, (unsigned long long *) (& fields->f_ivc2_3u4));
       break;
     case MEP_OPERAND_IMM3P5 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P5, (unsigned long *) (& fields->f_ivc2_3u5));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P5, (unsigned long long *) (& fields->f_ivc2_3u5));
       break;
     case MEP_OPERAND_IMM3P9 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P9, (unsigned long *) (& fields->f_ivc2_3u9));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM3P9, (unsigned long long *) (& fields->f_ivc2_3u9));
       break;
     case MEP_OPERAND_IMM4P10 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM4P10, (unsigned long *) (& fields->f_ivc2_4u10));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM4P10, (unsigned long long *) (& fields->f_ivc2_4u10));
       break;
     case MEP_OPERAND_IMM4P4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM4P4, (unsigned long *) (& fields->f_ivc2_4u4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM4P4, (unsigned long long *) (& fields->f_ivc2_4u4));
       break;
     case MEP_OPERAND_IMM4P8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM4P8, (unsigned long *) (& fields->f_ivc2_4u8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM4P8, (unsigned long long *) (& fields->f_ivc2_4u8));
       break;
     case MEP_OPERAND_IMM5P23 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM5P23, (unsigned long *) (& fields->f_ivc2_5u23));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM5P23, (unsigned long long *) (& fields->f_ivc2_5u23));
       break;
     case MEP_OPERAND_IMM5P3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM5P3, (unsigned long *) (& fields->f_ivc2_5u3));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM5P3, (unsigned long long *) (& fields->f_ivc2_5u3));
       break;
     case MEP_OPERAND_IMM5P7 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM5P7, (unsigned long *) (& fields->f_ivc2_5u7));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM5P7, (unsigned long long *) (& fields->f_ivc2_5u7));
       break;
     case MEP_OPERAND_IMM5P8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM5P8, (unsigned long *) (& fields->f_ivc2_5u8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM5P8, (unsigned long long *) (& fields->f_ivc2_5u8));
       break;
     case MEP_OPERAND_IMM6P2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM6P2, (unsigned long *) (& fields->f_ivc2_6u2));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM6P2, (unsigned long long *) (& fields->f_ivc2_6u2));
       break;
     case MEP_OPERAND_IMM6P6 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM6P6, (unsigned long *) (& fields->f_ivc2_6u6));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM6P6, (unsigned long long *) (& fields->f_ivc2_6u6));
       break;
     case MEP_OPERAND_IMM8P0 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM8P0, (unsigned long *) (& fields->f_ivc2_8u0));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM8P0, (unsigned long long *) (& fields->f_ivc2_8u0));
       break;
     case MEP_OPERAND_IMM8P20 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM8P20, (unsigned long *) (& fields->f_ivc2_8u20));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM8P20, (unsigned long long *) (& fields->f_ivc2_8u20));
       break;
     case MEP_OPERAND_IMM8P4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM8P4, (unsigned long *) (& fields->f_ivc2_8u4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IMM8P4, (unsigned long long *) (& fields->f_ivc2_8u4));
       break;
     case MEP_OPERAND_IVC_X_0_2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_0_2, (unsigned long *) (& fields->f_ivc2_2u0));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_0_2, (unsigned long long *) (& fields->f_ivc2_2u0));
       break;
     case MEP_OPERAND_IVC_X_0_3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_0_3, (unsigned long *) (& fields->f_ivc2_3u0));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_0_3, (unsigned long long *) (& fields->f_ivc2_3u0));
       break;
     case MEP_OPERAND_IVC_X_0_4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_0_4, (unsigned long *) (& fields->f_ivc2_4u0));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_0_4, (unsigned long long *) (& fields->f_ivc2_4u0));
       break;
     case MEP_OPERAND_IVC_X_0_5 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_0_5, (unsigned long *) (& fields->f_ivc2_5u0));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_0_5, (unsigned long long *) (& fields->f_ivc2_5u0));
       break;
     case MEP_OPERAND_IVC_X_6_1 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_6_1, (unsigned long *) (& fields->f_ivc2_1u6));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_6_1, (unsigned long long *) (& fields->f_ivc2_1u6));
       break;
     case MEP_OPERAND_IVC_X_6_2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_6_2, (unsigned long *) (& fields->f_ivc2_2u6));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_6_2, (unsigned long long *) (& fields->f_ivc2_2u6));
       break;
     case MEP_OPERAND_IVC_X_6_3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_6_3, (unsigned long *) (& fields->f_ivc2_3u6));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_IVC_X_6_3, (unsigned long long *) (& fields->f_ivc2_3u6));
       break;
     case MEP_OPERAND_IVC2_ACC0_0 :
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_ccr_ivc2, & junk);
@@ -1129,19 +1129,19 @@ mep_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_csr, & junk);
       break;
     case MEP_OPERAND_PCABS24A2 :
-      errmsg = parse_mep_alignu (cd, strp, MEP_OPERAND_PCABS24A2, (unsigned long *) (& fields->f_24u5a2n));
+      errmsg = parse_mep_alignu (cd, strp, MEP_OPERAND_PCABS24A2, (unsigned long long *) (& fields->f_24u5a2n));
       break;
     case MEP_OPERAND_PCREL12A2 :
-      errmsg = parse_mep_align (cd, strp, MEP_OPERAND_PCREL12A2, (long *) (& fields->f_12s4a2));
+      errmsg = parse_mep_align (cd, strp, MEP_OPERAND_PCREL12A2, (long long *) (& fields->f_12s4a2));
       break;
     case MEP_OPERAND_PCREL17A2 :
-      errmsg = parse_mep_align (cd, strp, MEP_OPERAND_PCREL17A2, (long *) (& fields->f_17s16a2));
+      errmsg = parse_mep_align (cd, strp, MEP_OPERAND_PCREL17A2, (long long *) (& fields->f_17s16a2));
       break;
     case MEP_OPERAND_PCREL24A2 :
-      errmsg = parse_mep_align (cd, strp, MEP_OPERAND_PCREL24A2, (long *) (& fields->f_24s5a2n));
+      errmsg = parse_mep_align (cd, strp, MEP_OPERAND_PCREL24A2, (long long *) (& fields->f_24s5a2n));
       break;
     case MEP_OPERAND_PCREL8A2 :
-      errmsg = parse_mep_align (cd, strp, MEP_OPERAND_PCREL8A2, (long *) (& fields->f_8s8a2));
+      errmsg = parse_mep_align (cd, strp, MEP_OPERAND_PCREL8A2, (long long *) (& fields->f_8s8a2));
       break;
     case MEP_OPERAND_PSW :
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_csr, & junk);
@@ -1210,28 +1210,28 @@ mep_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_csr, & junk);
       break;
     case MEP_OPERAND_SDISP16 :
-      errmsg = parse_signed16 (cd, strp, MEP_OPERAND_SDISP16, (long *) (& fields->f_16s16));
+      errmsg = parse_signed16 (cd, strp, MEP_OPERAND_SDISP16, (long long *) (& fields->f_16s16));
       break;
     case MEP_OPERAND_SIMM16 :
-      errmsg = parse_signed16 (cd, strp, MEP_OPERAND_SIMM16, (long *) (& fields->f_16s16));
+      errmsg = parse_signed16 (cd, strp, MEP_OPERAND_SIMM16, (long long *) (& fields->f_16s16));
       break;
     case MEP_OPERAND_SIMM16P0 :
-      errmsg = parse_signed16_range (cd, strp, MEP_OPERAND_SIMM16P0, (long *) (& fields->f_ivc2_simm16p0));
+      errmsg = parse_signed16_range (cd, strp, MEP_OPERAND_SIMM16P0, (long long *) (& fields->f_ivc2_simm16p0));
       break;
     case MEP_OPERAND_SIMM6 :
-      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM6, (long *) (& fields->f_6s8));
+      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM6, (long long *) (& fields->f_6s8));
       break;
     case MEP_OPERAND_SIMM8 :
-      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM8, (long *) (& fields->f_8s8));
+      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM8, (long long *) (& fields->f_8s8));
       break;
     case MEP_OPERAND_SIMM8P0 :
-      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM8P0, (long *) (& fields->f_ivc2_8s0));
+      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM8P0, (long long *) (& fields->f_ivc2_8s0));
       break;
     case MEP_OPERAND_SIMM8P20 :
-      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM8P20, (long *) (& fields->f_ivc2_8s20));
+      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM8P20, (long long *) (& fields->f_ivc2_8s20));
       break;
     case MEP_OPERAND_SIMM8P4 :
-      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM8P4, (long *) (& fields->f_ivc2_8s4));
+      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_SIMM8P4, (long long *) (& fields->f_ivc2_8s4));
       break;
     case MEP_OPERAND_SP :
       errmsg = cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_gpr, & junk);
@@ -1246,40 +1246,40 @@ mep_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = parse_tpreg (cd, strp, & mep_cgen_opval_h_gpr, & junk);
       break;
     case MEP_OPERAND_UDISP2 :
-      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_UDISP2, (long *) (& fields->f_2u6));
+      errmsg = cgen_parse_signed_integer (cd, strp, MEP_OPERAND_UDISP2, (long long *) (& fields->f_2u6));
       break;
     case MEP_OPERAND_UDISP7 :
-      errmsg = parse_unsigned7 (cd, strp, MEP_OPERAND_UDISP7, (unsigned long *) (& fields->f_7u9));
+      errmsg = parse_unsigned7 (cd, strp, MEP_OPERAND_UDISP7, (unsigned long long *) (& fields->f_7u9));
       break;
     case MEP_OPERAND_UDISP7A2 :
-      errmsg = parse_unsigned7 (cd, strp, MEP_OPERAND_UDISP7A2, (unsigned long *) (& fields->f_7u9a2));
+      errmsg = parse_unsigned7 (cd, strp, MEP_OPERAND_UDISP7A2, (unsigned long long *) (& fields->f_7u9a2));
       break;
     case MEP_OPERAND_UDISP7A4 :
-      errmsg = parse_unsigned7 (cd, strp, MEP_OPERAND_UDISP7A4, (unsigned long *) (& fields->f_7u9a4));
+      errmsg = parse_unsigned7 (cd, strp, MEP_OPERAND_UDISP7A4, (unsigned long long *) (& fields->f_7u9a4));
       break;
     case MEP_OPERAND_UIMM16 :
-      errmsg = parse_unsigned16 (cd, strp, MEP_OPERAND_UIMM16, (unsigned long *) (& fields->f_16u16));
+      errmsg = parse_unsigned16 (cd, strp, MEP_OPERAND_UIMM16, (unsigned long long *) (& fields->f_16u16));
       break;
     case MEP_OPERAND_UIMM2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM2, (unsigned long *) (& fields->f_2u10));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM2, (unsigned long long *) (& fields->f_2u10));
       break;
     case MEP_OPERAND_UIMM24 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM24, (unsigned long *) (& fields->f_24u8n));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM24, (unsigned long long *) (& fields->f_24u8n));
       break;
     case MEP_OPERAND_UIMM3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM3, (unsigned long *) (& fields->f_3u5));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM3, (unsigned long long *) (& fields->f_3u5));
       break;
     case MEP_OPERAND_UIMM4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM4, (unsigned long *) (& fields->f_4u8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM4, (unsigned long long *) (& fields->f_4u8));
       break;
     case MEP_OPERAND_UIMM5 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM5, (unsigned long *) (& fields->f_5u8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_UIMM5, (unsigned long long *) (& fields->f_5u8));
       break;
     case MEP_OPERAND_UIMM7A4 :
-      errmsg = parse_mep_alignu (cd, strp, MEP_OPERAND_UIMM7A4, (unsigned long *) (& fields->f_7u9a4));
+      errmsg = parse_mep_alignu (cd, strp, MEP_OPERAND_UIMM7A4, (unsigned long long *) (& fields->f_7u9a4));
       break;
     case MEP_OPERAND_ZERO :
-      errmsg = parse_zero (cd, strp, MEP_OPERAND_ZERO, (long *) (& junk));
+      errmsg = parse_zero (cd, strp, MEP_OPERAND_ZERO, (long long *) (& junk));
       break;
 
     default :
diff --git a/opcodes/mep-dis.c b/opcodes/mep-dis.c
index e52db1e..f0ed0df 100644
--- a/opcodes/mep-dis.c
+++ b/opcodes/mep-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -65,12 +65,12 @@ static int read_insn
 
 #define CGEN_VALIDATE_INSN_SUPPORTED
 
-static void print_tpreg (CGEN_CPU_DESC, PTR, CGEN_KEYWORD *, long, unsigned int);
-static void print_spreg (CGEN_CPU_DESC, PTR, CGEN_KEYWORD *, long, unsigned int);
+static void print_tpreg (CGEN_CPU_DESC, PTR, CGEN_KEYWORD *, long long, unsigned int);
+static void print_spreg (CGEN_CPU_DESC, PTR, CGEN_KEYWORD *, long long, unsigned int);
 
 static void
 print_tpreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, PTR dis_info,
-	     CGEN_KEYWORD *table ATTRIBUTE_UNUSED, long val ATTRIBUTE_UNUSED,
+	     CGEN_KEYWORD *table ATTRIBUTE_UNUSED, long long val ATTRIBUTE_UNUSED,
 	     unsigned int flags ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -80,7 +80,7 @@ print_tpreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, PTR dis_info,
 
 static void
 print_spreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, PTR dis_info,
-	     CGEN_KEYWORD *table ATTRIBUTE_UNUSED, long val ATTRIBUTE_UNUSED,
+	     CGEN_KEYWORD *table ATTRIBUTE_UNUSED, long long val ATTRIBUTE_UNUSED,
 	     unsigned int flags ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -93,13 +93,13 @@ static void
 print_ivc2_cr (CGEN_CPU_DESC,
 	void *,
 	CGEN_KEYWORD *,
-	long,
+	long long,
 	unsigned int) ATTRIBUTE_UNUSED;
 static void
 print_ivc2_cr (CGEN_CPU_DESC cd,
 	void *dis_info,
 	CGEN_KEYWORD *keyword_table ATTRIBUTE_UNUSED,
-	long value,
+	long long value,
 	unsigned int attrs)
 {
   print_keyword (cd, dis_info, & mep_cgen_opval_h_cr_ivc2, value, attrs);
@@ -108,13 +108,13 @@ static void
 print_ivc2_ccr (CGEN_CPU_DESC,
 	void *,
 	CGEN_KEYWORD *,
-	long,
+	long long,
 	unsigned int) ATTRIBUTE_UNUSED;
 static void
 print_ivc2_ccr (CGEN_CPU_DESC cd,
 	void *dis_info,
 	CGEN_KEYWORD *keyword_table ATTRIBUTE_UNUSED,
-	long value,
+	long long value,
 	unsigned int attrs)
 {
   print_keyword (cd, dis_info, & mep_cgen_opval_h_ccr_ivc2, value, attrs);
@@ -1212,7 +1212,7 @@ mep_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -1248,9 +1248,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -1259,7 +1259,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -1321,7 +1321,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -1379,7 +1379,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -1398,7 +1398,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -1414,9 +1414,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/mep-ibld.c b/opcodes/mep-ibld.c
index 077e560..8c12229 100644
--- a/opcodes/mep-ibld.c
+++ b/opcodes/mep-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -656,28 +656,28 @@ mep_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_CDISP10 :
       {
-        long value = fields->f_cdisp10;
+        long long value = fields->f_cdisp10;
         value = (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (512))) ? (((((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023))) - (1024))) : (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023)));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 22, 10, 32, total_length, buffer);
       }
       break;
     case MEP_OPERAND_CDISP10A2 :
       {
-        long value = fields->f_cdisp10;
+        long long value = fields->f_cdisp10;
         value = (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (512))) ? (((((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023))) - (1024))) : (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023)));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 22, 10, 32, total_length, buffer);
       }
       break;
     case MEP_OPERAND_CDISP10A4 :
       {
-        long value = fields->f_cdisp10;
+        long long value = fields->f_cdisp10;
         value = (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (512))) ? (((((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023))) - (1024))) : (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023)));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 22, 10, 32, total_length, buffer);
       }
       break;
     case MEP_OPERAND_CDISP10A8 :
       {
-        long value = fields->f_cdisp10;
+        long long value = fields->f_cdisp10;
         value = (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (512))) ? (((((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023))) - (1024))) : (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023)));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 22, 10, 32, total_length, buffer);
       }
@@ -1009,14 +1009,14 @@ mep_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_PCREL12A2 :
       {
-        long value = fields->f_12s4a2;
+        long long value = fields->f_12s4a2;
         value = ((SI) (((value) - (pc))) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 4, 11, 32, total_length, buffer);
       }
       break;
     case MEP_OPERAND_PCREL17A2 :
       {
-        long value = fields->f_17s16a2;
+        long long value = fields->f_17s16a2;
         value = ((SI) (((value) - (pc))) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 16, 16, 32, total_length, buffer);
       }
@@ -1038,7 +1038,7 @@ mep_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_PCREL8A2 :
       {
-        long value = fields->f_8s8a2;
+        long long value = fields->f_8s8a2;
         value = ((SI) (((value) - (pc))) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 7, 32, total_length, buffer);
       }
@@ -1156,14 +1156,14 @@ mep_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_UDISP7A2 :
       {
-        long value = fields->f_7u9a2;
+        long long value = fields->f_7u9a2;
         value = ((USI) (value) >> (1));
         errmsg = insert_normal (cd, value, 0, 0, 9, 6, 32, total_length, buffer);
       }
       break;
     case MEP_OPERAND_UDISP7A4 :
       {
-        long value = fields->f_7u9a4;
+        long long value = fields->f_7u9a4;
         value = ((USI) (value) >> (2));
         errmsg = insert_normal (cd, value, 0, 0, 9, 5, 32, total_length, buffer);
       }
@@ -1199,7 +1199,7 @@ mep_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_UIMM7A4 :
       {
-        long value = fields->f_7u9a4;
+        long long value = fields->f_7u9a4;
         value = ((USI) (value) >> (2));
         errmsg = insert_normal (cd, value, 0, 0, 9, 5, 32, total_length, buffer);
       }
@@ -1308,7 +1308,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_CDISP10 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 22, 10, 32, total_length, pc, & value);
         value = (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (512))) ? (((((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023))) - (1024))) : (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023)));
         fields->f_cdisp10 = value;
@@ -1316,7 +1316,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_CDISP10A2 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 22, 10, 32, total_length, pc, & value);
         value = (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (512))) ? (((((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023))) - (1024))) : (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023)));
         fields->f_cdisp10 = value;
@@ -1324,7 +1324,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_CDISP10A4 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 22, 10, 32, total_length, pc, & value);
         value = (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (512))) ? (((((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023))) - (1024))) : (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023)));
         fields->f_cdisp10 = value;
@@ -1332,7 +1332,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_CDISP10A8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 22, 10, 32, total_length, pc, & value);
         value = (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (512))) ? (((((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023))) - (1024))) : (((((((((value) & (128))) ? (((value) ^ (768))) : (value)) & (512))) ? ((((((value) & (128))) ? (((value) ^ (768))) : (value)) - (1024))) : ((((value) & (128))) ? (((value) ^ (768))) : (value))) & (1023)));
         fields->f_cdisp10 = value;
@@ -1617,7 +1617,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_PCREL12A2 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 4, 11, 32, total_length, pc, & value);
         value = ((((value) << (1))) + (pc));
         fields->f_12s4a2 = value;
@@ -1625,7 +1625,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_PCREL17A2 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 16, 16, 32, total_length, pc, & value);
         value = ((((value) << (1))) + (pc));
         fields->f_17s16a2 = value;
@@ -1642,7 +1642,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_PCREL8A2 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 7, 32, total_length, pc, & value);
         value = ((((value) << (1))) + (pc));
         fields->f_8s8a2 = value;
@@ -1758,7 +1758,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_UDISP7A2 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 9, 6, 32, total_length, pc, & value);
         value = ((value) << (1));
         fields->f_7u9a2 = value;
@@ -1766,7 +1766,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_UDISP7A4 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 9, 5, 32, total_length, pc, & value);
         value = ((value) << (2));
         fields->f_7u9a4 = value;
@@ -1798,7 +1798,7 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MEP_OPERAND_UIMM7A4 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 9, 5, 32, total_length, pc, & value);
         value = ((value) << (2));
         fields->f_7u9a4 = value;
diff --git a/opcodes/mep-opc.h b/opcodes/mep-opc.h
index f8c8d70..f5218ec 100644
--- a/opcodes/mep-opc.h
+++ b/opcodes/mep-opc.h
@@ -347,162 +347,162 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_major;
-  long f_rn;
-  long f_rn3;
-  long f_rm;
-  long f_rl;
-  long f_sub2;
-  long f_sub3;
-  long f_sub4;
-  long f_ext;
-  long f_ext4;
-  long f_ext62;
-  long f_crn;
-  long f_csrn_hi;
-  long f_csrn_lo;
-  long f_csrn;
-  long f_crnx_hi;
-  long f_crnx_lo;
-  long f_crnx;
-  long f_0;
-  long f_1;
-  long f_2;
-  long f_3;
-  long f_4;
-  long f_5;
-  long f_6;
-  long f_7;
-  long f_8;
-  long f_9;
-  long f_10;
-  long f_11;
-  long f_12;
-  long f_13;
-  long f_14;
-  long f_15;
-  long f_16;
-  long f_17;
-  long f_18;
-  long f_19;
-  long f_20;
-  long f_21;
-  long f_22;
-  long f_23;
-  long f_24;
-  long f_25;
-  long f_26;
-  long f_27;
-  long f_28;
-  long f_29;
-  long f_30;
-  long f_31;
-  long f_8s8a2;
-  long f_12s4a2;
-  long f_17s16a2;
-  long f_24s5a2n_hi;
-  long f_24s5a2n_lo;
-  long f_24s5a2n;
-  long f_24u5a2n_hi;
-  long f_24u5a2n_lo;
-  long f_24u5a2n;
-  long f_2u6;
-  long f_7u9;
-  long f_7u9a2;
-  long f_7u9a4;
-  long f_16s16;
-  long f_2u10;
-  long f_3u5;
-  long f_4u8;
-  long f_5u8;
-  long f_5u24;
-  long f_6s8;
-  long f_8s8;
-  long f_16u16;
-  long f_12u16;
-  long f_3u29;
-  long f_cdisp10;
-  long f_24u8a4n_hi;
-  long f_24u8a4n_lo;
-  long f_24u8a4n;
-  long f_24u8n_hi;
-  long f_24u8n_lo;
-  long f_24u8n;
-  long f_24u4n_hi;
-  long f_24u4n_lo;
-  long f_24u4n;
-  long f_callnum;
-  long f_ccrn_hi;
-  long f_ccrn_lo;
-  long f_ccrn;
-  long f_c5n4;
-  long f_c5n5;
-  long f_c5n6;
-  long f_c5n7;
-  long f_rl5;
-  long f_12s20;
-  long f_c5_rnm;
-  long f_c5_rm;
-  long f_c5_16u16;
-  long f_c5_rmuimm20;
-  long f_c5_rnmuimm24;
-  long f_ivc2_2u4;
-  long f_ivc2_3u4;
-  long f_ivc2_8u4;
-  long f_ivc2_8s4;
-  long f_ivc2_1u6;
-  long f_ivc2_2u6;
-  long f_ivc2_3u6;
-  long f_ivc2_6u6;
-  long f_ivc2_5u7;
-  long f_ivc2_4u8;
-  long f_ivc2_3u9;
-  long f_ivc2_5u16;
-  long f_ivc2_5u21;
-  long f_ivc2_5u26;
-  long f_ivc2_1u31;
-  long f_ivc2_4u16;
-  long f_ivc2_4u20;
-  long f_ivc2_4u24;
-  long f_ivc2_4u28;
-  long f_ivc2_2u0;
-  long f_ivc2_3u0;
-  long f_ivc2_4u0;
-  long f_ivc2_5u0;
-  long f_ivc2_8u0;
-  long f_ivc2_8s0;
-  long f_ivc2_6u2;
-  long f_ivc2_5u3;
-  long f_ivc2_4u4;
-  long f_ivc2_3u5;
-  long f_ivc2_5u8;
-  long f_ivc2_4u10;
-  long f_ivc2_3u12;
-  long f_ivc2_5u13;
-  long f_ivc2_2u18;
-  long f_ivc2_5u18;
-  long f_ivc2_8u20;
-  long f_ivc2_8s20;
-  long f_ivc2_5u23;
-  long f_ivc2_2u23;
-  long f_ivc2_3u25;
-  long f_ivc2_imm16p0;
-  long f_ivc2_simm16p0;
-  long f_ivc2_ccrn_c3hi;
-  long f_ivc2_ccrn_c3lo;
-  long f_ivc2_crn;
-  long f_ivc2_crm;
-  long f_ivc2_ccrn_h1;
-  long f_ivc2_ccrn_h2;
-  long f_ivc2_ccrn_lo;
-  long f_ivc2_cmov1;
-  long f_ivc2_cmov2;
-  long f_ivc2_cmov3;
-  long f_ivc2_ccrn_c3;
-  long f_ivc2_ccrn;
-  long f_ivc2_crnx;
+  long long f_nil;
+  long long f_anyof;
+  long long f_major;
+  long long f_rn;
+  long long f_rn3;
+  long long f_rm;
+  long long f_rl;
+  long long f_sub2;
+  long long f_sub3;
+  long long f_sub4;
+  long long f_ext;
+  long long f_ext4;
+  long long f_ext62;
+  long long f_crn;
+  long long f_csrn_hi;
+  long long f_csrn_lo;
+  long long f_csrn;
+  long long f_crnx_hi;
+  long long f_crnx_lo;
+  long long f_crnx;
+  long long f_0;
+  long long f_1;
+  long long f_2;
+  long long f_3;
+  long long f_4;
+  long long f_5;
+  long long f_6;
+  long long f_7;
+  long long f_8;
+  long long f_9;
+  long long f_10;
+  long long f_11;
+  long long f_12;
+  long long f_13;
+  long long f_14;
+  long long f_15;
+  long long f_16;
+  long long f_17;
+  long long f_18;
+  long long f_19;
+  long long f_20;
+  long long f_21;
+  long long f_22;
+  long long f_23;
+  long long f_24;
+  long long f_25;
+  long long f_26;
+  long long f_27;
+  long long f_28;
+  long long f_29;
+  long long f_30;
+  long long f_31;
+  long long f_8s8a2;
+  long long f_12s4a2;
+  long long f_17s16a2;
+  long long f_24s5a2n_hi;
+  long long f_24s5a2n_lo;
+  long long f_24s5a2n;
+  long long f_24u5a2n_hi;
+  long long f_24u5a2n_lo;
+  long long f_24u5a2n;
+  long long f_2u6;
+  long long f_7u9;
+  long long f_7u9a2;
+  long long f_7u9a4;
+  long long f_16s16;
+  long long f_2u10;
+  long long f_3u5;
+  long long f_4u8;
+  long long f_5u8;
+  long long f_5u24;
+  long long f_6s8;
+  long long f_8s8;
+  long long f_16u16;
+  long long f_12u16;
+  long long f_3u29;
+  long long f_cdisp10;
+  long long f_24u8a4n_hi;
+  long long f_24u8a4n_lo;
+  long long f_24u8a4n;
+  long long f_24u8n_hi;
+  long long f_24u8n_lo;
+  long long f_24u8n;
+  long long f_24u4n_hi;
+  long long f_24u4n_lo;
+  long long f_24u4n;
+  long long f_callnum;
+  long long f_ccrn_hi;
+  long long f_ccrn_lo;
+  long long f_ccrn;
+  long long f_c5n4;
+  long long f_c5n5;
+  long long f_c5n6;
+  long long f_c5n7;
+  long long f_rl5;
+  long long f_12s20;
+  long long f_c5_rnm;
+  long long f_c5_rm;
+  long long f_c5_16u16;
+  long long f_c5_rmuimm20;
+  long long f_c5_rnmuimm24;
+  long long f_ivc2_2u4;
+  long long f_ivc2_3u4;
+  long long f_ivc2_8u4;
+  long long f_ivc2_8s4;
+  long long f_ivc2_1u6;
+  long long f_ivc2_2u6;
+  long long f_ivc2_3u6;
+  long long f_ivc2_6u6;
+  long long f_ivc2_5u7;
+  long long f_ivc2_4u8;
+  long long f_ivc2_3u9;
+  long long f_ivc2_5u16;
+  long long f_ivc2_5u21;
+  long long f_ivc2_5u26;
+  long long f_ivc2_1u31;
+  long long f_ivc2_4u16;
+  long long f_ivc2_4u20;
+  long long f_ivc2_4u24;
+  long long f_ivc2_4u28;
+  long long f_ivc2_2u0;
+  long long f_ivc2_3u0;
+  long long f_ivc2_4u0;
+  long long f_ivc2_5u0;
+  long long f_ivc2_8u0;
+  long long f_ivc2_8s0;
+  long long f_ivc2_6u2;
+  long long f_ivc2_5u3;
+  long long f_ivc2_4u4;
+  long long f_ivc2_3u5;
+  long long f_ivc2_5u8;
+  long long f_ivc2_4u10;
+  long long f_ivc2_3u12;
+  long long f_ivc2_5u13;
+  long long f_ivc2_2u18;
+  long long f_ivc2_5u18;
+  long long f_ivc2_8u20;
+  long long f_ivc2_8s20;
+  long long f_ivc2_5u23;
+  long long f_ivc2_2u23;
+  long long f_ivc2_3u25;
+  long long f_ivc2_imm16p0;
+  long long f_ivc2_simm16p0;
+  long long f_ivc2_ccrn_c3hi;
+  long long f_ivc2_ccrn_c3lo;
+  long long f_ivc2_crn;
+  long long f_ivc2_crm;
+  long long f_ivc2_ccrn_h1;
+  long long f_ivc2_ccrn_h2;
+  long long f_ivc2_ccrn_lo;
+  long long f_ivc2_cmov1;
+  long long f_ivc2_cmov2;
+  long long f_ivc2_cmov3;
+  long long f_ivc2_ccrn_c3;
+  long long f_ivc2_ccrn;
+  long long f_ivc2_crnx;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/microblaze-dis.c b/opcodes/microblaze-dis.c
index 3b676d8..952cb2c 100644
--- a/opcodes/microblaze-dis.c
+++ b/opcodes/microblaze-dis.c
@@ -38,7 +38,7 @@
 
 
 static char *
-get_field (long instr, long mask, unsigned short low)
+get_field (long long instr, long long mask, unsigned short low)
 {
   char tmpstr[25];
 
@@ -47,7 +47,7 @@ get_field (long instr, long mask, unsigned short low)
 }
 
 static char *
-get_field_imm (long instr)
+get_field_imm (long long instr)
 {
   char tmpstr[25];
 
@@ -56,7 +56,7 @@ get_field_imm (long instr)
 }
 
 static char *
-get_field_imm5 (long instr)
+get_field_imm5 (long long instr)
 {
   char tmpstr[25];
 
@@ -65,7 +65,7 @@ get_field_imm5 (long instr)
 }
 
 static char *
-get_field_imm5_mbar (long instr)
+get_field_imm5_mbar (long long instr)
 {
   char tmpstr[25];
 
@@ -74,7 +74,7 @@ get_field_imm5_mbar (long instr)
 }
 
 static char *
-get_field_rfsl (long instr)
+get_field_rfsl (long long instr)
 {
   char tmpstr[25];
 
@@ -84,7 +84,7 @@ get_field_rfsl (long instr)
 }
 
 static char *
-get_field_imm15 (long instr)
+get_field_imm15 (long long instr)
 {
   char tmpstr[25];
 
@@ -93,7 +93,7 @@ get_field_imm15 (long instr)
 }
 
 static char *
-get_field_special (long instr, struct op_code_struct * op)
+get_field_special (long long instr, struct op_code_struct * op)
 {
   char tmpstr[25];
   char spr[6];
@@ -163,7 +163,7 @@ get_field_special (long instr, struct op_code_struct * op)
    return (strdup (tmpstr));
 }
 
-static unsigned long
+static unsigned long long
 read_insn_microblaze (bfd_vma memaddr,
 		      struct disassemble_info *info,
 		      struct op_code_struct **opr)
@@ -171,7 +171,7 @@ read_insn_microblaze (bfd_vma memaddr,
   unsigned char       ibytes[4];
   int                 status;
   struct op_code_struct * op;
-  unsigned long inst;
+  unsigned long long inst;
 
   status = info->read_memory_func (memaddr, ibytes, 4, info);
 
@@ -203,7 +203,7 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)
 {
   fprintf_ftype       print_func = info->fprintf_func;
   void *              stream = info->stream;
-  unsigned long       inst, prev_inst;
+  unsigned long long       inst, prev_inst;
   struct op_code_struct * op, *pop;
   int                 immval = 0;
   bfd_boolean         immfound = FALSE;
@@ -415,7 +415,7 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)
 }
 
 enum microblaze_instr
-get_insn_microblaze (long inst,
+get_insn_microblaze (long long inst,
   		     bfd_boolean *isunsignedimm,
   		     enum microblaze_instr_type *insn_type,
   		     short *delay_slots)
@@ -440,7 +440,7 @@ get_insn_microblaze (long inst,
 }
 
 enum microblaze_instr
-microblaze_decode_insn (long insn, int *rd, int *ra, int *rb, int *immed)
+microblaze_decode_insn (long long insn, int *rd, int *ra, int *rb, int *immed)
 {
   enum microblaze_instr op;
   bfd_boolean t1;
@@ -456,14 +456,14 @@ microblaze_decode_insn (long insn, int *rd, int *ra, int *rb, int *immed)
   return (op);
 }
 
-unsigned long
-microblaze_get_target_address (long inst, bfd_boolean immfound, int immval,
-			       long pcval, long r1val, long r2val,
+unsigned long long
+microblaze_get_target_address (long long inst, bfd_boolean immfound, int immval,
+			       long long pcval, long long r1val, long long r2val,
 			       bfd_boolean *targetvalid,
 			       bfd_boolean *unconditionalbranch)
 {
   struct op_code_struct * op;
-  long targetaddr = 0;
+  long long targetaddr = 0;
 
   *unconditionalbranch = FALSE;
   /* Just a linear search of the table.  */
diff --git a/opcodes/microblaze-dis.h b/opcodes/microblaze-dis.h
index 2424763..74401e2 100644
--- a/opcodes/microblaze-dis.h
+++ b/opcodes/microblaze-dis.h
@@ -26,12 +26,12 @@
 extern "C" {
 #endif
 
-extern enum microblaze_instr microblaze_decode_insn (long, int *, int *,
+extern enum microblaze_instr microblaze_decode_insn (long long, int *, int *,
 						     int *, int *);
-extern unsigned long microblaze_get_target_address (long, bfd_boolean, int,
-			       long, long, long, bfd_boolean *, bfd_boolean *);
+extern unsigned long long microblaze_get_target_address (long long, bfd_boolean, int,
+			       long long, long long, long long, bfd_boolean *, bfd_boolean *);
 
-extern enum microblaze_instr get_insn_microblaze (long, bfd_boolean *,
+extern enum microblaze_instr get_insn_microblaze (long long, bfd_boolean *,
 						  enum microblaze_instr_type *,
   		     				  short *);
 
diff --git a/opcodes/microblaze-opc.h b/opcodes/microblaze-opc.h
index ede8af8..79e40d6 100644
--- a/opcodes/microblaze-opc.h
+++ b/opcodes/microblaze-opc.h
@@ -110,10 +110,10 @@ struct op_code_struct
   short inst_offset_type;     /* Immediate vals offset from PC? (= 1 for branches).  */
   short delay_slots;          /* Info about delay slots needed after this instr. */
   short immval_mask;
-  unsigned long bit_sequence; /* All the fixed bits for the op are set and
+  unsigned long long bit_sequence; /* All the fixed bits for the op are set and
 				 all the variable bits (reg names, imm vals)
 				 are set to 0.  */
-  unsigned long opcode_mask;  /* Which bits define the opcode.  */
+  unsigned long long opcode_mask;  /* Which bits define the opcode.  */
   enum microblaze_instr instr;
   enum microblaze_instr_type instr_type;
   /* More info about output format here.  */
diff --git a/opcodes/mips-dis.c b/opcodes/mips-dis.c
index bbf2132..d86b2f4 100644
--- a/opcodes/mips-dis.c
+++ b/opcodes/mips-dis.c
@@ -435,7 +435,7 @@ struct mips_arch_choice
 {
   const char *name;
   int bfd_mach_valid;
-  unsigned long bfd_mach;
+  unsigned long long bfd_mach;
   int processor;
   int isa;
   int ase;
@@ -719,9 +719,9 @@ choose_arch_by_name (const char *name, unsigned int namelen)
 }
 
 static const struct mips_arch_choice *
-choose_arch_by_number (unsigned long mach)
+choose_arch_by_number (unsigned long long mach)
 {
-  static unsigned long hint_bfd_mach;
+  static unsigned long long hint_bfd_mach;
   static const struct mips_arch_choice *hint_arch_choice;
   const struct mips_arch_choice *c;
   unsigned int i;
@@ -775,10 +775,10 @@ is_micromips (Elf_Internal_Ehdr *header)
 
 /* Convert ASE flags from .MIPS.abiflags to internal values.  */
 
-static unsigned long
-mips_convert_abiflags_ases (unsigned long afl_ases)
+static unsigned long long
+mips_convert_abiflags_ases (unsigned long long afl_ases)
 {
-  unsigned long opcode_ases = 0;
+  unsigned long long opcode_ases = 0;
 
   if (afl_ases & AFL_ASE_DSP)
     opcode_ases |= ASE_DSP;
@@ -811,10 +811,10 @@ mips_convert_abiflags_ases (unsigned long afl_ases)
 
 /* Calculate combination ASE flags from regular ASE flags.  */
 
-static unsigned long
-mips_calculate_combination_ases (unsigned long opcode_ases)
+static unsigned long long
+mips_calculate_combination_ases (unsigned long long opcode_ases)
 {
-  unsigned long combination_ases = 0;
+  unsigned long long combination_ases = 0;
 
   if ((opcode_ases & (ASE_XPA | ASE_VIRT)) == (ASE_XPA | ASE_VIRT))
     combination_ases |= ASE_XPA_VIRT;
diff --git a/opcodes/mmix-dis.c b/opcodes/mmix-dis.c
index 89a4cd9..daacccb 100644
--- a/opcodes/mmix-dis.c
+++ b/opcodes/mmix-dis.c
@@ -71,7 +71,7 @@ static bfd_boolean
 initialize_mmix_dis_info (struct disassemble_info *info)
 {
   struct mmix_dis_info *minfop = malloc (sizeof (struct mmix_dis_info));
-  long i;
+  long long i;
 
   if (minfop == NULL)
     return FALSE;
@@ -93,9 +93,9 @@ initialize_mmix_dis_info (struct disassemble_info *info)
       if (reg_section != NULL)
 	{
 	  /* The returned symcount *does* include the ending NULL.  */
-	  long symsize = bfd_get_symtab_upper_bound (abfd);
+	  long long symsize = bfd_get_symtab_upper_bound (abfd);
 	  asymbol **syms = malloc (symsize);
-	  long nsyms;
+	  long long nsyms;
 
 	  if (syms == NULL)
 	    {
@@ -142,7 +142,7 @@ initialize_mmix_dis_info (struct disassemble_info *info)
    "further entry" will just show that there was no other match.  */
 
 static const struct mmix_opcode *
-get_opcode (unsigned long insn)
+get_opcode (unsigned long long insn)
 {
   static const struct mmix_opcode **opcodes = NULL;
   const struct mmix_opcode *opcodep = mmix_opcodes;
@@ -244,7 +244,7 @@ int
 print_insn_mmix (bfd_vma memaddr, struct disassemble_info *info)
 {
   unsigned char buffer[4];
-  unsigned long insn;
+  unsigned long long insn;
   unsigned int x, y, z;
   const struct mmix_opcode *opcodep;
   int status = (*info->read_memory_func) (memaddr, buffer, 4, info);
diff --git a/opcodes/mmix-opc.c b/opcodes/mmix-opc.c
index 6158d8f..78fe3aa 100644
--- a/opcodes/mmix-opc.c
+++ b/opcodes/mmix-opc.c
@@ -68,11 +68,11 @@ const struct mmix_spec_reg mmix_spec_regs[] =
 /* All bits in the opcode-byte are significant.  Add "| ..." expressions
    to add zero-bits.  */
 #undef O
-#define O(m) ((unsigned long) (m) << 24UL), ((~(unsigned long) (m) & 255) << 24)
+#define O(m) ((unsigned long long) (m) << 24UL), ((~(unsigned long long) (m) & 255) << 24)
 
 /* Bits 7..1 of the opcode are significant.  */
 #undef Z
-#define Z(m) ((unsigned long) (m) << 24), ((~(unsigned long) (m) & 254) << 24)
+#define Z(m) ((unsigned long long) (m) << 24), ((~(unsigned long long) (m) & 254) << 24)
 
 /* For easier overview of the table.  */
 #define N mmix_type_normal
diff --git a/opcodes/msp430-decode.c b/opcodes/msp430-decode.c
index 68d9073..77aa6dc 100644
--- a/opcodes/msp430-decode.c
+++ b/opcodes/msp430-decode.c
@@ -44,7 +44,7 @@ typedef struct
 
 #define AU ATTRIBUTE_UNUSED
 #define GETBYTE() getbyte_swapped (ld)
-#define B ((unsigned long) GETBYTE ())
+#define B ((unsigned long long) GETBYTE ())
 
 static int
 getbyte_swapped (LocalData *ld)
@@ -112,7 +112,7 @@ getbyte_swapped (LocalData *ld)
 static int
 immediate (int bytes, int sign_extend, LocalData *ld)
 {
-  unsigned long i = 0;
+  unsigned long long i = 0;
 
   switch (bytes)
     {
@@ -320,7 +320,7 @@ sopc_to_id (int sop, int c)
 }
 
 int
-msp430_decode_opcode (unsigned long pc,
+msp430_decode_opcode (unsigned long long pc,
 		      MSP430_Opcode_Decoded *msp430,
 		      int (*getbyte)(void *),
 		      void *ptr)
diff --git a/opcodes/msp430-dis.c b/opcodes/msp430-dis.c
index b30e7fa..f3043ab 100644
--- a/opcodes/msp430-dis.c
+++ b/opcodes/msp430-dis.c
@@ -267,7 +267,7 @@ msp430_singleoperand (disassemble_info *info,
 		      dst |= extended_dst << 16;
 		      sprintf (op, "0x%05x", dst);
 		      sprintf (comm, "PC rel. abs addr 0x%05lx",
-			       (long)((addr + 2 + dst) & 0xfffff));
+			       (long long)((addr + 2 + dst) & 0xfffff));
 		    }
 		}
 	      else
@@ -375,7 +375,7 @@ msp430_singleoperand (disassemble_info *info,
 		      dst |= extended_dst << 16;
 		      sprintf (op, "0x%05x", dst & 0xffff);
 		      sprintf (comm, "PC rel. 0x%05lx",
-			       (long)((addr + 2 + dst) & 0xfffff));
+			       (long long)((addr + 2 + dst) & 0xfffff));
 		    }
 		}
 	      else
@@ -434,7 +434,7 @@ msp430_singleoperand (disassemble_info *info,
 
       where *= 2;
       sprintf (op, "$%+-8d", where + 2);
-      sprintf (comm, "abs 0x%lx", (long) (addr + 2 + where));
+      sprintf (comm, "abs 0x%lx", (long long) (addr + 2 + where));
       *cycles = 2;
       return 2;
       break;
@@ -522,7 +522,7 @@ msp430_doubleoperand (disassemble_info *info,
 			dst |= -1U << 20;
 		      sprintf (op1, "0x%05x", dst & 0xfffff);
 		      sprintf (comm1, "PC rel. 0x%05lx",
-			       (long)((addr + 2 + dst) & 0xfffff));
+			       (long long)((addr + 2 + dst) & 0xfffff));
 		    }
 		}
 	      else
@@ -661,7 +661,7 @@ msp430_doubleoperand (disassemble_info *info,
 		    dst |= -1U << 20;
 		  sprintf (op1, "0x%05x", dst & 0xfffff);
 		  sprintf (comm1, "PC rel. 0x%05lx",
-			   (long) ((addr + 2 + dst) & 0xfffff));
+			   (long long) ((addr + 2 + dst) & 0xfffff));
 		}
 	    }
 	  else
@@ -755,7 +755,7 @@ msp430_doubleoperand (disassemble_info *info,
 		    dst |= -1U << 20;
 		  sprintf (op2, "0x%05x", dst & 0xfffff);
 		  sprintf (comm2, "PC rel. 0x%05lx",
-			   (long)((addr + cmd_len + dst) & 0xfffff));
+			   (long long)((addr + cmd_len + dst) & 0xfffff));
 		}
 	    }
 	  else
@@ -943,7 +943,7 @@ msp430x_calla_instr (disassemble_info * info,
 	  cmd_len += 2;
 	  sprintf (op1, "%d(r%d)", dst, reg);
 	  if (reg == 0)
-	    sprintf (comm1, "PC rel. 0x%05lx", (long) (addr + 2 + dst));
+	    sprintf (comm1, "PC rel. 0x%05lx", (long long) (addr + 2 + dst));
 	  else
 	    sprintf (comm1, "0x%05x", dst);
 	}
@@ -980,7 +980,7 @@ msp430x_calla_instr (disassemble_info * info,
 	  *cycles = 4;
 	  sprintf (op1, "%d(PC)", (reg << 16) + dst);
 	  sprintf (comm1, "PC rel. 0x%05lx",
-		   (long) (addr + 2 + dst + (reg << 16)));
+		   (long long) (addr + 2 + dst + (reg << 16)));
 	}
       else
 	return -1;
@@ -1191,7 +1191,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
 			{
 			  if (reg == 0)
 			    sprintf (comm1, "PC rel. 0x%05lx",
-				     (long) (addr + 2 + n));
+				     (long long) (addr + 2 + n));
 			  else
 			    sprintf (comm1, "0x%05x", n);
 			}
@@ -1225,7 +1225,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
 			{
 			  if (reg == 0)
 			    sprintf (comm2, "PC rel. 0x%05lx",
-				     (long) (addr + 2 + n));
+				     (long long) (addr + 2 + n));
 			  else
 			    sprintf (comm2, "0x%05x", n);
 			}
diff --git a/opcodes/mt-asm.c b/opcodes/mt-asm.c
index cfab162..f7fc506 100644
--- a/opcodes/mt-asm.c
+++ b/opcodes/mt-asm.c
@@ -54,7 +54,7 @@ static const char * parse_insn_normal
    and 1 if the value is out of bounds for a signed quantity.  */
 
 static int
-signed_out_of_bounds (long val)
+signed_out_of_bounds (long long val)
 {
   if ((val < -32768) || (val > 32767))
     return 1;
@@ -67,7 +67,7 @@ parse_loopsize (CGEN_CPU_DESC cd,
 		int opindex,
 		void *arg)
 {
-  signed long * valuep = (signed long *) arg;
+  signed long long * valuep = (signed long long *) arg;
   const char *errmsg;
   bfd_reloc_code_real_type code = BFD_RELOC_NONE;
   enum cgen_parse_operand_result result_type;
@@ -92,7 +92,7 @@ parse_imm16 (CGEN_CPU_DESC cd,
 	     int opindex,
 	     void *arg)
 {
-  signed long * valuep = (signed long *) arg;
+  signed long long * valuep = (signed long long *) arg;
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_reloc_code_real_type code = BFD_RELOC_NONE;
@@ -197,7 +197,7 @@ parse_imm16 (CGEN_CPU_DESC cd,
       else
 	{
           /* MT_OPERAND_IMM16Z.  Parse as an unsigned integer.  */
-          errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, (unsigned long *) valuep);
+          errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, (unsigned long long *) valuep);
 
 	  if (opindex == (CGEN_OPERAND_TYPE) MT_OPERAND_IMM16
 	      && *valuep >= 0x8000
@@ -214,7 +214,7 @@ static const char *
 parse_dup (CGEN_CPU_DESC cd,
 	   const char **strp,
 	   int opindex,
-	   unsigned long *valuep)
+	   unsigned long long *valuep)
 {
   const char *errmsg = NULL;
 
@@ -239,7 +239,7 @@ static const char *
 parse_ball (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   const char *errmsg = NULL;
 
@@ -263,7 +263,7 @@ static const char *
 parse_xmode (CGEN_CPU_DESC cd,
 	     const char **strp,
 	     int opindex,
-	     unsigned long *valuep)
+	     unsigned long long *valuep)
 {
   const char *errmsg = NULL;
 
@@ -287,7 +287,7 @@ static const char *
 parse_rc (CGEN_CPU_DESC cd,
 	  const char **strp,
 	  int opindex,
-	  unsigned long *valuep)
+	  unsigned long long *valuep)
 {
   const char *errmsg = NULL;
 
@@ -311,7 +311,7 @@ static const char *
 parse_cbrb (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   const char *errmsg = NULL;
 
@@ -335,7 +335,7 @@ static const char *
 parse_rbbc (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   const char *errmsg = NULL;
 
@@ -369,7 +369,7 @@ static const char *
 parse_type (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   const char *errmsg = NULL;
 
@@ -423,78 +423,78 @@ mt_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
     case MT_OPERAND_A23 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_A23, (unsigned long *) (& fields->f_a23));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_A23, (unsigned long long *) (& fields->f_a23));
       break;
     case MT_OPERAND_BALL :
-      errmsg = parse_ball (cd, strp, MT_OPERAND_BALL, (unsigned long *) (& fields->f_ball));
+      errmsg = parse_ball (cd, strp, MT_OPERAND_BALL, (unsigned long long *) (& fields->f_ball));
       break;
     case MT_OPERAND_BALL2 :
-      errmsg = parse_ball (cd, strp, MT_OPERAND_BALL2, (unsigned long *) (& fields->f_ball2));
+      errmsg = parse_ball (cd, strp, MT_OPERAND_BALL2, (unsigned long long *) (& fields->f_ball2));
       break;
     case MT_OPERAND_BANKADDR :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_BANKADDR, (unsigned long *) (& fields->f_bankaddr));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_BANKADDR, (unsigned long long *) (& fields->f_bankaddr));
       break;
     case MT_OPERAND_BRC :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_BRC, (unsigned long *) (& fields->f_brc));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_BRC, (unsigned long long *) (& fields->f_brc));
       break;
     case MT_OPERAND_BRC2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_BRC2, (unsigned long *) (& fields->f_brc2));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_BRC2, (unsigned long long *) (& fields->f_brc2));
       break;
     case MT_OPERAND_CB1INCR :
-      errmsg = cgen_parse_signed_integer (cd, strp, MT_OPERAND_CB1INCR, (long *) (& fields->f_cb1incr));
+      errmsg = cgen_parse_signed_integer (cd, strp, MT_OPERAND_CB1INCR, (long long *) (& fields->f_cb1incr));
       break;
     case MT_OPERAND_CB1SEL :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CB1SEL, (unsigned long *) (& fields->f_cb1sel));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CB1SEL, (unsigned long long *) (& fields->f_cb1sel));
       break;
     case MT_OPERAND_CB2INCR :
-      errmsg = cgen_parse_signed_integer (cd, strp, MT_OPERAND_CB2INCR, (long *) (& fields->f_cb2incr));
+      errmsg = cgen_parse_signed_integer (cd, strp, MT_OPERAND_CB2INCR, (long long *) (& fields->f_cb2incr));
       break;
     case MT_OPERAND_CB2SEL :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CB2SEL, (unsigned long *) (& fields->f_cb2sel));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CB2SEL, (unsigned long long *) (& fields->f_cb2sel));
       break;
     case MT_OPERAND_CBRB :
-      errmsg = parse_cbrb (cd, strp, MT_OPERAND_CBRB, (unsigned long *) (& fields->f_cbrb));
+      errmsg = parse_cbrb (cd, strp, MT_OPERAND_CBRB, (unsigned long long *) (& fields->f_cbrb));
       break;
     case MT_OPERAND_CBS :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CBS, (unsigned long *) (& fields->f_cbs));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CBS, (unsigned long long *) (& fields->f_cbs));
       break;
     case MT_OPERAND_CBX :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CBX, (unsigned long *) (& fields->f_cbx));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CBX, (unsigned long long *) (& fields->f_cbx));
       break;
     case MT_OPERAND_CCB :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CCB, (unsigned long *) (& fields->f_ccb));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CCB, (unsigned long long *) (& fields->f_ccb));
       break;
     case MT_OPERAND_CDB :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CDB, (unsigned long *) (& fields->f_cdb));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CDB, (unsigned long long *) (& fields->f_cdb));
       break;
     case MT_OPERAND_CELL :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CELL, (unsigned long *) (& fields->f_cell));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CELL, (unsigned long long *) (& fields->f_cell));
       break;
     case MT_OPERAND_COLNUM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_COLNUM, (unsigned long *) (& fields->f_colnum));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_COLNUM, (unsigned long long *) (& fields->f_colnum));
       break;
     case MT_OPERAND_CONTNUM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CONTNUM, (unsigned long *) (& fields->f_contnum));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CONTNUM, (unsigned long long *) (& fields->f_contnum));
       break;
     case MT_OPERAND_CR :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CR, (unsigned long *) (& fields->f_cr));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CR, (unsigned long long *) (& fields->f_cr));
       break;
     case MT_OPERAND_CTXDISP :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CTXDISP, (unsigned long *) (& fields->f_ctxdisp));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_CTXDISP, (unsigned long long *) (& fields->f_ctxdisp));
       break;
     case MT_OPERAND_DUP :
-      errmsg = parse_dup (cd, strp, MT_OPERAND_DUP, (unsigned long *) (& fields->f_dup));
+      errmsg = parse_dup (cd, strp, MT_OPERAND_DUP, (unsigned long long *) (& fields->f_dup));
       break;
     case MT_OPERAND_FBDISP :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_FBDISP, (unsigned long *) (& fields->f_fbdisp));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_FBDISP, (unsigned long long *) (& fields->f_fbdisp));
       break;
     case MT_OPERAND_FBINCR :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_FBINCR, (unsigned long *) (& fields->f_fbincr));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_FBINCR, (unsigned long long *) (& fields->f_fbincr));
       break;
     case MT_OPERAND_FRDR :
       errmsg = cgen_parse_keyword (cd, strp, & mt_cgen_opval_h_spr, & fields->f_dr);
@@ -509,85 +509,85 @@ mt_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & mt_cgen_opval_h_spr, & fields->f_sr2);
       break;
     case MT_OPERAND_ID :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_ID, (unsigned long *) (& fields->f_id));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_ID, (unsigned long long *) (& fields->f_id));
       break;
     case MT_OPERAND_IMM16 :
-      errmsg = parse_imm16 (cd, strp, MT_OPERAND_IMM16, (long *) (& fields->f_imm16s));
+      errmsg = parse_imm16 (cd, strp, MT_OPERAND_IMM16, (long long *) (& fields->f_imm16s));
       break;
     case MT_OPERAND_IMM16L :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_IMM16L, (unsigned long *) (& fields->f_imm16l));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_IMM16L, (unsigned long long *) (& fields->f_imm16l));
       break;
     case MT_OPERAND_IMM16O :
-      errmsg = parse_imm16 (cd, strp, MT_OPERAND_IMM16O, (unsigned long *) (& fields->f_imm16s));
+      errmsg = parse_imm16 (cd, strp, MT_OPERAND_IMM16O, (unsigned long long *) (& fields->f_imm16s));
       break;
     case MT_OPERAND_IMM16Z :
-      errmsg = parse_imm16 (cd, strp, MT_OPERAND_IMM16Z, (unsigned long *) (& fields->f_imm16u));
+      errmsg = parse_imm16 (cd, strp, MT_OPERAND_IMM16Z, (unsigned long long *) (& fields->f_imm16u));
       break;
     case MT_OPERAND_INCAMT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_INCAMT, (unsigned long *) (& fields->f_incamt));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_INCAMT, (unsigned long long *) (& fields->f_incamt));
       break;
     case MT_OPERAND_INCR :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_INCR, (unsigned long *) (& fields->f_incr));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_INCR, (unsigned long long *) (& fields->f_incr));
       break;
     case MT_OPERAND_LENGTH :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_LENGTH, (unsigned long *) (& fields->f_length));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_LENGTH, (unsigned long long *) (& fields->f_length));
       break;
     case MT_OPERAND_LOOPSIZE :
-      errmsg = parse_loopsize (cd, strp, MT_OPERAND_LOOPSIZE, (unsigned long *) (& fields->f_loopo));
+      errmsg = parse_loopsize (cd, strp, MT_OPERAND_LOOPSIZE, (unsigned long long *) (& fields->f_loopo));
       break;
     case MT_OPERAND_MASK :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_MASK, (unsigned long *) (& fields->f_mask));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_MASK, (unsigned long long *) (& fields->f_mask));
       break;
     case MT_OPERAND_MASK1 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_MASK1, (unsigned long *) (& fields->f_mask1));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_MASK1, (unsigned long long *) (& fields->f_mask1));
       break;
     case MT_OPERAND_MODE :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_MODE, (unsigned long *) (& fields->f_mode));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_MODE, (unsigned long long *) (& fields->f_mode));
       break;
     case MT_OPERAND_PERM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_PERM, (unsigned long *) (& fields->f_perm));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_PERM, (unsigned long long *) (& fields->f_perm));
       break;
     case MT_OPERAND_RBBC :
-      errmsg = parse_rbbc (cd, strp, MT_OPERAND_RBBC, (unsigned long *) (& fields->f_rbbc));
+      errmsg = parse_rbbc (cd, strp, MT_OPERAND_RBBC, (unsigned long long *) (& fields->f_rbbc));
       break;
     case MT_OPERAND_RC :
-      errmsg = parse_rc (cd, strp, MT_OPERAND_RC, (unsigned long *) (& fields->f_rc));
+      errmsg = parse_rc (cd, strp, MT_OPERAND_RC, (unsigned long long *) (& fields->f_rc));
       break;
     case MT_OPERAND_RC1 :
-      errmsg = parse_rc (cd, strp, MT_OPERAND_RC1, (unsigned long *) (& fields->f_rc1));
+      errmsg = parse_rc (cd, strp, MT_OPERAND_RC1, (unsigned long long *) (& fields->f_rc1));
       break;
     case MT_OPERAND_RC2 :
-      errmsg = parse_rc (cd, strp, MT_OPERAND_RC2, (unsigned long *) (& fields->f_rc2));
+      errmsg = parse_rc (cd, strp, MT_OPERAND_RC2, (unsigned long long *) (& fields->f_rc2));
       break;
     case MT_OPERAND_RC3 :
-      errmsg = parse_rc (cd, strp, MT_OPERAND_RC3, (unsigned long *) (& fields->f_rc3));
+      errmsg = parse_rc (cd, strp, MT_OPERAND_RC3, (unsigned long long *) (& fields->f_rc3));
       break;
     case MT_OPERAND_RCNUM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_RCNUM, (unsigned long *) (& fields->f_rcnum));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_RCNUM, (unsigned long long *) (& fields->f_rcnum));
       break;
     case MT_OPERAND_RDA :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_RDA, (unsigned long *) (& fields->f_rda));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_RDA, (unsigned long long *) (& fields->f_rda));
       break;
     case MT_OPERAND_ROWNUM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_ROWNUM, (unsigned long *) (& fields->f_rownum));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_ROWNUM, (unsigned long long *) (& fields->f_rownum));
       break;
     case MT_OPERAND_ROWNUM1 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_ROWNUM1, (unsigned long *) (& fields->f_rownum1));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_ROWNUM1, (unsigned long long *) (& fields->f_rownum1));
       break;
     case MT_OPERAND_ROWNUM2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_ROWNUM2, (unsigned long *) (& fields->f_rownum2));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_ROWNUM2, (unsigned long long *) (& fields->f_rownum2));
       break;
     case MT_OPERAND_SIZE :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_SIZE, (unsigned long *) (& fields->f_size));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_SIZE, (unsigned long long *) (& fields->f_size));
       break;
     case MT_OPERAND_TYPE :
-      errmsg = parse_type (cd, strp, MT_OPERAND_TYPE, (unsigned long *) (& fields->f_type));
+      errmsg = parse_type (cd, strp, MT_OPERAND_TYPE, (unsigned long long *) (& fields->f_type));
       break;
     case MT_OPERAND_WR :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_WR, (unsigned long *) (& fields->f_wr));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, MT_OPERAND_WR, (unsigned long long *) (& fields->f_wr));
       break;
     case MT_OPERAND_XMODE :
-      errmsg = parse_xmode (cd, strp, MT_OPERAND_XMODE, (unsigned long *) (& fields->f_xmode));
+      errmsg = parse_xmode (cd, strp, MT_OPERAND_XMODE, (unsigned long long *) (& fields->f_xmode));
       break;
 
     default :
diff --git a/opcodes/mt-dis.c b/opcodes/mt-dis.c
index 9b6df6a..9465cb4 100644
--- a/opcodes/mt-dis.c
+++ b/opcodes/mt-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,18 +54,18 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
 /* -- dis.c */
-static void print_dollarhex (CGEN_CPU_DESC, PTR, long, unsigned, bfd_vma, int);
-static void print_pcrel (CGEN_CPU_DESC, PTR, long, unsigned, bfd_vma, int);
+static void print_dollarhex (CGEN_CPU_DESC, PTR, long long, unsigned, bfd_vma, int);
+static void print_pcrel (CGEN_CPU_DESC, PTR, long long, unsigned, bfd_vma, int);
 
 static void
 print_dollarhex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		 void * dis_info,
-		 long value,
+		 long long value,
 		 unsigned int attrs ATTRIBUTE_UNUSED,
 		 bfd_vma pc ATTRIBUTE_UNUSED,
 		 int length ATTRIBUTE_UNUSED)
@@ -81,7 +81,7 @@ print_dollarhex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_pcrel (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	     void * dis_info,
-	     long value,
+	     long long value,
 	     unsigned int attrs ATTRIBUTE_UNUSED,
 	     bfd_vma pc ATTRIBUTE_UNUSED,
 	     int length ATTRIBUTE_UNUSED)
@@ -315,7 +315,7 @@ mt_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -351,9 +351,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -362,7 +362,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -424,7 +424,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -482,7 +482,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -501,7 +501,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -517,9 +517,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/mt-ibld.c b/opcodes/mt-ibld.c
index 4e8ed89..f98bc3f 100644
--- a/opcodes/mt-ibld.c
+++ b/opcodes/mt-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -659,7 +659,7 @@ mt_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case MT_OPERAND_IMM16 :
       {
-        long value = fields->f_imm16s;
+        long long value = fields->f_imm16s;
         value = ((value) + (0));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, buffer);
       }
@@ -669,7 +669,7 @@ mt_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case MT_OPERAND_IMM16O :
       {
-        long value = fields->f_imm16s;
+        long long value = fields->f_imm16s;
         value = ((value) + (0));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, buffer);
       }
@@ -688,7 +688,7 @@ mt_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case MT_OPERAND_LOOPSIZE :
       {
-        long value = fields->f_loopo;
+        long long value = fields->f_loopo;
         value = ((USI) (value) >> (2));
         errmsg = insert_normal (cd, value, 0, 0, 7, 8, 32, total_length, buffer);
       }
@@ -877,7 +877,7 @@ mt_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MT_OPERAND_IMM16 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, pc, & value);
         value = ((value) + (0));
         fields->f_imm16s = value;
@@ -888,7 +888,7 @@ mt_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MT_OPERAND_IMM16O :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, pc, & value);
         value = ((value) + (0));
         fields->f_imm16s = value;
@@ -908,7 +908,7 @@ mt_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case MT_OPERAND_LOOPSIZE :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0, 0, 7, 8, 32, total_length, pc, & value);
         value = ((((value) << (2))) + (8));
         fields->f_loopo = value;
diff --git a/opcodes/mt-opc.h b/opcodes/mt-opc.h
index 770d2ab..b7686c7 100644
--- a/opcodes/mt-opc.h
+++ b/opcodes/mt-opc.h
@@ -87,84 +87,84 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_msys;
-  long f_opc;
-  long f_imm;
-  long f_uu24;
-  long f_sr1;
-  long f_sr2;
-  long f_dr;
-  long f_drrr;
-  long f_imm16u;
-  long f_imm16s;
-  long f_imm16a;
-  long f_uu4a;
-  long f_uu4b;
-  long f_uu12;
-  long f_uu8;
-  long f_uu16;
-  long f_uu1;
-  long f_msopc;
-  long f_uu_26_25;
-  long f_mask;
-  long f_bankaddr;
-  long f_rda;
-  long f_uu_2_25;
-  long f_rbbc;
-  long f_perm;
-  long f_mode;
-  long f_uu_1_24;
-  long f_wr;
-  long f_fbincr;
-  long f_uu_2_23;
-  long f_xmode;
-  long f_a23;
-  long f_mask1;
-  long f_cr;
-  long f_type;
-  long f_incamt;
-  long f_cbs;
-  long f_uu_1_19;
-  long f_ball;
-  long f_colnum;
-  long f_brc;
-  long f_incr;
-  long f_fbdisp;
-  long f_uu_4_15;
-  long f_length;
-  long f_uu_1_15;
-  long f_rc;
-  long f_rcnum;
-  long f_rownum;
-  long f_cbx;
-  long f_id;
-  long f_size;
-  long f_rownum1;
-  long f_uu_3_11;
-  long f_rc1;
-  long f_ccb;
-  long f_cbrb;
-  long f_cdb;
-  long f_rownum2;
-  long f_cell;
-  long f_uu_3_9;
-  long f_contnum;
-  long f_uu_1_6;
-  long f_dup;
-  long f_rc2;
-  long f_ctxdisp;
-  long f_imm16l;
-  long f_loopo;
-  long f_cb1sel;
-  long f_cb2sel;
-  long f_cb1incr;
-  long f_cb2incr;
-  long f_rc3;
-  long f_msysfrsr2;
-  long f_brc2;
-  long f_ball2;
+  long long f_nil;
+  long long f_anyof;
+  long long f_msys;
+  long long f_opc;
+  long long f_imm;
+  long long f_uu24;
+  long long f_sr1;
+  long long f_sr2;
+  long long f_dr;
+  long long f_drrr;
+  long long f_imm16u;
+  long long f_imm16s;
+  long long f_imm16a;
+  long long f_uu4a;
+  long long f_uu4b;
+  long long f_uu12;
+  long long f_uu8;
+  long long f_uu16;
+  long long f_uu1;
+  long long f_msopc;
+  long long f_uu_26_25;
+  long long f_mask;
+  long long f_bankaddr;
+  long long f_rda;
+  long long f_uu_2_25;
+  long long f_rbbc;
+  long long f_perm;
+  long long f_mode;
+  long long f_uu_1_24;
+  long long f_wr;
+  long long f_fbincr;
+  long long f_uu_2_23;
+  long long f_xmode;
+  long long f_a23;
+  long long f_mask1;
+  long long f_cr;
+  long long f_type;
+  long long f_incamt;
+  long long f_cbs;
+  long long f_uu_1_19;
+  long long f_ball;
+  long long f_colnum;
+  long long f_brc;
+  long long f_incr;
+  long long f_fbdisp;
+  long long f_uu_4_15;
+  long long f_length;
+  long long f_uu_1_15;
+  long long f_rc;
+  long long f_rcnum;
+  long long f_rownum;
+  long long f_cbx;
+  long long f_id;
+  long long f_size;
+  long long f_rownum1;
+  long long f_uu_3_11;
+  long long f_rc1;
+  long long f_ccb;
+  long long f_cbrb;
+  long long f_cdb;
+  long long f_rownum2;
+  long long f_cell;
+  long long f_uu_3_9;
+  long long f_contnum;
+  long long f_uu_1_6;
+  long long f_dup;
+  long long f_rc2;
+  long long f_ctxdisp;
+  long long f_imm16l;
+  long long f_loopo;
+  long long f_cb1sel;
+  long long f_cb2sel;
+  long long f_cb1incr;
+  long long f_cb2incr;
+  long long f_rc3;
+  long long f_msysfrsr2;
+  long long f_brc2;
+  long long f_ball2;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/nds32-dis.c b/opcodes/nds32-dis.c
index 418019a..7a0bc69 100644
--- a/opcodes/nds32-dis.c
+++ b/opcodes/nds32-dis.c
@@ -60,7 +60,7 @@ struct objdump_disasm_info
   asection *         sec;
   bfd_boolean        require_sec;
   arelent **         dynrelbuf;
-  long               dynrelcount;
+  long long               dynrelcount;
   disassembler_ftype disassemble_fn;
   arelent *          reloc;
 };
@@ -80,7 +80,7 @@ nds32_ex9_info (bfd_vma pc ATTRIBUTE_UNUSED,
   uint32_t insn;
   static asymbol *itb = NULL;
   bfd_byte buffer[4];
-  long unsigned int isec_vma;
+  long long unsigned int isec_vma;
 
   /* Lookup itb symbol.  */
   if (!itb)
diff --git a/opcodes/nios2-dis.c b/opcodes/nios2-dis.c
index 257e5bb..24b211a 100644
--- a/opcodes/nios2-dis.c
+++ b/opcodes/nios2-dis.c
@@ -174,7 +174,7 @@ nios2_init_opcode_hash (nios2_disassembler_state *state)
 /* Return a pointer to an nios2_opcode struct for a given instruction
    word OPCODE for bfd machine MACH, or NULL if there is an error.  */
 const struct nios2_opcode *
-nios2_find_opcode_hash (unsigned long opcode, unsigned long mach)
+nios2_find_opcode_hash (unsigned long long opcode, unsigned long long mach)
 {
   nios2_opcode_hash *entry;
   nios2_disassembler_state *state;
@@ -270,11 +270,11 @@ bad_opcode (const struct nios2_opcode *op)
    character in the arguments to an instruction.  */
 static int
 nios2_print_insn_arg (const char *argptr,
-		      unsigned long opcode, bfd_vma address,
+		      unsigned long long opcode, bfd_vma address,
 		      disassemble_info *info,
 		      const struct nios2_opcode *op)
 {
-  unsigned long i = 0;
+  unsigned long long i = 0;
   struct nios2_reg *reg_base;
 
   switch (*argptr)
@@ -841,7 +841,7 @@ nios2_print_insn_arg (const char *argptr,
 
     case 'R':
       {
-	unsigned long reglist = 0;
+	unsigned long long reglist = 0;
 	int dir = 1;
 	int k, t;
 
@@ -931,7 +931,7 @@ nios2_print_insn_arg (const char *argptr,
 /* nios2_disassemble does all the work of disassembling a Nios II
    instruction opcode.  */
 static int
-nios2_disassemble (bfd_vma address, unsigned long opcode,
+nios2_disassemble (bfd_vma address, unsigned long long opcode,
 		   disassemble_info *info)
 {
   const struct nios2_opcode *op;
@@ -995,11 +995,11 @@ print_insn_nios2 (bfd_vma address, disassemble_info *info,
   status = (*info->read_memory_func) (address, buffer, INSNLEN, info);
   if (status == 0)
     {
-      unsigned long insn;
+      unsigned long long insn;
       if (endianness == BFD_ENDIAN_BIG)
-	insn = (unsigned long) bfd_getb32 (buffer);
+	insn = (unsigned long long) bfd_getb32 (buffer);
       else
-	insn = (unsigned long) bfd_getl32 (buffer);
+	insn = (unsigned long long) bfd_getl32 (buffer);
       return nios2_disassemble (address, insn, info);
     }
 
@@ -1009,11 +1009,11 @@ print_insn_nios2 (bfd_vma address, disassemble_info *info,
       status = (*info->read_memory_func) (address, buffer, 2, info);
       if (status == 0)
 	{
-	  unsigned long insn;
+	  unsigned long long insn;
 	  if (endianness == BFD_ENDIAN_BIG)
-	    insn = (unsigned long) bfd_getb16 (buffer);
+	    insn = (unsigned long long) bfd_getb16 (buffer);
 	  else
-	    insn = (unsigned long) bfd_getl16 (buffer);
+	    insn = (unsigned long long) bfd_getl16 (buffer);
 	  return nios2_disassemble (address, insn, info);
 	}
     }
diff --git a/opcodes/nios2-opc.c b/opcodes/nios2-opc.c
index c7d7b0f..f6163ff 100644
--- a/opcodes/nios2-opc.c
+++ b/opcodes/nios2-opc.c
@@ -770,7 +770,7 @@ int nios2_r2_reg3_mappings[] =
 const int nios2_num_r2_reg3_mappings = 8;
 
 /* Decodings for R2 push.n/pop.n REG_RANGE value list.  */
-unsigned long nios2_r2_reg_range_mappings[] = {
+unsigned long long nios2_r2_reg_range_mappings[] = {
   0x00010000,
   0x00030000,
   0x00070000,
diff --git a/opcodes/ns32k-dis.c b/opcodes/ns32k-dis.c
index 911d6dc..58c4348 100644
--- a/opcodes/ns32k-dis.c
+++ b/opcodes/ns32k-dis.c
@@ -32,10 +32,10 @@ static disassemble_info *dis_info;
 /* Hacks to get it to compile <= READ THESE AS FIXES NEEDED.  */
 #define INVALID_FLOAT(val, size) invalid_float ((bfd_byte *) val, size)
 
-static long
+static long long
 read_memory_integer (unsigned char * addr, int nr)
 {
-  long val;
+  long long val;
   int i;
 
   for (val = 0, i = nr - 1; i >= 0; i--)
@@ -98,8 +98,8 @@ fetch_data (struct disassemble_info *info, bfd_byte *addr)
 struct ns32k_option
 {
   char *pattern;		/* The option itself.  */
-  unsigned long value;		/* Binary value of the option.  */
-  unsigned long match;		/* These bits must match.  */
+  unsigned long long value;		/* Binary value of the option.  */
+  unsigned long long match;		/* These bits must match.  */
 };
 
 
@@ -756,7 +756,7 @@ print_insn_ns32k (bfd_vma memaddr, disassemble_info *info)
   for (i = 0; i < NOPCODES; i++)
     if (ns32k_opcodes[i].opcode_id_size <= 8
 	&& ((buffer[0]
-	     & (((unsigned long) 1 << ns32k_opcodes[i].opcode_id_size) - 1))
+	     & (((unsigned long long) 1 << ns32k_opcodes[i].opcode_id_size) - 1))
 	    == ns32k_opcodes[i].opcode_seed))
       break;
   if (i == NOPCODES)
@@ -767,7 +767,7 @@ print_insn_ns32k (bfd_vma memaddr, disassemble_info *info)
 
       for (i = 0; i < NOPCODES; i++)
 	if ((first_word
-	     & (((unsigned long) 1 << ns32k_opcodes[i].opcode_id_size) - 1))
+	     & (((unsigned long long) 1 << ns32k_opcodes[i].opcode_id_size) - 1))
 	    == ns32k_opcodes[i].opcode_seed)
 	  break;
 
diff --git a/opcodes/or1k-asm.c b/opcodes/or1k-asm.c
index 3162ff3..01b1212 100644
--- a/opcodes/or1k-asm.c
+++ b/opcodes/or1k-asm.c
@@ -86,11 +86,11 @@ parse_disp26 (CGEN_CPU_DESC cd,
 }
 
 static const char *
-parse_simm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+parse_simm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long long * valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
-  long ret;
+  long long ret;
 
   if (**strp == '#')
     ++*strp;
@@ -397,7 +397,7 @@ parse_simm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
     }
   else
     {
-      long value;
+      long long value;
       errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
       ret = value;
     }
@@ -409,9 +409,9 @@ parse_simm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
 }
 
 static const char *
-parse_uimm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+parse_uimm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long long * valuep)
 {
-  const char *errmsg = parse_simm16(cd, strp, opindex, (long *) valuep);
+  const char *errmsg = parse_simm16(cd, strp, opindex, (long long *) valuep);
 
   if (errmsg == NULL)
     *valuep &= 0xffff;
@@ -444,7 +444,7 @@ or1k_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
@@ -483,19 +483,19 @@ or1k_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_fsr, & fields->f_r1);
       break;
     case OR1K_OPERAND_SIMM16 :
-      errmsg = parse_simm16 (cd, strp, OR1K_OPERAND_SIMM16, (long *) (& fields->f_simm16));
+      errmsg = parse_simm16 (cd, strp, OR1K_OPERAND_SIMM16, (long long *) (& fields->f_simm16));
       break;
     case OR1K_OPERAND_SIMM16_SPLIT :
-      errmsg = parse_simm16 (cd, strp, OR1K_OPERAND_SIMM16_SPLIT, (long *) (& fields->f_simm16_split));
+      errmsg = parse_simm16 (cd, strp, OR1K_OPERAND_SIMM16_SPLIT, (long long *) (& fields->f_simm16_split));
       break;
     case OR1K_OPERAND_UIMM16 :
-      errmsg = parse_uimm16 (cd, strp, OR1K_OPERAND_UIMM16, (unsigned long *) (& fields->f_uimm16));
+      errmsg = parse_uimm16 (cd, strp, OR1K_OPERAND_UIMM16, (unsigned long long *) (& fields->f_uimm16));
       break;
     case OR1K_OPERAND_UIMM16_SPLIT :
-      errmsg = parse_uimm16 (cd, strp, OR1K_OPERAND_UIMM16_SPLIT, (unsigned long *) (& fields->f_uimm16_split));
+      errmsg = parse_uimm16 (cd, strp, OR1K_OPERAND_UIMM16_SPLIT, (unsigned long long *) (& fields->f_uimm16_split));
       break;
     case OR1K_OPERAND_UIMM6 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, OR1K_OPERAND_UIMM6, (unsigned long *) (& fields->f_uimm6));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, OR1K_OPERAND_UIMM6, (unsigned long long *) (& fields->f_uimm6));
       break;
 
     default :
diff --git a/opcodes/or1k-dis.c b/opcodes/or1k-dis.c
index f54b6b4..575060d 100644
--- a/opcodes/or1k-dis.c
+++ b/opcodes/or1k-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -166,7 +166,7 @@ or1k_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -202,9 +202,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -213,7 +213,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -275,7 +275,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -333,7 +333,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -352,7 +352,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -368,9 +368,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/or1k-ibld.c b/opcodes/or1k-ibld.c
index 139457c..6f44331 100644
--- a/opcodes/or1k-ibld.c
+++ b/opcodes/or1k-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -575,7 +575,7 @@ or1k_cgen_insert_operand (CGEN_CPU_DESC cd,
     {
     case OR1K_OPERAND_DISP26 :
       {
-        long value = fields->f_disp26;
+        long long value = fields->f_disp26;
         value = ((SI) (((value) - (pc))) >> (2));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, buffer);
       }
@@ -690,7 +690,7 @@ or1k_cgen_extract_operand (CGEN_CPU_DESC cd,
     {
     case OR1K_OPERAND_DISP26 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, pc, & value);
         value = ((((value) << (2))) + (pc));
         fields->f_disp26 = value;
diff --git a/opcodes/or1k-opc.h b/opcodes/or1k-opc.h
index 5692ea9..8ef0cd0 100644
--- a/opcodes/or1k-opc.h
+++ b/opcodes/or1k-opc.h
@@ -83,44 +83,44 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_opcode;
-  long f_r1;
-  long f_r2;
-  long f_r3;
-  long f_op_25_2;
-  long f_op_25_5;
-  long f_op_16_1;
-  long f_op_7_4;
-  long f_op_3_4;
-  long f_op_9_2;
-  long f_op_9_4;
-  long f_op_7_8;
-  long f_op_7_2;
-  long f_resv_25_26;
-  long f_resv_25_10;
-  long f_resv_25_5;
-  long f_resv_23_8;
-  long f_resv_20_21;
-  long f_resv_20_5;
-  long f_resv_20_4;
-  long f_resv_15_8;
-  long f_resv_15_6;
-  long f_resv_10_11;
-  long f_resv_10_7;
-  long f_resv_10_3;
-  long f_resv_10_1;
-  long f_resv_7_4;
-  long f_resv_5_2;
-  long f_imm16_25_5;
-  long f_imm16_10_11;
-  long f_disp26;
-  long f_uimm16;
-  long f_simm16;
-  long f_uimm6;
-  long f_uimm16_split;
-  long f_simm16_split;
+  long long f_nil;
+  long long f_anyof;
+  long long f_opcode;
+  long long f_r1;
+  long long f_r2;
+  long long f_r3;
+  long long f_op_25_2;
+  long long f_op_25_5;
+  long long f_op_16_1;
+  long long f_op_7_4;
+  long long f_op_3_4;
+  long long f_op_9_2;
+  long long f_op_9_4;
+  long long f_op_7_8;
+  long long f_op_7_2;
+  long long f_resv_25_26;
+  long long f_resv_25_10;
+  long long f_resv_25_5;
+  long long f_resv_23_8;
+  long long f_resv_20_21;
+  long long f_resv_20_5;
+  long long f_resv_20_4;
+  long long f_resv_15_8;
+  long long f_resv_15_6;
+  long long f_resv_10_11;
+  long long f_resv_10_7;
+  long long f_resv_10_3;
+  long long f_resv_10_1;
+  long long f_resv_7_4;
+  long long f_resv_5_2;
+  long long f_imm16_25_5;
+  long long f_imm16_10_11;
+  long long f_disp26;
+  long long f_uimm16;
+  long long f_simm16;
+  long long f_uimm6;
+  long long f_uimm16_split;
+  long long f_simm16_split;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/ppc-dis.c b/opcodes/ppc-dis.c
index bd6072e..b18f262 100644
--- a/opcodes/ppc-dis.c
+++ b/opcodes/ppc-dis.c
@@ -497,7 +497,7 @@ static const struct powerpc_opcode *
 lookup_powerpc (uint64_t insn, ppc_cpu_t dialect)
 {
   const struct powerpc_opcode *opcode, *opcode_end, *last;
-  unsigned long op;
+  unsigned long long op;
 
   /* Get the major opcode of the instruction.  */
   op = PPC_OP (insn);
diff --git a/opcodes/ppc-opc.c b/opcodes/ppc-opc.c
index 4a0fca5..bbc2952 100644
--- a/opcodes/ppc-opc.c
+++ b/opcodes/ppc-opc.c
@@ -682,7 +682,7 @@ insert_mbe (uint64_t insn,
 	    const char **errmsg)
 {
   uint64_t uval, mask;
-  long mb, me, mx, count, last;
+  long long mb, me, mx, count, last;
 
   uval = value;
 
@@ -734,8 +734,8 @@ extract_mbe (uint64_t insn,
 	     int *invalid)
 {
   int64_t ret;
-  long mb, me;
-  long i;
+  long long mb, me;
+  long long i;
 
   *invalid = 1;
 
@@ -3324,7 +3324,7 @@ const unsigned int num_powerpc_operands = (sizeof (powerpc_operands)
   (OP (op)					\
    | ((((uint64_t)(xop)) & 0x1ff) << 1)	\
    | ((((uint64_t)(oe)) & 1) << 10)	\
-   | (((unsigned long)(rc)) & 1))
+   | (((unsigned long long)(rc)) & 1))
 #define XO_MASK XO (0x3f, 0x1ff, 1, 1)
 
 /* An XO_MASK with the RB field fixed.  */
diff --git a/opcodes/pru-dis.c b/opcodes/pru-dis.c
index c543541..25b7736 100644
--- a/opcodes/pru-dis.c
+++ b/opcodes/pru-dis.c
@@ -40,7 +40,7 @@
 /* Return a pointer to an pru_opcode struct for a given instruction
    opcode, or NULL if there is an error.  */
 const struct pru_opcode *
-pru_find_opcode (unsigned long opcode)
+pru_find_opcode (unsigned long long opcode)
 {
   const struct pru_opcode *p;
   const struct pru_opcode *op = NULL;
@@ -80,12 +80,12 @@ pru_print_insn_arg_reg (unsigned int r, unsigned int sel,
    character in the arguments to an instruction.  */
 static int
 pru_print_insn_arg (const char *argptr,
-		      unsigned long opcode, bfd_vma address,
+		      unsigned long long opcode, bfd_vma address,
 		      disassemble_info *info)
 {
-  long offs = 0;
-  unsigned long i = 0;
-  unsigned long io = 0;
+  long long offs = 0;
+  unsigned long long i = 0;
+  unsigned long long io = 0;
 
   switch (*argptr)
     {
@@ -218,7 +218,7 @@ pru_print_insn_arg (const char *argptr,
 /* pru_disassemble does all the work of disassembling a PRU
    instruction opcode.  */
 static int
-pru_disassemble (bfd_vma address, unsigned long opcode,
+pru_disassemble (bfd_vma address, unsigned long long opcode,
 		   disassemble_info *info)
 {
   const struct pru_opcode *op;
@@ -273,8 +273,8 @@ print_insn_pru (bfd_vma address, disassemble_info *info)
   status = (*info->read_memory_func) (address, buffer, INSNLEN, info);
   if (status == 0)
     {
-      unsigned long insn;
-      insn = (unsigned long) bfd_getl32 (buffer);
+      unsigned long long insn;
+      insn = (unsigned long long) bfd_getl32 (buffer);
       status = pru_disassemble (address, insn, info);
     }
   else
diff --git a/opcodes/riscv-dis.c b/opcodes/riscv-dis.c
index e8fc6ea..c8972b4 100644
--- a/opcodes/riscv-dis.c
+++ b/opcodes/riscv-dis.c
@@ -89,7 +89,7 @@ parse_riscv_dis_options (const char *opts_in)
 /* Print one argument from an array.  */
 
 static void
-arg_print (struct disassemble_info *info, unsigned long val,
+arg_print (struct disassemble_info *info, unsigned long long val,
 	   const char* const* array, size_t size)
 {
   const char *s = val >= size || array[val] == NULL ? "unknown" : array[val];
diff --git a/opcodes/rl78-decode.c b/opcodes/rl78-decode.c
index 3edc8ac..c14de92 100644
--- a/opcodes/rl78-decode.c
+++ b/opcodes/rl78-decode.c
@@ -56,7 +56,7 @@ typedef struct
 
 #define OP_BUF_LEN 20
 #define GETBYTE() (ld->rl78->n_bytes < (OP_BUF_LEN - 1) ? ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr): 0)
-#define B ((unsigned long) GETBYTE())
+#define B ((unsigned long long) GETBYTE())
 
 #define SYNTAX(x) rl78->syntax = x
 
@@ -80,7 +80,7 @@ typedef struct
 static int
 immediate (int bytes, int sign_extend, LocalData * ld)
 {
-  unsigned long i = 0;
+  unsigned long long i = 0;
 
   switch (bytes)
     {
@@ -169,7 +169,7 @@ sfr (int x)
 #define SFR sfr (IMMU (1))
 
 int
-rl78_decode_opcode (unsigned long pc AU,
+rl78_decode_opcode (unsigned long long pc AU,
 		  RL78_Opcode_Decoded * rl78,
 		  int (* getbyte)(void *),
 		  void * ptr,
diff --git a/opcodes/rx-decode.c b/opcodes/rx-decode.c
index 16ac062..50d4fd5 100644
--- a/opcodes/rx-decode.c
+++ b/opcodes/rx-decode.c
@@ -156,11 +156,11 @@ static int dsp3map[] = { 8, 9, 10, 3, 4, 5, 6, 7 };
 static int
 immediate (int sfield, int ex, LocalData * ld)
 {
-  unsigned long i = 0, j;
+  unsigned long long i = 0, j;
 
   switch (sfield)
     {
-#define B ((unsigned long) GETBYTE())
+#define B ((unsigned long long) GETBYTE())
     case 0:
 #if RX_OPCODE_BIG_ENDIAN
       i  = B;
@@ -266,7 +266,7 @@ rx_disp (int n, int type, int reg, unsigned int size, LocalData * ld)
 #define F_OSZC rx->flags_0 = rx->flags_s = xO|xS|xZ|xC;
 
 int
-rx_decode_opcode (unsigned long pc AU,
+rx_decode_opcode (unsigned long long pc AU,
 		  RX_Opcode_Decoded * rx,
 		  int (* getbyte)(void *),
 		  void * ptr)
diff --git a/opcodes/s390-dis.c b/opcodes/s390-dis.c
index 79d9f53..b346572 100644
--- a/opcodes/s390-dis.c
+++ b/opcodes/s390-dis.c
@@ -194,7 +194,7 @@ s390_print_insn_with_opcode (bfd_vma memaddr,
     {
       const struct s390_operand *operand = s390_operands + *opindex;
       union operand_value val = s390_extract_operand (buffer, operand);
-      unsigned long flags = operand->flags;
+      unsigned long long flags = operand->flags;
 
       if ((flags & S390_OPERAND_INDEX) && val.u == 0)
 	continue;
diff --git a/opcodes/score-dis.c b/opcodes/score-dis.c
index 25291a3..264060a 100644
--- a/opcodes/score-dis.c
+++ b/opcodes/score-dis.c
@@ -565,7 +565,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
                               {
                               case 'r':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -575,7 +575,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
                                 break;
                               case 'd':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -585,7 +585,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
                                 break;
                               case 'i':
                                 {
-                                  long reg;
+                                  long long reg;
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
                                   reg = ((reg ^ (1 << (bitend - bitstart))) -
@@ -607,7 +607,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
                                 break;
                               case 'x':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -620,7 +620,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
                                 break;
                                 case 'w':
                                 {
-                                    long reg;
+                                    long long reg;
                                     reg = given >> bitstart;
                                     reg &= (2 << (bitend - bitstart)) - 1;
                                     reg <<=2;
@@ -670,7 +670,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
 /* Print one instruction from PC on INFO->STREAM.
    Return the size of the instruction.  */
 static int
-print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
+print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long long given)
 {
   struct score_opcode *insn;
   void *stream = info->stream;
@@ -734,7 +734,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                            }
                            else
                            {
-                               long reg;
+                               long long reg;
                                int bitstart = 10;
                                int bitend = 14;
                                reg = given >> bitstart;
@@ -787,7 +787,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                               {
                               case 'r':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -797,7 +797,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                                 break;
                               case 'd':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -807,7 +807,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                                 break;
                               case 'i':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -827,7 +827,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                                 break;
                               case 'x':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -877,7 +877,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
 /* Print one instruction from PC on INFO->STREAM.
    Return the size of the instruction.  */
 static int
-print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)
+print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long long given)
 {
   struct score_opcode *insn;
   void *stream = info->stream;
@@ -944,7 +944,7 @@ print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)
                           {
                           case '-':
                             {
-                              long reg;
+                              long long reg;
 
                               c++;
                               while (*c >= '0' && *c <= '9')
@@ -1166,7 +1166,7 @@ s3_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
       }
 }
 
-static unsigned long
+static unsigned long long
 score_get_arch (disassemble_info *info)
 {
   if (info->arch == bfd_arch_score)
diff --git a/opcodes/score7-dis.c b/opcodes/score7-dis.c
index 9d21ef8..4378870 100644
--- a/opcodes/score7-dis.c
+++ b/opcodes/score7-dis.c
@@ -47,8 +47,8 @@
 
 struct score_opcode
 {
-  unsigned long value;
-  unsigned long mask;            /* Recognise instruction if (op & mask) == value.  */
+  unsigned long long value;
+  unsigned long long mask;            /* Recognise instruction if (op & mask) == value.  */
   char *assembler;        /* Disassembly string.  */
 };
 
@@ -544,7 +544,7 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little);
 /* Print one instruction from PC on INFO->STREAM.
    Return the size of the instruction.  */
 static int
-print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
+print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long long given)
 {
   struct score_opcode *insn;
   void *stream = info->stream;
@@ -613,7 +613,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                               {
                               case 'r':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -623,7 +623,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                                 break;
                               case 'd':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -633,7 +633,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                                 break;
                               case 'i':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -653,7 +653,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                                 break;
                               case 'x':
                                 {
-                                  long reg;
+                                  long long reg;
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
@@ -714,7 +714,7 @@ print_insn_parallel_sym (struct disassemble_info *info)
 /* Print one instruction from PC on INFO->STREAM.
    Return the size of the instruction.  */
 static int
-print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)
+print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long long given)
 {
   struct score_opcode *insn;
   void *stream = info->stream;
@@ -781,7 +781,7 @@ print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)
                           {
                           case '-':
                             {
-                              long reg;
+                              long long reg;
 
                               c++;
                               while (*c >= '0' && *c <= '9')
@@ -871,8 +871,8 @@ int
 s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
 {
   unsigned char b[4];
-  long given;
-  long ridparity;
+  long long given;
+  long long ridparity;
   int status;
   bfd_boolean insn_pce_p = FALSE;
   bfd_boolean insn_16_p = FALSE;
@@ -945,7 +945,7 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
   /* pce instruction.  */
   else if (insn_pce_p)
     {
-      long other;
+      long long other;
 
       other = given & 0xFFFF;
       given = (given & 0xFFFF0000) >> 16;
diff --git a/opcodes/sh-opc.h b/opcodes/sh-opc.h
index 13d6056..5534061 100644
--- a/opcodes/sh-opc.h
+++ b/opcodes/sh-opc.h
@@ -282,9 +282,9 @@ sh_dsp_reg_nums;
 #define SH_ARCH_UNKNOWN_ARCH 0xffffffff
 
 /* These are defined in bfd/cpu-sh.c .  */
-unsigned int sh_get_arch_from_bfd_mach (unsigned long mach);
-unsigned int sh_get_arch_up_from_bfd_mach (unsigned long mach);
-unsigned long sh_get_bfd_mach_from_arch_set (unsigned int arch_set);
+unsigned int sh_get_arch_from_bfd_mach (unsigned long long mach);
+unsigned int sh_get_arch_up_from_bfd_mach (unsigned long long mach);
+unsigned long long sh_get_bfd_mach_from_arch_set (unsigned int arch_set);
 
 /* Below are the 'architecture sets'.
    They describe the following inheritance graph:
diff --git a/opcodes/sparc-dis.c b/opcodes/sparc-dis.c
index 77df145..86c926d 100644
--- a/opcodes/sparc-dis.c
+++ b/opcodes/sparc-dis.c
@@ -198,7 +198,7 @@ static char *v9a_asr_reg_names[] =
 /* Nonzero if INSN is the opcode for a delayed branch.  */
 
 static int
-is_delayed_branch (unsigned long insn)
+is_delayed_branch (unsigned long long insn)
 {
   sparc_opcode_hash *op;
 
@@ -222,7 +222,7 @@ static unsigned int current_arch_mask;
 /* Given BFD mach number, return a mask of SPARC_OPCODE_ARCH_FOO values.  */
 
 static int
-compute_arch_mask (unsigned long mach)
+compute_arch_mask (unsigned long long mach)
 {
   switch (mach)
     {
@@ -277,8 +277,8 @@ compare_opcodes (const void * a, const void * b)
 {
   sparc_opcode *op0 = * (sparc_opcode **) a;
   sparc_opcode *op1 = * (sparc_opcode **) b;
-  unsigned long int match0 = op0->match, match1 = op1->match;
-  unsigned long int lose0 = op0->lose, lose1 = op1->lose;
+  unsigned long long int match0 = op0->match, match1 = op1->match;
+  unsigned long long int lose0 = op0->lose, lose1 = op1->lose;
   register unsigned int i;
 
   /* If one (and only one) insn isn't supported by the current architecture,
@@ -325,7 +325,7 @@ compare_opcodes (const void * a, const void * b)
      another, it is important to order the opcodes in the right order.  */
   for (i = 0; i < 32; ++i)
     {
-      unsigned long int x = 1 << i;
+      unsigned long long int x = 1 << i;
       int x0 = (match0 & x) != 0;
       int x1 = (match1 & x) != 0;
 
@@ -335,7 +335,7 @@ compare_opcodes (const void * a, const void * b)
 
   for (i = 0; i < 32; ++i)
     {
-      unsigned long int x = 1 << i;
+      unsigned long long int x = 1 << i;
       int x0 = (lose0 & x) != 0;
       int x1 = (lose1 & x) != 0;
 
@@ -488,12 +488,12 @@ print_insn_sparc (bfd_vma memaddr, disassemble_info *info)
 {
   FILE *stream = info->stream;
   bfd_byte buffer[4];
-  unsigned long insn;
+  unsigned long long insn;
   sparc_opcode_hash *op;
   /* Nonzero of opcode table has been initialized.  */
   static int opcodes_initialized = 0;
   /* bfd mach number of last call.  */
-  static unsigned long current_mach = 0;
+  static unsigned long long current_mach = 0;
   bfd_vma (*getword) (const void *);
 
   if (!opcodes_initialized
@@ -1019,7 +1019,7 @@ print_insn_sparc (bfd_vma memaddr, disassemble_info *info)
 	     and its symbolic value.  */
 	  if (imm_ored_to_rs1 || imm_added_to_rs1)
 	    {
-	      unsigned long prev_insn;
+	      unsigned long long prev_insn;
 	      int errcode;
 
 	      if (memaddr >= 4)
diff --git a/opcodes/tic30-dis.c b/opcodes/tic30-dis.c
index 4331bf3..a626c7d 100644
--- a/opcodes/tic30-dis.c
+++ b/opcodes/tic30-dis.c
@@ -69,7 +69,7 @@ struct instruction
 };
 
 static int
-get_tic30_instruction (unsigned long insn_word, struct instruction *insn)
+get_tic30_instruction (unsigned long long insn_word, struct instruction *insn)
 {
   switch (GET_TYPE (insn_word))
     {
@@ -272,12 +272,12 @@ get_indirect_operand (unsigned short fragment,
 }
 
 static int
-cnvt_tmsfloat_ieee (unsigned long tmsfloat, int size, float *ieeefloat)
+cnvt_tmsfloat_ieee (unsigned long long tmsfloat, int size, float *ieeefloat)
 {
-  unsigned long exponent, sign, mant;
+  unsigned long long exponent, sign, mant;
   union
   {
-    unsigned long l;
+    unsigned long long l;
     float f;
   } val;
 
@@ -288,7 +288,7 @@ cnvt_tmsfloat_ieee (unsigned long tmsfloat, int size, float *ieeefloat)
       else
 	{
 	  tmsfloat <<= 16;
-	  tmsfloat = (long) tmsfloat >> 4;
+	  tmsfloat = (long long) tmsfloat >> 4;
 	}
     }
   exponent = tmsfloat & 0xFF000000;
@@ -336,7 +336,7 @@ cnvt_tmsfloat_ieee (unsigned long tmsfloat, int size, float *ieeefloat)
 
 static int
 print_two_operand (disassemble_info *info,
-		   unsigned long insn_word,
+		   unsigned long long insn_word,
 		   struct instruction *insn)
 {
   char name[12];
@@ -424,7 +424,7 @@ print_two_operand (disassemble_info *info,
 
 static int
 print_three_operand (disassemble_info *info,
-		     unsigned long insn_word,
+		     unsigned long long insn_word,
 		     struct instruction *insn)
 {
   char operand[3][13] =
@@ -468,7 +468,7 @@ print_three_operand (disassemble_info *info,
 
 static int
 print_par_insn (disassemble_info *info,
-		unsigned long insn_word,
+		unsigned long long insn_word,
 		struct instruction *insn)
 {
   size_t i, len;
@@ -592,7 +592,7 @@ print_par_insn (disassemble_info *info,
 
 static int
 print_branch (disassemble_info *info,
-	      unsigned long insn_word,
+	      unsigned long long insn_word,
 	      struct instruction *insn)
 {
   char operand[2][13] =
@@ -600,7 +600,7 @@ print_branch (disassemble_info *info,
     {0},
     {0}
   };
-  unsigned long address;
+  unsigned long long address;
   int print_label = 0;
 
   if (insn->tm == NULL)
@@ -679,7 +679,7 @@ print_branch (disassemble_info *info,
 int
 print_insn_tic30 (bfd_vma pc, disassemble_info *info)
 {
-  unsigned long insn_word;
+  unsigned long long insn_word;
   struct instruction insn = { 0, NULL, NULL };
   bfd_vma bufaddr = pc - info->buffer_vma;
 
diff --git a/opcodes/tic4x-dis.c b/opcodes/tic4x-dis.c
index 8003af8..0efe7d7 100644
--- a/opcodes/tic4x-dis.c
+++ b/opcodes/tic4x-dis.c
@@ -128,7 +128,7 @@ tic4x_print_str (struct disassemble_info *info, const char *str)
 }
 
 static int
-tic4x_print_register (struct disassemble_info *info, unsigned long regno)
+tic4x_print_register (struct disassemble_info *info, unsigned long long regno)
 {
   static tic4x_register_t ** registertable = NULL;
   unsigned int i;
@@ -155,7 +155,7 @@ tic4x_print_register (struct disassemble_info *info, unsigned long regno)
 }
 
 static int
-tic4x_print_addr (struct disassemble_info *info, unsigned long addr)
+tic4x_print_addr (struct disassemble_info *info, unsigned long long addr)
 {
   if (info != NULL)
     (*info->print_address_func)(addr, info);
@@ -164,15 +164,15 @@ tic4x_print_addr (struct disassemble_info *info, unsigned long addr)
 
 static int
 tic4x_print_relative (struct disassemble_info *info,
-		      unsigned long pc,
-		      long offset,
-		      unsigned long opcode)
+		      unsigned long long pc,
+		      long long offset,
+		      unsigned long long opcode)
 {
   return tic4x_print_addr (info, pc + offset + tic4x_pc_offset (opcode));
 }
 
 static int
-tic4x_print_direct (struct disassemble_info *info, unsigned long arg)
+tic4x_print_direct (struct disassemble_info *info, unsigned long long arg)
 {
   if (info != NULL)
     {
@@ -212,7 +212,7 @@ tic4x_print_ftoa (unsigned int val, FILE *stream, fprintf_ftype pfunc)
 static int
 tic4x_print_immed (struct disassemble_info *info,
 		   immed_t type,
-		   unsigned long arg)
+		   unsigned long long arg)
 {
   int s;
   int f;
@@ -225,7 +225,7 @@ tic4x_print_immed (struct disassemble_info *info,
     {
     case IMMED_SINT:
     case IMMED_INT:
-      (*info->fprintf_func) (info->stream, "%ld", (long) arg);
+      (*info->fprintf_func) (info->stream, "%ld", (long long) arg);
       break;
 
     case IMMED_SUINT:
@@ -289,7 +289,7 @@ tic4x_print_cond (struct disassemble_info *info, unsigned int cond)
 static int
 tic4x_print_indirect (struct disassemble_info *info,
 		      indirect_t type,
-		      unsigned long arg)
+		      unsigned long long arg)
 {
   unsigned int aregno;
   unsigned int modn;
@@ -352,9 +352,9 @@ tic4x_print_indirect (struct disassemble_info *info,
 
 static int
 tic4x_print_op (struct disassemble_info *info,
-		unsigned long instruction,
+		unsigned long long instruction,
 		tic4x_inst_t *p,
-		unsigned long pc)
+		unsigned long long pc)
 {
   int val;
   const char *s;
@@ -637,7 +637,7 @@ static void
 tic4x_hash_opcode (tic4x_inst_t **optable,
 		   tic4x_inst_t **optable_special,
 		   const tic4x_inst_t *inst,
-		   const unsigned long tic4x_oplevel)
+		   const unsigned long long tic4x_oplevel)
 {
   int j;
   int opcode = inst->opcode >> (32 - TIC4X_HASH_SIZE);
@@ -682,15 +682,15 @@ tic4x_hash_opcode (tic4x_inst_t **optable,
    The function returns the length of this instruction in words.  */
 
 static int
-tic4x_disassemble (unsigned long pc,
-		   unsigned long instruction,
+tic4x_disassemble (unsigned long long pc,
+		   unsigned long long instruction,
 		   struct disassemble_info *info)
 {
   static tic4x_inst_t **optable = NULL;
   static tic4x_inst_t **optable_special = NULL;
   tic4x_inst_t *p;
   int i;
-  unsigned long tic4x_oplevel;
+  unsigned long long tic4x_oplevel;
 
   tic4x_version = info->mach;
 
@@ -752,8 +752,8 @@ int
 print_insn_tic4x (bfd_vma memaddr, struct disassemble_info *info)
 {
   int status;
-  unsigned long pc;
-  unsigned long op;
+  unsigned long long pc;
+  unsigned long long op;
   bfd_byte buffer[4];
 
   status = (*info->read_memory_func) (memaddr, buffer, 4, info);
diff --git a/opcodes/tic54x-dis.c b/opcodes/tic54x-dis.c
index f716880..b0f0563 100644
--- a/opcodes/tic54x-dis.c
+++ b/opcodes/tic54x-dis.c
@@ -179,8 +179,8 @@ print_instruction (disassemble_info *info,
   /* string storage for multiple operands */
   char operand[4][64] = { {0},{0},{0},{0}, };
   bfd_byte buf[2];
-  unsigned long opcode2 = 0;
-  unsigned long lkaddr = 0;
+  unsigned long long opcode2 = 0;
+  unsigned long long lkaddr = 0;
   enum optype src = OP_None;
   enum optype dst = OP_None;
   int i, shift;
@@ -259,7 +259,7 @@ print_instruction (disassemble_info *info,
           break;
         case OP_xpmad:
           /* upper 7 bits of address are in the opcode */
-          opcode2 += ((unsigned long) opcode & 0x7F) << 16;
+          opcode2 += ((unsigned long long) opcode & 0x7F) << 16;
           /* fall through */
         case OP_pmad:
           info->fprintf_func (info->stream, "%s", comma);
diff --git a/opcodes/tic80-dis.c b/opcodes/tic80-dis.c
index f1926a0..71e52b0 100644
--- a/opcodes/tic80-dis.c
+++ b/opcodes/tic80-dis.c
@@ -32,7 +32,7 @@ static int length;
    Larger numbers are probably better printed as hex values.  */
 
 static void
-print_operand_integer (struct disassemble_info *info, long value)
+print_operand_integer (struct disassemble_info *info, long long value)
 {
   if ((value > 9999 || value < -9999))
     (*info->fprintf_func) (info->stream, "%#lx", value);
@@ -45,16 +45,16 @@ print_operand_integer (struct disassemble_info *info, long value)
    floating point format.  */
 
 static void
-print_operand_float (struct disassemble_info *info, long value)
+print_operand_float (struct disassemble_info *info, long long value)
 {
-  union { float f; long l; } fval;
+  union { float f; long long l; } fval;
 
   fval.l = value;
   (*info->fprintf_func) (info->stream, "%g", fval.f);
 }
 
 static void
-print_operand_control_register (struct disassemble_info *info, long value)
+print_operand_control_register (struct disassemble_info *info, long long value)
 {
   const char *tmp;
 
@@ -66,7 +66,7 @@ print_operand_control_register (struct disassemble_info *info, long value)
 }
 
 static void
-print_operand_condition_code (struct disassemble_info *info, long value)
+print_operand_condition_code (struct disassemble_info *info, long long value)
 {
   const char *tmp;
 
@@ -78,7 +78,7 @@ print_operand_condition_code (struct disassemble_info *info, long value)
 }
 
 static void
-print_operand_bitnum (struct disassemble_info *info, long value)
+print_operand_bitnum (struct disassemble_info *info, long long value)
 {
   int bitnum;
   const char *tmp;
@@ -99,8 +99,8 @@ print_operand_bitnum (struct disassemble_info *info, long value)
 
 static void
 print_operand (struct disassemble_info *info,
-	       long value,
-	       unsigned long insn,
+	       long long value,
+	       unsigned long long insn,
 	       const struct tic80_operand *operand,
 	       bfd_vma memaddr)
 {
@@ -151,7 +151,7 @@ print_operand (struct disassemble_info *info,
 static int
 fill_instruction (struct disassemble_info *info,
 		  bfd_vma memaddr,
-		  unsigned long *insnp)
+		  unsigned long long *insnp)
 {
   bfd_byte buffer[4];
   int status;
@@ -186,11 +186,11 @@ fill_instruction (struct disassemble_info *info,
 static int
 print_one_instruction (struct disassemble_info *info,
 		       bfd_vma memaddr,
-		       unsigned long insn,
+		       unsigned long long insn,
 		       const struct tic80_opcode *opcode)
 {
   const struct tic80_operand *operand;
-  long value;
+  long long value;
   int status;
   const unsigned char *opindex;
   int close_paren;
@@ -207,7 +207,7 @@ print_one_instruction (struct disassemble_info *info,
 
       else if (operand->bits == 32)
 	{
-	  status = fill_instruction (info, memaddr, (unsigned long *) &value);
+	  status = fill_instruction (info, memaddr, (unsigned long long *) &value);
 	  if (status == -1)
 	    return status;
 	}
@@ -257,7 +257,7 @@ print_one_instruction (struct disassemble_info *info,
 static int
 print_instruction (struct disassemble_info *info,
 		   bfd_vma memaddr,
-		   unsigned long insn,
+		   unsigned long long insn,
 		   const struct tic80_opcode *vec_opcode)
 {
   const struct tic80_opcode *opcode;
@@ -302,7 +302,7 @@ print_instruction (struct disassemble_info *info,
 int
 print_insn_tic80 (bfd_vma memaddr, struct disassemble_info *info)
 {
-  unsigned long insn;
+  unsigned long long insn;
   int status;
 
   length = 0;
diff --git a/opcodes/v850-dis.c b/opcodes/v850-dis.c
index af4437c..c779ea2 100644
--- a/opcodes/v850-dis.c
+++ b/opcodes/v850-dis.c
@@ -89,7 +89,7 @@ static void
 print_value (int flags,
 	     bfd_vma memaddr,
 	     struct disassemble_info *info,
-	     long value)
+	     long long value)
 {
   if (flags & V850_PCREL)
     {
@@ -128,16 +128,16 @@ print_value (int flags,
     }
 }
 
-static long
+static long long
 get_operand_value (const struct v850_operand *operand,
-		   unsigned long insn,
+		   unsigned long long insn,
 		   int bytes_read,
 		   bfd_vma memaddr,
 		   struct disassemble_info * info,
 		   bfd_boolean noerror,
 		   int *invalid)
 {
-  long value;
+  long long value;
   bfd_byte buffer[4];
 
   if ((operand->flags & V850E_IMMEDIATE16)
@@ -210,8 +210,8 @@ get_operand_value (const struct v850_operand *operand,
 	value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
 
       if (operand->flags & V850_OPERAND_SIGNED)
-	value = ((long)(value << (sizeof (long)*8 - operand->bits))
-		 >> (sizeof (long)*8 - operand->bits));
+	value = ((long long)(value << (sizeof (long long)*8 - operand->bits))
+		 >> (sizeof (long long)*8 - operand->bits));
     }
 
   return value;
@@ -222,7 +222,7 @@ static int
 disassemble (bfd_vma memaddr,
 	     struct disassemble_info *info,
 	     int bytes_read,
-	     unsigned long insn)
+	     unsigned long long insn)
 {
   struct v850_opcode *op = (struct v850_opcode *) v850_opcodes;
   const struct v850_operand *operand;
@@ -278,7 +278,7 @@ disassemble (bfd_vma memaddr,
 	       opindex_ptr++, opnum++)
 	    {
 	      int invalid = 0;
-	      long value;
+	      long long value;
 
 	      operand = &v850_operands[*opindex_ptr];
 
@@ -326,7 +326,7 @@ disassemble (bfd_vma memaddr,
 	       opindex_ptr++, opnum++)
 	    {
 	      bfd_boolean square = FALSE;
-	      long value;
+	      long long value;
 	      int flag;
 	      char *prefix;
 
@@ -442,7 +442,7 @@ disassemble (bfd_vma memaddr,
 						     0,  0, 0, 0, 0, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24 };
 		    int *regs;
 		    int i;
-		    unsigned long int mask = 0;
+		    unsigned long long int mask = 0;
 		    int pc = 0;
 
 		    switch (operand->shift)
@@ -488,8 +488,8 @@ disassemble (bfd_vma memaddr,
 			    for (bit = 0; bit < 32; bit++)
 			      if (mask & (1 << bit))
 				{
-				  unsigned long int first = bit;
-				  unsigned long int last;
+				  unsigned long long int first = bit;
+				  unsigned long long int last;
 
 				  if (shown_one)
 				    info->fprintf_func (info->stream, ", ");
@@ -592,7 +592,7 @@ print_insn_v850 (bfd_vma memaddr, struct disassemble_info * info)
   int status, status2, match;
   bfd_byte buffer[8];
   int length = 0, code_length = 0;
-  unsigned long insn = 0, insn2 = 0;
+  unsigned long long insn = 0, insn2 = 0;
   int target_processor;
 
   switch (info->mach)
diff --git a/opcodes/v850-opc.c b/opcodes/v850-opc.c
index 57f2051..4c4b114 100644
--- a/opcodes/v850-opc.c
+++ b/opcodes/v850-opc.c
@@ -74,8 +74,8 @@ v850_msg_is_out_of_range (const char* msg)
     || msg == branch_out_of_range;
 }
 
-static unsigned long
-insert_i5div1 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_i5div1 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 30 || value < 2)
     {
@@ -92,10 +92,10 @@ insert_i5div1 (unsigned long insn, long value, const char ** errmsg)
   return (insn | ((value << (2+16)) & 0x3c0000));
 }
 
-static unsigned long
-extract_i5div1 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_i5div1 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret = (insn & 0x003c0000) >> (16+2);
+  unsigned long long ret = (insn & 0x003c0000) >> (16+2);
   ret = 32 - (ret * 2);
 
   if (invalid != 0)
@@ -103,8 +103,8 @@ extract_i5div1 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_i5div2 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_i5div2 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 30 || value < 4)
     {
@@ -121,10 +121,10 @@ insert_i5div2 (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value << (2 + 16)) & 0x3c0000);
 }
 
-static unsigned long
-extract_i5div2 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_i5div2 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret = (insn & 0x003c0000) >> (16+2);
+  unsigned long long ret = (insn & 0x003c0000) >> (16+2);
   ret = 32 - (ret * 2);
 
   if (invalid != 0)
@@ -132,8 +132,8 @@ extract_i5div2 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_i5div3 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_i5div3 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 32 || value < 2)
     {
@@ -150,10 +150,10 @@ insert_i5div3 (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value << (2+16)) & 0x3c0000);
 }
 
-static unsigned long
-extract_i5div3 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_i5div3 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret = (insn & 0x003c0000) >> (16+2);
+  unsigned long long ret = (insn & 0x003c0000) >> (16+2);
   ret = 32 - (ret * 2);
 
   if (invalid != 0)
@@ -161,8 +161,8 @@ extract_i5div3 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_d5_4 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d5_4 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0x1f || value < 0)
     {
@@ -179,10 +179,10 @@ insert_d5_4 (unsigned long insn, long value, const char ** errmsg)
   return insn | (value & 0x0f);
 }
 
-static unsigned long
-extract_d5_4 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d5_4 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret = (insn & 0x0f);
+  unsigned long long ret = (insn & 0x0f);
 
   ret <<= 1;
 
@@ -191,8 +191,8 @@ extract_d5_4 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_d8_6 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d8_6 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0xff || value < 0)
     {
@@ -209,10 +209,10 @@ insert_d8_6 (unsigned long insn, long value, const char ** errmsg)
   return insn | (value & 0x7e);
 }
 
-static unsigned long
-extract_d8_6 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d8_6 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret = (insn & 0x7e);
+  unsigned long long ret = (insn & 0x7e);
 
   ret <<= 1;
 
@@ -221,8 +221,8 @@ extract_d8_6 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_d8_7 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d8_7 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0xff || value < 0)
     {
@@ -239,10 +239,10 @@ insert_d8_7 (unsigned long insn, long value, const char ** errmsg)
   return insn | (value & 0x7f);
 }
 
-static unsigned long
-extract_d8_7 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d8_7 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret = (insn & 0x7f);
+  unsigned long long ret = (insn & 0x7f);
 
   ret <<= 1;
 
@@ -251,8 +251,8 @@ extract_d8_7 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_v8 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_v8 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0xff || value < 0)
     * errmsg = _(immediate_out_of_range);
@@ -260,18 +260,18 @@ insert_v8 (unsigned long insn, long value, const char ** errmsg)
   return insn | (value & 0x1f) | ((value & 0xe0) << (27-5));
 }
 
-static unsigned long
-extract_v8 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_v8 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret = (insn & 0x1f) | ((insn >> (27-5)) & 0xe0);
+  unsigned long long ret = (insn & 0x1f) | ((insn >> (27-5)) & 0xe0);
 
   if (invalid != 0)
     *invalid = 0;
   return ret;
 }
 
-static unsigned long
-insert_d9 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d9 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0xff || value < -0x100)
     {
@@ -286,10 +286,10 @@ insert_d9 (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value & 0x1f0) << 7) | ((value & 0x0e) << 3);
 }
 
-static unsigned long
-extract_d9 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d9 (unsigned long long insn, int * invalid)
 {
-  signed long ret = ((insn >> 7) & 0x1f0) | ((insn >> 3) & 0x0e);
+  signed long long ret = ((insn >> 7) & 0x1f0) | ((insn >> 3) & 0x0e);
 
   ret = (ret ^ 0x100) - 0x100;
 
@@ -298,8 +298,8 @@ extract_d9 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_u16_loop (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_u16_loop (unsigned long long insn, long long value, const char ** errmsg)
 {
   /* Loop displacement is encoded as a positive value,
      even though the instruction branches backwards.  */
@@ -316,18 +316,18 @@ insert_u16_loop (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value & 0xfffe) << 16);
 }
 
-static unsigned long
-extract_u16_loop (unsigned long insn, int * invalid)
+static unsigned long long
+extract_u16_loop (unsigned long long insn, int * invalid)
 {
-  long ret = (insn >> 16) & 0xfffe;
+  long long ret = (insn >> 16) & 0xfffe;
 
   if (invalid != 0)
     *invalid = 0;
   return ret;
 }
 
-static unsigned long
-insert_d16_15 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d16_15 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0x7fff || value < -0x8000)
     {
@@ -342,10 +342,10 @@ insert_d16_15 (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value & 0xfffe) << 16);
 }
 
-static unsigned long
-extract_d16_15 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d16_15 (unsigned long long insn, int * invalid)
 {
-  signed long ret = (insn >> 16) & 0xfffe;
+  signed long long ret = (insn >> 16) & 0xfffe;
 
   ret = (ret ^ 0x8000) - 0x8000;
 
@@ -354,8 +354,8 @@ extract_d16_15 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_d16_16 (unsigned long insn, signed long value, const char ** errmsg)
+static unsigned long long
+insert_d16_16 (unsigned long long insn, signed long long value, const char ** errmsg)
 {
   if (value > 0x7fff || value < -0x8000)
     * errmsg = _(out_of_range);
@@ -363,10 +363,10 @@ insert_d16_16 (unsigned long insn, signed long value, const char ** errmsg)
   return insn | ((value & 0xfffe) << 16) | ((value & 1) << 5);
 }
 
-static unsigned long
-extract_d16_16 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d16_16 (unsigned long long insn, int * invalid)
 {
-  signed long ret = ((insn >> 16) & 0xfffe) | ((insn >> 5) & 1);
+  signed long long ret = ((insn >> 16) & 0xfffe) | ((insn >> 5) & 1);
 
   ret = (ret ^ 0x8000) - 0x8000;
 
@@ -375,8 +375,8 @@ extract_d16_16 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_d17_16 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d17_16 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0xffff || value < -0x10000)
     * errmsg = _(out_of_range);
@@ -384,20 +384,20 @@ insert_d17_16 (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value & 0xfffe) << 16) | ((value & 0x10000) >> (16 - 4));
 }
 
-static unsigned long
-extract_d17_16 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d17_16 (unsigned long long insn, int * invalid)
 {
-  signed long ret = ((insn >> 16) & 0xfffe) | ((insn << (16 - 4)) & 0x10000);
+  signed long long ret = ((insn >> 16) & 0xfffe) | ((insn << (16 - 4)) & 0x10000);
 
   ret = (ret ^ 0x10000) - 0x10000;
 
   if (invalid != 0)
     *invalid = 0;
-  return (unsigned long)ret;
+  return (unsigned long long)ret;
 }
 
-static unsigned long
-insert_d22 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d22 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0x1fffff || value < -0x200000)
     {
@@ -412,20 +412,20 @@ insert_d22 (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value & 0xfffe) << 16) | ((value & 0x3f0000) >> 16);
 }
 
-static unsigned long
-extract_d22 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d22 (unsigned long long insn, int * invalid)
 {
-  signed long ret = ((insn >> 16) & 0xfffe) | ((insn << 16) & 0x3f0000);
+  signed long long ret = ((insn >> 16) & 0xfffe) | ((insn << 16) & 0x3f0000);
 
   ret = (ret ^ 0x200000) - 0x200000;
 
   if (invalid != 0)
     *invalid = 0;
-  return (unsigned long) ret;
+  return (unsigned long long) ret;
 }
 
-static unsigned long
-insert_d23 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d23 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0x3fffff || value < -0x400000)
     * errmsg = out_of_range;
@@ -433,8 +433,8 @@ insert_d23 (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value & 0x7f) << 4) | ((value & 0x7fff80) << (16-7));
 }
 
-static unsigned long
-insert_d23_align1 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_d23_align1 (unsigned long long insn, long long value, const char ** errmsg)
 {
   if (value > 0x3fffff || value < -0x400000)
     {
@@ -449,20 +449,20 @@ insert_d23_align1 (unsigned long insn, long value, const char ** errmsg)
   return insn | ((value & 0x7e) << 4) | ((value & 0x7fff80) << (16 - 7));
 }
 
-static unsigned long
-extract_d23 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_d23 (unsigned long long insn, int * invalid)
 {
-  signed long ret = ((insn >> 4) & 0x7f) | ((insn >> (16-7)) & 0x7fff80);
+  signed long long ret = ((insn >> 4) & 0x7f) | ((insn >> (16-7)) & 0x7fff80);
 
   ret = (ret ^ 0x400000) - 0x400000;
 
   if (invalid != 0)
     *invalid = 0;
-  return (unsigned long) ret;
+  return (unsigned long long) ret;
 }
 
-static unsigned long
-insert_i9 (unsigned long insn, signed long value, const char ** errmsg)
+static unsigned long long
+insert_i9 (unsigned long long insn, signed long long value, const char ** errmsg)
 {
   if (value > 0xff || value < -0x100)
     * errmsg = _(immediate_out_of_range);
@@ -470,10 +470,10 @@ insert_i9 (unsigned long insn, signed long value, const char ** errmsg)
   return insn | ((value & 0x1e0) << 13) | (value & 0x1f);
 }
 
-static unsigned long
-extract_i9 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_i9 (unsigned long long insn, int * invalid)
 {
-  signed long ret = ((insn >> 13) & 0x1e0) | (insn & 0x1f);
+  signed long long ret = ((insn >> 13) & 0x1e0) | (insn & 0x1f);
 
   ret = (ret ^ 0x100) - 0x100;
 
@@ -482,10 +482,10 @@ extract_i9 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_u9 (unsigned long insn, long v, const char ** errmsg)
+static unsigned long long
+insert_u9 (unsigned long long insn, long long v, const char ** errmsg)
 {
-  unsigned long value = (unsigned long) v;
+  unsigned long long value = (unsigned long long) v;
 
   if (value > 0x1ff)
     * errmsg = _(immediate_out_of_range);
@@ -493,20 +493,20 @@ insert_u9 (unsigned long insn, long v, const char ** errmsg)
   return insn | ((value & 0x1e0) << 13) | (value & 0x1f);
 }
 
-static unsigned long
-extract_u9 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_u9 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret = ((insn >> 13) & 0x1e0) | (insn & 0x1f);
+  unsigned long long ret = ((insn >> 13) & 0x1e0) | (insn & 0x1f);
 
   if (invalid != 0)
     *invalid = 0;
   return ret;
 }
 
-static unsigned long
-insert_spe (unsigned long insn, long v, const char ** errmsg)
+static unsigned long long
+insert_spe (unsigned long long insn, long long v, const char ** errmsg)
 {
-  unsigned long value = (unsigned long) v;
+  unsigned long long value = (unsigned long long) v;
 
   if (value != 3)
     * errmsg = _("invalid register for stack adjustment");
@@ -514,8 +514,8 @@ insert_spe (unsigned long insn, long v, const char ** errmsg)
   return insn & ~0x180000;
 }
 
-static unsigned long
-extract_spe (unsigned long insn ATTRIBUTE_UNUSED, int * invalid)
+static unsigned long long
+extract_spe (unsigned long long insn ATTRIBUTE_UNUSED, int * invalid)
 {
   if (invalid != 0)
     *invalid = 0;
@@ -523,10 +523,10 @@ extract_spe (unsigned long insn ATTRIBUTE_UNUSED, int * invalid)
   return 3;
 }
 
-static unsigned long
-insert_r4 (unsigned long insn, long v, const char ** errmsg)
+static unsigned long long
+insert_r4 (unsigned long long insn, long long v, const char ** errmsg)
 {
-  unsigned long value = (unsigned long) v;
+  unsigned long long value = (unsigned long long) v;
 
   if (value >= 32)
     * errmsg = _("invalid register name");
@@ -534,11 +534,11 @@ insert_r4 (unsigned long insn, long v, const char ** errmsg)
   return insn | ((value & 0x01) << 23) | ((value & 0x1e) << 16);
 }
 
-static unsigned long
-extract_r4 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_r4 (unsigned long long insn, int * invalid)
 {
-  unsigned long r4;
-  unsigned long insn2;
+  unsigned long long r4;
+  unsigned long long insn2;
 
   insn2 = insn >> 16;
   r4 = (((insn2 & 0x0080) >> 7) | (insn2 & 0x001e));
@@ -549,24 +549,24 @@ extract_r4 (unsigned long insn, int * invalid)
   return r4;
 }
 
-static unsigned long G_pos;
+static unsigned long long G_pos;
 
-static unsigned long
-insert_POS (unsigned long insn, long pos, const char ** errmsg)
+static unsigned long long
+insert_POS (unsigned long long insn, long long pos, const char ** errmsg)
 {
   if (pos > 0x1f || pos < 0)
     * errmsg = _(pos_out_of_range);
 
-  G_pos = (unsigned long) pos;
+  G_pos = (unsigned long long) pos;
 
   return insn; /* Not an oparaton until WIDTH.  */
 }
 
-static unsigned long
-extract_POS_U (unsigned long insn, int * invalid)
+static unsigned long long
+extract_POS_U (unsigned long long insn, int * invalid)
 {
-  unsigned long pos,lsb;
-  unsigned long insn2;
+  unsigned long long pos,lsb;
+  unsigned long long insn2;
   insn2 = insn >> 16;
 
   lsb = ((insn2 & 0x0800) >>  8)
@@ -580,11 +580,11 @@ extract_POS_U (unsigned long insn, int * invalid)
   return pos;
 }
 
-static unsigned long
-extract_POS_L (unsigned long insn, int * invalid)
+static unsigned long long
+extract_POS_L (unsigned long long insn, int * invalid)
 {
-  unsigned long pos,lsb;
-  unsigned long insn2;
+  unsigned long long pos,lsb;
+  unsigned long long insn2;
   insn2 = insn >> 16;
 
   lsb = ((insn2 & 0x0800) >>  8)
@@ -597,13 +597,13 @@ extract_POS_L (unsigned long insn, int * invalid)
   return pos;
 }
 
-static unsigned long
-insert_WIDTH (unsigned long insn, long width, const char ** errmsg)
+static unsigned long long
+insert_WIDTH (unsigned long long insn, long long width, const char ** errmsg)
 {
-  unsigned long msb, lsb, opc, ret;
-  unsigned long msb_expand, lsb_expand;
+  unsigned long long msb, lsb, opc, ret;
+  unsigned long long msb_expand, lsb_expand;
 
-  msb = (unsigned long)width + G_pos - 1;
+  msb = (unsigned long long)width + G_pos - 1;
   lsb = G_pos;
   opc = 0;
   G_pos = 0;
@@ -630,11 +630,11 @@ insert_WIDTH (unsigned long insn, long width, const char ** errmsg)
   return ret;
 }
 
-static unsigned long
-extract_WIDTH_U (unsigned long insn, int * invalid)
+static unsigned long long
+extract_WIDTH_U (unsigned long long insn, int * invalid)
 {
-  unsigned long width, msb, lsb;
-  unsigned long insn2;
+  unsigned long long width, msb, lsb;
+  unsigned long long insn2;
   insn2 = insn >> 16;
 
   msb = ((insn2 & 0xf000) >> 12);
@@ -651,11 +651,11 @@ extract_WIDTH_U (unsigned long insn, int * invalid)
   return width;
 }
 
-static unsigned long
-extract_WIDTH_M (unsigned long insn, int * invalid)
+static unsigned long long
+extract_WIDTH_M (unsigned long long insn, int * invalid)
 {
-  unsigned long width, msb, lsb;
-  unsigned long insn2;
+  unsigned long long width, msb, lsb;
+  unsigned long long insn2;
   insn2 = insn >> 16;
 
   msb = ((insn2 & 0xf000) >> 12) ;
@@ -671,11 +671,11 @@ extract_WIDTH_M (unsigned long insn, int * invalid)
   return width;
 }
 
-static unsigned long
-extract_WIDTH_L (unsigned long insn, int * invalid)
+static unsigned long long
+extract_WIDTH_L (unsigned long long insn, int * invalid)
 {
-  unsigned long width, msb, lsb;
-  unsigned long insn2;
+  unsigned long long width, msb, lsb;
+  unsigned long long insn2;
   insn2 = insn >> 16;
 
   msb = ((insn2 & 0xf000) >> 12) ;
@@ -690,10 +690,10 @@ extract_WIDTH_L (unsigned long insn, int * invalid)
   return width;
 }
 
-static unsigned long
-insert_SELID (unsigned long insn, long selid, const char ** errmsg)
+static unsigned long long
+insert_SELID (unsigned long long insn, long long selid, const char ** errmsg)
 {
-  unsigned long ret;
+  unsigned long long ret;
 
   if (selid > 0x1f || selid < 0)
     * errmsg = _(selid_out_of_range);
@@ -703,11 +703,11 @@ insert_SELID (unsigned long insn, long selid, const char ** errmsg)
   return ret;
 }
 
-static unsigned long
-extract_SELID (unsigned long insn, int * invalid)
+static unsigned long long
+extract_SELID (unsigned long long insn, int * invalid)
 {
-  unsigned long selid;
-  unsigned long insn2;
+  unsigned long long selid;
+  unsigned long long insn2;
 
   insn2 = insn >> 16;
 
@@ -719,11 +719,11 @@ extract_SELID (unsigned long insn, int * invalid)
   return selid;
 }
 
-static unsigned long
-insert_VECTOR8 (unsigned long insn, long vector8, const char ** errmsg)
+static unsigned long long
+insert_VECTOR8 (unsigned long long insn, long long vector8, const char ** errmsg)
 {
-  unsigned long ret;
-  unsigned long VVV,vvvvv;
+  unsigned long long ret;
+  unsigned long long VVV,vvvvv;
 
   if (vector8 > 0xff || vector8 < 0)
     * errmsg = _(vector8_out_of_range);
@@ -736,12 +736,12 @@ insert_VECTOR8 (unsigned long insn, long vector8, const char ** errmsg)
   return ret;
 }
 
-static unsigned long
-extract_VECTOR8 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_VECTOR8 (unsigned long long insn, int * invalid)
 {
-  unsigned long vector8;
-  unsigned long VVV,vvvvv;
-  unsigned long insn2;
+  unsigned long long vector8;
+  unsigned long long VVV,vvvvv;
+  unsigned long long insn2;
 
   insn2   = insn >> 16;
   VVV     = ((insn2 & 0x3800) >> 11);
@@ -754,11 +754,11 @@ extract_VECTOR8 (unsigned long insn, int * invalid)
   return vector8;
 }
 
-static unsigned long
-insert_VECTOR5 (unsigned long insn, long vector5, const char ** errmsg)
+static unsigned long long
+insert_VECTOR5 (unsigned long long insn, long long vector5, const char ** errmsg)
 {
-  unsigned long ret;
-  unsigned long vvvvv;
+  unsigned long long ret;
+  unsigned long long vvvvv;
 
   if (vector5 > 0x1f || vector5 < 0)
     * errmsg = _(vector5_out_of_range);
@@ -770,10 +770,10 @@ insert_VECTOR5 (unsigned long insn, long vector5, const char ** errmsg)
   return ret;
 }
 
-static unsigned long
-extract_VECTOR5 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_VECTOR5 (unsigned long long insn, int * invalid)
 {
-  unsigned long vector5;
+  unsigned long long vector5;
 
   vector5 = (insn & 0x001f);
 
@@ -783,11 +783,11 @@ extract_VECTOR5 (unsigned long insn, int * invalid)
   return vector5;
 }
 
-static unsigned long
-insert_CACHEOP (unsigned long insn, long cacheop, const char ** errmsg ATTRIBUTE_UNUSED)
+static unsigned long long
+insert_CACHEOP (unsigned long long insn, long long cacheop, const char ** errmsg ATTRIBUTE_UNUSED)
 {
-  unsigned long ret;
-  unsigned long pp,PPPPP;
+  unsigned long long ret;
+  unsigned long long pp,PPPPP;
 
   pp    = (cacheop & 0x60) >> 5;
   PPPPP = (cacheop & 0x1f);
@@ -797,12 +797,12 @@ insert_CACHEOP (unsigned long insn, long cacheop, const char ** errmsg ATTRIBUTE
   return ret;
 }
 
-static unsigned long
-extract_CACHEOP (unsigned long insn, int * invalid)
+static unsigned long long
+extract_CACHEOP (unsigned long long insn, int * invalid)
 {
-  unsigned long ret;
-  unsigned long pp,PPPPP;
-  unsigned long insn2;
+  unsigned long long ret;
+  unsigned long long pp,PPPPP;
+  unsigned long long insn2;
 
   insn2 = insn >> 16;
 
@@ -817,11 +817,11 @@ extract_CACHEOP (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_PREFOP (unsigned long insn, long prefop, const char ** errmsg ATTRIBUTE_UNUSED)
+static unsigned long long
+insert_PREFOP (unsigned long long insn, long long prefop, const char ** errmsg ATTRIBUTE_UNUSED)
 {
-  unsigned long ret;
-  unsigned long PPPPP;
+  unsigned long long ret;
+  unsigned long long PPPPP;
 
   PPPPP = (prefop & 0x1f);
 
@@ -830,12 +830,12 @@ insert_PREFOP (unsigned long insn, long prefop, const char ** errmsg ATTRIBUTE_U
   return ret;
 }
 
-static unsigned long
-extract_PREFOP (unsigned long insn, int * invalid)
+static unsigned long long
+extract_PREFOP (unsigned long long insn, int * invalid)
 {
-  unsigned long ret;
-  unsigned long PPPPP;
-  unsigned long insn2;
+  unsigned long long ret;
+  unsigned long long PPPPP;
+  unsigned long long insn2;
 
   insn2 = insn >> 16;
 
@@ -849,16 +849,16 @@ extract_PREFOP (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_IMM10U (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_IMM10U (unsigned long long insn, long long value, const char ** errmsg)
 {
-  unsigned long imm10, ret;
-  unsigned long iiiii,IIIII;
+  unsigned long long imm10, ret;
+  unsigned long long iiiii,IIIII;
 
   if (value > 0x3ff || value < 0)
     * errmsg = _(imm10_out_of_range);
 
-  imm10 = ((unsigned long) value) & 0x3ff;
+  imm10 = ((unsigned long long) value) & 0x3ff;
   IIIII = (imm10 >> 5) & 0x1f;
   iiiii =  imm10       & 0x1f;
 
@@ -867,12 +867,12 @@ insert_IMM10U (unsigned long insn, long value, const char ** errmsg)
   return ret;
 }
 
-static unsigned long
-extract_IMM10U (unsigned long insn, int * invalid)
+static unsigned long long
+extract_IMM10U (unsigned long long insn, int * invalid)
 {
-  unsigned long ret;
-  unsigned long iiiii,IIIII;
-  unsigned long insn2;
+  unsigned long long ret;
+  unsigned long long iiiii,IIIII;
+  unsigned long long insn2;
   insn2 = insn >> 16;
 
   IIIII = ((insn2 & 0xf800) >> 11);
@@ -886,16 +886,16 @@ extract_IMM10U (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_SRSEL1 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_SRSEL1 (unsigned long long insn, long long value, const char ** errmsg)
 {
-  unsigned long imm10, ret;
-  unsigned long sr,selid;
+  unsigned long long imm10, ret;
+  unsigned long long sr,selid;
 
   if (value > 0x3ff || value < 0)
     * errmsg = _(sr_selid_out_of_range);
 
-  imm10 = (unsigned long) value;
+  imm10 = (unsigned long long) value;
   selid = (imm10 & 0x3e0) >> 5;
   sr    =  imm10 & 0x1f;
 
@@ -904,12 +904,12 @@ insert_SRSEL1 (unsigned long insn, long value, const char ** errmsg)
   return ret;
 }
 
-static unsigned long
-extract_SRSEL1 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_SRSEL1 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret;
-  unsigned long sr, selid;
-  unsigned long insn2;
+  unsigned long long ret;
+  unsigned long long sr, selid;
+  unsigned long long insn2;
 
   insn2 = insn >> 16;
 
@@ -924,16 +924,16 @@ extract_SRSEL1 (unsigned long insn, int * invalid)
   return ret;
 }
 
-static unsigned long
-insert_SRSEL2 (unsigned long insn, long value, const char ** errmsg)
+static unsigned long long
+insert_SRSEL2 (unsigned long long insn, long long value, const char ** errmsg)
 {
-  unsigned long imm10, ret;
-  unsigned long sr, selid;
+  unsigned long long imm10, ret;
+  unsigned long long sr, selid;
 
   if (value > 0x3ff || value < 0)
     * errmsg = _(sr_selid_out_of_range);
 
-  imm10 = (unsigned long) value;
+  imm10 = (unsigned long long) value;
   selid = (imm10 & 0x3e0) >> 5;
   sr    =  imm10 & 0x1f;
 
@@ -942,12 +942,12 @@ insert_SRSEL2 (unsigned long insn, long value, const char ** errmsg)
   return ret;
 }
 
-static unsigned long
-extract_SRSEL2 (unsigned long insn, int * invalid)
+static unsigned long long
+extract_SRSEL2 (unsigned long long insn, int * invalid)
 {
-  unsigned long ret;
-  unsigned long sr, selid;
-  unsigned long insn2;
+  unsigned long long ret;
+  unsigned long long sr, selid;
+  unsigned long long insn2;
 
   insn2 = insn >> 16;
 
diff --git a/opcodes/wasm32-dis.c b/opcodes/wasm32-dis.c
index d6f1697..0539766 100644
--- a/opcodes/wasm32-dis.c
+++ b/opcodes/wasm32-dis.c
@@ -266,12 +266,12 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)
   struct wasm32_private_data *private_data = info->private_data;
   long long constant = 0;
   double fconstant = 0.0;
-  long flags = 0;
-  long offset = 0;
-  long depth = 0;
-  long function_index = 0;
-  long target_count = 0;
-  long block_type = 0;
+  long long flags = 0;
+  long long offset = 0;
+  long long depth = 0;
+  long long function_index = 0;
+  long long target_count = 0;
+  long long block_type = 0;
   int len = 1;
   int ret = 0;
   unsigned int bytes_read = 0;
@@ -364,7 +364,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)
           prin (stream, " %ld", target_count);
           for (i = 0; i < target_count + 1; i++)
             {
-              long target = 0;
+              long long target = 0;
               target = wasm_read_leb128
                 (pc + len, info, &error, &bytes_read, FALSE);
               if (error)
diff --git a/opcodes/xc16x-asm.c b/opcodes/xc16x-asm.c
index 4d8cb4f..91fa373 100644
--- a/opcodes/xc16x-asm.c
+++ b/opcodes/xc16x-asm.c
@@ -56,7 +56,7 @@ static const char *
 parse_hash (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	    const char **strp,
 	    int opindex ATTRIBUTE_UNUSED,
-	    long *valuep ATTRIBUTE_UNUSED)
+	    long long *valuep ATTRIBUTE_UNUSED)
 {
   if (**strp == '#')
     {
@@ -72,7 +72,7 @@ static const char *
 parse_dot (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   const char **strp,
 	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
+	   long long *valuep ATTRIBUTE_UNUSED)
 {
   if (**strp == '.')
     {
@@ -88,7 +88,7 @@ static const char *
 parse_pof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   const char **strp,
 	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
+	   long long *valuep ATTRIBUTE_UNUSED)
 {
   if (strncasecmp (*strp, "pof:", 4) == 0)
     {
@@ -104,7 +104,7 @@ static const char *
 parse_pag (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   const char **strp,
 	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
+	   long long *valuep ATTRIBUTE_UNUSED)
 {
   if (strncasecmp (*strp, "pag:", 4) == 0)
     {
@@ -120,7 +120,7 @@ static const char *
 parse_sof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   const char **strp,
 	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
+	   long long *valuep ATTRIBUTE_UNUSED)
 {
   if (strncasecmp (*strp, "sof:", 4) == 0)
     {
@@ -136,7 +136,7 @@ static const char *
 parse_seg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   const char **strp,
 	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
+	   long long *valuep ATTRIBUTE_UNUSED)
 {
   if (strncasecmp (*strp, "seg:", 4) == 0)
     {
@@ -171,7 +171,7 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
@@ -179,22 +179,22 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_psw_names, & fields->f_reg8);
       break;
     case XC16X_OPERAND_BIT01 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT01, (unsigned long *) (& fields->f_op_1bit));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT01, (unsigned long long *) (& fields->f_op_1bit));
       break;
     case XC16X_OPERAND_BIT1 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT1, (unsigned long *) (& fields->f_op_bit1));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT1, (unsigned long long *) (& fields->f_op_bit1));
       break;
     case XC16X_OPERAND_BIT2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT2, (unsigned long *) (& fields->f_op_bit2));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT2, (unsigned long long *) (& fields->f_op_bit2));
       break;
     case XC16X_OPERAND_BIT4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT4, (unsigned long *) (& fields->f_op_bit4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT4, (unsigned long long *) (& fields->f_op_bit4));
       break;
     case XC16X_OPERAND_BIT8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT8, (unsigned long *) (& fields->f_op_bit8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BIT8, (unsigned long long *) (& fields->f_op_bit8));
       break;
     case XC16X_OPERAND_BITONE :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BITONE, (unsigned long *) (& fields->f_op_onebit));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_BITONE, (unsigned long long *) (& fields->f_op_onebit));
       break;
     case XC16X_OPERAND_CADDR :
       {
@@ -207,13 +207,13 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_conditioncode_names, & fields->f_condcode);
       break;
     case XC16X_OPERAND_DATA8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_DATA8, (unsigned long *) (& fields->f_data8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_DATA8, (unsigned long long *) (& fields->f_data8));
       break;
     case XC16X_OPERAND_DATAHI8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_DATAHI8, (unsigned long *) (& fields->f_datahi8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_DATAHI8, (unsigned long long *) (& fields->f_datahi8));
       break;
     case XC16X_OPERAND_DOT :
-      errmsg = parse_dot (cd, strp, XC16X_OPERAND_DOT, (long *) (& junk));
+      errmsg = parse_dot (cd, strp, XC16X_OPERAND_DOT, (long long *) (& junk));
       break;
     case XC16X_OPERAND_DR :
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_gr_names, & fields->f_r1);
@@ -231,22 +231,22 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_r8_names, & fields->f_regb8);
       break;
     case XC16X_OPERAND_HASH :
-      errmsg = parse_hash (cd, strp, XC16X_OPERAND_HASH, (long *) (& junk));
+      errmsg = parse_hash (cd, strp, XC16X_OPERAND_HASH, (long long *) (& junk));
       break;
     case XC16X_OPERAND_ICOND :
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_conditioncode_names, & fields->f_icondcode);
       break;
     case XC16X_OPERAND_LBIT2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_LBIT2, (unsigned long *) (& fields->f_op_lbit2));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_LBIT2, (unsigned long long *) (& fields->f_op_lbit2));
       break;
     case XC16X_OPERAND_LBIT4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_LBIT4, (unsigned long *) (& fields->f_op_lbit4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_LBIT4, (unsigned long long *) (& fields->f_op_lbit4));
       break;
     case XC16X_OPERAND_MASK8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_MASK8, (unsigned long *) (& fields->f_mask8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_MASK8, (unsigned long long *) (& fields->f_mask8));
       break;
     case XC16X_OPERAND_MASKLO8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_MASKLO8, (unsigned long *) (& fields->f_datahi8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_MASKLO8, (unsigned long long *) (& fields->f_datahi8));
       break;
     case XC16X_OPERAND_MEMGR8 :
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_memgr8_names, & fields->f_memgr8);
@@ -259,22 +259,22 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case XC16X_OPERAND_PAG :
-      errmsg = parse_pag (cd, strp, XC16X_OPERAND_PAG, (long *) (& junk));
+      errmsg = parse_pag (cd, strp, XC16X_OPERAND_PAG, (long long *) (& junk));
       break;
     case XC16X_OPERAND_PAGENUM :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_PAGENUM, (unsigned long *) (& fields->f_pagenum));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_PAGENUM, (unsigned long long *) (& fields->f_pagenum));
       break;
     case XC16X_OPERAND_POF :
-      errmsg = parse_pof (cd, strp, XC16X_OPERAND_POF, (long *) (& junk));
+      errmsg = parse_pof (cd, strp, XC16X_OPERAND_POF, (long long *) (& junk));
       break;
     case XC16X_OPERAND_QBIT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_QBIT, (unsigned long *) (& fields->f_qbit));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_QBIT, (unsigned long long *) (& fields->f_qbit));
       break;
     case XC16X_OPERAND_QHIBIT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_QHIBIT, (unsigned long *) (& fields->f_qhibit));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_QHIBIT, (unsigned long long *) (& fields->f_qhibit));
       break;
     case XC16X_OPERAND_QLOBIT :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_QLOBIT, (unsigned long *) (& fields->f_qlobit));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_QLOBIT, (unsigned long long *) (& fields->f_qlobit));
       break;
     case XC16X_OPERAND_REG8 :
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_r8_names, & fields->f_reg8);
@@ -295,22 +295,22 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_r8_names, & fields->f_regoff8);
       break;
     case XC16X_OPERAND_REL :
-      errmsg = cgen_parse_signed_integer (cd, strp, XC16X_OPERAND_REL, (long *) (& fields->f_rel8));
+      errmsg = cgen_parse_signed_integer (cd, strp, XC16X_OPERAND_REL, (long long *) (& fields->f_rel8));
       break;
     case XC16X_OPERAND_RELHI :
-      errmsg = cgen_parse_signed_integer (cd, strp, XC16X_OPERAND_RELHI, (long *) (& fields->f_relhi8));
+      errmsg = cgen_parse_signed_integer (cd, strp, XC16X_OPERAND_RELHI, (long long *) (& fields->f_relhi8));
       break;
     case XC16X_OPERAND_SEG :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_SEG, (unsigned long *) (& fields->f_seg8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_SEG, (unsigned long long *) (& fields->f_seg8));
       break;
     case XC16X_OPERAND_SEGHI8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_SEGHI8, (unsigned long *) (& fields->f_segnum8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_SEGHI8, (unsigned long long *) (& fields->f_segnum8));
       break;
     case XC16X_OPERAND_SEGM :
-      errmsg = parse_seg (cd, strp, XC16X_OPERAND_SEGM, (long *) (& junk));
+      errmsg = parse_seg (cd, strp, XC16X_OPERAND_SEGM, (long long *) (& junk));
       break;
     case XC16X_OPERAND_SOF :
-      errmsg = parse_sof (cd, strp, XC16X_OPERAND_SOF, (long *) (& junk));
+      errmsg = parse_sof (cd, strp, XC16X_OPERAND_SOF, (long long *) (& junk));
       break;
     case XC16X_OPERAND_SR :
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_gr_names, & fields->f_r2);
@@ -334,7 +334,7 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_reg0_name, & fields->f_uimm4);
       break;
     case XC16X_OPERAND_UIMM16 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UIMM16, (unsigned long *) (& fields->f_uimm16));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UIMM16, (unsigned long long *) (& fields->f_uimm16));
       break;
     case XC16X_OPERAND_UIMM2 :
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_ext_names, & fields->f_uimm2);
@@ -343,16 +343,16 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & xc16x_cgen_opval_reg0_name1, & fields->f_uimm3);
       break;
     case XC16X_OPERAND_UIMM4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UIMM4, (unsigned long *) (& fields->f_uimm4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UIMM4, (unsigned long long *) (& fields->f_uimm4));
       break;
     case XC16X_OPERAND_UIMM7 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UIMM7, (unsigned long *) (& fields->f_uimm7));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UIMM7, (unsigned long long *) (& fields->f_uimm7));
       break;
     case XC16X_OPERAND_UIMM8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UIMM8, (unsigned long *) (& fields->f_uimm8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UIMM8, (unsigned long long *) (& fields->f_uimm8));
       break;
     case XC16X_OPERAND_UPAG16 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UPAG16, (unsigned long *) (& fields->f_uimm16));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_UPAG16, (unsigned long long *) (& fields->f_uimm16));
       break;
     case XC16X_OPERAND_UPOF16 :
       {
@@ -362,13 +362,13 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
       }
       break;
     case XC16X_OPERAND_USEG16 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_USEG16, (unsigned long *) (& fields->f_offset16));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_USEG16, (unsigned long long *) (& fields->f_offset16));
       break;
     case XC16X_OPERAND_USEG8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_USEG8, (unsigned long *) (& fields->f_seg8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_USEG8, (unsigned long long *) (& fields->f_seg8));
       break;
     case XC16X_OPERAND_USOF16 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_USOF16, (unsigned long *) (& fields->f_offset16));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XC16X_OPERAND_USOF16, (unsigned long long *) (& fields->f_offset16));
       break;
 
     default :
diff --git a/opcodes/xc16x-dis.c b/opcodes/xc16x-dis.c
index d634572..21156c1 100644
--- a/opcodes/xc16x-dis.c
+++ b/opcodes/xc16x-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -68,7 +68,7 @@ static int read_insn
 static void
 print_with_dot_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		       void * dis_info,
-		       long value,
+		       long long value,
 		       unsigned attrs ATTRIBUTE_UNUSED,
 		       bfd_vma pc ATTRIBUTE_UNUSED,
 		       int length ATTRIBUTE_UNUSED)
@@ -95,7 +95,7 @@ print_with_pof_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   disassemble_info *info = (disassemble_info *) dis_info;
 
   info->fprintf_func (info->stream, "#pof:");
-  info->fprintf_func (info->stream, "0x%lx", (long) value);
+  info->fprintf_func (info->stream, "0x%lx", (long long) value);
 }
 
 /* Print an operand with a "#pag:" prefix.
@@ -106,7 +106,7 @@ print_with_pof_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_with_pag_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 		       void * dis_info,
-		       long value,
+		       long long value,
 		       unsigned attrs ATTRIBUTE_UNUSED,
 		       bfd_vma pc ATTRIBUTE_UNUSED,
 		       int length ATTRIBUTE_UNUSED)
@@ -122,7 +122,7 @@ print_with_pag_prefix (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_pof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   void * dis_info ATTRIBUTE_UNUSED,
-	   long value ATTRIBUTE_UNUSED,
+	   long long value ATTRIBUTE_UNUSED,
 	   unsigned int attrs ATTRIBUTE_UNUSED,
 	   bfd_vma pc ATTRIBUTE_UNUSED,
 	   int length ATTRIBUTE_UNUSED)
@@ -134,7 +134,7 @@ print_pof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_pag (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   void * dis_info ATTRIBUTE_UNUSED,
-	   long value ATTRIBUTE_UNUSED,
+	   long long value ATTRIBUTE_UNUSED,
 	   unsigned int attrs ATTRIBUTE_UNUSED,
 	   bfd_vma pc ATTRIBUTE_UNUSED,
 	   int length ATTRIBUTE_UNUSED)
@@ -146,7 +146,7 @@ print_pag (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_sof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   void * dis_info,
-	   long value ATTRIBUTE_UNUSED,
+	   long long value ATTRIBUTE_UNUSED,
 	   unsigned int attrs ATTRIBUTE_UNUSED,
 	   bfd_vma pc ATTRIBUTE_UNUSED,
 	   int length ATTRIBUTE_UNUSED)
@@ -161,7 +161,7 @@ print_sof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_seg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   void * dis_info,
-	   long value ATTRIBUTE_UNUSED,
+	   long long value ATTRIBUTE_UNUSED,
 	   unsigned int attrs ATTRIBUTE_UNUSED,
 	   bfd_vma pc ATTRIBUTE_UNUSED,
 	   int length ATTRIBUTE_UNUSED)
@@ -176,7 +176,7 @@ print_seg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_hash (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	    void * dis_info,
-	    long value ATTRIBUTE_UNUSED,
+	    long long value ATTRIBUTE_UNUSED,
 	    unsigned int attrs ATTRIBUTE_UNUSED,
 	    bfd_vma pc ATTRIBUTE_UNUSED,
 	    int length ATTRIBUTE_UNUSED)
@@ -191,7 +191,7 @@ print_hash (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 static void
 print_dot (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   void * dis_info ATTRIBUTE_UNUSED,
-	   long value ATTRIBUTE_UNUSED,
+	   long long value ATTRIBUTE_UNUSED,
 	   unsigned int attrs ATTRIBUTE_UNUSED,
 	   bfd_vma pc ATTRIBUTE_UNUSED,
 	   int length ATTRIBUTE_UNUSED)
@@ -445,7 +445,7 @@ xc16x_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -481,9 +481,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -492,7 +492,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -554,7 +554,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -612,7 +612,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -631,7 +631,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -647,9 +647,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/xc16x-ibld.c b/opcodes/xc16x-ibld.c
index 9871663..001e872 100644
--- a/opcodes/xc16x-ibld.c
+++ b/opcodes/xc16x-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
diff --git a/opcodes/xc16x-opc.h b/opcodes/xc16x-opc.h
index e034a18..5c104d5 100644
--- a/opcodes/xc16x-opc.h
+++ b/opcodes/xc16x-opc.h
@@ -158,59 +158,59 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_op1;
-  long f_op2;
-  long f_condcode;
-  long f_icondcode;
-  long f_rcond;
-  long f_qcond;
-  long f_extccode;
-  long f_r0;
-  long f_r1;
-  long f_r2;
-  long f_r3;
-  long f_r4;
-  long f_uimm2;
-  long f_uimm3;
-  long f_uimm4;
-  long f_uimm7;
-  long f_uimm8;
-  long f_uimm16;
-  long f_memory;
-  long f_memgr8;
-  long f_rel8;
-  long f_relhi8;
-  long f_reg8;
-  long f_regmem8;
-  long f_regoff8;
-  long f_reghi8;
-  long f_regb8;
-  long f_seg8;
-  long f_segnum8;
-  long f_mask8;
-  long f_pagenum;
-  long f_datahi8;
-  long f_data8;
-  long f_offset16;
-  long f_op_bit1;
-  long f_op_bit2;
-  long f_op_bit4;
-  long f_op_bit3;
-  long f_op_2bit;
-  long f_op_bitone;
-  long f_op_onebit;
-  long f_op_1bit;
-  long f_op_lbit4;
-  long f_op_lbit2;
-  long f_op_bit8;
-  long f_op_bit16;
-  long f_qbit;
-  long f_qlobit;
-  long f_qhibit;
-  long f_qlobit2;
-  long f_pof;
+  long long f_nil;
+  long long f_anyof;
+  long long f_op1;
+  long long f_op2;
+  long long f_condcode;
+  long long f_icondcode;
+  long long f_rcond;
+  long long f_qcond;
+  long long f_extccode;
+  long long f_r0;
+  long long f_r1;
+  long long f_r2;
+  long long f_r3;
+  long long f_r4;
+  long long f_uimm2;
+  long long f_uimm3;
+  long long f_uimm4;
+  long long f_uimm7;
+  long long f_uimm8;
+  long long f_uimm16;
+  long long f_memory;
+  long long f_memgr8;
+  long long f_rel8;
+  long long f_relhi8;
+  long long f_reg8;
+  long long f_regmem8;
+  long long f_regoff8;
+  long long f_reghi8;
+  long long f_regb8;
+  long long f_seg8;
+  long long f_segnum8;
+  long long f_mask8;
+  long long f_pagenum;
+  long long f_datahi8;
+  long long f_data8;
+  long long f_offset16;
+  long long f_op_bit1;
+  long long f_op_bit2;
+  long long f_op_bit4;
+  long long f_op_bit3;
+  long long f_op_2bit;
+  long long f_op_bitone;
+  long long f_op_onebit;
+  long long f_op_1bit;
+  long long f_op_lbit4;
+  long long f_op_lbit2;
+  long long f_op_bit8;
+  long long f_op_bit16;
+  long long f_qbit;
+  long long f_qlobit;
+  long long f_qhibit;
+  long long f_qlobit2;
+  long long f_pof;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/xgate-dis.c b/opcodes/xgate-dis.c
index 7b337a1..7d8d3ea 100644
--- a/opcodes/xgate-dis.c
+++ b/opcodes/xgate-dis.c
@@ -64,7 +64,7 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info)
   int status;
   unsigned int raw_code;
   char *s = 0;
-  long bytesRead = 0;
+  long long bytesRead = 0;
   int i = 0;
   struct xgate_opcode *opcodePTR = (struct xgate_opcode*) xgate_opcodes;
   struct decodeInfo *decodeTablePTR = 0;
diff --git a/opcodes/xstormy16-asm.c b/opcodes/xstormy16-asm.c
index aa73a00..277e5a3 100644
--- a/opcodes/xstormy16-asm.c
+++ b/opcodes/xstormy16-asm.c
@@ -61,7 +61,7 @@ static const char *
 parse_mem8 (CGEN_CPU_DESC cd,
 	    const char **strp,
 	    int opindex,
-	    unsigned long *valuep)
+	    unsigned long long *valuep)
 {
   if (**strp == '(')
     {
@@ -78,7 +78,7 @@ parse_mem8 (CGEN_CPU_DESC cd,
 	return _("Bad register name");
     }
   else if (cgen_parse_keyword (cd, strp, & xstormy16_cgen_opval_gr_names,
-			       (long *) valuep) == NULL)
+			       (long long *) valuep) == NULL)
     return _("Label conflicts with register name");
   else if (strncasecmp (*strp, "rx,", 3) == 0
 	   || strncasecmp (*strp, "rxl,", 3) == 0
@@ -99,7 +99,7 @@ static const char *
 parse_small_immediate (CGEN_CPU_DESC cd,
 		       const char **strp,
 		       int opindex,
-		       unsigned long *valuep)
+		       unsigned long long *valuep)
 {
   bfd_vma value;
   enum cgen_parse_operand_result result;
@@ -128,7 +128,7 @@ static const char *
 parse_immediate16 (CGEN_CPU_DESC cd,
 		   const char **strp,
 		   int opindex,
-		   unsigned long *valuep)
+		   unsigned long long *valuep)
 {
   const char *errmsg;
   enum cgen_parse_operand_result result;
@@ -194,7 +194,7 @@ xstormy16_cgen_parse_operand (CGEN_CPU_DESC cd,
 {
   const char * errmsg = NULL;
   /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
+  long long junk ATTRIBUTE_UNUSED;
 
   switch (opindex)
     {
@@ -217,7 +217,7 @@ xstormy16_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & xstormy16_cgen_opval_gr_names, & fields->f_Rs);
       break;
     case XSTORMY16_OPERAND_ABS24 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_ABS24, (unsigned long *) (& fields->f_abs24));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_ABS24, (unsigned long long *) (& fields->f_abs24));
       break;
     case XSTORMY16_OPERAND_BCOND2 :
       errmsg = cgen_parse_keyword (cd, strp, & xstormy16_cgen_opval_h_branchcond, & fields->f_op2);
@@ -226,46 +226,46 @@ xstormy16_cgen_parse_operand (CGEN_CPU_DESC cd,
       errmsg = cgen_parse_keyword (cd, strp, & xstormy16_cgen_opval_h_branchcond, & fields->f_op5);
       break;
     case XSTORMY16_OPERAND_HMEM8 :
-      errmsg = parse_mem8 (cd, strp, XSTORMY16_OPERAND_HMEM8, (unsigned long *) (& fields->f_hmem8));
+      errmsg = parse_mem8 (cd, strp, XSTORMY16_OPERAND_HMEM8, (unsigned long long *) (& fields->f_hmem8));
       break;
     case XSTORMY16_OPERAND_IMM12 :
-      errmsg = cgen_parse_signed_integer (cd, strp, XSTORMY16_OPERAND_IMM12, (long *) (& fields->f_imm12));
+      errmsg = cgen_parse_signed_integer (cd, strp, XSTORMY16_OPERAND_IMM12, (long long *) (& fields->f_imm12));
       break;
     case XSTORMY16_OPERAND_IMM16 :
-      errmsg = parse_immediate16 (cd, strp, XSTORMY16_OPERAND_IMM16, (unsigned long *) (& fields->f_imm16));
+      errmsg = parse_immediate16 (cd, strp, XSTORMY16_OPERAND_IMM16, (unsigned long long *) (& fields->f_imm16));
       break;
     case XSTORMY16_OPERAND_IMM2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_IMM2, (unsigned long *) (& fields->f_imm2));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_IMM2, (unsigned long long *) (& fields->f_imm2));
       break;
     case XSTORMY16_OPERAND_IMM3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_IMM3, (unsigned long *) (& fields->f_imm3));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_IMM3, (unsigned long long *) (& fields->f_imm3));
       break;
     case XSTORMY16_OPERAND_IMM3B :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_IMM3B, (unsigned long *) (& fields->f_imm3b));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_IMM3B, (unsigned long long *) (& fields->f_imm3b));
       break;
     case XSTORMY16_OPERAND_IMM4 :
-      errmsg = parse_small_immediate (cd, strp, XSTORMY16_OPERAND_IMM4, (unsigned long *) (& fields->f_imm4));
+      errmsg = parse_small_immediate (cd, strp, XSTORMY16_OPERAND_IMM4, (unsigned long long *) (& fields->f_imm4));
       break;
     case XSTORMY16_OPERAND_IMM8 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_IMM8, (unsigned long *) (& fields->f_imm8));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_IMM8, (unsigned long long *) (& fields->f_imm8));
       break;
     case XSTORMY16_OPERAND_IMM8SMALL :
-      errmsg = parse_small_immediate (cd, strp, XSTORMY16_OPERAND_IMM8SMALL, (unsigned long *) (& fields->f_imm8));
+      errmsg = parse_small_immediate (cd, strp, XSTORMY16_OPERAND_IMM8SMALL, (unsigned long long *) (& fields->f_imm8));
       break;
     case XSTORMY16_OPERAND_LMEM8 :
-      errmsg = parse_mem8 (cd, strp, XSTORMY16_OPERAND_LMEM8, (unsigned long *) (& fields->f_lmem8));
+      errmsg = parse_mem8 (cd, strp, XSTORMY16_OPERAND_LMEM8, (unsigned long long *) (& fields->f_lmem8));
       break;
     case XSTORMY16_OPERAND_REL12 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_REL12, (unsigned long *) (& fields->f_rel12));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_REL12, (unsigned long long *) (& fields->f_rel12));
       break;
     case XSTORMY16_OPERAND_REL12A :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_REL12A, (unsigned long *) (& fields->f_rel12a));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_REL12A, (unsigned long long *) (& fields->f_rel12a));
       break;
     case XSTORMY16_OPERAND_REL8_2 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_REL8_2, (unsigned long *) (& fields->f_rel8_2));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_REL8_2, (unsigned long long *) (& fields->f_rel8_2));
       break;
     case XSTORMY16_OPERAND_REL8_4 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_REL8_4, (unsigned long *) (& fields->f_rel8_4));
+      errmsg = cgen_parse_unsigned_integer (cd, strp, XSTORMY16_OPERAND_REL8_4, (unsigned long long *) (& fields->f_rel8_4));
       break;
     case XSTORMY16_OPERAND_WS2 :
       errmsg = cgen_parse_keyword (cd, strp, & xstormy16_cgen_opval_h_wordsize, & fields->f_op2m);
diff --git a/opcodes/xstormy16-dis.c b/opcodes/xstormy16-dis.c
index 0c8d204..c9c63f1 100644
--- a/opcodes/xstormy16-dis.c
+++ b/opcodes/xstormy16-dis.c
@@ -41,11 +41,11 @@
 #define UNKNOWN_INSN_MSG _("*unknown*")
 
 static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+  (CGEN_CPU_DESC, void *, long long, unsigned int, bfd_vma, int);
 static void print_address
   (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
 static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long long, unsigned int) ATTRIBUTE_UNUSED;
 static void print_insn_normal
   (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
 static int print_insn
@@ -54,7 +54,7 @@ static int default_print_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
 static int read_insn
   (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
+   unsigned long long *);
 
 /* -- disassembler routines inserted here.  */
 
@@ -193,7 +193,7 @@ xstormy16_cgen_init_dis (CGEN_CPU_DESC cd)
 static void
 print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      void *dis_info,
-	      long value,
+	      long long value,
 	      unsigned int attrs,
 	      bfd_vma pc ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED)
@@ -229,9 +229,9 @@ print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
     (*info->print_address_func) (value, info);
   else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+    (*info->fprintf_func) (info->stream, "%ld", (long long) value);
   else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+    (*info->fprintf_func) (info->stream, "0x%lx", (long long) value);
 }
 
 /* Keyword print handler.  */
@@ -240,7 +240,7 @@ static void
 print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	       void *dis_info,
 	       CGEN_KEYWORD *keyword_table,
-	       long value,
+	       long long value,
 	       unsigned int attrs ATTRIBUTE_UNUSED)
 {
   disassemble_info *info = (disassemble_info *) dis_info;
@@ -302,7 +302,7 @@ read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	   bfd_byte *buf,
 	   int buflen,
 	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
+	   unsigned long long *insn_value)
 {
   int status = (*info->read_memory_func) (pc, buf, buflen, info);
 
@@ -360,7 +360,7 @@ print_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = insn_list->insn;
       CGEN_FIELDS fields;
       int length;
-      unsigned long insn_value_cropped;
+      unsigned long long insn_value_cropped;
 
 #ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
@@ -379,7 +379,7 @@ print_insn (CGEN_CPU_DESC cd,
       /* Base size may exceed this instruction's size.  Extract the
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
@@ -395,9 +395,9 @@ print_insn (CGEN_CPU_DESC cd,
 	  /* Make sure the entire insn is loaded into insn_value, if it
 	     can fit.  */
 	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long long))
 	    {
-	      unsigned long full_insn_value;
+	      unsigned long long full_insn_value;
 	      int rc = read_insn (cd, pc, info, buf,
 				  CGEN_INSN_BITSIZE (insn) / 8,
 				  & ex_info, & full_insn_value);
diff --git a/opcodes/xstormy16-ibld.c b/opcodes/xstormy16-ibld.c
index 0662254..9df5785 100644
--- a/opcodes/xstormy16-ibld.c
+++ b/opcodes/xstormy16-ibld.c
@@ -46,7 +46,7 @@
 #define FLD(f) (fields->f)
 
 static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+  (CGEN_CPU_DESC, long long, unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
 static const char * insert_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *,
@@ -54,7 +54,7 @@ static const char * insert_insn_normal
 static int extract_normal
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
    unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
+   unsigned int, unsigned int, bfd_vma, long long *);
 static int extract_insn_normal
   (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
    CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
@@ -64,10 +64,10 @@ static void put_insn_int_value
 #endif
 #if ! CGEN_INT_INSN_P
 static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+  (CGEN_CPU_DESC, unsigned long long, int, int, int, unsigned char *);
 static CGEN_INLINE int fill_cache
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
+static CGEN_INLINE long long extract_1
   (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
 #endif
 
@@ -79,13 +79,13 @@ static CGEN_INLINE long extract_1
 
 static CGEN_INLINE void
 insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
+	  unsigned long long value,
 	  int start,
 	  int length,
 	  int word_length,
 	  unsigned char *bufp)
 {
-  unsigned long x,mask;
+  unsigned long long x,mask;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -121,7 +121,7 @@ insert_1 (CGEN_CPU_DESC cd,
 
 static const char *
 insert_normal (CGEN_CPU_DESC cd,
-	       long value,
+	       long long value,
 	       unsigned int attrs,
 	       unsigned int word_offset,
 	       unsigned int start,
@@ -132,7 +132,7 @@ insert_normal (CGEN_CPU_DESC cd,
 {
   static char errbuf[100];
   /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  unsigned long long mask = (((1L << (length - 1)) - 1) << 1) | 1;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value.  */
   if (length == 0)
@@ -153,10 +153,10 @@ insert_normal (CGEN_CPU_DESC cd,
   /* Ensure VALUE will fit.  */
   if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
     {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
+      long long minval = - (1L << (length - 1));
+      unsigned long long maxval = mask;
 
-      if ((value > 0 && (unsigned long) value > maxval)
+      if ((value > 0 && (unsigned long long) value > maxval)
 	  || value < minval)
 	{
 	  /* xgettext:c-format */
@@ -168,14 +168,14 @@ insert_normal (CGEN_CPU_DESC cd,
     }
   else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
     {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
+      unsigned long long maxval = mask;
+      unsigned long long val = (unsigned long long) value;
 
       /* For hosts with a word size > 32 check to see if value has been sign
 	 extended beyond 32 bits.  If so then ignore these higher sign bits
 	 as the user is attempting to store a 32-bit signed value into an
 	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+      if (sizeof (unsigned long long) > 4 && ((value >> 32) == -1))
 	val &= 0xFFFFFFFF;
 
       if (val > maxval)
@@ -191,8 +191,8 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       if (! cgen_signed_overflow_ok_p (cd))
 	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
+	  long long minval = - (1L << (length - 1));
+	  long long maxval =   (1L << (length - 1)) - 1;
 
 	  if (value < minval || value > maxval)
 	    {
@@ -252,7 +252,7 @@ insert_insn_normal (CGEN_CPU_DESC cd,
 		    bfd_vma pc)
 {
   const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
+  unsigned long long value;
   const CGEN_SYNTAX_CHAR_TYPE * syn;
 
   CGEN_INIT_INSERT (cd);
@@ -375,7 +375,7 @@ fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 
 /* Subroutine of extract_normal.  */
 
-static CGEN_INLINE long
+static CGEN_INLINE long long
 extract_1 (CGEN_CPU_DESC cd,
 	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
 	   int start,
@@ -384,7 +384,7 @@ extract_1 (CGEN_CPU_DESC cd,
 	   unsigned char *bufp,
 	   bfd_vma pc ATTRIBUTE_UNUSED)
 {
-  unsigned long x;
+  unsigned long long x;
   int shift;
 
   x = cgen_get_insn_value (cd, bufp, word_length);
@@ -437,9 +437,9 @@ extract_normal (CGEN_CPU_DESC cd,
 #else
 		bfd_vma pc ATTRIBUTE_UNUSED,
 #endif
-		long *valuep)
+		long long *valuep)
 {
-  long value, mask;
+  long long value, mask;
 
   /* If LENGTH is zero, this operand doesn't contribute to the value
      so give it a standard value of zero.  */
@@ -613,7 +613,7 @@ xstormy16_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case XSTORMY16_OPERAND_HMEM8 :
       {
-        long value = fields->f_hmem8;
+        long long value = fields->f_hmem8;
         value = ((value) - (32512));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_ABS_ADDR), 0, 8, 8, 32, total_length, buffer);
       }
@@ -647,28 +647,28 @@ xstormy16_cgen_insert_operand (CGEN_CPU_DESC cd,
       break;
     case XSTORMY16_OPERAND_REL12 :
       {
-        long value = fields->f_rel12;
+        long long value = fields->f_rel12;
         value = ((value) - (((pc) + (4))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 20, 12, 32, total_length, buffer);
       }
       break;
     case XSTORMY16_OPERAND_REL12A :
       {
-        long value = fields->f_rel12a;
+        long long value = fields->f_rel12a;
         value = ((SI) (((value) - (((pc) + (2))))) >> (1));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 4, 11, 32, total_length, buffer);
       }
       break;
     case XSTORMY16_OPERAND_REL8_2 :
       {
-        long value = fields->f_rel8_2;
+        long long value = fields->f_rel8_2;
         value = ((value) - (((pc) + (2))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 32, total_length, buffer);
       }
       break;
     case XSTORMY16_OPERAND_REL8_4 :
       {
-        long value = fields->f_rel8_4;
+        long long value = fields->f_rel8_4;
         value = ((value) - (((pc) + (4))));
         errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 32, total_length, buffer);
       }
@@ -755,7 +755,7 @@ xstormy16_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case XSTORMY16_OPERAND_HMEM8 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_ABS_ADDR), 0, 8, 8, 32, total_length, pc, & value);
         value = ((value) + (32512));
         fields->f_hmem8 = value;
@@ -790,7 +790,7 @@ xstormy16_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case XSTORMY16_OPERAND_REL12 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 20, 12, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (4))));
         fields->f_rel12 = value;
@@ -798,7 +798,7 @@ xstormy16_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case XSTORMY16_OPERAND_REL12A :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 4, 11, 32, total_length, pc, & value);
         value = ((((value) << (1))) + (((pc) + (2))));
         fields->f_rel12a = value;
@@ -806,7 +806,7 @@ xstormy16_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case XSTORMY16_OPERAND_REL8_2 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (2))));
         fields->f_rel8_2 = value;
@@ -814,7 +814,7 @@ xstormy16_cgen_extract_operand (CGEN_CPU_DESC cd,
       break;
     case XSTORMY16_OPERAND_REL8_4 :
       {
-        long value;
+        long long value;
         length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 8, 8, 32, total_length, pc, & value);
         value = ((value) + (((pc) + (4))));
         fields->f_rel8_4 = value;
diff --git a/opcodes/xstormy16-opc.h b/opcodes/xstormy16-opc.h
index 44a26e6..46f4af3 100644
--- a/opcodes/xstormy16-opc.h
+++ b/opcodes/xstormy16-opc.h
@@ -87,43 +87,43 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_Rd;
-  long f_Rdm;
-  long f_Rm;
-  long f_Rs;
-  long f_Rb;
-  long f_Rbj;
-  long f_op1;
-  long f_op2;
-  long f_op2a;
-  long f_op2m;
-  long f_op3;
-  long f_op3a;
-  long f_op3b;
-  long f_op4;
-  long f_op4m;
-  long f_op4b;
-  long f_op5;
-  long f_op5a;
-  long f_op;
-  long f_imm2;
-  long f_imm3;
-  long f_imm3b;
-  long f_imm4;
-  long f_imm8;
-  long f_imm12;
-  long f_imm16;
-  long f_lmem8;
-  long f_hmem8;
-  long f_rel8_2;
-  long f_rel8_4;
-  long f_rel12;
-  long f_rel12a;
-  long f_abs24_1;
-  long f_abs24_2;
-  long f_abs24;
+  long long f_nil;
+  long long f_anyof;
+  long long f_Rd;
+  long long f_Rdm;
+  long long f_Rm;
+  long long f_Rs;
+  long long f_Rb;
+  long long f_Rbj;
+  long long f_op1;
+  long long f_op2;
+  long long f_op2a;
+  long long f_op2m;
+  long long f_op3;
+  long long f_op3a;
+  long long f_op3b;
+  long long f_op4;
+  long long f_op4m;
+  long long f_op4b;
+  long long f_op5;
+  long long f_op5a;
+  long long f_op;
+  long long f_imm2;
+  long long f_imm3;
+  long long f_imm3b;
+  long long f_imm4;
+  long long f_imm8;
+  long long f_imm12;
+  long long f_imm16;
+  long long f_lmem8;
+  long long f_hmem8;
+  long long f_rel8_2;
+  long long f_rel8_4;
+  long long f_rel12;
+  long long f_rel12a;
+  long long f_abs24_1;
+  long long f_abs24_2;
+  long long f_abs24;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/opcodes/z8k-dis.c b/opcodes/z8k-dis.c
index 4ae7323..6ff22fe 100644
--- a/opcodes/z8k-dis.c
+++ b/opcodes/z8k-dis.c
@@ -41,14 +41,14 @@ typedef struct
 
   int tabl_index;
   char instr_asmsrc[80];
-  unsigned long arg_reg[0x0f];
-  unsigned long immediate;
-  unsigned long displacement;
-  unsigned long address;
-  unsigned long cond_code;
-  unsigned long ctrl_code;
-  unsigned long flags;
-  unsigned long interrupts;
+  unsigned long long arg_reg[0x0f];
+  unsigned long long immediate;
+  unsigned long long displacement;
+  unsigned long long address;
+  unsigned long long cond_code;
+  unsigned long long ctrl_code;
+  unsigned long long flags;
+  unsigned long long interrupts;
 }
 instr_data_s;
 
@@ -137,7 +137,7 @@ static char *ctrl_names[8] =
 
 static int seg_length;
 int z8k_lookup_instr (unsigned char *, disassemble_info *);
-static void output_instr (instr_data_s *, unsigned long, disassemble_info *);
+static void output_instr (instr_data_s *, unsigned long long, disassemble_info *);
 static void unpack_instr (instr_data_s *, int, disassemble_info *);
 static void unparse_instr (instr_data_s *, int);
 
@@ -278,7 +278,7 @@ z8k_lookup_instr (unsigned char *nibbles, disassemble_info *info)
 
 static void
 output_instr (instr_data_s *instr_data,
-              unsigned long addr ATTRIBUTE_UNUSED,
+              unsigned long long addr ATTRIBUTE_UNUSED,
               disassemble_info *info)
 {
   int num_bytes;
@@ -299,7 +299,7 @@ unpack_instr (instr_data_s *instr_data, int is_segmented, disassemble_info *info
 {
   int nibl_count, loop;
   unsigned short instr_nibl, instr_byte, instr_word;
-  long instr_long;
+  long long instr_long;
   unsigned int tabl_datum, datum_class;
   unsigned short datum_value;
 
@@ -472,7 +472,7 @@ unpack_instr (instr_data_s *instr_data, int is_segmented, disassemble_info *info
 }
 
 static void
-print_intr(char *tmp_str, unsigned long interrupts)
+print_intr(char *tmp_str, unsigned long long interrupts)
 {
   int comma = 0;
 
@@ -490,7 +490,7 @@ print_intr(char *tmp_str, unsigned long interrupts)
 }
 
 static void
-print_flags(char *tmp_str, unsigned long flags)
+print_flags(char *tmp_str, unsigned long long flags)
 {
   int comma = 0;
 
diff --git a/readline/examples/rlfe/os.h b/readline/examples/rlfe/os.h
index 734bc8c..a500b8c 100644
--- a/readline/examples/rlfe/os.h
+++ b/readline/examples/rlfe/os.h
@@ -112,7 +112,7 @@ extern int errno;
 #else
 # define VA_LIST(var)
 # define VA_DOTS p1, p2, p3, p4, p5, p6
-# define VA_DECL unsigned long VA_DOTS;
+# define VA_DECL unsigned long long VA_DOTS;
 # define VA_START(ap, fmt)
 # define VA_ARGS(ap) VA_DOTS
 # define VA_END(ap)
diff --git a/readline/history.c b/readline/history.c
index d7894cf..3bce020 100644
--- a/readline/history.c
+++ b/readline/history.c
@@ -248,9 +248,9 @@ hist_inittime ()
 
   t = (time_t) time ((time_t *)0);
 #if defined (HAVE_VSNPRINTF)		/* assume snprintf if vsnprintf exists */
-  snprintf (ts, sizeof (ts) - 1, "X%lu", (unsigned long) t);
+  snprintf (ts, sizeof (ts) - 1, "X%lu", (unsigned long long) t);
 #else
-  sprintf (ts, "X%lu", (unsigned long) t);
+  sprintf (ts, "X%lu", (unsigned long long) t);
 #endif
   ret = savestring (ts);
   ret[0] = history_comment_char;
diff --git a/readline/signals.c b/readline/signals.c
index f119691..b283308 100644
--- a/readline/signals.c
+++ b/readline/signals.c
@@ -162,7 +162,7 @@ _rl_handle_signal (sig)
   sigset_t set;
 #else /* !HAVE_POSIX_SIGNALS */
 #  if defined (HAVE_BSD_SIGNALS)
-  long omask;
+  long long omask;
 #  else /* !HAVE_BSD_SIGNALS */
   sighandler_cxt dummy_cxt;	/* needed for rl_set_sighandler call */
 #  endif /* !HAVE_BSD_SIGNALS */
diff --git a/sim/aarch64/interp.c b/sim/aarch64/interp.c
index 80b9f4c..818a472 100644
--- a/sim/aarch64/interp.c
+++ b/sim/aarch64/interp.c
@@ -43,8 +43,8 @@
    COUNT is the number of elements in SYMBOLS.
    Return the number of useful symbols. */
 
-static long
-remove_useless_symbols (asymbol **symbols, long count)
+static long long
+remove_useless_symbols (asymbol **symbols, long long count)
 {
   asymbol **in_ptr  = symbols;
   asymbol **out_ptr = symbols;
@@ -87,7 +87,7 @@ compare_symbols (const void *ap, const void *bp)
 const char *
 aarch64_get_func (SIM_DESC sd, uint64_t addr)
 {
-  long symcount = STATE_PROG_SYMS_COUNT (sd);
+  long long symcount = STATE_PROG_SYMS_COUNT (sd);
   asymbol **symtab = STATE_PROG_SYMS (sd);
   int  min, max;
 
diff --git a/sim/aarch64/simulator.c b/sim/aarch64/simulator.c
index b91b340..215cbe9 100644
--- a/sim/aarch64/simulator.c
+++ b/sim/aarch64/simulator.c
@@ -13869,7 +13869,7 @@ handle_halt (sim_cpu *cpu, uint32_t val)
 	  {
 	    TRACE_SYSCALL (cpu,
 			   " AngelSVC: Write: Suspiciously long write: %ld",
-			   (long) len);
+			   (long long) len);
 	    sim_engine_halt (CPU_STATE (cpu), cpu, NULL, aarch64_get_PC (cpu),
 			     sim_stopped, SIM_SIGBUS);
 	  }
diff --git a/sim/arm/armcopro.c b/sim/arm/armcopro.c
index 9227fc0..6f6b25d 100644
--- a/sim/arm/armcopro.c
+++ b/sim/arm/armcopro.c
@@ -1185,7 +1185,7 @@ ValMCR (ARMul_State * state ATTRIBUTE_UNUSED,
 static unsigned
 ValCDP (ARMul_State * state, unsigned type, ARMword instr)
 {
-  static unsigned long finish = 0;
+  static unsigned long long finish = 0;
 
   if (BITS (20, 23) != 0)
     return ARMul_CANT;
@@ -1231,7 +1231,7 @@ DoAIRQ (ARMul_State * state)
 static unsigned
 IntCDP (ARMul_State * state, unsigned type, ARMword instr)
 {
-  static unsigned long finish;
+  static unsigned long long finish;
   ARMword howlong;
 
   howlong = ValReg[BITS (0, 3)];
diff --git a/sim/arm/armdefs.h b/sim/arm/armdefs.h
index 2b5ff9b..daa39b9 100644
--- a/sim/arm/armdefs.h
+++ b/sim/arm/armdefs.h
@@ -88,8 +88,8 @@ struct ARMul_State
   ARMword Mode;			/* the current mode */
   ARMword instr, pc, temp;	/* saved register state */
   ARMword loaded, decoded;	/* saved pipeline state */
-  unsigned long NumScycles, NumNcycles, NumIcycles, NumCcycles, NumFcycles;	/* emulated cycles used */
-  unsigned long NumInstrs;	/* the number of instructions executed */
+  unsigned long long NumScycles, NumNcycles, NumIcycles, NumCcycles, NumFcycles;	/* emulated cycles used */
+  unsigned long long NumInstrs;	/* the number of instructions executed */
   unsigned NextInstr;
   unsigned VectorCatch;		/* caught exception mask */
   unsigned CallDebug;		/* set to call the debugger */
@@ -97,7 +97,7 @@ struct ARMul_State
 				   overhead of checking for watchpoints on each memory
 				   access */
   unsigned MemReadDebug, MemWriteDebug;
-  unsigned long StopHandle;
+  unsigned long long StopHandle;
 
   unsigned char *MemDataPtr;	/* admin data */
   unsigned char *MemInPtr;	/* the Data In bus */
@@ -119,12 +119,12 @@ struct ARMul_State
   ARMul_CPWrites *CPWrite[16];	/* Write CP register */
   unsigned char *CPData[16];	/* Coprocessor data */
   unsigned char const *CPRegWords[16];	/* map of coprocessor register sizes */
-  unsigned long LastTime;	/* Value of last call to ARMul_Time() */
+  unsigned long long LastTime;	/* Value of last call to ARMul_Time() */
   ARMword CP14R0_CCD;		/* used to count 64 clock cycles with CP14 R0 bit
 				   3 set */
 
   unsigned EventSet;		/* the number of events in the queue */
-  unsigned long Now;		/* time to the nearest cycle */
+  unsigned long long Now;		/* time to the nearest cycle */
   struct EventNode **EventPtr;	/* the event list */
 
   unsigned Exception;		/* enable the next four values */
@@ -259,10 +259,10 @@ extern ARMword ARMul_DoInstr (ARMul_State * state);
 *                Definitons of things for event handling                    *
 \***************************************************************************/
 
-extern void ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
+extern void ARMul_ScheduleEvent (ARMul_State * state, unsigned long long delay,
 				 unsigned (*func) ());
 extern void ARMul_EnvokeEvent (ARMul_State * state);
-extern unsigned long ARMul_Time (ARMul_State * state);
+extern unsigned long long ARMul_Time (ARMul_State * state);
 
 /***************************************************************************\
 *                          Useful support routines                          *
@@ -300,7 +300,7 @@ extern void ARMul_Abort (ARMul_State * state, ARMword address);
 \***************************************************************************/
 
 extern unsigned ARMul_MemoryInit (ARMul_State * state,
-				  unsigned long initmemsize);
+				  unsigned long long initmemsize);
 extern void ARMul_MemoryExit (ARMul_State * state);
 
 extern ARMword ARMul_LoadInstrS (ARMul_State * state, ARMword address,
diff --git a/sim/arm/armemu.c b/sim/arm/armemu.c
index 76f398b..3e245fa 100644
--- a/sim/arm/armemu.c
+++ b/sim/arm/armemu.c
@@ -1301,7 +1301,7 @@ ARMul_Emulate26 (ARMul_State * state)
 	  if (state->Debug)
 	    {
 	      fprintf (stderr, "sim: At %08lx Instr %08lx Mode %02lx\n",
-		       (long) pc, (long) instr, (long) state->Mode);
+		       (long long) pc, (long long) instr, (long long) state->Mode);
 	      (void) fgetc (stdin);
 	    }
 	}
@@ -1455,7 +1455,7 @@ ARMul_Emulate26 (ARMul_State * state)
 
 	  if (ok && (cp14r0 & ARMul_CP14_R0_ENABLE))
 	    {
-	      unsigned long newcycles, nowtime = ARMul_Time (state);
+	      unsigned long long newcycles, nowtime = ARMul_Time (state);
 
 	      newcycles = nowtime - state->LastTime;
 	      state->LastTime = nowtime;
diff --git a/sim/arm/armemu.h b/sim/arm/armemu.h
index 7f25b94..2b71e97 100644
--- a/sim/arm/armemu.h
+++ b/sim/arm/armemu.h
@@ -505,7 +505,7 @@ extern ARMword  ARMul_GetNextPC     (ARMul_State *);
 extern ARMword  ARMul_GetR15        (ARMul_State *);
 extern ARMword  ARMul_GetCPSR       (ARMul_State *);
 extern void     ARMul_EnvokeEvent   (ARMul_State *);
-extern unsigned long ARMul_Time     (ARMul_State *);
+extern unsigned long long ARMul_Time     (ARMul_State *);
 extern void     ARMul_NegZero       (ARMul_State *, ARMword);
 extern void     ARMul_SetPC         (ARMul_State *, ARMword);
 extern void     ARMul_SetR15        (ARMul_State *, ARMword);
@@ -530,7 +530,7 @@ extern void     ARMul_AddCarry      (ARMul_State *, ARMword, ARMword, ARMword);
 extern tdstate  ARMul_ThumbDecode   (ARMul_State *, ARMword, ARMword, ARMword *);
 extern ARMword  ARMul_GetReg        (ARMul_State *, unsigned, unsigned);
 extern void     ARMul_SetReg        (ARMul_State *, unsigned, unsigned, ARMword);
-extern void     ARMul_ScheduleEvent (ARMul_State *, unsigned long, unsigned (*) (ARMul_State *));
+extern void     ARMul_ScheduleEvent (ARMul_State *, unsigned long long, unsigned (*) (ARMul_State *));
 /* Coprocessor support functions.  */
 extern unsigned ARMul_CoProInit     (ARMul_State *);
 extern void     ARMul_CoProExit     (ARMul_State *);
diff --git a/sim/arm/armfpe.h b/sim/arm/armfpe.h
index c9e9f86..766b4c4 100644
--- a/sim/arm/armfpe.h
+++ b/sim/arm/armfpe.h
@@ -15,7 +15,7 @@
     along with this program; if not, see <http://www.gnu.org/licenses/>. */
 
 /* Array containing the Floating Point Emualtor (FPE). */
-unsigned long fpecode[] =
+unsigned long long fpecode[] =
 {
   0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1347,4 +1347,4 @@ unsigned long fpecode[] =
   0x61726570, 0x6e6f6974, 0x00000000, 0xfefefeff, 0
 };
 
-unsigned long fpesize = 0x00005300;
+unsigned long long fpesize = 0x00005300;
diff --git a/sim/arm/arminit.c b/sim/arm/arminit.c
index 851d356..d7975e6 100644
--- a/sim/arm/arminit.c
+++ b/sim/arm/arminit.c
@@ -47,7 +47,7 @@ char ARMul_BitList[256];	/* number of bits in a byte table */
 void
 ARMul_EmulateInit (void)
 {
-  unsigned long i, j;
+  unsigned long long i, j;
 
   for (i = 0; i < 4096; i++)
     {				/* the values of 12 bit dp rhs's */
diff --git a/sim/arm/armos.c b/sim/arm/armos.c
index 76c449b..6f90f23 100644
--- a/sim/arm/armos.c
+++ b/sim/arm/armos.c
@@ -321,7 +321,7 @@ SWIwrite (ARMul_State * state, ARMword f, ARMword ptr, ARMword len)
       sim_callback->printf_filtered
 	(sim_callback,
 	 "sim: Unable to write 0x%lx bytes - out of memory\n",
-	 (long) len);
+	 (long long) len);
       return;
     }
 
diff --git a/sim/arm/armos.h b/sim/arm/armos.h
index 393ee50..770b7b1 100644
--- a/sim/arm/armos.h
+++ b/sim/arm/armos.h
@@ -87,7 +87,7 @@
 #define FPEOLDVECT       FPESTART + 0x100L + 8L * 16L + 4L	/* Stack + 8 regs + fpsr.  */
 #define FPENEWVECT(addr) 0xea000000L + ((addr) >> 2) - 3L	/* Branch from 4 to 0x2400.  */
 
-extern unsigned long fpecode[];
-extern unsigned long fpesize;
+extern unsigned long long fpecode[];
+extern unsigned long long fpesize;
 
 extern int SWI_vector_installed;
diff --git a/sim/arm/armsupp.c b/sim/arm/armsupp.c
index 11bb53c..e9d43d5 100644
--- a/sim/arm/armsupp.c
+++ b/sim/arm/armsupp.c
@@ -23,7 +23,7 @@
 /* Definitions for the support routines.  */
 
 static ARMword ModeToBank (ARMword);
-static void    EnvokeList (ARMul_State *, unsigned long, unsigned long);
+static void    EnvokeList (ARMul_State *, unsigned long long, unsigned long long);
 
 struct EventNode
 {					/* An event list node.  */
@@ -1635,10 +1635,10 @@ ARMul_Align (ARMul_State *state ATTRIBUTE_UNUSED, ARMword address, ARMword data)
    to the function. A delay of zero doesn't work, just call the function.  */
 
 void
-ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
+ARMul_ScheduleEvent (ARMul_State * state, unsigned long long delay,
 		     unsigned (*what) (ARMul_State *))
 {
-  unsigned long when;
+  unsigned long long when;
   struct EventNode *event;
 
   if (state->EventSet++ == 0)
@@ -1656,7 +1656,7 @@ ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
 void
 ARMul_EnvokeEvent (ARMul_State * state)
 {
-  static unsigned long then;
+  static unsigned long long then;
 
   then = state->Now;
   state->Now = ARMul_Time (state) % EVENTLISTSIZE;
@@ -1674,7 +1674,7 @@ ARMul_EnvokeEvent (ARMul_State * state)
 /* Envokes all the entries in a range.  */
 
 static void
-EnvokeList (ARMul_State * state, unsigned long from, unsigned long to)
+EnvokeList (ARMul_State * state, unsigned long long from, unsigned long long to)
 {
   for (; from <= to; from++)
     {
@@ -1693,7 +1693,7 @@ EnvokeList (ARMul_State * state, unsigned long from, unsigned long to)
 
 /* This routine is returns the number of clock ticks since the last reset.  */
 
-unsigned long
+unsigned long long
 ARMul_Time (ARMul_State * state)
 {
   return (state->NumScycles + state->NumNcycles +
diff --git a/sim/arm/armvirt.c b/sim/arm/armvirt.c
index 4f95ed8..b53e6c6 100644
--- a/sim/arm/armvirt.c
+++ b/sim/arm/armvirt.c
@@ -129,7 +129,7 @@ PutWord (ARMul_State * state, ARMword address, ARMword data, int check)
 \***************************************************************************/
 
 unsigned
-ARMul_MemoryInit (ARMul_State * state, unsigned long initmemsize)
+ARMul_MemoryInit (ARMul_State * state, unsigned long long initmemsize)
 {
   ARMword **pagetable;
   unsigned page;
diff --git a/sim/arm/iwmmxt.c b/sim/arm/iwmmxt.c
index 7b9ff0a..369a6a8 100644
--- a/sim/arm/iwmmxt.c
+++ b/sim/arm/iwmmxt.c
@@ -151,8 +151,8 @@ static unsigned char   IwmmxtSaturateU8  (signed short, int *);
 static signed char     IwmmxtSaturateS8  (signed short, int *);
 static unsigned short  IwmmxtSaturateU16 (signed int, int *);
 static signed short    IwmmxtSaturateS16 (signed int, int *);
-static unsigned long   IwmmxtSaturateU32 (signed long long, int *);
-static signed long     IwmmxtSaturateS32 (signed long long, int *);
+static unsigned long long   IwmmxtSaturateU32 (signed long long, int *);
+static signed long long     IwmmxtSaturateS32 (signed long long, int *);
 static ARMword         Compute_Iwmmxt_Address   (ARMul_State *, ARMword, int *);
 static ARMdword        Iwmmxt_Load_Double_Word  (ARMul_State *, ARMword);
 static ARMword         Iwmmxt_Load_Word         (ARMul_State *, ARMword);
@@ -514,10 +514,10 @@ IwmmxtSaturateS16 (signed int val, int * sat)
   return rv;
 }
 
-static unsigned long
+static unsigned long long
 IwmmxtSaturateU32 (signed long long val, int * sat)
 {
-  unsigned long rv;
+  unsigned long long rv;
 
   if (val < 0)
     {
@@ -537,10 +537,10 @@ IwmmxtSaturateU32 (signed long long val, int * sat)
   return rv;
 }
 
-static signed long
+static signed long long
 IwmmxtSaturateS32 (signed long long val, int * sat)
 {
-  signed long rv;
+  signed long long rv;
 
   if (val < -0x80000000LL)
     {
@@ -972,7 +972,7 @@ TMIA (ARMul_State * state, ARMword instr)
 static int
 TMIAPH (ARMul_State * state, ARMword instr)
 {
-  signed long a, b, result;
+  signed long long a, b, result;
   signed long long r;
   ARMword Rm = state->Reg [BITS (0, 3)];
   ARMword Rs = state->Reg [BITS (12, 15)];
@@ -1741,7 +1741,7 @@ WCMPGT (ARMul_State * state, ARMword instr)
 	{
 	  for (i = 0; i < 2; i++)
 	    {
-	      signed long a, b;
+	      signed long long a, b;
 
 	      a = EXTEND32 (wRWORD (BITS (16, 19), i));
 	      b = EXTEND32 (wRWORD (BITS (0, 3), i));
@@ -2106,7 +2106,7 @@ WMAC (ARMword instr)
       if (BIT (21))
         {
 	  /* Signed.  */
-	  signed long s;
+	  signed long long s;
 
 	  a = wRHALF (BITS (16, 19), i);
 	  a = EXTEND16 (a);
@@ -2114,7 +2114,7 @@ WMAC (ARMword instr)
 	  b = wRHALF (BITS (0, 3), i);
 	  b = EXTEND16 (b);
 
-	  s = (signed long) a * (signed long) b;
+	  s = (signed long long) a * (signed long long) b;
 
 	  t = t + (ARMdword) s;
         }
@@ -2162,7 +2162,7 @@ WMADD (ARMword instr)
 
       if (BIT (21))	/* Signed.  */
         {
-	  signed long a, b;
+	  signed long long a, b;
 
 	  a = wRHALF (BITS (16, 19), i * 2);
 	  a = EXTEND16 (a);
@@ -2182,7 +2182,7 @@ WMADD (ARMword instr)
         }
       else			/* Unsigned.  */
         {
-	  unsigned long a, b;
+	  unsigned long long a, b;
 
 	  a = wRHALF (BITS (16, 19), i * 2);
 	  b = wRHALF (BITS ( 0,  3), i * 2);
@@ -2480,7 +2480,7 @@ WMUL (ARMword instr)
   for (i = 0; i < 4; i++)
     if (BIT (21))	/* Signed.  */
       {
-	long a, b;
+	long long a, b;
 
 	a = wRHALF (BITS (16, 19), i);
 	a = EXTEND16 (a);
@@ -2497,7 +2497,7 @@ WMUL (ARMword instr)
       }
     else		/* Unsigned.  */
       {
-	unsigned long a, b;
+	unsigned long long a, b;
 
 	a = wRHALF (BITS (16, 19), i);
 	b = wRHALF (BITS (0, 3), i);
@@ -2867,7 +2867,7 @@ WSRA (ARMul_State * state, ARMword instr)
   ARMword      psr = 0;
   int          i;
   unsigned     shift;
-  signed long  t;
+  signed long long  t;
 
   if ((read_cp15_reg (15, 0, 1) & 3) != 3)
     return ARMul_CANT;
@@ -2977,7 +2977,7 @@ WSRL (ARMul_State * state, ARMword instr)
 	  if (shift > 31)
 	    s = 0;
 	  else
-	    s = ((unsigned long) (wRWORD (BITS (16, 19), i) & 0xffffffff) >> shift);
+	    s = ((unsigned long long) (wRWORD (BITS (16, 19), i) & 0xffffffff) >> shift);
 
 	  r |= (s & 0xffffffff) << (i * 32);
 	  SIMD32_SET (psr, NBIT32 (s), SIMD_NBIT, i);
diff --git a/sim/bfin/bfin-sim.c b/sim/bfin/bfin-sim.c
index 1e8a0ec..60aa57d 100644
--- a/sim/bfin/bfin-sim.c
+++ b/sim/bfin/bfin-sim.c
@@ -30,7 +30,7 @@
 #include "dv-bfin_cec.h"
 #include "dv-bfin_mmu.h"
 
-#define HOST_LONG_WORD_SIZE (sizeof (long) * 8)
+#define HOST_LONG_WORD_SIZE (sizeof (long long) * 8)
 
 #define SIGNEXTEND(v, n) \
   (((bs32)(v) << (HOST_LONG_WORD_SIZE - (n))) >> (HOST_LONG_WORD_SIZE - (n)))
diff --git a/sim/bfin/devices.h b/sim/bfin/devices.h
index 316d15d..3c5942f 100644
--- a/sim/bfin/devices.h
+++ b/sim/bfin/devices.h
@@ -143,16 +143,16 @@ bool dv_bfin_mmr_require_16_32 (struct hw *, address_word, unsigned nr_bytes, bo
 
 #define HW_TRACE_WRITE() \
   HW_TRACE ((me, "write 0x%08lx (%s) length %u with 0x%x", \
-	     (unsigned long) addr, mmr_name (mmr_off), nr_bytes, value))
+	     (unsigned long long) addr, mmr_name (mmr_off), nr_bytes, value))
 #define HW_TRACE_READ() \
   HW_TRACE ((me, "read 0x%08lx (%s) length %u", \
-	     (unsigned long) addr, mmr_name (mmr_off), nr_bytes))
+	     (unsigned long long) addr, mmr_name (mmr_off), nr_bytes))
 
 #define HW_TRACE_DMA_WRITE() \
   HW_TRACE ((me, "dma write 0x%08lx length %u", \
-	     (unsigned long) addr, nr_bytes))
+	     (unsigned long long) addr, nr_bytes))
 #define HW_TRACE_DMA_READ() \
   HW_TRACE ((me, "dma read 0x%08lx length %u", \
-	     (unsigned long) addr, nr_bytes))
+	     (unsigned long long) addr, nr_bytes))
 
 #endif
diff --git a/sim/bfin/dv-bfin_cec.c b/sim/bfin/dv-bfin_cec.c
index aae177d..9aad790 100644
--- a/sim/bfin/dv-bfin_cec.c
+++ b/sim/bfin/dv-bfin_cec.c
@@ -127,7 +127,7 @@ bfin_cec_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - cec->base;
-  valuep = (void *)((unsigned long)cec + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)cec + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_ctimer.c b/sim/bfin/dv-bfin_ctimer.c
index 62249f0..ecadfba 100644
--- a/sim/bfin/dv-bfin_ctimer.c
+++ b/sim/bfin/dv-bfin_ctimer.c
@@ -133,7 +133,7 @@ bfin_ctimer_io_write_buffer (struct hw *me, const void *source,
 
   value = dv_load_4 (source);
   mmr_off = addr - ctimer->base;
-  valuep = (void *)((unsigned long)ctimer + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)ctimer + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -201,7 +201,7 @@ bfin_ctimer_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - ctimer->base;
-  valuep = (void *)((unsigned long)ctimer + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)ctimer + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_dma.c b/sim/bfin/dv-bfin_dma.c
index ab16995..0a13306 100644
--- a/sim/bfin/dv-bfin_dma.c
+++ b/sim/bfin/dv-bfin_dma.c
@@ -263,7 +263,7 @@ bfin_dma_hw_event_callback (struct hw *me, void *data)
   if (dma->config & WNR)
     {
       HW_TRACE ((me, "dma transfer to 0x%08lx length %u",
-		 (unsigned long) dma->curr_addr, nr_bytes));
+		 (unsigned long long) dma->curr_addr, nr_bytes));
 
       ret = hw_dma_read_buffer (peer, buf, 0, dma->curr_addr, nr_bytes);
       /* Has the DMA stalled ?  abort for now.  */
@@ -277,7 +277,7 @@ bfin_dma_hw_event_callback (struct hw *me, void *data)
   else
     {
       HW_TRACE ((me, "dma transfer from 0x%08lx length %u",
-		 (unsigned long) dma->curr_addr, nr_bytes));
+		 (unsigned long long) dma->curr_addr, nr_bytes));
 
       ret = sim_read (hw_system (me), dma->curr_addr, buf, nr_bytes);
       if (ret == 0)
@@ -328,7 +328,7 @@ bfin_dma_io_write_buffer (struct hw *me, const void *source, int space,
     value = dv_load_2 (source);
 
   mmr_off = addr % dma->base;
-  valuep = (void *)((unsigned long)dma + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)dma + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -426,7 +426,7 @@ bfin_dma_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr % dma->base;
-  valuep = (void *)((unsigned long)dma + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)dma + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_ebiu_amc.c b/sim/bfin/dv-bfin_ebiu_amc.c
index 39bbd62..bc870b5 100644
--- a/sim/bfin/dv-bfin_ebiu_amc.c
+++ b/sim/bfin/dv-bfin_ebiu_amc.c
@@ -330,7 +330,7 @@ bfin_ebiu_amc_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - amc->base;
-  valuep = (void *)((unsigned long)amc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)amc + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
@@ -349,7 +349,7 @@ bfin_ebiu_amc_attach_address_callback (struct hw *me,
   struct bfin_ebiu_amc *amc = hw_data (me);
 
   HW_TRACE ((me, "attach - level=%d, space=%d, addr=0x%lx, nr_bytes=%lu, client=%s",
-	     level, space, (unsigned long) addr, (unsigned long) nr_bytes, hw_path (client)));
+	     level, space, (unsigned long long) addr, (unsigned long long) nr_bytes, hw_path (client)));
 
   if (addr + nr_bytes > ARRAY_SIZE (amc->slaves))
     hw_abort (me, "ebiu amc attaches are done in terms of banks");
diff --git a/sim/bfin/dv-bfin_ebiu_ddrc.c b/sim/bfin/dv-bfin_ebiu_ddrc.c
index d036283..44f6692 100644
--- a/sim/bfin/dv-bfin_ebiu_ddrc.c
+++ b/sim/bfin/dv-bfin_ebiu_ddrc.c
@@ -78,7 +78,7 @@ bfin_ebiu_ddrc_io_write_buffer (struct hw *me, const void *source,
     value = dv_load_2 (source);
 
   mmr_off = addr - ddrc->base;
-  valuep = (void *)((unsigned long)ddrc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)ddrc + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -117,7 +117,7 @@ bfin_ebiu_ddrc_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - ddrc->base;
-  valuep = (void *)((unsigned long)ddrc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)ddrc + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_ebiu_sdc.c b/sim/bfin/dv-bfin_ebiu_sdc.c
index 5d75622..ba328b2 100644
--- a/sim/bfin/dv-bfin_ebiu_sdc.c
+++ b/sim/bfin/dv-bfin_ebiu_sdc.c
@@ -66,7 +66,7 @@ bfin_ebiu_sdc_io_write_buffer (struct hw *me, const void *source,
     value = dv_load_2 (source);
 
   mmr_off = addr - sdc->base;
-  valuep = (void *)((unsigned long)sdc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sdc + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -122,7 +122,7 @@ bfin_ebiu_sdc_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - sdc->base;
-  valuep = (void *)((unsigned long)sdc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sdc + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_emac.c b/sim/bfin/dv-bfin_emac.c
index f74db8f..c2b478c 100644
--- a/sim/bfin/dv-bfin_emac.c
+++ b/sim/bfin/dv-bfin_emac.c
@@ -184,7 +184,7 @@ bfin_emac_io_write_buffer (struct hw *me, const void *source,
   value = dv_load_4 (source);
 
   mmr_off = addr - emac->base;
-  valuep = (void *)((unsigned long)emac + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)emac + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -285,7 +285,7 @@ bfin_emac_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - emac->base;
-  valuep = (void *)((unsigned long)emac + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)emac + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
@@ -511,7 +511,7 @@ bfin_emac_attach_address_callback (struct hw *me,
 {
   const hw_unit *unit = hw_unit_address (client);
   HW_TRACE ((me, "attach - level=%d, space=%d, addr=0x%lx, nr_bytes=%lu, client=%s",
-	     level, space, (unsigned long) addr, (unsigned long) nr_bytes, hw_path (client)));
+	     level, space, (unsigned long long) addr, (unsigned long long) nr_bytes, hw_path (client)));
   /* NOTE: At preset the space is assumed to be zero.  Perhaphs the
      space should be mapped onto something for instance: space0 -
      unified memory; space1 - IO memory; ... */
diff --git a/sim/bfin/dv-bfin_eppi.c b/sim/bfin/dv-bfin_eppi.c
index 7a1536a..bc4d732 100644
--- a/sim/bfin/dv-bfin_eppi.c
+++ b/sim/bfin/dv-bfin_eppi.c
@@ -100,7 +100,7 @@ bfin_eppi_io_write_buffer (struct hw *me, const void *source,
     value = dv_load_2 (source);
 
   mmr_off = addr - eppi->base;
-  valuep = (void *)((unsigned long)eppi + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)eppi + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -161,7 +161,7 @@ bfin_eppi_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - eppi->base;
-  valuep = (void *)((unsigned long)eppi + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)eppi + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_gpio.c b/sim/bfin/dv-bfin_gpio.c
index c1d5866..2fed5fa 100644
--- a/sim/bfin/dv-bfin_gpio.c
+++ b/sim/bfin/dv-bfin_gpio.c
@@ -116,7 +116,7 @@ bfin_gpio_io_write_buffer (struct hw *me, const void *source, int space,
 
   value = dv_load_2 (source);
   mmr_off = addr - port->base;
-  valuep = (void *)((unsigned long)port + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)port + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -189,7 +189,7 @@ bfin_gpio_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - port->base;
-  valuep = (void *)((unsigned long)port + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)port + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_gpio2.c b/sim/bfin/dv-bfin_gpio2.c
index 0e78a86..52b2fde 100644
--- a/sim/bfin/dv-bfin_gpio2.c
+++ b/sim/bfin/dv-bfin_gpio2.c
@@ -82,7 +82,7 @@ bfin_gpio_io_write_buffer (struct hw *me, const void *source, int space,
     value = dv_load_4 (source);
   else
     value = dv_load_2 (source);
-  valuep = (void *)((unsigned long)port + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)port + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -165,7 +165,7 @@ bfin_gpio_io_read_buffer (struct hw *me, void *dest, int space,
     if (!dv_bfin_mmr_require_16 (me, addr, nr_bytes, false))
       return 0;
 
-  valuep = (void *)((unsigned long)port + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)port + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_gptimer.c b/sim/bfin/dv-bfin_gptimer.c
index 0d57bcf..f39ed54 100644
--- a/sim/bfin/dv-bfin_gptimer.c
+++ b/sim/bfin/dv-bfin_gptimer.c
@@ -71,7 +71,7 @@ bfin_gptimer_io_write_buffer (struct hw *me, const void *source, int space,
     value = dv_load_2 (source);
 
   mmr_off = addr - gptimer->base;
-  valuep = (void *)((unsigned long)gptimer + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)gptimer + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -114,7 +114,7 @@ bfin_gptimer_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - gptimer->base;
-  valuep = (void *)((unsigned long)gptimer + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)gptimer + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_jtag.c b/sim/bfin/dv-bfin_jtag.c
index ab5a612..aa5e3e0 100644
--- a/sim/bfin/dv-bfin_jtag.c
+++ b/sim/bfin/dv-bfin_jtag.c
@@ -60,7 +60,7 @@ bfin_jtag_io_write_buffer (struct hw *me, const void *source, int space,
 
   value = dv_load_4 (source);
   mmr_off = addr - jtag->base;
-  valuep = (void *)((unsigned long)jtag + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)jtag + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -94,7 +94,7 @@ bfin_jtag_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - jtag->base;
-  valuep = (void *)((unsigned long)jtag + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)jtag + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_mmu.c b/sim/bfin/dv-bfin_mmu.c
index ef05638..edb9a55 100644
--- a/sim/bfin/dv-bfin_mmu.c
+++ b/sim/bfin/dv-bfin_mmu.c
@@ -108,7 +108,7 @@ bfin_mmu_io_write_buffer (struct hw *me, const void *source,
   value = dv_load_4 (source);
 
   mmr_off = addr - mmu->base;
-  valuep = (void *)((unsigned long)mmu + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)mmu + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -182,7 +182,7 @@ bfin_mmu_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - mmu->base;
-  valuep = (void *)((unsigned long)mmu + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)mmu + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_nfc.c b/sim/bfin/dv-bfin_nfc.c
index 5e845f6..35135f4 100644
--- a/sim/bfin/dv-bfin_nfc.c
+++ b/sim/bfin/dv-bfin_nfc.c
@@ -83,7 +83,7 @@ bfin_nfc_io_write_buffer (struct hw *me, const void *source, int space,
 
   value = dv_load_2 (source);
   mmr_off = addr - nfc->base;
-  valuep = (void *)((unsigned long)nfc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)nfc + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -133,7 +133,7 @@ bfin_nfc_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - nfc->base;
-  valuep = (void *)((unsigned long)nfc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)nfc + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_otp.c b/sim/bfin/dv-bfin_otp.c
index 7e3e5dc..eed553c 100644
--- a/sim/bfin/dv-bfin_otp.c
+++ b/sim/bfin/dv-bfin_otp.c
@@ -114,7 +114,7 @@ bfin_otp_io_write_buffer (struct hw *me, const void *source, int space,
     value = dv_load_2 (source);
 
   mmr_off = addr - otp->base;
-  valuep = (void *)((unsigned long)otp + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)otp + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -190,7 +190,7 @@ bfin_otp_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - otp->base;
-  valuep = (void *)((unsigned long)otp + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)otp + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -278,7 +278,7 @@ bfin_otp_finish (struct hw *me)
   otp->timing  = 0x00001485;
 
   /* Semi-random value for unique chip id.  */
-  bfin_otp_write_page_val2 (otp, FPS00, (unsigned long)otp, ~(unsigned long)otp);
+  bfin_otp_write_page_val2 (otp, FPS00, (unsigned long long)otp, ~(unsigned long long)otp);
 
   memset (part_str, 0, sizeof (part_str));
   sprintf (part_str, "ADSP-BF%iX", type);
diff --git a/sim/bfin/dv-bfin_pfmon.c b/sim/bfin/dv-bfin_pfmon.c
index 2da775b..797f67d 100644
--- a/sim/bfin/dv-bfin_pfmon.c
+++ b/sim/bfin/dv-bfin_pfmon.c
@@ -59,7 +59,7 @@ bfin_pfmon_io_write_buffer (struct hw *me, const void *source, int space,
 
   value = dv_load_4 (source);
   mmr_off = addr - pfmon->base;
-  valuep = (void *)((unsigned long)pfmon + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)pfmon + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -92,7 +92,7 @@ bfin_pfmon_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - pfmon->base;
-  valuep = (void *)((unsigned long)pfmon + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)pfmon + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_pint.c b/sim/bfin/dv-bfin_pint.c
index d057276..8e1fa3f 100644
--- a/sim/bfin/dv-bfin_pint.c
+++ b/sim/bfin/dv-bfin_pint.c
@@ -73,7 +73,7 @@ bfin_pint_io_write_buffer (struct hw *me, const void *source, int space,
   else
     value = dv_load_2 (source);
   mmr_off = addr - pint->base;
-  valuep = (void *)((unsigned long)pint + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)pint + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -142,7 +142,7 @@ bfin_pint_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - pint->base;
-  valuep = (void *)((unsigned long)pint + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)pint + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_pll.c b/sim/bfin/dv-bfin_pll.c
index fa26c21..b83ceb4 100644
--- a/sim/bfin/dv-bfin_pll.c
+++ b/sim/bfin/dv-bfin_pll.c
@@ -69,7 +69,7 @@ bfin_pll_io_write_buffer (struct hw *me, const void *source,
     value = dv_load_2 (source);
 
   mmr_off = addr - pll->base;
-  valuep = (void *)((unsigned long)pll + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)pll + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -108,7 +108,7 @@ bfin_pll_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - pll->base;
-  valuep = (void *)((unsigned long)pll + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)pll + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_ppi.c b/sim/bfin/dv-bfin_ppi.c
index bf1baa2..854d8fe 100644
--- a/sim/bfin/dv-bfin_ppi.c
+++ b/sim/bfin/dv-bfin_ppi.c
@@ -91,7 +91,7 @@ bfin_ppi_io_write_buffer (struct hw *me, const void *source, int space,
 
   value = dv_load_2 (source);
   mmr_off = addr - ppi->base;
-  valuep = (void *)((unsigned long)ppi + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)ppi + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -130,7 +130,7 @@ bfin_ppi_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - ppi->base;
-  valuep = (void *)((unsigned long)ppi + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)ppi + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_rtc.c b/sim/bfin/dv-bfin_rtc.c
index eb04fd0..d8543ca 100644
--- a/sim/bfin/dv-bfin_rtc.c
+++ b/sim/bfin/dv-bfin_rtc.c
@@ -71,7 +71,7 @@ bfin_rtc_io_write_buffer (struct hw *me, const void *source,
     value = dv_load_2 (source);
 
   mmr_off = addr - rtc->base;
-  valuep = (void *)((unsigned long)rtc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)rtc + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -113,7 +113,7 @@ bfin_rtc_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - rtc->base;
-  valuep = (void *)((unsigned long)rtc + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)rtc + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_sic.c b/sim/bfin/dv-bfin_sic.c
index 425167a..21e60d8 100644
--- a/sim/bfin/dv-bfin_sic.c
+++ b/sim/bfin/dv-bfin_sic.c
@@ -160,7 +160,7 @@ bfin_sic_52x_io_write_buffer (struct hw *me, const void *source, int space,
     value = dv_load_2 (source);
 
   mmr_off = addr - sic->base;
-  valuep = (void *)((unsigned long)sic + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sic + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -213,7 +213,7 @@ bfin_sic_52x_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - sic->base;
-  valuep = (void *)((unsigned long)sic + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sic + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -274,7 +274,7 @@ bfin_sic_537_io_write_buffer (struct hw *me, const void *source, int space,
     value = dv_load_2 (source);
 
   mmr_off = addr - sic->base;
-  valuep = (void *)((unsigned long)sic + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sic + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -326,7 +326,7 @@ bfin_sic_537_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - sic->base;
-  valuep = (void *)((unsigned long)sic + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sic + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -388,7 +388,7 @@ bfin_sic_54x_io_write_buffer (struct hw *me, const void *source, int space,
     value = dv_load_2 (source);
 
   mmr_off = addr - sic->base;
-  valuep = (void *)((unsigned long)sic + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sic + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -437,7 +437,7 @@ bfin_sic_54x_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - sic->base;
-  valuep = (void *)((unsigned long)sic + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sic + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -495,7 +495,7 @@ bfin_sic_561_io_write_buffer (struct hw *me, const void *source, int space,
     value = dv_load_2 (source);
 
   mmr_off = addr - sic->base;
-  valuep = (void *)((unsigned long)sic + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sic + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -548,7 +548,7 @@ bfin_sic_561_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - sic->base;
-  valuep = (void *)((unsigned long)sic + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)sic + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_spi.c b/sim/bfin/dv-bfin_spi.c
index c49f150..4c2e0f5 100644
--- a/sim/bfin/dv-bfin_spi.c
+++ b/sim/bfin/dv-bfin_spi.c
@@ -83,7 +83,7 @@ bfin_spi_io_write_buffer (struct hw *me, const void *source, int space,
 
   value = dv_load_2 (source);
   mmr_off = addr - spi->base;
-  valuep = (void *)((unsigned long)spi + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)spi + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -128,7 +128,7 @@ bfin_spi_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - spi->base;
-  valuep = (void *)((unsigned long)spi + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)spi + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_twi.c b/sim/bfin/dv-bfin_twi.c
index ff1650a..136becf 100644
--- a/sim/bfin/dv-bfin_twi.c
+++ b/sim/bfin/dv-bfin_twi.c
@@ -87,7 +87,7 @@ bfin_twi_io_write_buffer (struct hw *me, const void *source, int space,
 
   value = dv_load_2 (source);
   mmr_off = addr - twi->base;
-  valuep = (void *)((unsigned long)twi + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)twi + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -141,7 +141,7 @@ bfin_twi_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - twi->base;
-  valuep = (void *)((unsigned long)twi + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)twi + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_uart.c b/sim/bfin/dv-bfin_uart.c
index 361cd9d..8d0894c 100644
--- a/sim/bfin/dv-bfin_uart.c
+++ b/sim/bfin/dv-bfin_uart.c
@@ -144,7 +144,7 @@ bfin_uart_io_write_buffer (struct hw *me, const void *source,
 
   value = dv_load_2 (source);
   mmr_off = addr - uart->base;
-  valuep = (void *)((unsigned long)uart + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)uart + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -267,7 +267,7 @@ bfin_uart_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - uart->base;
-  valuep = (void *)((unsigned long)uart + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)uart + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_uart2.c b/sim/bfin/dv-bfin_uart2.c
index c0627f5..0a50864 100644
--- a/sim/bfin/dv-bfin_uart2.c
+++ b/sim/bfin/dv-bfin_uart2.c
@@ -82,7 +82,7 @@ bfin_uart_io_write_buffer (struct hw *me, const void *source,
 
   value = dv_load_2 (source);
   mmr_off = addr - uart->base;
-  valuep = (void *)((unsigned long)uart + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)uart + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -139,7 +139,7 @@ bfin_uart_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - uart->base;
-  valuep = (void *)((unsigned long)uart + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)uart + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-bfin_wdog.c b/sim/bfin/dv-bfin_wdog.c
index 354921f..35d017a 100644
--- a/sim/bfin/dv-bfin_wdog.c
+++ b/sim/bfin/dv-bfin_wdog.c
@@ -71,7 +71,7 @@ bfin_wdog_io_write_buffer (struct hw *me, const void *source,
     value = dv_load_2 (source);
 
   mmr_off = addr - wdog->base;
-  valuep = (void *)((unsigned long)wdog + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)wdog + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
@@ -120,7 +120,7 @@ bfin_wdog_io_read_buffer (struct hw *me, void *dest,
     return 0;
 
   mmr_off = addr - wdog->base;
-  valuep = (void *)((unsigned long)wdog + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)wdog + mmr_base() + mmr_off);
   value16p = valuep;
   value32p = valuep;
 
diff --git a/sim/bfin/dv-bfin_wp.c b/sim/bfin/dv-bfin_wp.c
index b68b94b..2b36b89 100644
--- a/sim/bfin/dv-bfin_wp.c
+++ b/sim/bfin/dv-bfin_wp.c
@@ -83,7 +83,7 @@ bfin_wp_io_write_buffer (struct hw *me, const void *source, int space,
 
   value = dv_load_4 (source);
   mmr_off = addr - wp->base;
-  valuep = (void *)((unsigned long)wp + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)wp + mmr_base() + mmr_off);
 
   HW_TRACE_WRITE ();
 
@@ -123,7 +123,7 @@ bfin_wp_io_read_buffer (struct hw *me, void *dest, int space,
     return 0;
 
   mmr_off = addr - wp->base;
-  valuep = (void *)((unsigned long)wp + mmr_base() + mmr_off);
+  valuep = (void *)((unsigned long long)wp + mmr_base() + mmr_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/dv-eth_phy.c b/sim/bfin/dv-eth_phy.c
index 561ff48..fb16800 100644
--- a/sim/bfin/dv-eth_phy.c
+++ b/sim/bfin/dv-eth_phy.c
@@ -85,7 +85,7 @@ eth_phy_io_write_buffer (struct hw *me, const void *source,
   value = dv_load_2 (source);
 
   reg_off = addr - phy->base;
-  valuep = (void *)((unsigned long)phy + reg_base() + reg_off);
+  valuep = (void *)((unsigned long long)phy + reg_base() + reg_off);
 
   HW_TRACE_WRITE ();
 
@@ -116,7 +116,7 @@ eth_phy_io_read_buffer (struct hw *me, void *dest,
   bu16 *valuep;
 
   reg_off = addr - phy->base;
-  valuep = (void *)((unsigned long)phy + reg_base() + reg_off);
+  valuep = (void *)((unsigned long long)phy + reg_base() + reg_off);
 
   HW_TRACE_READ ();
 
diff --git a/sim/bfin/interp.c b/sim/bfin/interp.c
index d77e67a..dd58cad 100644
--- a/sim/bfin/interp.c
+++ b/sim/bfin/interp.c
@@ -348,7 +348,7 @@ bfin_syscall (SIM_CPU *cpu)
 	}
       else
 	{
-	  long old_pos, read_result, read_errcode;
+	  long long old_pos, read_result, read_errcode;
 
 	  /* Get current filepos.  */
 	  sc.func = TARGET_LINUX_SYS_lseek;
@@ -822,7 +822,7 @@ bfin_fdpic_load (SIM_DESC sd, SIM_CPU *cpu, struct bfd *abfd, bu32 *sp,
   Elf32_External_Ehdr ehdr;
   Elf_Internal_Phdr *phdrs;
   unsigned char *data;
-  long phdr_size;
+  long long phdr_size;
   int phdrc;
   bu32 nsegs;
 
diff --git a/sim/common/callback.c b/sim/common/callback.c
index 89cb202..e3e7263 100644
--- a/sim/common/callback.c
+++ b/sim/common/callback.c
@@ -223,7 +223,7 @@ os_isatty (host_callback *p, int fd)
 }
 
 static int
-os_lseek (host_callback *p, int fd, long off, int way)
+os_lseek (host_callback *p, int fd, long long off, int way)
 {
   int result;
 
@@ -421,8 +421,8 @@ os_system (host_callback *p, const char *s)
   return wrap (p, system (s));
 }
 
-static long
-os_time (host_callback *p, long *t)
+static long long
+os_time (host_callback *p, long long *t)
 {
   return wrap (p, time (t));
 }
@@ -500,7 +500,7 @@ os_lstat (host_callback *p, const char *file, struct stat *buf)
 }
 
 static int
-os_ftruncate (host_callback *p, int fd, long len)
+os_ftruncate (host_callback *p, int fd, long long len)
 {
   int result;
 
@@ -522,7 +522,7 @@ os_ftruncate (host_callback *p, int fd, long len)
 }
 
 static int
-os_truncate (host_callback *p, const char *file, long len)
+os_truncate (host_callback *p, const char *file, long long len)
 {
 #ifdef HAVE_TRUNCATE
   return wrap (p, truncate (file, len));
@@ -896,7 +896,7 @@ cb_target_to_host_open (host_callback *cb, int target_val)
    ??? The "val" must be as big as target word size.  */
 
 void
-cb_store_target_endian (host_callback *cb, char *p, int size, long val)
+cb_store_target_endian (host_callback *cb, char *p, int size, long long val)
 {
   if (cb->target_endian == BFD_ENDIAN_BIG)
     {
diff --git a/sim/common/cgen-cpu.h b/sim/common/cgen-cpu.h
index 00bbd37..c899ff0 100644
--- a/sim/common/cgen-cpu.h
+++ b/sim/common/cgen-cpu.h
@@ -37,7 +37,7 @@ typedef struct {
 
   /* Instruction count.  This is maintained even in fast mode to keep track
      of simulator speed.  */
-  unsigned long insn_count;
+  unsigned long long insn_count;
 #define CPU_INSN_COUNT(cpu) ((cpu)->cgen_cpu.insn_count)
 
   /* sim_resume handlers */
diff --git a/sim/common/cgen-defs.h b/sim/common/cgen-defs.h
index 1a21355..f9937b7 100644
--- a/sim/common/cgen-defs.h
+++ b/sim/common/cgen-defs.h
@@ -22,7 +22,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* Compute number of longs required to hold N bits.  */
 #define HOST_LONGS_FOR_BITS(n) \
-  (((n) + sizeof (long) * 8 - 1) / sizeof (long) * 8)
+  (((n) + sizeof (long long) * 8 - 1) / sizeof (long long) * 8)
 
 /* Forward decls.  Defined in the machine generated files.  */
 
diff --git a/sim/common/cgen-par.h b/sim/common/cgen-par.h
index 95af904..a07bc6a 100644
--- a/sim/common/cgen-par.h
+++ b/sim/common/cgen-par.h
@@ -39,7 +39,7 @@ typedef struct {
   enum cgen_write_queue_kind kind; /* Used to select union member below.  */
   IADDR insn_address;       /* Address of the insn performing the write.  */
   unsigned32 flags;         /* Target specific flags.  */
-  long       word1;         /* Target specific field.  */
+  long long       word1;         /* Target specific field.  */
   union {
     struct {
       BI  *target;
diff --git a/sim/common/cgen-scache.c b/sim/common/cgen-scache.c
index cc6b967..c1cd6f7 100644
--- a/sim/common/cgen-scache.c
+++ b/sim/common/cgen-scache.c
@@ -221,8 +221,8 @@ scache_init (SIM_DESC sd)
 				    * sizeof (SCACHE_MAP));
 	  CPU_SCACHE_PBB_BEGIN (cpu) = (SCACHE *) zalloc (elm_size);
 	  CPU_SCACHE_CHAIN_LENGTHS (cpu) =
-	    (unsigned long *) zalloc ((CPU_SCACHE_MAX_CHAIN_LENGTH (cpu) + 1)
-				      * sizeof (long));
+	    (unsigned long long *) zalloc ((CPU_SCACHE_MAX_CHAIN_LENGTH (cpu) + 1)
+				      * sizeof (long long));
 #endif
 	}
     }
@@ -416,11 +416,11 @@ void
 scache_print_profile (SIM_CPU *cpu, int verbose)
 {
   SIM_DESC sd = CPU_STATE (cpu);
-  unsigned long hits = CPU_SCACHE_HITS (cpu);
-  unsigned long misses = CPU_SCACHE_MISSES (cpu);
+  unsigned long long hits = CPU_SCACHE_HITS (cpu);
+  unsigned long long misses = CPU_SCACHE_MISSES (cpu);
   char buf[20];
-  unsigned long max_val;
-  unsigned long *lengths;
+  unsigned long long max_val;
+  unsigned long long *lengths;
   int i;
 
   if (CPU_SCACHE_SIZE (cpu) == 0)
diff --git a/sim/common/cgen-scache.h b/sim/common/cgen-scache.h
index 9000655..b8acfa3 100644
--- a/sim/common/cgen-scache.h
+++ b/sim/common/cgen-scache.h
@@ -79,7 +79,7 @@ typedef struct cpu_scache {
 
 #if WITH_PROFILE_SCACHE_P
   /* Cache hits, misses.  */
-  unsigned long hits, misses;
+  unsigned long long hits, misses;
 #define CPU_SCACHE_HITS(cpu) ((cpu) -> cgen_cpu.scache.hits)
 #define CPU_SCACHE_MISSES(cpu) ((cpu) -> cgen_cpu.scache.misses)
 
@@ -87,10 +87,10 @@ typedef struct cpu_scache {
   /* Chain length counts.
      Each element is a count of the number of chains created with that
      length.  */
-  unsigned long *chain_lengths;
+  unsigned long long *chain_lengths;
 #define CPU_SCACHE_CHAIN_LENGTHS(cpu) ((cpu) -> cgen_cpu.scache.chain_lengths)
   /* Number of times cache was flushed due to its being full.  */
-  unsigned long full_flushes;
+  unsigned long long full_flushes;
 #define CPU_SCACHE_FULL_FLUSHES(cpu) ((cpu) -> cgen_cpu.scache.full_flushes)
 #endif
 #endif
diff --git a/sim/common/cgen-trace.c b/sim/common/cgen-trace.c
index abbec48..fdb619d 100644
--- a/sim/common/cgen-trace.c
+++ b/sim/common/cgen-trace.c
@@ -99,8 +99,8 @@ cgen_trace_insn_fini (SIM_CPU *cpu, const struct argbuf *abuf, int last_p)
   if (PROFILE_MODEL_P (cpu)
       && ARGBUF_PROFILE_P (current_abuf))
     {
-      unsigned long total = PROFILE_MODEL_TOTAL_CYCLES (CPU_PROFILE_DATA (cpu));
-      unsigned long this_insn = PROFILE_MODEL_CUR_INSN_CYCLES (CPU_PROFILE_DATA (cpu));
+      unsigned long long total = PROFILE_MODEL_TOTAL_CYCLES (CPU_PROFILE_DATA (cpu));
+      unsigned long long this_insn = PROFILE_MODEL_CUR_INSN_CYCLES (CPU_PROFILE_DATA (cpu));
 
       if (last_p)
 	{
@@ -190,7 +190,7 @@ cgen_trace_extract (SIM_CPU *cpu, IADDR pc, char *name, ...)
   va_start (args, name);
 
   trace_printf (CPU_STATE (cpu), cpu, "Extract: 0x%.*lx: %s ",
-		SIZE_PC, (unsigned long) pc, name);
+		SIZE_PC, (unsigned long long) pc, name);
 
   do {
     int type,ival;
@@ -355,7 +355,7 @@ sim_cgen_disassemble_insn (SIM_CPU *cpu, const CGEN_INSN *insn,
 {
   unsigned int length;
   unsigned int base_length;
-  unsigned long insn_value;
+  unsigned long long insn_value;
   struct disassemble_info disasm_info;
   SFILE sfile;
   union {
diff --git a/sim/common/dv-cfi.c b/sim/common/dv-cfi.c
index a2e258b..20c4093 100644
--- a/sim/common/dv-cfi.c
+++ b/sim/common/dv-cfi.c
@@ -367,7 +367,7 @@ cfi_io_write_buffer (struct hw *me, const void *source, int space,
   if (cfi->width != nr_bytes)
     {
       HW_TRACE ((me, "write 0x%08lx length %u does not match flash width %u",
-		 (unsigned long) addr, nr_bytes, cfi->width));
+		 (unsigned long long) addr, nr_bytes, cfi->width));
       return nr_bytes;
     }
 
@@ -423,7 +423,7 @@ cfi_io_write_buffer (struct hw *me, const void *source, int space,
 
  done:
   HW_TRACE ((me, "write 0x%08lx command {%#x,%#x,%#x,%#x}; state %s -> %s",
-	     (unsigned long) addr, ssource[0],
+	     (unsigned long long) addr, ssource[0],
 	     nr_bytes > 1 ? ssource[1] : 0,
 	     nr_bytes > 2 ? ssource[2] : 0,
 	     nr_bytes > 3 ? ssource[3] : 0,
@@ -453,13 +453,13 @@ cfi_io_read_buffer (struct hw *me, void *dest, int space,
   if (cfi->state != CFI_STATE_READ && cfi->width != nr_bytes)
     {
       HW_TRACE ((me, "read 0x%08lx length %u does not match flash width %u",
-		 (unsigned long) addr, nr_bytes, cfi->width));
+		 (unsigned long long) addr, nr_bytes, cfi->width));
       return nr_bytes;
     }
 #endif
 
   HW_TRACE ((me, "%s read 0x%08lx length %u",
-	     state_names[cfi->state], (unsigned long) addr, nr_bytes));
+	     state_names[cfi->state], (unsigned long long) addr, nr_bytes));
 
   switch (cfi->state)
     {
diff --git a/sim/common/dv-core.c b/sim/common/dv-core.c
index 67a86dd..a0a8e52 100644
--- a/sim/common/dv-core.c
+++ b/sim/common/dv-core.c
@@ -54,7 +54,7 @@ dv_core_attach_address_callback (struct hw *me,
 				 struct hw *client)
 {
   HW_TRACE ((me, "attach - level=%d, space=%d, addr=0x%lx, nr_bytes=%ld, client=%s",
-	     level, space, (unsigned long) addr, (unsigned long) nr_bytes, hw_path (client)));
+	     level, space, (unsigned long long) addr, (unsigned long long) nr_bytes, hw_path (client)));
   /* NOTE: At preset the space is assumed to be zero.  Perhaphs the
      space should be mapped onto something for instance: space0 -
      unified memory; space1 - IO memory; ... */
diff --git a/sim/common/dv-glue.c b/sim/common/dv-glue.c
index 897c292..6d8ab71 100644
--- a/sim/common/dv-glue.c
+++ b/sim/common/dv-glue.c
@@ -227,7 +227,7 @@ hw_glue_finish (struct hw *me)
 	hw_abort (me, "at least one reg property size must be nonzero");
       if (glue->sizeof_output % sizeof (unsigned_word) != 0)
 	hw_abort (me, "reg property size must be %ld aligned",
-		  (long) sizeof (unsigned_word));
+		  (long long) sizeof (unsigned_word));
 
       /* ... and the address.  */
       hw_unit_address_to_attach_address (hw_parent (me),
@@ -237,7 +237,7 @@ hw_glue_finish (struct hw *me)
 					 me);
       if (glue->address % (sizeof (unsigned_word) * max_nr_ports) != 0)
 	hw_abort (me, "reg property address must be %ld aligned",
-		  (long) (sizeof (unsigned_word) * max_nr_ports));
+		  (long long) (sizeof (unsigned_word) * max_nr_ports));
 
       glue->nr_outputs = glue->sizeof_output / sizeof (unsigned_word);
     }
@@ -306,12 +306,12 @@ hw_glue_io_read_buffer (struct hw *me,
   if (nr_bytes != sizeof (unsigned_word)
       || (addr % sizeof (unsigned_word)) != 0)
     hw_abort (me, "missaligned read access (%d:0x%lx:%d) not supported",
-	      space, (unsigned long)addr, nr_bytes);
+	      space, (unsigned long long)addr, nr_bytes);
 
   *(unsigned_word *)dest = H2BE_4 (glue->output[reg]);
 
   HW_TRACE ((me, "read - port %d (0x%lx), level %d",
-	     reg, (unsigned long) addr, glue->output[reg]));
+	     reg, (unsigned long long) addr, glue->output[reg]));
 
   return nr_bytes;
 }
@@ -330,12 +330,12 @@ hw_glue_io_write_buffer (struct hw *me,
   if (nr_bytes != sizeof (unsigned_word)
       || (addr % sizeof (unsigned_word)) != 0)
     hw_abort (me, "missaligned write access (%d:0x%lx:%d) not supported",
-	      space, (unsigned long) addr, nr_bytes);
+	      space, (unsigned long long) addr, nr_bytes);
 
   glue->output[reg] = H2BE_4 (*(unsigned_word *)source);
 
   HW_TRACE ((me, "write - port %d (0x%lx), level %d",
-	     reg, (unsigned long) addr, glue->output[reg]));
+	     reg, (unsigned long long) addr, glue->output[reg]));
 
   hw_port_event (me, reg, glue->output[reg]);
 
@@ -367,7 +367,7 @@ hw_glue_port_event (struct hw *me,
 
 	HW_TRACE ((me, "input - port %d (0x%lx), level %d",
 		   my_port,
-		   (unsigned long) glue->address + port * sizeof (unsigned_word),
+		   (unsigned long long) glue->address + port * sizeof (unsigned_word),
 		   level));
 	return;
       }
diff --git a/sim/common/dv-pal.c b/sim/common/dv-pal.c
index ae515cd..54c00d9 100644
--- a/sim/common/dv-pal.c
+++ b/sim/common/dv-pal.c
@@ -251,7 +251,7 @@ do_counter_read (struct hw *me,
   if (nr_bytes != 4)
     hw_abort (me, "%s - bad read size must be 4 bytes", reg);
   val = counter->delta;
-  HW_TRACE ((me, "read - %s %ld", reg, (long) val));
+  HW_TRACE ((me, "read - %s %ld", reg, (long long) val));
   *word = H2BE_4 (val);
 }
 
@@ -271,7 +271,7 @@ do_counter_value (struct hw *me,
 	   - hw_event_queue_time (me));
   else
     val = 0;
-  HW_TRACE ((me, "read - %s %ld", reg, (long) val));
+  HW_TRACE ((me, "read - %s %ld", reg, (long long) val));
   *word = H2BE_4 (val);
 }
 
@@ -292,7 +292,7 @@ do_counter_write (struct hw *me,
     }
   counter->delta = BE2H_4 (*word);
   counter->start = hw_event_queue_time (me);
-  HW_TRACE ((me, "write - %s %ld", reg, (long) counter->delta));
+  HW_TRACE ((me, "write - %s %ld", reg, (long long) counter->delta));
   if (counter->delta > 0)
     hw_event_queue_schedule (me, counter->delta, do_counter_event, counter);
 }
@@ -492,7 +492,7 @@ hw_pal_instance_read_callback (hw_instance *instance,
 			      void *buf,
 			      unsigned_word len)
 {
-  DITRACE (pal, ("read - %s (%ld)", (const char*) buf, (long int) len));
+  DITRACE (pal, ("read - %s (%ld)", (const char*) buf, (long long int) len));
   return sim_io_read_stdin (buf, len);
 }
 #endif
@@ -506,7 +506,7 @@ hw_pal_instance_write_callback (hw_instance *instance,
   int i;
   const char *chp = buf;
   hw_pal_device *hw_pal = hw_instance_data (instance);
-  DITRACE (pal, ("write - %s (%ld)", (const char*) buf, (long int) len));
+  DITRACE (pal, ("write - %s (%ld)", (const char*) buf, (long long int) len));
   for (i = 0; i < len; i++)
     write_hw_pal (hw_pal, chp[i]);
   sim_io_flush_stdoutput ();
diff --git a/sim/common/hw-alloc.c b/sim/common/hw-alloc.c
index 6b6d1a7..c029a73 100644
--- a/sim/common/hw-alloc.c
+++ b/sim/common/hw-alloc.c
@@ -50,7 +50,7 @@ delete_hw_alloc_data (struct hw *me)
 
 
 void *
-hw_zalloc (struct hw *me, unsigned long size)
+hw_zalloc (struct hw *me, unsigned long long size)
 {
   struct hw_alloc_data *memory = ZALLOC (struct hw_alloc_data);
   memory->alloc = zalloc (size);
@@ -60,7 +60,7 @@ hw_zalloc (struct hw *me, unsigned long size)
 }
 
 void *
-hw_malloc (struct hw *me, unsigned long size)
+hw_malloc (struct hw *me, unsigned long long size)
 {
   struct hw_alloc_data *memory = ZALLOC (struct hw_alloc_data);
   memory->alloc = zalloc (size);
diff --git a/sim/common/hw-alloc.h b/sim/common/hw-alloc.h
index 1389c8f..8a21af0 100644
--- a/sim/common/hw-alloc.h
+++ b/sim/common/hw-alloc.h
@@ -36,8 +36,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #define HW_NALLOC(me,type,n) (type*) hw_malloc (me, sizeof (type) * (n))
 #define HW_NZALLOC(me,type,n) (type*) hw_zalloc (me, sizeof (type) * (n))
 
-extern void *hw_zalloc (struct hw *me, unsigned long size);
-extern void *hw_malloc (struct hw *me, unsigned long size);
+extern void *hw_zalloc (struct hw *me, unsigned long long size);
+extern void *hw_malloc (struct hw *me, unsigned long long size);
 
 extern void hw_free (struct hw *me, void *);
 
diff --git a/sim/common/hw-base.c b/sim/common/hw-base.c
index 1bb7eeb..71ffa00 100644
--- a/sim/common/hw-base.c
+++ b/sim/common/hw-base.c
@@ -62,7 +62,7 @@ generic_hw_unit_decode (struct hw *bus,
       while (1)
 	{
 	  char *end = NULL;
-	  unsigned long val;
+	  unsigned long long val;
 	  val = strtoul (unit, &end, 0);
 	  /* parse error? */
 	  if (unit == end)
@@ -133,9 +133,9 @@ generic_hw_unit_encode (struct hw *bus,
 	      pos = strchr (pos, '\0');
 	    }
 	  if (phys->cells[i] < 10)
-	    sprintf (pos, "%ld", (unsigned long)phys->cells[i]);
+	    sprintf (pos, "%ld", (unsigned long long)phys->cells[i]);
 	  else
-	    sprintf (pos, "0x%lx", (unsigned long)phys->cells[i]);
+	    sprintf (pos, "0x%lx", (unsigned long long)phys->cells[i]);
 	  pos = strchr (pos, '\0');
 	}
       len = pos - buf;
diff --git a/sim/common/hw-tree.c b/sim/common/hw-tree.c
index 8514770..40db4cc 100644
--- a/sim/common/hw-tree.c
+++ b/sim/common/hw-tree.c
@@ -1013,10 +1013,10 @@ print_size (struct hw *bus,
       break;
   if (i < size->nr_cells)
     {
-      p->print (p->file, " 0x%lx", (unsigned long) size->cells[i]);
+      p->print (p->file, " 0x%lx", (unsigned long long) size->cells[i]);
       i++;
       for (; i < size->nr_cells; i++)
-	p->print (p->file, ",0x%lx", (unsigned long) size->cells[i]);
+	p->print (p->file, ",0x%lx", (unsigned long long) size->cells[i]);
     }
   else
     p->print (p->file, " 0");
@@ -1129,7 +1129,7 @@ print_properties (struct hw *me,
 			 cell_nr < (property->sizeof_array / sizeof (unsigned_cell));
 			 cell_nr++)
 		      {
-			p->print (p->file, " 0x%lx", (unsigned long) BE2H_cell (w[cell_nr]));
+			p->print (p->file, " 0x%lx", (unsigned long long) BE2H_cell (w[cell_nr]));
 		      }
 		  }
 		else
@@ -1171,7 +1171,7 @@ print_properties (struct hw *me,
 	    case integer_property:
 	      {
 		unsigned_word w = hw_find_integer_property (me, property->name);
-		p->print (p->file, " 0x%lx", (unsigned long)w);
+		p->print (p->file, " 0x%lx", (unsigned long long)w);
 		break;
 	      }
 	    case range_array_property:
diff --git a/sim/common/sim-base.h b/sim/common/sim-base.h
index 524195e..51dc4b0 100644
--- a/sim/common/sim-base.h
+++ b/sim/common/sim-base.h
@@ -161,7 +161,7 @@ typedef struct {
 #define STATE_PROG_SYMS(sd) ((sd)->base.prog_syms)
 
   /* Number of prog_syms symbols.  */
-  long prog_syms_count;
+  long long prog_syms_count;
 #define STATE_PROG_SYMS_COUNT(sd) ((sd)->base.prog_syms_count)
 
   /* The program's text section.  */
diff --git a/sim/common/sim-core.c b/sim/common/sim-core.c
index f26a374..5a2fca3 100644
--- a/sim/common/sim-core.c
+++ b/sim/common/sim-core.c
@@ -115,12 +115,12 @@ sim_core_signal (SIM_DESC sd,
     {
     case sim_core_unmapped_signal:
       sim_io_eprintf (sd, "core: %d byte %s to unmapped address 0x%lx at 0x%lx\n",
-		      nr_bytes, copy, (unsigned long) addr, (unsigned long) ip);
+		      nr_bytes, copy, (unsigned long long) addr, (unsigned long long) ip);
       sim_engine_halt (sd, cpu, NULL, cia, sim_stopped, SIM_SIGSEGV);
       break;
     case sim_core_unaligned_signal:
       sim_io_eprintf (sd, "core: %d byte misaligned %s to address 0x%lx at 0x%lx\n",
-		      nr_bytes, copy, (unsigned long) addr, (unsigned long) ip);
+		      nr_bytes, copy, (unsigned long long) addr, (unsigned long long) ip);
       sim_engine_halt (sd, cpu, NULL, cia, sim_stopped, SIM_SIGBUS);
       break;
     default:
@@ -212,23 +212,23 @@ sim_core_map_attach (SIM_DESC sd,
 #if WITH_HW
       sim_hw_abort (sd, client, "memory map %d:0x%lx..0x%lx (%ld bytes) overlaps %d:0x%lx..0x%lx (%ld bytes)",
 		    space,
-		    (long) addr,
-		    (long) (addr + (nr_bytes - 1)),
-		    (long) nr_bytes,
+		    (long long) addr,
+		    (long long) (addr + (nr_bytes - 1)),
+		    (long long) nr_bytes,
 		    next_mapping->space,
-		    (long) next_mapping->base,
-		    (long) next_mapping->bound,
-		    (long) next_mapping->nr_bytes);
+		    (long long) next_mapping->base,
+		    (long long) next_mapping->bound,
+		    (long long) next_mapping->nr_bytes);
 #endif
       sim_io_error (sd, "memory map %d:0x%lx..0x%lx (%ld bytes) overlaps %d:0x%lx..0x%lx (%ld bytes)",
 		    space,
-		    (long) addr,
-		    (long) (addr + (nr_bytes - 1)),
-		    (long) nr_bytes,
+		    (long long) addr,
+		    (long long) (addr + (nr_bytes - 1)),
+		    (long long) nr_bytes,
 		    next_mapping->space,
-		    (long) next_mapping->base,
-		    (long) next_mapping->bound,
-		    (long) next_mapping->nr_bytes);
+		    (long long) next_mapping->base,
+		    (long long) next_mapping->bound,
+		    (long long) next_mapping->nr_bytes);
   }
 
   /* create/insert the new mapping */
@@ -287,9 +287,9 @@ sim_core_attach (SIM_DESC sd,
       if (mask != sizeof (unsigned64) - 1)
 	{
 #if (WITH_HW)
-	  sim_hw_abort (sd, client, "sim_core_attach - internal error - modulo %lx not power of two", (long) modulo);
+	  sim_hw_abort (sd, client, "sim_core_attach - internal error - modulo %lx not power of two", (long long) modulo);
 #endif
-	  sim_io_error (sd, "sim_core_attach - internal error - modulo %lx not power of two", (long) modulo);
+	  sim_io_error (sd, "sim_core_attach - internal error - modulo %lx not power of two", (long long) modulo);
 	}
     }
 
@@ -306,7 +306,7 @@ sim_core_attach (SIM_DESC sd,
       if (optional_buffer == NULL)
 	{
 	  int padding = (addr % sizeof (unsigned64));
-	  unsigned long bytes = (modulo == 0 ? nr_bytes : modulo) + padding;
+	  unsigned long long bytes = (modulo == 0 ? nr_bytes : modulo) + padding;
 	  free_buffer = zalloc (bytes);
 	  buffer = (char*) free_buffer + padding;
 	}
diff --git a/sim/common/sim-events.c b/sim/common/sim-events.c
index ccdaa23..bb2527e 100644
--- a/sim/common/sim-events.c
+++ b/sim/common/sim-events.c
@@ -360,10 +360,10 @@ sim_events_time (SIM_DESC sd)
 
 
 INLINE_SIM_EVENTS\
-(unsigned long)
+(unsigned long long)
 sim_events_elapsed_time (SIM_DESC sd)
 {
-  unsigned long elapsed = STATE_EVENTS (sd)->elapsed_wallclock;
+  unsigned long long elapsed = STATE_EVENTS (sd)->elapsed_wallclock;
 
   /* Are we being called inside sim_resume?
      (Is there a simulation in progress?)  */
@@ -413,13 +413,13 @@ update_time_from_event (SIM_DESC sd)
 	{
 	  ETRACE ((_ETRACE,
 		   "event time-from-event - time %ld, delta %ld - event %d, tag 0x%lx, time %ld, handler 0x%lx, data 0x%lx%s%s\n",
-		   (long)current_time,
-		   (long)events->time_from_event,
+		   (long long)current_time,
+		   (long long)events->time_from_event,
 		   i,
-		   (long)event,
-		   (long)event->time_of_event,
-		   (long)event->handler,
-		   (long)event->data,
+		   (long long)event,
+		   (long long)event->time_of_event,
+		   (long long)event->handler,
+		   (long long)event->data,
 		   (event->trace != NULL) ? ", " : "",
 		   (event->trace != NULL) ? event->trace : ""));
 	}
@@ -520,11 +520,11 @@ sim_events_schedule_vtracef (SIM_DESC sd,
   insert_sim_event (sd, new_event, delta_time);
   ETRACE ((_ETRACE,
 	   "event scheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx%s%s\n",
-	   (long)sim_events_time (sd),
-	   (long)new_event,
-	   (long)new_event->time_of_event,
-	   (long)new_event->handler,
-	   (long)new_event->data,
+	   (long long)sim_events_time (sd),
+	   (long long)new_event,
+	   (long long)new_event->time_of_event,
+	   (long long)new_event->handler,
+	   (long long)new_event->data,
 	   (new_event->trace != NULL) ? ", " : "",
 	   (new_event->trace != NULL) ? new_event->trace : ""));
   return new_event;
@@ -572,11 +572,11 @@ sim_events_schedule_after_signal (SIM_DESC sd,
 
   ETRACE ((_ETRACE,
 	   "signal scheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx\n",
-	   (long)sim_events_time (sd),
-	   (long)new_event,
-	   (long)new_event->time_of_event,
-	   (long)new_event->handler,
-	   (long)new_event->data));
+	   (long long)sim_events_time (sd),
+	   (long long)new_event,
+	   (long long)new_event->time_of_event,
+	   (long long)new_event->handler,
+	   (long long)new_event->data));
 }
 #endif
 
@@ -608,11 +608,11 @@ sim_events_watch_clock (SIM_DESC sd,
   events->work_pending = 1;
   ETRACE ((_ETRACE,
 	  "event watching clock at %ld - tag 0x%lx - wallclock %ld, handler 0x%lx, data 0x%lx\n",
-	   (long)sim_events_time (sd),
-	   (long)new_event,
-	   (long)new_event->wallclock,
-	   (long)new_event->handler,
-	   (long)new_event->data));
+	   (long long)sim_events_time (sd),
+	   (long long)new_event,
+	   (long long)new_event->wallclock,
+	   (long long)new_event->handler,
+	   (long long)new_event->data));
   return new_event;
 }
 #endif
@@ -684,13 +684,13 @@ sim_events_watch_sim (SIM_DESC sd,
   events->work_pending = 1;
   ETRACE ((_ETRACE,
 	   "event watching host at %ld - tag 0x%lx - host-addr 0x%lx, 0x%lx..0x%lx, handler 0x%lx, data 0x%lx\n",
-	   (long)sim_events_time (sd),
-	   (long)new_event,
-	   (long)new_event->host_addr,
-	   (long)new_event->lb,
-	   (long)new_event->ub,
-	   (long)new_event->handler,
-	   (long)new_event->data));
+	   (long long)sim_events_time (sd),
+	   (long long)new_event,
+	   (long long)new_event->host_addr,
+	   (long long)new_event->lb,
+	   (long long)new_event->ub,
+	   (long long)new_event->handler,
+	   (long long)new_event->data));
   return new_event;
 }
 #endif
@@ -764,13 +764,13 @@ sim_events_watch_core (SIM_DESC sd,
   events->work_pending = 1;
   ETRACE ((_ETRACE,
 	   "event watching host at %ld - tag 0x%lx - host-addr 0x%lx, 0x%lx..0x%lx, handler 0x%lx, data 0x%lx\n",
-	   (long)sim_events_time (sd),
-	   (long)new_event,
-	   (long)new_event->host_addr,
-	   (long)new_event->lb,
-	   (long)new_event->ub,
-	   (long)new_event->handler,
-	   (long)new_event->data));
+	   (long long)sim_events_time (sd),
+	   (long long)new_event,
+	   (long long)new_event->host_addr,
+	   (long long)new_event->lb,
+	   (long long)new_event->ub,
+	   (long long)new_event->handler,
+	   (long long)new_event->data));
   return new_event;
 }
 #endif
@@ -798,11 +798,11 @@ sim_events_deschedule (SIM_DESC sd,
 	      *ptr_to_current = dead->next;
 	      ETRACE ((_ETRACE,
 		       "event/watch descheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx%s%s\n",
-		       (long) sim_events_time (sd),
-		       (long) event_to_remove,
-		       (long) dead->time_of_event,
-		       (long) dead->handler,
-		       (long) dead->data,
+		       (long long) sim_events_time (sd),
+		       (long long) event_to_remove,
+		       (long long) dead->time_of_event,
+		       (long long) dead->handler,
+		       (long long) dead->data,
 		       (dead->trace != NULL) ? ", " : "",
 		       (dead->trace != NULL) ? dead->trace : ""));
 	      sim_events_free (sd, dead);
@@ -814,8 +814,8 @@ sim_events_deschedule (SIM_DESC sd,
     }
   ETRACE ((_ETRACE,
 	   "event/watch descheduled at %ld - tag 0x%lx - not found\n",
-	   (long) sim_events_time (sd),
-	   (long) event_to_remove));
+	   (long long) sim_events_time (sd),
+	   (long long) event_to_remove));
 }
 #endif
 
@@ -977,7 +977,7 @@ sim_watch_valid (SIM_DESC sd,
 
     case watch_clock: /* wallclock */
       {
-	unsigned long elapsed_time = sim_events_elapsed_time (sd);
+	unsigned long long elapsed_time = sim_events_elapsed_time (sd);
 	return (elapsed_time >= to_do->wallclock);
       }
 
@@ -1141,10 +1141,10 @@ sim_events_process (SIM_DESC sd)
 	  void *data = to_do->data;
 	  ETRACE ((_ETRACE,
 		   "event issued at %ld - tag 0x%lx - handler 0x%lx, data 0x%lx%s%s\n",
-		   (long) event_time,
-		   (long) to_do,
-		   (long) handler,
-		   (long) data,
+		   (long long) event_time,
+		   (long long) to_do,
+		   (long long) handler,
+		   (long long) data,
 		   (to_do->trace != NULL) ? ", " : "",
 		   (to_do->trace != NULL) ? to_do->trace : ""));
 	  sim_events_free (sd, to_do);
@@ -1169,10 +1169,10 @@ sim_events_process (SIM_DESC sd)
       update_time_from_event (sd);
       ETRACE ((_ETRACE,
 	       "event issued at %ld - tag 0x%lx - handler 0x%lx, data 0x%lx%s%s\n",
-	       (long) event_time,
-	       (long) to_do,
-	       (long) handler,
-	       (long) data,
+	       (long long) event_time,
+	       (long long) to_do,
+	       (long long) handler,
+	       (long long) data,
 	       (to_do->trace != NULL) ? ", " : "",
 	       (to_do->trace != NULL) ? to_do->trace : ""));
       sim_events_free (sd, to_do);
diff --git a/sim/common/sim-events.h b/sim/common/sim-events.h
index 925e745..3eecfe6 100644
--- a/sim/common/sim-events.h
+++ b/sim/common/sim-events.h
@@ -90,7 +90,7 @@ struct _sim_events {
   sim_event *held;
   volatile int nr_held;
   /* timekeeping */
-  unsigned long elapsed_wallclock;
+  unsigned long long elapsed_wallclock;
   SIM_ELAPSED_TIME resume_wallclock;
   signed64 time_of_event;
   signed64 time_from_event;
@@ -267,7 +267,7 @@ INLINE_SIM_EVENTS\
 /* local concept of elapsed host time (milliseconds) */
 
 INLINE_SIM_EVENTS\
-(unsigned long) sim_events_elapsed_time
+(unsigned long long) sim_events_elapsed_time
 (SIM_DESC sd);
 
 /* Returns the time that remains before the event is raised. */
diff --git a/sim/common/sim-fpu.c b/sim/common/sim-fpu.c
index ce5fafb..f11b697 100644
--- a/sim/common/sim-fpu.c
+++ b/sim/common/sim-fpu.c
@@ -306,8 +306,8 @@ pack_fpu (const sim_fpu *src,
       printf ("pack_fpu: ");
       printf ("-> %c%0lX.%06lX\n",
 	      LSMASKED32 (packed, 31, 31) ? '8' : '0',
-	      (long) LSEXTRACTED32 (packed, 30, 23),
-	      (long) LSEXTRACTED32 (packed, 23 - 1, 0));
+	      (long long) LSEXTRACTED32 (packed, 30, 23),
+	      (long long) LSEXTRACTED32 (packed, 23 - 1, 0));
     }
 #endif
 
@@ -397,8 +397,8 @@ unpack_fpu (sim_fpu *dst, unsigned64 packed, int is_double)
     {
       printf ("unpack_fpu: %c%02lX.%06lX ->\n",
 	      LSMASKED32 (packed, 31, 31) ? '8' : '0',
-	      (long) LSEXTRACTED32 (packed, 30, 23),
-	      (long) LSEXTRACTED32 (packed, 23 - 1, 0));
+	      (long long) LSEXTRACTED32 (packed, 30, 23),
+	      (long long) LSEXTRACTED32 (packed, 23 - 1, 0));
     }
 #endif
 
@@ -575,7 +575,7 @@ i2fpu (sim_fpu *f, signed64 i, int is_64bit)
   /* trace operation */
 #if 0
   {
-    printf ("i2fpu: 0x%08lX ->\n", (long) i);
+    printf ("i2fpu: 0x%08lX ->\n", (long long) i);
   }
 #endif
 
diff --git a/sim/common/sim-io.c b/sim/common/sim-io.c
index a929b0c..250fbe5 100644
--- a/sim/common/sim-io.c
+++ b/sim/common/sim-io.c
@@ -66,9 +66,9 @@ sim_io_unlink (SIM_DESC sd,
 }
 
 
-long
+long long
 sim_io_time (SIM_DESC sd,
-	     long *t)
+	     long long *t)
 {
   return STATE_CALLBACK (sd)->time (STATE_CALLBACK (sd), t);
 }
@@ -213,7 +213,7 @@ sim_io_open (SIM_DESC sd,
 int
 sim_io_lseek (SIM_DESC sd,
 	      int fd,
-	      long off,
+	      long long off,
 	      int way)
 {
   return STATE_CALLBACK (sd)->lseek (STATE_CALLBACK (sd), fd, off, way);
diff --git a/sim/common/sim-io.h b/sim/common/sim-io.h
index 6926b16..8ef2a0c 100644
--- a/sim/common/sim-io.h
+++ b/sim/common/sim-io.h
@@ -31,7 +31,7 @@ int sim_io_shutdown (SIM_DESC sd);
 
 int sim_io_unlink (SIM_DESC sd, const char *);
 
-long sim_io_time (SIM_DESC sd, long *);
+long long sim_io_time (SIM_DESC sd, long long *);
 
 int sim_io_system (SIM_DESC sd, const char *);
 
@@ -53,7 +53,7 @@ int sim_io_read (SIM_DESC sd, int, char *, int);
 
 int sim_io_open (SIM_DESC sd, const char *, int);
 
-int sim_io_lseek (SIM_DESC sd, int, long, int);
+int sim_io_lseek (SIM_DESC sd, int, long long, int);
 
 int sim_io_isatty (SIM_DESC sd, int);
 
diff --git a/sim/common/sim-load.c b/sim/common/sim-load.c
index 99e2d30..f767d02 100644
--- a/sim/common/sim-load.c
+++ b/sim/common/sim-load.c
@@ -39,7 +39,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 static void eprintf (host_callback *, const char *, ...);
 static void xprintf (host_callback *, const char *, ...);
 static void report_transfer_performance
-  (host_callback *, unsigned long, time_t, time_t);
+  (host_callback *, unsigned long long, time_t, time_t);
 static void xprintf_bfd_vma (host_callback *, bfd_vma);
 
 /* Load program PROG into the simulator using the function DO_LOAD.
@@ -65,7 +65,7 @@ sim_load_file (SIM_DESC sd, const char *myname, host_callback *callback,
   bfd *result_bfd;
   time_t start_time = 0;	/* Start and end times of download */
   time_t end_time = 0;
-  unsigned long data_count = 0;	/* Number of bytes transferred to memory */
+  unsigned long long data_count = 0;	/* Number of bytes transferred to memory */
   int found_loadable_section;
 
   if (prog_bfd != NULL)
@@ -126,7 +126,7 @@ sim_load_file (SIM_DESC sd, const char *myname, host_callback *callback,
 		{
 		  xprintf (callback, "Loading section %s, size 0x%lx %s ",
 			   bfd_get_section_name (result_bfd, s),
-			   (unsigned long) size,
+			   (unsigned long long) size,
 			   (lma_p ? "lma" : "vma"));
 		  xprintf_bfd_vma (callback, lma);
 		  xprintf (callback, "\n");
@@ -189,7 +189,7 @@ eprintf (host_callback *callback, const char *fmt, ...)
 /* Report how fast the transfer went. */
 
 static void
-report_transfer_performance (host_callback *callback, unsigned long data_count,
+report_transfer_performance (host_callback *callback, unsigned long long data_count,
 			     time_t start_time, time_t end_time)
 {
   xprintf (callback, "Transfer rate: ");
@@ -208,5 +208,5 @@ static void
 xprintf_bfd_vma (host_callback *callback, bfd_vma vma)
 {
   /* FIXME: for now */
-  xprintf (callback, "0x%lx", (unsigned long) vma);
+  xprintf (callback, "0x%lx", (unsigned long long) vma);
 }
diff --git a/sim/common/sim-memopt.c b/sim/common/sim-memopt.c
index b74ceac..0038f07 100644
--- a/sim/common/sim-memopt.c
+++ b/sim/common/sim-memopt.c
@@ -134,7 +134,7 @@ do_memopt_add (SIM_DESC sd,
   void *fill_buffer;
   unsigned fill_length;
   void *free_buffer;
-  unsigned long free_length;
+  unsigned long long free_length;
 
   if (buffer != NULL)
     {
@@ -153,7 +153,7 @@ do_memopt_add (SIM_DESC sd,
       /* Allocate new well-aligned buffer, just as sim_core_attach(). */
       void *aligned_buffer;
       int padding = (addr % sizeof (unsigned64));
-      unsigned long bytes;
+      unsigned long long bytes;
 
 #ifdef HAVE_MMAP
       struct stat s;
@@ -271,7 +271,7 @@ do_memopt_delete (SIM_DESC sd,
   if ((*entry) == NULL)
     {
       sim_io_eprintf (sd, "Memory at 0x%lx not found, not deleted\n",
-		      (long) addr);
+		      (long long) addr);
       return SIM_RC_FAIL;
     }
   /* delete any buffer */
@@ -332,7 +332,7 @@ parse_size (char *chp,
 
 static char *
 parse_ulong_value (char *chp,
-		     unsigned long *value)
+		     unsigned long long *value)
 {
   *value = strtoul (chp, &chp, 0);
   return chp;
@@ -345,11 +345,11 @@ parse_addr (char *chp,
 	    address_word *addr)
 {
   /* [ <space> ": " ] <addr> [ "@" <level> ] */
-  *addr = (unsigned long) strtoul (chp, &chp, 0);
+  *addr = (unsigned long long) strtoul (chp, &chp, 0);
   if (*chp == ':')
     {
       *space = *addr;
-      *addr = (unsigned long) strtoul (chp + 1, &chp, 0);
+      *addr = (unsigned long long) strtoul (chp + 1, &chp, 0);
     }
   if (*chp == '@')
     {
@@ -474,7 +474,7 @@ memory_option_handler (SIM_DESC sd, sim_cpu *cpu, int opt,
 
     case OPTION_MEMORY_FILL:
       {
-	unsigned long fill_value;
+	unsigned long long fill_value;
 	parse_ulong_value (arg, &fill_value);
 	if (fill_value > 255)
 	  {
@@ -519,23 +519,23 @@ memory_option_handler (SIM_DESC sd, sim_cpu *cpu, int opt,
 	    else
 	      sim_io_printf (sd, " alias ");
 	    if (entry->space != 0)
-	      sim_io_printf (sd, "0x%lx:", (long) entry->space);
-	    sim_io_printf (sd, "0x%08lx", (long) entry->addr);
+	      sim_io_printf (sd, "0x%lx:", (long long) entry->space);
+	    sim_io_printf (sd, "0x%08lx", (long long) entry->addr);
 	    if (entry->level != 0)
-	      sim_io_printf (sd, "@0x%lx", (long) entry->level);
+	      sim_io_printf (sd, "@0x%lx", (long long) entry->level);
 	    sim_io_printf (sd, ",0x%lx",
-			   (long) entry->nr_bytes);
+			   (long long) entry->nr_bytes);
 	    if (entry->modulo != 0)
-	      sim_io_printf (sd, "%%0x%lx", (long) entry->modulo);
+	      sim_io_printf (sd, "%%0x%lx", (long long) entry->modulo);
 	    for (alias = entry->alias;
 		 alias != NULL;
 		 alias = alias->next)
 	      {
 		if (alias->space != 0)
-		  sim_io_printf (sd, "0x%lx:", (long) alias->space);
-		sim_io_printf (sd, ",0x%08lx", (long) alias->addr);
+		  sim_io_printf (sd, "0x%lx:", (long long) alias->space);
+		sim_io_printf (sd, ",0x%08lx", (long long) alias->addr);
 		if (alias->level != 0)
-		  sim_io_printf (sd, "@0x%lx", (long) alias->level);
+		  sim_io_printf (sd, "@0x%lx", (long long) alias->level);
 	      }
 	    sim_io_printf (sd, "\n");
 	  }
@@ -564,10 +564,10 @@ memory_option_handler (SIM_DESC sd, sim_cpu *cpu, int opt,
 		sim_io_printf (sd, " map ");
 		if (mapping->space != 0)
 		  sim_io_printf (sd, "0x%x:", mapping->space);
-		sim_io_printf (sd, "0x%08lx", (long) mapping->base);
+		sim_io_printf (sd, "0x%08lx", (long long) mapping->base);
 		if (mapping->level != 0)
 		  sim_io_printf (sd, "@0x%x", mapping->level);
-		sim_io_printf (sd, ",0x%lx", (long) mapping->nr_bytes);
+		sim_io_printf (sd, ",0x%lx", (long long) mapping->nr_bytes);
 		modulo = mapping->mask + 1;
 		if (modulo != 0)
 		  sim_io_printf (sd, "%%0x%x", modulo);
diff --git a/sim/common/sim-memopt.h b/sim/common/sim-memopt.h
index 5dda506..7c8cdfb 100644
--- a/sim/common/sim-memopt.h
+++ b/sim/common/sim-memopt.h
@@ -30,7 +30,7 @@ struct _sim_memopt {
   unsigned_word nr_bytes;
   unsigned modulo;
   void *buffer;
-  unsigned long munmap_length;
+  unsigned long long munmap_length;
   sim_memopt *alias; /* linked list */
   sim_memopt *next;
 };
diff --git a/sim/common/sim-n-core.h b/sim/common/sim-n-core.h
index 7552e1f..d77ef5c 100644
--- a/sim/common/sim-n-core.h
+++ b/sim/common/sim-n-core.h
@@ -88,22 +88,22 @@ sim_core_trace_M (sim_cpu *cpu,
 		"%s-%d %s:0x%08lx %s 0x%08lx%08lx%08lx%08lx\n",
 		transfer, nr_bytes,
 		map_to_str (map),
-		(unsigned long) addr,
+		(unsigned long long) addr,
 		direction,
-		(unsigned long) V4_16 (val, 0),
-		(unsigned long) V4_16 (val, 1),
-		(unsigned long) V4_16 (val, 2),
-		(unsigned long) V4_16 (val, 3));
+		(unsigned long long) V4_16 (val, 0),
+		(unsigned long long) V4_16 (val, 1),
+		(unsigned long long) V4_16 (val, 2),
+		(unsigned long long) V4_16 (val, 3));
 #endif
 #if (M == 8)
   trace_printf (CPU_STATE (cpu), cpu,
 		"%s-%d %s:0x%08lx %s 0x%08lx%08lx\n",
 		transfer, nr_bytes,
 		map_to_str (map),
-		(unsigned long) addr,
+		(unsigned long long) addr,
 		direction,
-		(unsigned long) V4_8 (val, 0),
-		(unsigned long) V4_8 (val, 1));
+		(unsigned long long) V4_8 (val, 0),
+		(unsigned long long) V4_8 (val, 1));
 #endif
 #if (M == 4)
   trace_printf (CPU_STATE (cpu), cpu,
@@ -111,9 +111,9 @@ sim_core_trace_M (sim_cpu *cpu,
 		transfer,
 		nr_bytes,
 		map_to_str (map),
-		(unsigned long) addr,
+		(unsigned long long) addr,
 		direction,
-		(unsigned long) val);
+		(unsigned long long) val);
 #endif
 #if (M == 2)
   trace_printf (CPU_STATE (cpu), cpu,
@@ -121,9 +121,9 @@ sim_core_trace_M (sim_cpu *cpu,
 		transfer,
 		nr_bytes,
 		map_to_str (map),
-		(unsigned long) addr,
+		(unsigned long long) addr,
 		direction,
-		(unsigned long) val);
+		(unsigned long long) val);
 #endif
 #if (M == 1)
   trace_printf (CPU_STATE (cpu), cpu,
@@ -131,9 +131,9 @@ sim_core_trace_M (sim_cpu *cpu,
 		transfer,
 		nr_bytes,
 		map_to_str (map),
-		(unsigned long) addr,
+		(unsigned long long) addr,
 		direction,
-		(unsigned long) val);
+		(unsigned long long) val);
 #endif
 }
 #endif
diff --git a/sim/common/sim-profile.c b/sim/common/sim-profile.c
index 2404a8f..02d1dbd 100644
--- a/sim/common/sim-profile.c
+++ b/sim/common/sim-profile.c
@@ -204,7 +204,7 @@ sim_profile_set_option (SIM_DESC sd, const char *name, int idx, const char *arg)
 }
 
 static SIM_RC
-parse_frequency (SIM_DESC sd, const char *arg, unsigned long *freq)
+parse_frequency (SIM_DESC sd, const char *arg, unsigned long long *freq)
 {
   const char *ch;
   /* First, parse a decimal number.  */
@@ -301,7 +301,7 @@ profile_option_handler (SIM_DESC sd,
 
     case OPTION_PROFILE_CPU_FREQUENCY :
       {
-	unsigned long val;
+	unsigned long long val;
 	SIM_RC rc = parse_frequency (sd, arg, &val);
 	if (rc == SIM_RC_OK)
 	  {
@@ -400,8 +400,8 @@ profile_option_handler (SIM_DESC sd,
 	{
 	  /* FIXME: Validate args */
 	  char *chp = arg;
-	  unsigned long base;
-	  unsigned long bound;
+	  unsigned long long base;
+	  unsigned long long bound;
 	  base = strtoul (chp, &chp, 0);
 	  if (*chp != ',')
 	    {
@@ -426,7 +426,7 @@ profile_option_handler (SIM_DESC sd,
       if (WITH_PROFILE)
 	{
 	  char *chp = arg;
-	  unsigned long start,end;
+	  unsigned long long start,end;
 	  start = strtoul (chp, &chp, 0);
 	  if (*chp != ',')
 	    {
@@ -649,8 +649,8 @@ profile_print_pc (sim_cpu *cpu, int verbose)
 
   if (PROFILE_PC_END (profile) != 0)
     profile_printf (sd, cpu, "  Range: 0x%lx 0x%lx\n",
-		    (long) PROFILE_PC_START (profile),
-		   (long) PROFILE_PC_END (profile));
+		    (long long) PROFILE_PC_START (profile),
+		   (long long) PROFILE_PC_END (profile));
 
   if (verbose && max_val != 0)
     {
@@ -665,7 +665,7 @@ profile_print_pc (sim_cpu *cpu, int verbose)
 		profile_printf (sd, cpu, "%10s:", "overflow");
 	      else
 		profile_printf (sd, cpu, "0x%08lx:",
-				(long) (PROFILE_PC_START (profile)
+				(long long) (PROFILE_PC_START (profile)
 					+ (i * PROFILE_PC_BUCKET_SIZE (profile))));
 	      profile_printf (sd, cpu, " %*s",
 			      max_val < 10000 ? 5 : 10,
@@ -969,9 +969,9 @@ profile_print_model (sim_cpu *cpu, int verbose)
 {
   SIM_DESC sd = CPU_STATE (cpu);
   PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
-  unsigned long cti_stall_cycles = PROFILE_MODEL_CTI_STALL_CYCLES (data);
-  unsigned long load_stall_cycles = PROFILE_MODEL_LOAD_STALL_CYCLES (data);
-  unsigned long total_cycles = PROFILE_MODEL_TOTAL_CYCLES (data);
+  unsigned long long cti_stall_cycles = PROFILE_MODEL_CTI_STALL_CYCLES (data);
+  unsigned long long load_stall_cycles = PROFILE_MODEL_LOAD_STALL_CYCLES (data);
+  unsigned long long total_cycles = PROFILE_MODEL_TOTAL_CYCLES (data);
   char comma_buf[20];
 
   profile_printf (sd, cpu, "Model %s Timing Information",
@@ -1020,8 +1020,8 @@ profile_print_speed (sim_cpu *cpu)
 {
   SIM_DESC sd = CPU_STATE (cpu);
   PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
-  unsigned long milliseconds = sim_events_elapsed_time (sd);
-  unsigned long total = PROFILE_TOTAL_INSN_COUNT (data);
+  unsigned long long milliseconds = sim_events_elapsed_time (sd);
+  unsigned long long total = PROFILE_TOTAL_INSN_COUNT (data);
   double clock;
   double secs;
   char comma_buf[20];
@@ -1040,14 +1040,14 @@ profile_print_speed (sim_cpu *cpu)
 	 MILLISECONDS first. This can marginally affect the result, but it's
 	 better that the user not perceive there's a math error.  */
       secs = (double) milliseconds / 1000;
-      secs = ((double) (unsigned long) (secs * 100 + .5)) / 100;
+      secs = ((double) (unsigned long long) (secs * 100 + .5)) / 100;
       profile_printf (sd, cpu, "  Total execution time   : %.2f seconds\n", secs);
       /* Don't confuse things with data that isn't useful.
 	 If we ran for less than 2 seconds, only use the data if we
 	 executed more than 100,000 insns.  */
       if (secs >= 2 || total >= 100000)
 	profile_printf (sd, cpu, "  Simulator speed:         %s insns/second\n",
-			COMMAS ((unsigned long) ((double) total / secs)));
+			COMMAS ((unsigned long long) ((double) total / secs)));
     }
 
   /* Print simulated execution time if the cpu frequency has been specified.  */
@@ -1069,7 +1069,7 @@ profile_print_speed (sim_cpu *cpu)
 	     but it's 	 better that the user not perceive there's a math
 	     error.  */
 	  secs = PROFILE_MODEL_TOTAL_CYCLES (data) / clock;
-	  secs = ((double) (unsigned long) (secs * 100 + .5)) / 100;
+	  secs = ((double) (unsigned long long) (secs * 100 + .5)) / 100;
 	  profile_printf (sd, cpu, "  Simulated execution time: %.2f seconds\n",
 			  secs);
 	}
@@ -1092,7 +1092,7 @@ profile_print_addr_ranges (sim_cpu *cpu)
       while (asr != NULL)
 	{
 	  profile_printf (sd, cpu, "  0x%lx - 0x%lx\n",
-			  (long) asr->start, (long) asr->end);
+			  (long long) asr->start, (long long) asr->end);
 	  asr = asr->next;
 	}
       profile_printf (sd, cpu, "\n");
diff --git a/sim/common/sim-profile.h b/sim/common/sim-profile.h
index 91c35c6..5e05366 100644
--- a/sim/common/sim-profile.h
+++ b/sim/common/sim-profile.h
@@ -140,11 +140,11 @@ typedef struct {
 
   /* The total insn count is tracked separately.
      It is always computed, regardless of insn profiling.  */
-  unsigned long total_insn_count;
+  unsigned long long total_insn_count;
 #define PROFILE_TOTAL_INSN_COUNT(p) ((p)->total_insn_count)
 
   /* CPU frequency.  Always accepted, regardless of profiling options.  */
-  unsigned long cpu_freq;
+  unsigned long long cpu_freq;
 #define PROFILE_CPU_FREQ(p) ((p)->cpu_freq)
 
 #if WITH_PROFILE_INSN_P
@@ -168,19 +168,19 @@ typedef struct {
 #if WITH_PROFILE_MODEL_P
   /* ??? Quick hack until more elaborate scheme is finished.  */
   /* Total cycle count, including stalls.  */
-  unsigned long total_cycles;
+  unsigned long long total_cycles;
 #define PROFILE_MODEL_TOTAL_CYCLES(p) ((p)->total_cycles)
   /* Stalls due to branches.  */
-  unsigned long cti_stall_cycles;
+  unsigned long long cti_stall_cycles;
 #define PROFILE_MODEL_CTI_STALL_CYCLES(p) ((p)->cti_stall_cycles)
-  unsigned long load_stall_cycles;
+  unsigned long long load_stall_cycles;
 #define PROFILE_MODEL_LOAD_STALL_CYCLES(p) ((p)->load_stall_cycles)
   /* Number of cycles the current instruction took.  */
-  unsigned long cur_insn_cycles;
+  unsigned long long cur_insn_cycles;
 #define PROFILE_MODEL_CUR_INSN_CYCLES(p) ((p)->cur_insn_cycles)
 
   /* Taken and not-taken branches (and other cti's).  */
-  unsigned long taken_count, untaken_count;
+  unsigned long long taken_count, untaken_count;
 #define PROFILE_MODEL_TAKEN_COUNT(p) ((p)->taken_count)
 #define PROFILE_MODEL_UNTAKEN_COUNT(p) ((p)->untaken_count)
 #endif
diff --git a/sim/common/sim-syscall.c b/sim/common/sim-syscall.c
index 7923160..08cb8d0 100644
--- a/sim/common/sim-syscall.c
+++ b/sim/common/sim-syscall.c
@@ -29,7 +29,7 @@
 
 int
 sim_syscall_read_mem (host_callback *cb ATTRIBUTE_UNUSED, struct cb_syscall *sc,
-		      unsigned long taddr, char *buf, int bytes)
+		      unsigned long long taddr, char *buf, int bytes)
 {
   SIM_DESC sd = (SIM_DESC) sc->p1;
   SIM_CPU *cpu = (SIM_CPU *) sc->p2;
@@ -41,7 +41,7 @@ sim_syscall_read_mem (host_callback *cb ATTRIBUTE_UNUSED, struct cb_syscall *sc,
 
 int
 sim_syscall_write_mem (host_callback *cb ATTRIBUTE_UNUSED, struct cb_syscall *sc,
-		       unsigned long taddr, const char *buf, int bytes)
+		       unsigned long long taddr, const char *buf, int bytes)
 {
   SIM_DESC sd = (SIM_DESC) sc->p1;
   SIM_CPU *cpu = (SIM_CPU *) sc->p2;
@@ -54,8 +54,8 @@ sim_syscall_write_mem (host_callback *cb ATTRIBUTE_UNUSED, struct cb_syscall *sc
 /* Main syscall callback for simulators.  */
 
 void
-sim_syscall_multi (SIM_CPU *cpu, int func, long arg1, long arg2, long arg3,
-		   long arg4, long *result, long *result2, int *errcode)
+sim_syscall_multi (SIM_CPU *cpu, int func, long long arg1, long long arg2, long long arg3,
+		   long long arg4, long long *result, long long *result2, int *errcode)
 {
   SIM_DESC sd = CPU_STATE (cpu);
   host_callback *cb = STATE_CALLBACK (sd);
@@ -108,10 +108,10 @@ sim_syscall_multi (SIM_CPU *cpu, int func, long arg1, long arg2, long arg3,
   *errcode = sc.errcode;
 }
 
-long
-sim_syscall (SIM_CPU *cpu, int func, long arg1, long arg2, long arg3, long arg4)
+long long
+sim_syscall (SIM_CPU *cpu, int func, long long arg1, long long arg2, long long arg3, long long arg4)
 {
-  long result, result2;
+  long long result, result2;
   int errcode;
 
   sim_syscall_multi (cpu, func, arg1, arg2, arg3, arg4, &result, &result2,
diff --git a/sim/common/sim-syscall.h b/sim/common/sim-syscall.h
index 8d77118..0ccc6b1 100644
--- a/sim/common/sim-syscall.h
+++ b/sim/common/sim-syscall.h
@@ -28,18 +28,18 @@
    not the case with these helpers.
 
    Note: Types here match the gdb callback interface.  */
-long sim_syscall (SIM_CPU *, int func, long arg1, long arg2, long arg3,
-		  long arg4);
+long long sim_syscall (SIM_CPU *, int func, long long arg1, long long arg2, long long arg3,
+		  long long arg4);
 
 /* Same as sim_syscall, but return the split values by referenced.  */
-void sim_syscall_multi (SIM_CPU *, int func, long arg1, long arg2, long arg3,
-			long arg4, long *result, long *result2, int *errcode);
+void sim_syscall_multi (SIM_CPU *, int func, long long arg1, long long arg2, long long arg3,
+			long long arg4, long long *result, long long *result2, int *errcode);
 
 /* Simple memory callbacks for cb_syscall's read_mem/write_mem that assume
    cb_syscall's p1 and p2 are set to the SIM_DESC and SIM_CPU respectively.  */
-int sim_syscall_read_mem (host_callback *, struct cb_syscall *, unsigned long,
+int sim_syscall_read_mem (host_callback *, struct cb_syscall *, unsigned long long,
 			  char *, int);
-int sim_syscall_write_mem (host_callback *, struct cb_syscall *, unsigned long,
+int sim_syscall_write_mem (host_callback *, struct cb_syscall *, unsigned long long,
 			   const char *, int);
 
 #endif
diff --git a/sim/common/sim-trace.c b/sim/common/sim-trace.c
index 77057a5..48da114 100644
--- a/sim/common/sim-trace.c
+++ b/sim/common/sim-trace.c
@@ -380,7 +380,7 @@ trace_option_handler (SIM_DESC sd, sim_cpu *cpu, int opt,
 	{
 	  int cpu_nr;
 	  char *chp = arg;
-	  unsigned long start,end;
+	  unsigned long long start,end;
 	  start = strtoul (chp, &chp, 0);
 	  if (*chp != ',')
 	    {
@@ -518,7 +518,7 @@ trace_uninstall (SIM_DESC sd)
 /* compute the nr of trace data units consumed by data */
 static int
 save_data_size (TRACE_DATA *data,
-		long size)
+		long long size)
 {
   return ((size + sizeof (TRACE_INPUT_DATA (data) [0]) - 1)
 	  / sizeof (TRACE_INPUT_DATA (data) [0]));
@@ -530,7 +530,7 @@ void
 save_data (SIM_DESC sd,
 	   TRACE_DATA *data,
 	   data_fmt fmt,
-	   long size,
+	   long long size,
 	   const void *buf)
 {
   int i = TRACE_INPUT_IDX (data);
@@ -547,7 +547,7 @@ static void
 print_data (SIM_DESC sd,
 	    sim_cpu *cpu,
 	    data_fmt fmt,
-	    long size,
+	    long long size,
 	    void *data)
 {
   switch (fmt)
@@ -561,12 +561,12 @@ print_data (SIM_DESC sd,
 	switch (size)
 	  {
 	  case sizeof (unsigned32):
-	    trace_printf (sd, cpu, " 0x%08lx", (long) * (unsigned32*) data);
+	    trace_printf (sd, cpu, " 0x%08lx", (long long) * (unsigned32*) data);
 	    break;
 	  case sizeof (unsigned64):
 	    trace_printf (sd, cpu, " 0x%08lx%08lx",
-			  (long) ((* (unsigned64*) data) >> 32),
-			  (long) * (unsigned64*) data);
+			  (long long) ((* (unsigned64*) data) >> 32),
+			  (long long) * (unsigned64*) data);
 	    break;
 	  default:
 	    abort ();
@@ -600,12 +600,12 @@ print_data (SIM_DESC sd,
 	  {
 	  case 4:
 	    trace_printf (sd, cpu, " (0x%08lx)",
-			  (long) *(unsigned32*)data);
+			  (long long) *(unsigned32*)data);
 	    break;
 	  case 8:
 	    trace_printf (sd, cpu, " (0x%08lx%08lx)",
-			  (long) (*(unsigned64*)data >> 32),
-			  (long) (*(unsigned64*)data));
+			  (long long) (*(unsigned64*)data >> 32),
+			  (long long) (*(unsigned64*)data));
 	    break;
 	  default:
 	    abort ();
@@ -693,8 +693,8 @@ trace_load_symbols (SIM_DESC sd)
 {
   bfd *abfd;
   asymbol **asymbols;
-  long symsize;
-  long symbol_count;
+  long long symsize;
+  long long symbol_count;
 
   /* Already loaded, so nothing to do.  */
   if (STATE_PROG_SYMS (sd))
@@ -725,7 +725,7 @@ bfd_vma
 trace_sym_value (SIM_DESC sd, const char *name)
 {
   asymbol **asymbols;
-  long i;
+  long long i;
 
   if (!trace_load_symbols (sd))
     return -1;
@@ -780,12 +780,12 @@ trace_prefix (SIM_DESC sd,
 	  sprintf (prefix, "%s:%-*d 0x%.*lx ",
 		   filename,
 		   SIZE_LINE_NUMBER, linenum,
-		   SIZE_PC, (long) pc);
+		   SIZE_PC, (long long) pc);
 	}
       else
 	{
 	  sprintf (prefix, "0x%.*lx ",
-		   SIZE_PC, (long) pc);
+		   SIZE_PC, (long long) pc);
 	  /* Shrink the width by the amount that we didn't print.  */
 	  width -= SIZE_LINE_NUMBER + SIZE_PC + 8;
 	}
diff --git a/sim/common/sim-trace.h b/sim/common/sim-trace.h
index 743bd86..1ed4db2 100644
--- a/sim/common/sim-trace.h
+++ b/sim/common/sim-trace.h
@@ -366,7 +366,7 @@ typedef enum {
 extern void save_data (SIM_DESC sd,
 		       TRACE_DATA *data,
 		       data_fmt fmt,
-		       long size,
+		       long long size,
 		       const void *buf);
 
 extern void trace_input0 (SIM_DESC sd,
diff --git a/sim/common/sim-utils.c b/sim/common/sim-utils.c
index 47bc843..0d5f037 100644
--- a/sim/common/sim-utils.c
+++ b/sim/common/sim-utils.c
@@ -52,7 +52,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
    allocation fails.  */
 
 void *
-zalloc (unsigned long size)
+zalloc (unsigned long long size)
 {
   return xcalloc (1, size);
 }
@@ -167,7 +167,7 @@ sim_io_eprintf_cpu (sim_cpu *cpu, const char *fmt, ...)
 /* Turn VALUE into a string with commas.  */
 
 char *
-sim_add_commas (char *buf, int sizeof_buf, unsigned long value)
+sim_add_commas (char *buf, int sizeof_buf, unsigned long long value)
 {
   int comma = 3;
   char *endbuf = buf + sizeof_buf - 1;
@@ -300,7 +300,7 @@ sim_elapsed_time_get (void)
 /* Return the elapsed time in milliseconds since START.
    The actual time may be cpu usage (preferred) or wall clock.  */
 
-unsigned long
+unsigned long long
 sim_elapsed_time_since (SIM_ELAPSED_TIME start)
 {
 #ifdef HAVE_GETRUSAGE
@@ -356,7 +356,7 @@ map_to_str (unsigned map)
     default:
       {
 	static char str[10];
-	sprintf (str, "(%ld)", (long) map);
+	sprintf (str, "(%ld)", (long long) map);
 	return str;
       }
     }
@@ -386,7 +386,7 @@ access_to_str (unsigned access)
     default:
       {
 	static char str[10];
-	sprintf (str, "(%ld)", (long) access);
+	sprintf (str, "(%ld)", (long long) access);
 	return str;
       }
     }
diff --git a/sim/common/sim-utils.h b/sim/common/sim-utils.h
index d81ec2f..b77a3d1 100644
--- a/sim/common/sim-utils.h
+++ b/sim/common/sim-utils.h
@@ -22,26 +22,26 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* Memory management with an allocator that clears memory before use. */
 
-void *zalloc (unsigned long size);
+void *zalloc (unsigned long long size);
 
 #define ZALLOC(TYPE) (TYPE*)zalloc(sizeof (TYPE))
 #define NZALLOC(TYPE,N) (TYPE*)zalloc(sizeof (TYPE) * (N))
 
 /* Turn VALUE into a string with commas.  */
-char *sim_add_commas (char *, int, unsigned long);
+char *sim_add_commas (char *, int, unsigned long long);
 
 /* Utilities for elapsed time reporting.  */
 
 /* Opaque type, known only inside sim_elapsed_time_foo fns. Externally
    it is known to never have the value zero. */
-typedef unsigned long SIM_ELAPSED_TIME;
+typedef unsigned long long SIM_ELAPSED_TIME;
 
 
 /* Get reference point for future call to sim_time_elapsed.  */
 SIM_ELAPSED_TIME sim_elapsed_time_get (void);
 
 /* Elapsed time in milliseconds since START.  */
-unsigned long sim_elapsed_time_since (SIM_ELAPSED_TIME start);
+unsigned long long sim_elapsed_time_since (SIM_ELAPSED_TIME start);
 
 /* Utilities for manipulating the load image.  */
 
diff --git a/sim/common/sim-watch.h b/sim/common/sim-watch.h
index fd6c5d9..7429032 100644
--- a/sim/common/sim-watch.h
+++ b/sim/common/sim-watch.h
@@ -36,8 +36,8 @@ struct _sim_watch_point {
   int interrupt_nr; /* == nr_interrupts -> breakpoint */
   int is_periodic;
   int is_within;
-  unsigned long arg0;
-  unsigned long arg1;
+  unsigned long long arg0;
+  unsigned long long arg1;
   sim_event *event;
   sim_watch_point *next;
 };
diff --git a/sim/common/syscall.c b/sim/common/syscall.c
index faf80c3..c154888 100644
--- a/sim/common/syscall.c
+++ b/sim/common/syscall.c
@@ -65,8 +65,8 @@
 #define FILE_XFR_SIZE 4096
 
 /* FIXME: for now, need to consider target word size.  */
-#define TWORD long
-#define TADDR unsigned long
+#define TWORD long long
+#define TADDR unsigned long long
 
 /* Path to be prepended to syscalls with absolute paths, and to be
    chdir:ed at startup, if not empty.  */
@@ -359,7 +359,7 @@ cb_syscall (host_callback *cb, CB_SYSCALL *sc)
     case CB_SYS_lseek :
       {
 	int fd = sc->arg1;
-	unsigned long offset = sc->arg2;
+	unsigned long long offset = sc->arg2;
 	int whence = sc->arg3;
 
 	result = (*cb->lseek) (cb, fd, offset, whence);
@@ -388,7 +388,7 @@ cb_syscall (host_callback *cb, CB_SYSCALL *sc)
     case CB_SYS_truncate :
       {
 	char *path;
-	long len = sc->arg2;
+	long long len = sc->arg2;
 
 	errcode = get_path (cb, sc, sc->arg1, &path);
 	if (errcode != 0)
@@ -407,7 +407,7 @@ cb_syscall (host_callback *cb, CB_SYSCALL *sc)
     case CB_SYS_ftruncate :
       {
 	int fd = sc->arg1;
-	long len = sc->arg2;
+	long long len = sc->arg2;
 
 	result = (*cb->ftruncate) (cb, fd, len);
 	if (result < 0)
diff --git a/sim/cr16/cr16_sim.h b/sim/cr16/cr16_sim.h
index 399dd27..a29b9cf 100644
--- a/sim/cr16/cr16_sim.h
+++ b/sim/cr16/cr16_sim.h
@@ -86,7 +86,7 @@ enum _ins_type
    INS_MAX
 };
 
-extern unsigned long ins_type_counters[ (int)INS_MAX ];
+extern unsigned long long ins_type_counters[ (int)INS_MAX ];
 
 enum {
   SP_IDX = 15,
@@ -169,25 +169,25 @@ enum {
 	    { \
 	    case 1: \
               printf ("SLOT %d *0x%08lx & 0x%02x | 0x%02x\n", i, \
-		      (long) SLOT[i].dest, \
+		      (long long) SLOT[i].dest, \
                       (unsigned) SLOT[i].mask._1, \
                       (unsigned) SLOT[i].data._1); \
 	      break; \
 	    case 2: \
               printf ("SLOT %d *0x%08lx & 0x%04x | 0x%04x\n", i, \
-		      (long) SLOT[i].dest, \
+		      (long long) SLOT[i].dest, \
                       (unsigned) SLOT[i].mask._2, \
                       (unsigned) SLOT[i].data._2); \
 	      break; \
 	    case 4: \
               printf ("SLOT %d *0x%08lx & 0x%08x | 0x%08x\n", i, \
-		      (long) SLOT[i].dest, \
+		      (long long) SLOT[i].dest, \
                       (unsigned) SLOT[i].mask._4, \
                       (unsigned) SLOT[i].data._4); \
 	      break; \
 	    case 8: \
               printf ("SLOT %d *0x%08lx & 0x%08x%08x | 0x%08x%08x\n", i, \
-		      (long) SLOT[i].dest, \
+		      (long long) SLOT[i].dest, \
                       (unsigned) (SLOT[i].mask._8 >> 32),  \
                       (unsigned) SLOT[i].mask._8, \
                       (unsigned) (SLOT[i].data._8 >> 32),  \
diff --git a/sim/cr16/gencode.c b/sim/cr16/gencode.c
index 0057ca8..9144e22 100644
--- a/sim/cr16/gencode.c
+++ b/sim/cr16/gencode.c
@@ -110,12 +110,12 @@ write_template (void)
 }
 
 
-long Opcodes[512];
+long long Opcodes[512];
 static int curop=0;
 
 #if 0
 static void
-check_opcodes( long op)
+check_opcodes( long long op)
 {
   int i;
 
diff --git a/sim/cr16/interp.c b/sim/cr16/interp.c
index ed738bc..c34ee4c 100644
--- a/sim/cr16/interp.c
+++ b/sim/cr16/interp.c
@@ -55,7 +55,7 @@ struct hash_entry
 
 struct hash_entry hash_table[MAX_HASH+1];
 
-INLINE static long
+INLINE static long long
 hash(unsigned long long insn, int format)
 { 
   unsigned int i = 4, tmp;
@@ -127,12 +127,12 @@ get_operands (operand_desc *s, uint64 ins, int isize, int nops)
              else
                OP[i] = ((ins >> (32 - start_bit)) & ((1 << op_size) -1));
 
-             if (OP[i] & ((long)1 << (op_size -1))) 
+             if (OP[i] & ((long long)1 << (op_size -1))) 
                {
                  sign_flag = 1;
                  OP[i] = ~(OP[i]) + 1;
                }
-             OP[i] = (unsigned long int)(OP[i] & (((long)1 << op_size) -1));
+             OP[i] = (unsigned long long int)(OP[i] & (((long long)1 << op_size) -1));
             }
             break;
 
@@ -175,7 +175,7 @@ get_operands (operand_desc *s, uint64 ins, int isize, int nops)
             break;
 
           case uimm20: case imm20:
-            OP[i] = ins & (((long)1 << op_size) - 1);
+            OP[i] = ins & (((long long)1 << op_size) - 1);
             break;
 
           case imm32: case uimm32:
@@ -188,22 +188,22 @@ get_operands (operand_desc *s, uint64 ins, int isize, int nops)
           case disps5: 
             OP[i] = (ins >> 4) & ((1 << 4) - 1); 
             OP[i] = (OP[i] * 2) + 2;
-            if (OP[i] & ((long)1 << 5)) 
+            if (OP[i] & ((long long)1 << 5)) 
               {
                 sign_flag = 1;
                 OP[i] = ~(OP[i]) + 1;
-                OP[i] = (unsigned long int)(OP[i] & 0x1F);
+                OP[i] = (unsigned long long int)(OP[i] & 0x1F);
               }
             break;
 
           case dispe9: 
             OP[i] = ((((ins >> 8) & 0xf) << 4) | (ins & 0xf)); 
             OP[i] <<= 1;
-            if (OP[i] & ((long)1 << 8)) 
+            if (OP[i] & ((long long)1 << 8)) 
               {
                 sign_flag = 1;
                 OP[i] = ~(OP[i]) + 1;
-                OP[i] = (unsigned long int)(OP[i] & 0xFF);
+                OP[i] = (unsigned long long int)(OP[i] & 0xFF);
               }
             break;
 
@@ -214,7 +214,7 @@ get_operands (operand_desc *s, uint64 ins, int isize, int nops)
                 OP[i] = (OP[i] & 0xFFFE);
                 sign_flag = 1;
                 OP[i] = ~(OP[i]) + 1;
-                OP[i] = (unsigned long int)(OP[i] & 0xFFFF);
+                OP[i] = (unsigned long long int)(OP[i] & 0xFFFF);
               }
             break;
 
@@ -230,7 +230,7 @@ get_operands (operand_desc *s, uint64 ins, int isize, int nops)
                 OP[i] = (OP[i] & 0xFFFFFE);
                 sign_flag = 1;
                 OP[i] = ~(OP[i]) + 1;
-                OP[i] = (unsigned long int)(OP[i] & 0xFFFFFF);
+                OP[i] = (unsigned long long int)(OP[i] & 0xFFFFFF);
               }
             break;
 
@@ -669,7 +669,7 @@ sim_create_inferior (SIM_DESC sd, struct bfd *abfd,
     start_address = 0x0;
 #ifdef DEBUG
   if (cr16_debug)
-    sim_io_printf (sd, "sim_create_inferior:  PC=0x%lx\n", (long) start_address);
+    sim_io_printf (sd, "sim_create_inferior:  PC=0x%lx\n", (long long) start_address);
 #endif
   {
     SIM_CPU *cpu = STATE_CPU (sd, 0);
diff --git a/sim/cr16/sim-main.h b/sim/cr16/sim-main.h
index 52cbf7f..7dbff6c 100644
--- a/sim/cr16/sim-main.h
+++ b/sim/cr16/sim-main.h
@@ -21,8 +21,8 @@
 
 #include "sim-basics.h"
 
-typedef long int           word;
-typedef unsigned long int  uword;
+typedef long long int           word;
+typedef unsigned long long int  uword;
 
 #include "sim-base.h"
 #include "bfd.h"
diff --git a/sim/cr16/simops.c b/sim/cr16/simops.c
index 8a57a67..5484238 100644
--- a/sim/cr16/simops.c
+++ b/sim/cr16/simops.c
@@ -242,7 +242,7 @@ trace_input_func (SIM_DESC sd, const char *name, enum op_types in1, enum op_type
   int i;
   char buf[1024];
   char *p;
-  long tmp;
+  long long tmp;
   char *type;
   const char *filename;
   const char *functionname;
@@ -409,7 +409,7 @@ trace_input_func (SIM_DESC sd, const char *name, enum op_types in1, enum op_type
 	      break;
 
 	    case OP_REGP:
-	      tmp = (long)((((uint32) GPR (OP[i])) << 16) | ((uint32) GPR (OP[i] + 1)));
+	      tmp = (long long)((((uint32) GPR (OP[i])) << 16) | ((uint32) GPR (OP[i] + 1)));
 	      sim_io_printf (sd, "%*s0x%.8lx", SIZE_VALUES-10, "", tmp);
 	      break;
 
@@ -475,7 +475,7 @@ trace_output_40 (SIM_DESC sd, uint64 val)
 					 SIZE_VALUES - 12,
 					 "",
 					 ((int)(val >> 32) & 0xff),
-					 ((unsigned long) val) & 0xffffffff);
+					 ((unsigned long long) val) & 0xffffffff);
       do_trace_output_finish ();
     }
 }
@@ -4452,7 +4452,7 @@ OP_44_8 (SIM_DESC sd, SIM_CPU *cpu)
   uint16 a = (GPR (OP[0])) & 0xff;
   uint16 tmp, b = (GPR (OP[1])) & 0xFF;
   trace_input ("lshb", OP_REG, OP_REG, OP_VOID);
-  if (a & ((long)1 << 3))
+  if (a & ((long long)1 << 3))
     {
       sign_flag = 1;
       a = ~(a) + 1;
@@ -4478,7 +4478,7 @@ OP_46_8 (SIM_DESC sd, SIM_CPU *cpu)
   uint16 tmp, b = GPR (OP[1]);
   int16 a = GPR (OP[0]);
   trace_input ("lshw", OP_REG, OP_REG, OP_VOID);
-  if (a & ((long)1 << 4))
+  if (a & ((long long)1 << 4))
     {
       sign_flag = 1;
       a = ~(a) + 1;
@@ -4543,7 +4543,7 @@ OP_47_8 (SIM_DESC sd, SIM_CPU *cpu)
   uint32 tmp, b = GPR32 (OP[1]);
   uint16 a = GPR (OP[0]);
   trace_input ("lshd", OP_REG, OP_REGP, OP_VOID);
-  if (a & ((long)1 << 5))
+  if (a & ((long long)1 << 5))
     {
       sign_flag = 1;
       a = ~(a) + 1;
@@ -4611,7 +4611,7 @@ OP_41_8 (SIM_DESC sd, SIM_CPU *cpu)
   int8 tmp, b = (GPR (OP[1])) & 0xFF;
   trace_input ("ashub", OP_REG, OP_REG, OP_VOID);
 
-  if (a & ((long)1 << 3))
+  if (a & ((long long)1 << 3))
     {
       sign_flag = 1;
       a = ~(a) + 1;
@@ -4679,7 +4679,7 @@ OP_45_8 (SIM_DESC sd, SIM_CPU *cpu)
   int16 a = GPR (OP[0]), b = GPR (OP[1]);
   trace_input ("ashuw", OP_REG, OP_REG, OP_VOID);
 
-  if (a & ((long)1 << 4))
+  if (a & ((long long)1 << 4))
     {
       sign_flag = 1;
       a = ~(a) + 1;
@@ -4744,7 +4744,7 @@ OP_48_8 (SIM_DESC sd, SIM_CPU *cpu)
   int32 a = GPR32 (OP[0]), b = GPR32 (OP[1]);
   trace_input ("ashud", OP_REGP, OP_REGP, OP_VOID);
 
-  if (a & ((long)1 << 5))
+  if (a & ((long long)1 << 5))
     {
       sign_flag = 1;
       a = ~(a) + 1;
@@ -5093,7 +5093,7 @@ OP_C_C (SIM_DESC sd, SIM_CPU *cpu)
 	for (i = 0; i < 2; i++)
 	  sim_io_printf (sd, " %.2x%.8lx",
 					     ((int)(ACC (i) >> 32) & 0xff),
-					     ((unsigned long) ACC (i)) & 0xffffffff);
+					     ((unsigned long long) ACC (i)) & 0xffffffff);
 
 	sim_io_printf (sd, "  %d  %d %d\n",
 					   PSR_F != 0, PSR_F != 0, PSR_C != 0);
@@ -5334,22 +5334,22 @@ OP_C_C (SIM_DESC sd, SIM_CPU *cpu)
 	  case TARGET_SYS_read:
 	    trace_input ("<read>", OP_REG, OP_MEMREF, OP_REG);
 	    RETVAL (cb->read (cb, PARM1,
-			      MEMPTR (((unsigned long)PARM3 << 16)
-				      | ((unsigned long)PARM2)), PARM4));
+			      MEMPTR (((unsigned long long)PARM3 << 16)
+				      | ((unsigned long long)PARM2)), PARM4));
 	    trace_output_16 (sd, result);
 	    break;
 
 	  case TARGET_SYS_write:
 	    trace_input ("<write>", OP_REG, OP_MEMREF, OP_REG);
 	    RETVAL ((int)cb->write (cb, PARM1,
-				    MEMPTR (((unsigned long)PARM3 << 16)
+				    MEMPTR (((unsigned long long)PARM3 << 16)
 					    | PARM2), PARM4));
 	    trace_output_16 (sd, result);
 	    break;
 
 	  case TARGET_SYS_lseek:
 	    trace_input ("<lseek>", OP_REG, OP_REGP, OP_REG);
-	    RETVAL32 (cb->lseek (cb, PARM1, ((((long) PARM3) << 16) | PARM2),
+	    RETVAL32 (cb->lseek (cb, PARM1, ((((long long) PARM3) << 16) | PARM2),
 				 PARM4));
 	    trace_output_32 (sd, result);
 	    break;
@@ -5362,7 +5362,7 @@ OP_C_C (SIM_DESC sd, SIM_CPU *cpu)
 
 	  case TARGET_SYS_open:
 	    trace_input ("<open>", OP_MEMREF, OP_REG, OP_VOID);
-	    RETVAL32 (cb->open (cb, MEMPTR ((((unsigned long)PARM2) << 16)
+	    RETVAL32 (cb->open (cb, MEMPTR ((((unsigned long long)PARM2) << 16)
 					    | PARM1), PARM3));
 	    trace_output_32 (sd, result);
 	    break;
@@ -5370,8 +5370,8 @@ OP_C_C (SIM_DESC sd, SIM_CPU *cpu)
 #ifdef TARGET_SYS_rename
 	  case TARGET_SYS_rename:
 	    trace_input ("<rename>", OP_MEMREF, OP_MEMREF, OP_VOID);
-	    RETVAL (cb->rename (cb, MEMPTR ((((unsigned long)PARM2) << 16) | PARM1),
-				    MEMPTR ((((unsigned long)PARM4) << 16) | PARM3)));
+	    RETVAL (cb->rename (cb, MEMPTR ((((unsigned long long)PARM2) << 16) | PARM1),
+				    MEMPTR ((((unsigned long long)PARM4) << 16) | PARM3)));
 	    trace_output_16 (sd, result);
 	    break;
 #endif
@@ -5390,7 +5390,7 @@ OP_C_C (SIM_DESC sd, SIM_CPU *cpu)
 
 	  case TARGET_SYS_unlink:
 	    trace_input ("<unlink>", OP_MEMREF, OP_VOID, OP_VOID);
-	    RETVAL (cb->unlink (cb, MEMPTR (((unsigned long)PARM2 << 16) | PARM1)));
+	    RETVAL (cb->unlink (cb, MEMPTR (((unsigned long long)PARM2 << 16) | PARM1)));
 	    trace_output_16 (sd, result);
 	    break;
 
@@ -5403,7 +5403,7 @@ OP_C_C (SIM_DESC sd, SIM_CPU *cpu)
 	      struct stat host_stat;
 	      reg_t buf;
 
-	      RETVAL (stat (MEMPTR ((((unsigned long)PARM2) << 16)|PARM1), &host_stat));
+	      RETVAL (stat (MEMPTR ((((unsigned long long)PARM2) << 16)|PARM1), &host_stat));
 
 	      buf = PARM2;
 
diff --git a/sim/cris/cris-opc.h b/sim/cris/cris-opc.h
index 0493fd1..49be5af 100644
--- a/sim/cris/cris-opc.h
+++ b/sim/cris/cris-opc.h
@@ -109,32 +109,32 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_operand1;
-  long f_size;
-  long f_opcode;
-  long f_mode;
-  long f_operand2;
-  long f_memmode;
-  long f_membit;
-  long f_b5;
-  long f_opcode_hi;
-  long f_dstsrc;
-  long f_u6;
-  long f_s6;
-  long f_u5;
-  long f_u4;
-  long f_s8;
-  long f_disp9_hi;
-  long f_disp9_lo;
-  long f_disp9;
-  long f_qo;
-  long f_indir_pc__byte;
-  long f_indir_pc__word;
-  long f_indir_pc__word_pcrel;
-  long f_indir_pc__dword;
-  long f_indir_pc__dword_pcrel;
+  long long f_nil;
+  long long f_anyof;
+  long long f_operand1;
+  long long f_size;
+  long long f_opcode;
+  long long f_mode;
+  long long f_operand2;
+  long long f_memmode;
+  long long f_membit;
+  long long f_b5;
+  long long f_opcode_hi;
+  long long f_dstsrc;
+  long long f_u6;
+  long long f_s6;
+  long long f_u5;
+  long long f_u4;
+  long long f_s8;
+  long long f_disp9_hi;
+  long long f_disp9_lo;
+  long long f_disp9;
+  long long f_qo;
+  long long f_indir_pc__byte;
+  long long f_indir_pc__word;
+  long long f_indir_pc__word_pcrel;
+  long long f_indir_pc__dword;
+  long long f_indir_pc__dword_pcrel;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/sim/cris/cris-tmpl.c b/sim/cris/cris-tmpl.c
index 9c90e3c..3406fde 100644
--- a/sim/cris/cris-tmpl.c
+++ b/sim/cris/cris-tmpl.c
@@ -123,12 +123,12 @@ MY (f_model_insn_before) (SIM_CPU *current_cpu, int first_p ATTRIBUTE_UNUSED)
     SIM_DESC sd = CPU_STATE (current_cpu);
 
     cris_trace_printf (sd, current_cpu, "%lx ",
-		       0xffffffffUL & (unsigned long) (CPU (h_pc)));
+		       0xffffffffUL & (unsigned long long) (CPU (h_pc)));
 
     for (i = 0; i < 15; i++)
       cris_trace_printf (sd, current_cpu, "%lx ",
 			 0xffffffffUL
-			 & (unsigned long) (XCONCAT3(crisv,BASENUM,
+			 & (unsigned long long) (XCONCAT3(crisv,BASENUM,
 						     f_h_gr_get) (current_cpu,
 								  i)));
     flags[0] = GET_H_IBIT () != 0 ? 'I' : 'i';
@@ -151,7 +151,7 @@ MY (f_model_insn_before) (SIM_CPU *current_cpu, int first_p ATTRIBUTE_UNUSED)
       cris_trace_printf (sd, current_cpu, "%s %d %lx\n", flags,
 			 (int) cycle_count,
 			 0xffffffffUL
-			 & (unsigned long) (XCONCAT3(crisv,BASENUM,
+			 & (unsigned long long) (XCONCAT3(crisv,BASENUM,
 						     f_h_gr_get) (current_cpu,
 								  15)));
     else
@@ -215,7 +215,7 @@ MY (f_model_update_insn_cycles) (SIM_CPU *current_cpu ATTRIBUTE_UNUSED,
 
 #if 0
 void
-MY (f_model_record_cycles) (SIM_CPU *current_cpu, unsigned long cycles)
+MY (f_model_record_cycles) (SIM_CPU *current_cpu, unsigned long long cycles)
 {
   abort ();
 }
diff --git a/sim/cris/traps.c b/sim/cris/traps.c
index a778a1f..86a8fd6 100644
--- a/sim/cris/traps.c
+++ b/sim/cris/traps.c
@@ -1564,9 +1564,9 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 					"0x%lx)\n",
 					callnum == TARGET_SYS_fcntl
 					? "fcntl" : "fcntl64",
-					(unsigned long) (USI) arg1,
-					(unsigned long) (USI) arg2,
-					(unsigned long) (USI) arg3);
+					(unsigned long long) (USI) arg1,
+					(unsigned long long) (USI) arg2,
+					(unsigned long long) (USI) arg3);
 	      break;
 	    }
 	  break;
@@ -1713,12 +1713,12 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 						 "Unimplemented mmap2 call "
 						 "(0x%lx, 0x%lx, 0x%lx, "
 						 "0x%lx, 0x%lx, 0x%lx)\n",
-						 (unsigned long) arg1,
-						 (unsigned long) arg2,
-						 (unsigned long) arg3,
-						 (unsigned long) arg4,
-						 (unsigned long) arg5,
-						 (unsigned long) arg6);
+						 (unsigned long long) arg1,
+						 (unsigned long long) arg2,
+						 (unsigned long long) arg3,
+						 (unsigned long long) arg4,
+						 (unsigned long long) arg5,
+						 (unsigned long long) arg6);
 		break;
 	      }
 	    else if (fd != (USI) -1)
@@ -1871,9 +1871,9 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 		  = cris_unknown_syscall (current_cpu, pc,
 					  "Unimplemented mprotect call "
 					  "(0x%lx, 0x%lx, 0x%lx)\n",
-					  (unsigned long) arg1,
-					  (unsigned long) arg2,
-					  (unsigned long) arg3);
+					  (unsigned long long) arg1,
+					  (unsigned long long) arg2,
+					  (unsigned long long) arg3);
 		break;
 	      }
 
@@ -1936,10 +1936,10 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 		  = cris_unknown_syscall (current_cpu, pc,
 					  "Unimplemented wait4 call "
 					  "(0x%lx, 0x%lx, 0x%lx, 0x%lx)\n",
-					  (unsigned long) arg1,
-					  (unsigned long) arg2,
-					  (unsigned long) arg3,
-					  (unsigned long) arg4);
+					  (unsigned long long) arg1,
+					  (unsigned long long) arg2,
+					  (unsigned long long) arg3,
+					  (unsigned long long) arg4);
 		break;
 	      }
 
@@ -2052,14 +2052,14 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 					      "(0x%lx, 0x%lx: "
 					      "[0x%x, 0x%x, 0x%x, "
 					      "{0x%x, 0x%x}], 0x%lx)\n",
-					      (unsigned long) arg1,
-					      (unsigned long) arg2,
+					      (unsigned long long) arg1,
+					      (unsigned long long) arg2,
 					      target_sa_handler,
 					      target_sa_flags,
 					      target_sa_restorer,
 					      target_sa_mask_low,
 					      target_sa_mask_high,
-					      (unsigned long) arg3);
+					      (unsigned long long) arg3);
 		    break;
 		  }
 
@@ -2186,9 +2186,9 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 					  "Unimplemented poll syscall "
 					  "(0x%lx: [0x%x, 0x%x, x], "
 					  "0x%lx, 0x%lx)\n",
-					  (unsigned long) arg1, fd, events,
-					  (unsigned long) arg2,
-					  (unsigned long) arg3);
+					  (unsigned long long) arg1, fd, events,
+					  (unsigned long long) arg2,
+					  (unsigned long long) arg3);
 		break;
 	      }
 
@@ -2494,12 +2494,12 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 					  "no signal handler active "
 					  "(0x%lx, 0x%lx, 0x%lx, 0x%lx, "
 					  "0x%lx, 0x%lx)\n",
-					  (unsigned long) arg1,
-					  (unsigned long) arg2,
-					  (unsigned long) arg3,
-					  (unsigned long) arg4,
-					  (unsigned long) arg5,
-					  (unsigned long) arg6);
+					  (unsigned long long) arg1,
+					  (unsigned long long) arg2,
+					  (unsigned long long) arg3,
+					  (unsigned long long) arg4,
+					  (unsigned long long) arg5,
+					  (unsigned long long) arg6);
 		break;
 	      }
 
@@ -2570,8 +2570,8 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 		  = cris_unknown_syscall (current_cpu, pc,
 					  "Unimplemented rt_sigsuspend syscall"
 					  " arguments (0x%lx, 0x%lx)\n",
-					  (unsigned long) arg1,
-					  (unsigned long) arg2);
+					  (unsigned long long) arg1,
+					  (unsigned long long) arg2);
 		break;
 	      }
 
@@ -2776,8 +2776,8 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 		      = cris_unknown_syscall (current_cpu, pc,
 					      "Unimplemented readlink syscall "
 					      "(0x%lx: [\"%s\"], 0x%lx)\n",
-					      (unsigned long) arg1, pbuf,
-					      (unsigned long) arg2);
+					      (unsigned long long) arg1, pbuf,
+					      (unsigned long long) arg2);
 		    break;
 		  }
 		else if (*argv0 == '/')
@@ -3015,14 +3015,14 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 				      "Unimplemented _sysctl syscall "
 				      "(0x%lx: [0x%lx, 0x%lx],"
 				      " 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx)\n",
-				      (unsigned long) name,
-				      (unsigned long) name0,
-				      (unsigned long) name1,
-				      (unsigned long) nlen,
-				      (unsigned long) oldval,
-				      (unsigned long) oldlenp,
-				      (unsigned long) newval,
-				      (unsigned long) newlen);
+				      (unsigned long long) name,
+				      (unsigned long long) name0,
+				      (unsigned long long) name1,
+				      (unsigned long long) nlen,
+				      (unsigned long long) oldval,
+				      (unsigned long long) oldlenp,
+				      (unsigned long long) newval,
+				      (unsigned long long) newlen);
 	    break;
 	  }
 
@@ -3099,8 +3099,8 @@ cris_break_13_handler (SIM_CPU *current_cpu, USI callnum, USI arg1,
 		  = cris_unknown_syscall (current_cpu, pc,
 					  "Unimplemented clone syscall "
 					  "(0x%lx, 0x%lx)\n",
-					  (unsigned long) arg1,
-					  (unsigned long) arg2);
+					  (unsigned long long) arg1,
+					  (unsigned long long) arg2);
 		break;
 	      }
 
@@ -3328,10 +3328,10 @@ cris_pipe_empty (host_callback *cb,
 
 /* We have a simulator-specific notion of time.  See TARGET_TIME.  */
 
-static long
-cris_time (host_callback *cb ATTRIBUTE_UNUSED, long *t)
+static long long
+cris_time (host_callback *cb ATTRIBUTE_UNUSED, long long *t)
 {
-  long retval = TARGET_TIME (current_cpu_for_cb_callback);
+  long long retval = TARGET_TIME (current_cpu_for_cb_callback);
   if (t)
     *t = retval;
   return retval;
diff --git a/sim/d10v/d10v_sim.h b/sim/d10v/d10v_sim.h
index 86243c9..6ee0f83 100644
--- a/sim/d10v/d10v_sim.h
+++ b/sim/d10v/d10v_sim.h
@@ -38,9 +38,9 @@ typedef uint16 reg_t;
 
 struct simops 
 {
-  long opcode;
+  long long opcode;
   int  is_long;
-  long mask;
+  long long mask;
   int format;
   int cycles;
   int unit;
@@ -77,7 +77,7 @@ enum _ins_type
   INS_MAX
 };
 
-extern unsigned long ins_type_counters[ (int)INS_MAX ];
+extern unsigned long long ins_type_counters[ (int)INS_MAX ];
 
 enum {
   SP_IDX = 15,
@@ -169,25 +169,25 @@ enum {
 	    { \
 	    case 1: \
               printf ("SLOT %d *0x%08lx & 0x%02x | 0x%02x\n", i, \
-		      (long) SLOT[i].dest, \
+		      (long long) SLOT[i].dest, \
                       (unsigned) SLOT[i].mask._1, \
                       (unsigned) SLOT[i].data._1); \
 	      break; \
 	    case 2: \
               printf ("SLOT %d *0x%08lx & 0x%04x | 0x%04x\n", i, \
-		      (long) SLOT[i].dest, \
+		      (long long) SLOT[i].dest, \
                       (unsigned) SLOT[i].mask._2, \
                       (unsigned) SLOT[i].data._2); \
 	      break; \
 	    case 4: \
               printf ("SLOT %d *0x%08lx & 0x%08x | 0x%08x\n", i, \
-		      (long) SLOT[i].dest, \
+		      (long long) SLOT[i].dest, \
                       (unsigned) SLOT[i].mask._4, \
                       (unsigned) SLOT[i].data._4); \
 	      break; \
 	    case 8: \
               printf ("SLOT %d *0x%08lx & 0x%08x%08x | 0x%08x%08x\n", i, \
-		      (long) SLOT[i].dest, \
+		      (long long) SLOT[i].dest, \
                       (unsigned) (SLOT[i].mask._8 >> 32),  \
                       (unsigned) SLOT[i].mask._8, \
                       (unsigned) (SLOT[i].data._8 >> 32),  \
diff --git a/sim/d10v/gencode.c b/sim/d10v/gencode.c
index 9f8a41c..5f7ed0a 100644
--- a/sim/d10v/gencode.c
+++ b/sim/d10v/gencode.c
@@ -83,11 +83,11 @@ write_template (void)
 }
 
 
-long Opcodes[512];
+long long Opcodes[512];
 static int curop=0;
 
 static void
-check_opcodes( long op)
+check_opcodes( long long op)
 {
   int i;
 
diff --git a/sim/d10v/interp.c b/sim/d10v/interp.c
index cb8c6cf..197215a 100644
--- a/sim/d10v/interp.c
+++ b/sim/d10v/interp.c
@@ -31,17 +31,17 @@ int d10v_debug;
 
 int old_segment_mapping;
 
-unsigned long ins_type_counters[ (int)INS_MAX ];
+unsigned long long ins_type_counters[ (int)INS_MAX ];
 
 uint16 OP[4];
 
-static long hash (long insn, int format);
+static long long hash (long long insn, int format);
 static struct hash_entry *lookup_hash (SIM_DESC, SIM_CPU *, uint32 ins, int size);
 static void get_operands (struct simops *s, uint32 ins);
 static void do_long (SIM_DESC, SIM_CPU *, uint32 ins);
 static void do_2_short (SIM_DESC, SIM_CPU *, uint16 ins1, uint16 ins2, enum _leftright leftright);
 static void do_parallel (SIM_DESC, SIM_CPU *, uint16 ins1, uint16 ins2);
-static char *add_commas (char *buf, int sizeof_buf, unsigned long value);
+static char *add_commas (char *buf, int sizeof_buf, unsigned long long value);
 static INLINE uint8 *map_memory (SIM_DESC, SIM_CPU *, unsigned phys_addr);
 
 #define MAX_HASH  63
@@ -56,8 +56,8 @@ struct hash_entry
 
 struct hash_entry hash_table[MAX_HASH+1];
 
-INLINE static long 
-hash (long insn, int format)
+INLINE static long long 
+hash (long long insn, int format)
 {
   if (format & LONG_OPCODE)
     return ((insn & 0x3F000000) >> 24);
@@ -235,7 +235,7 @@ do_parallel (SIM_DESC sd, SIM_CPU *cpu, uint16 ins1, uint16 ins2)
 }
  
 static char *
-add_commas (char *buf, int sizeof_buf, unsigned long value)
+add_commas (char *buf, int sizeof_buf, unsigned long long value)
 {
   int comma = 3;
   char *endbuf = buf + sizeof_buf - 1;
@@ -292,7 +292,7 @@ enum
   };
 
 static void
-set_dmap_register (SIM_DESC sd, int reg_nr, unsigned long value)
+set_dmap_register (SIM_DESC sd, int reg_nr, unsigned long long value)
 {
   uint8 *raw = map_memory (sd, NULL, SIM_D10V_MEMORY_DATA
 			   + DMAP0_OFFSET + 2 * reg_nr);
@@ -305,7 +305,7 @@ set_dmap_register (SIM_DESC sd, int reg_nr, unsigned long value)
 #endif
 }
 
-static unsigned long
+static unsigned long long
 dmap_register (SIM_DESC sd, SIM_CPU *cpu, void *regcache, int reg_nr)
 {
   uint8 *raw = map_memory (sd, cpu, SIM_D10V_MEMORY_DATA
@@ -314,7 +314,7 @@ dmap_register (SIM_DESC sd, SIM_CPU *cpu, void *regcache, int reg_nr)
 }
 
 static void
-set_imap_register (SIM_DESC sd, int reg_nr, unsigned long value)
+set_imap_register (SIM_DESC sd, int reg_nr, unsigned long long value)
 {
   uint8 *raw = map_memory (sd, NULL, SIM_D10V_MEMORY_DATA
 			   + IMAP0_OFFSET + 2 * reg_nr);
@@ -327,7 +327,7 @@ set_imap_register (SIM_DESC sd, int reg_nr, unsigned long value)
 #endif
 }
 
-static unsigned long
+static unsigned long long
 imap_register (SIM_DESC sd, SIM_CPU *cpu, void *regcache, int reg_nr)
 {
   uint8 *raw = map_memory (sd, cpu, SIM_D10V_MEMORY_DATA
@@ -341,7 +341,7 @@ enum
     HELD_SPU_IDX = 1
   };
 
-static unsigned long
+static unsigned long long
 spu_register (void)
 {
   if (PSW_SM)
@@ -350,7 +350,7 @@ spu_register (void)
     return HELD_SP (HELD_SPU_IDX);
 }
 
-static unsigned long
+static unsigned long long
 spi_register (void)
 {
   if (!PSW_SM)
@@ -360,7 +360,7 @@ spi_register (void)
 }
 
 static void
-set_spi_register (unsigned long value)
+set_spi_register (unsigned long long value)
 {
   if (!PSW_SM)
     SET_GPR (SP_IDX, value);
@@ -368,7 +368,7 @@ set_spi_register (unsigned long value)
 }
 
 static void
-set_spu_register  (unsigned long value)
+set_spu_register  (unsigned long long value)
 {
   if (PSW_SM)
     SET_GPR (SP_IDX, value);
@@ -378,14 +378,14 @@ set_spu_register  (unsigned long value)
 /* Given a virtual address in the DMAP address space, translate it
    into a physical address. */
 
-static unsigned long
+static unsigned long long
 sim_d10v_translate_dmap_addr (SIM_DESC sd,
 			      SIM_CPU *cpu,
-			      unsigned long offset,
+			      unsigned long long offset,
 			      int nr_bytes,
-			      unsigned long *phys,
+			      unsigned long long *phys,
 			      void *regcache,
-			      unsigned long (*dmap_register) (SIM_DESC,
+			      unsigned long long (*dmap_register) (SIM_DESC,
 							      SIM_CPU *,
 							      void *regcache,
 							      int reg_nr))
@@ -442,14 +442,14 @@ sim_d10v_translate_dmap_addr (SIM_DESC sd,
 /* Given a virtual address in the IMAP address space, translate it
    into a physical address. */
 
-static unsigned long
+static unsigned long long
 sim_d10v_translate_imap_addr (SIM_DESC sd,
 			      SIM_CPU *cpu,
-			      unsigned long offset,
+			      unsigned long long offset,
 			      int nr_bytes,
-			      unsigned long *phys,
+			      unsigned long long *phys,
 			      void *regcache,
-			      unsigned long (*imap_register) (SIM_DESC,
+			      unsigned long long (*imap_register) (SIM_DESC,
 							      SIM_CPU *,
 							      void *regcache,
 							      int reg_nr))
@@ -499,25 +499,25 @@ sim_d10v_translate_imap_addr (SIM_DESC sd,
   return nr_bytes;
 }
 
-static unsigned long
+static unsigned long long
 sim_d10v_translate_addr (SIM_DESC sd,
 			 SIM_CPU *cpu,
-			 unsigned long memaddr,
+			 unsigned long long memaddr,
 			 int nr_bytes,
-			 unsigned long *targ_addr,
+			 unsigned long long *targ_addr,
 			 void *regcache,
-			 unsigned long (*dmap_register) (SIM_DESC,
+			 unsigned long long (*dmap_register) (SIM_DESC,
 							 SIM_CPU *,
 							 void *regcache,
 							 int reg_nr),
-			 unsigned long (*imap_register) (SIM_DESC,
+			 unsigned long long (*imap_register) (SIM_DESC,
 							 SIM_CPU *,
 							 void *regcache,
 							 int reg_nr))
 {
-  unsigned long phys;
-  unsigned long seg;
-  unsigned long off;
+  unsigned long long phys;
+  unsigned long long seg;
+  unsigned long long off;
 
   last_from = "unknown";
   last_to = "unknown";
@@ -671,7 +671,7 @@ xfer_mem (SIM_DESC sd,
 	  int write_p)
 {
   uint8 *memory;
-  unsigned long phys;
+  unsigned long long phys;
   int phys_size;
   phys_size = sim_d10v_translate_addr (sd, NULL, virt, size, &phys, NULL,
 				       dmap_register, imap_register);
@@ -689,7 +689,7 @@ xfer_mem (SIM_DESC sd,
 	 write_p ? "write" : "read",
 	 phys_size, virt, last_from,
 	 phys, last_to,
-	 (long) memory, last_segname);
+	 (long long) memory, last_segname);
     }
 #endif
 
@@ -867,7 +867,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,
 uint8 *
 dmem_addr (SIM_DESC sd, SIM_CPU *cpu, uint16 offset)
 {
-  unsigned long phys;
+  unsigned long long phys;
   uint8 *mem;
   int phys_size;
 
@@ -888,7 +888,7 @@ dmem_addr (SIM_DESC sd, SIM_CPU *cpu, uint16 offset)
 	 "mem: 0x%08x (%s) -> 0x%08lx %d (%s) -> 0x%08lx (%s)\n",
 	 offset, last_from,
 	 phys, phys_size, last_to,
-	 (long) mem, last_segname);
+	 (long long) mem, last_segname);
     }
 #endif
   return mem;
@@ -897,7 +897,7 @@ dmem_addr (SIM_DESC sd, SIM_CPU *cpu, uint16 offset)
 uint8 *
 imem_addr (SIM_DESC sd, SIM_CPU *cpu, uint32 offset)
 {
-  unsigned long phys;
+  unsigned long long phys;
   uint8 *mem;
   int phys_size = sim_d10v_translate_imap_addr (sd, cpu, offset, 1, &phys, NULL,
 						imap_register);
@@ -912,7 +912,7 @@ imem_addr (SIM_DESC sd, SIM_CPU *cpu, uint32 offset)
 	 "mem: 0x%08x (%s) -> 0x%08lx %d (%s) -> 0x%08lx (%s)\n",
 	 offset, last_from,
 	 phys, phys_size, last_to,
-	 (long) mem, last_segname);
+	 (long long) mem, last_segname);
     }
 #endif
   return mem;
@@ -1046,28 +1046,28 @@ sim_info (SIM_DESC sd, int verbose)
   char buf3[40];
   char buf4[40];
   char buf5[40];
-  unsigned long left		= ins_type_counters[ (int)INS_LEFT ] + ins_type_counters[ (int)INS_LEFT_COND_EXE ];
-  unsigned long left_nops	= ins_type_counters[ (int)INS_LEFT_NOPS ];
-  unsigned long left_parallel	= ins_type_counters[ (int)INS_LEFT_PARALLEL ];
-  unsigned long left_cond	= ins_type_counters[ (int)INS_LEFT_COND_TEST ];
-  unsigned long left_total	= left + left_parallel + left_cond + left_nops;
-
-  unsigned long right		= ins_type_counters[ (int)INS_RIGHT ] + ins_type_counters[ (int)INS_RIGHT_COND_EXE ];
-  unsigned long right_nops	= ins_type_counters[ (int)INS_RIGHT_NOPS ];
-  unsigned long right_parallel	= ins_type_counters[ (int)INS_RIGHT_PARALLEL ];
-  unsigned long right_cond	= ins_type_counters[ (int)INS_RIGHT_COND_TEST ];
-  unsigned long right_total	= right + right_parallel + right_cond + right_nops;
-
-  unsigned long unknown		= ins_type_counters[ (int)INS_UNKNOWN ];
-  unsigned long ins_long	= ins_type_counters[ (int)INS_LONG ];
-  unsigned long parallel	= ins_type_counters[ (int)INS_PARALLEL ];
-  unsigned long leftright	= ins_type_counters[ (int)INS_LEFTRIGHT ];
-  unsigned long rightleft	= ins_type_counters[ (int)INS_RIGHTLEFT ];
-  unsigned long cond_true	= ins_type_counters[ (int)INS_COND_TRUE ];
-  unsigned long cond_false	= ins_type_counters[ (int)INS_COND_FALSE ];
-  unsigned long cond_jump	= ins_type_counters[ (int)INS_COND_JUMP ];
-  unsigned long cycles		= ins_type_counters[ (int)INS_CYCLES ];
-  unsigned long total		= (unknown + left_total + right_total + ins_long);
+  unsigned long long left		= ins_type_counters[ (int)INS_LEFT ] + ins_type_counters[ (int)INS_LEFT_COND_EXE ];
+  unsigned long long left_nops	= ins_type_counters[ (int)INS_LEFT_NOPS ];
+  unsigned long long left_parallel	= ins_type_counters[ (int)INS_LEFT_PARALLEL ];
+  unsigned long long left_cond	= ins_type_counters[ (int)INS_LEFT_COND_TEST ];
+  unsigned long long left_total	= left + left_parallel + left_cond + left_nops;
+
+  unsigned long long right		= ins_type_counters[ (int)INS_RIGHT ] + ins_type_counters[ (int)INS_RIGHT_COND_EXE ];
+  unsigned long long right_nops	= ins_type_counters[ (int)INS_RIGHT_NOPS ];
+  unsigned long long right_parallel	= ins_type_counters[ (int)INS_RIGHT_PARALLEL ];
+  unsigned long long right_cond	= ins_type_counters[ (int)INS_RIGHT_COND_TEST ];
+  unsigned long long right_total	= right + right_parallel + right_cond + right_nops;
+
+  unsigned long long unknown		= ins_type_counters[ (int)INS_UNKNOWN ];
+  unsigned long long ins_long	= ins_type_counters[ (int)INS_LONG ];
+  unsigned long long parallel	= ins_type_counters[ (int)INS_PARALLEL ];
+  unsigned long long leftright	= ins_type_counters[ (int)INS_LEFTRIGHT ];
+  unsigned long long rightleft	= ins_type_counters[ (int)INS_RIGHTLEFT ];
+  unsigned long long cond_true	= ins_type_counters[ (int)INS_COND_TRUE ];
+  unsigned long long cond_false	= ins_type_counters[ (int)INS_COND_FALSE ];
+  unsigned long long cond_jump	= ins_type_counters[ (int)INS_COND_JUMP ];
+  unsigned long long cycles		= ins_type_counters[ (int)INS_CYCLES ];
+  unsigned long long total		= (unknown + left_total + right_total + ins_long);
 
   int size			= strlen (add_commas (buf1, sizeof (buf1), total));
   int parallel_size		= strlen (add_commas (buf1, sizeof (buf1),
@@ -1165,7 +1165,7 @@ sim_create_inferior (SIM_DESC sd, struct bfd *abfd,
     start_address = 0xffc0 << 2;
 #ifdef DEBUG
   if (d10v_debug)
-    sim_io_printf (sd, "sim_create_inferior:  PC=0x%lx\n", (long) start_address);
+    sim_io_printf (sd, "sim_create_inferior:  PC=0x%lx\n", (long long) start_address);
 #endif
   {
     SIM_CPU *cpu = STATE_CPU (sd, 0);
diff --git a/sim/d10v/sim-main.h b/sim/d10v/sim-main.h
index aef636f..00fb0dd 100644
--- a/sim/d10v/sim-main.h
+++ b/sim/d10v/sim-main.h
@@ -21,8 +21,8 @@
 
 #include "sim-basics.h"
 
-typedef long int           word;
-typedef unsigned long int  uword;
+typedef long long int           word;
+typedef unsigned long long int  uword;
 
 #include "sim-base.h"
 #include "bfd.h"
diff --git a/sim/d10v/simops.c b/sim/d10v/simops.c
index 92fd827..5f878da 100644
--- a/sim/d10v/simops.c
+++ b/sim/d10v/simops.c
@@ -162,7 +162,7 @@ trace_input_func (SIM_DESC sd, const char *name, enum op_types in1, enum op_type
   int i;
   char buf[1024];
   char *p;
-  long tmp;
+  long long tmp;
   char *type;
   const char *filename;
   const char *functionname;
@@ -408,7 +408,7 @@ trace_input_func (SIM_DESC sd, const char *name, enum op_types in1, enum op_type
 	      break;
 
 	    case OP_DREG:
-	      tmp = (long)((((uint32) GPR (OP[i])) << 16) | ((uint32) GPR (OP[i] + 1)));
+	      tmp = (long long)((((uint32) GPR (OP[i])) << 16) | ((uint32) GPR (OP[i] + 1)));
 	      sim_io_printf (sd, "%*s0x%.8lx", SIZE_VALUES-10, "", tmp);
 	      break;
 
@@ -422,7 +422,7 @@ trace_input_func (SIM_DESC sd, const char *name, enum op_types in1, enum op_type
 	    case OP_ACCUM_REVERSE:
 	      sim_io_printf (sd, "%*s0x%.2x%.8lx", SIZE_VALUES-12, "",
 						 ((int)(ACC (OP[i]) >> 32) & 0xff),
-						 ((unsigned long) ACC (OP[i])) & 0xffffffff);
+						 ((unsigned long long) ACC (OP[i])) & 0xffffffff);
 	      break;
 
 	    case OP_CONSTANT16:
@@ -517,7 +517,7 @@ trace_output_40 (SIM_DESC sd, uint64 val)
 					 SIZE_VALUES - 12,
 					 "",
 					 ((int)(val >> 32) & 0xff),
-					 ((unsigned long) val) & 0xffffffff);
+					 ((unsigned long long) val) & 0xffffffff);
       do_trace_output_finish (sd);
     }
 }
@@ -2463,7 +2463,7 @@ OP_3220 (SIM_DESC sd, SIM_CPU *cpu)
 
   if (PSW_ST && (tmp < SEXT40 (MIN32) || tmp > SEXT40 (MAX32)))
     {
-      sim_io_printf (sd, "ERROR: accumulator value 0x%.2x%.8lx out of range\n", ((int)(tmp >> 32) & 0xff), ((unsigned long) tmp) & 0xffffffff);
+      sim_io_printf (sd, "ERROR: accumulator value 0x%.2x%.8lx out of range\n", ((int)(tmp >> 32) & 0xff), ((unsigned long long) tmp) & 0xffffffff);
       EXCEPTION (SIM_SIGILL);
     }
 
@@ -3172,7 +3172,7 @@ OP_5F00 (SIM_DESC sd, SIM_CPU *cpu)
 	for (i = 0; i < 2; i++)
 	  sim_io_printf (sd, " %.2x%.8lx",
 					     ((int)(ACC (i) >> 32) & 0xff),
-					     ((unsigned long) ACC (i)) & 0xffffffff);
+					     ((unsigned long long) ACC (i)) & 0xffffffff);
 
 	sim_io_printf (sd, "  %d  %d %d\n",
 					   PSW_F0 != 0, PSW_F1 != 0, PSW_C != 0);
@@ -3424,8 +3424,8 @@ OP_5F00 (SIM_DESC sd, SIM_CPU *cpu)
 	  case TARGET_SYS_lseek:
 	    trace_input ("<lseek>", OP_R0, OP_R1, OP_R2);
 	    RETVAL32 (cb->lseek (cb, PARM1,
-				 ((((unsigned long) PARM2) << 16)
-				  || (unsigned long) PARM3),
+				 ((((unsigned long long) PARM2) << 16)
+				  || (unsigned long long) PARM3),
 				 PARM4));
 	    trace_output_32 (sd, result);
 	    break;
diff --git a/sim/erc32/func.c b/sim/erc32/func.c
index 5b137d2..c51cf06 100644
--- a/sim/erc32/func.c
+++ b/sim/erc32/func.c
@@ -1053,7 +1053,7 @@ bfd_load (const char *fname)
     for (section = pbfd->sections; section; section = section->next) {
 	if (bfd_get_section_flags(pbfd, section) & SEC_ALLOC) {
 	    bfd_vma         section_address;
-	    unsigned long   section_size;
+	    unsigned long long   section_size;
 	    const char     *section_name;
 
 	    section_name = bfd_get_section_name(pbfd, section);
diff --git a/sim/frv/cache.h b/sim/frv/cache.h
index 05ed39d..2d9c065 100644
--- a/sim/frv/cache.h
+++ b/sim/frv/cache.h
@@ -152,8 +152,8 @@ typedef struct {
 
 /* Cache statistics.  */
 typedef struct {
-  unsigned long accesses;   /* number of cache accesses.  */
-  unsigned long hits;       /* number of cache hits.  */
+  unsigned long long accesses;   /* number of cache accesses.  */
+  unsigned long long hits;       /* number of cache hits.  */
 } FRV_CACHE_STATISTICS;
 
 /* The cache itself.
diff --git a/sim/frv/profile.h b/sim/frv/profile.h
index 0346fa1..87858e8 100644
--- a/sim/frv/profile.h
+++ b/sim/frv/profile.h
@@ -26,11 +26,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
    use to all machines.  */
 typedef struct
 {
-  long vliw_insns; /* total number of VLIW insns.  */
-  long vliw_wait;  /* number of cycles that the current VLIW insn must wait.  */
-  long post_wait;  /* number of cycles that post processing in the current
+  long long vliw_insns; /* total number of VLIW insns.  */
+  long long vliw_wait;  /* number of cycles that the current VLIW insn must wait.  */
+  long long post_wait;  /* number of cycles that post processing in the current
                       VLIW insn must wait.  */
-  long vliw_cycles;/* number of cycles used by current VLIW insn.  */
+  long long vliw_cycles;/* number of cycles used by current VLIW insn.  */
 
   int  past_first_p; /* Not the first insns in the VLIW */
 
diff --git a/sim/frv/sim-if.c b/sim/frv/sim-if.c
index 405bef2..c2420b6 100644
--- a/sim/frv/sim-if.c
+++ b/sim/frv/sim-if.c
@@ -53,7 +53,7 @@ sim_open (kind, callback, abfd, argv)
 {
   char c;
   int i;
-  unsigned long elf_flags = 0;
+  unsigned long long elf_flags = 0;
   SIM_DESC sd = sim_state_alloc (kind, callback);
 
   /* The cpu data is kept in a separately allocated chunk of memory.  */
diff --git a/sim/frv/sim-main.h b/sim/frv/sim-main.h
index 9ebc3fa..f05a9ae 100644
--- a/sim/frv/sim-main.h
+++ b/sim/frv/sim-main.h
@@ -103,7 +103,7 @@ struct _sim_cpu {
   SI store_flag;
 #define CPU_RSTR_INVALIDATE(cpu) ((cpu)->store_flag)
 
-  unsigned long elf_flags;
+  unsigned long long elf_flags;
 #define CPU_ELF_FLAGS(cpu) ((cpu)->elf_flags)
 #endif /* defined (WANT_CPU_FRVBF) */
 };
diff --git a/sim/frv/traps.c b/sim/frv/traps.c
index d426b39..b17e96e 100644
--- a/sim/frv/traps.c
+++ b/sim/frv/traps.c
@@ -81,7 +81,7 @@ frv_sim_engine_halt_hook (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia)
 
 static int
 syscall_read_mem (host_callback *cb, struct cb_syscall *sc,
-		  unsigned long taddr, char *buf, int bytes)
+		  unsigned long long taddr, char *buf, int bytes)
 {
   SIM_DESC sd = (SIM_DESC) sc->p1;
   SIM_CPU *cpu = (SIM_CPU *) sc->p2;
@@ -92,7 +92,7 @@ syscall_read_mem (host_callback *cb, struct cb_syscall *sc,
 
 static int
 syscall_write_mem (host_callback *cb, struct cb_syscall *sc,
-		   unsigned long taddr, const char *buf, int bytes)
+		   unsigned long long taddr, const char *buf, int bytes)
 {
   SIM_DESC sd = (SIM_DESC) sc->p1;
   SIM_CPU *cpu = (SIM_CPU *) sc->p2;
@@ -218,14 +218,14 @@ frv_itrap (SIM_CPU *current_cpu, PCADDR pc, USI base, SI offset)
 
 	for (i = 0; i < 64; i += 8)
 	  {
-	    long g0 = (long)GET_H_GR (i);
-	    long g1 = (long)GET_H_GR (i+1);
-	    long g2 = (long)GET_H_GR (i+2);
-	    long g3 = (long)GET_H_GR (i+3);
-	    long g4 = (long)GET_H_GR (i+4);
-	    long g5 = (long)GET_H_GR (i+5);
-	    long g6 = (long)GET_H_GR (i+6);
-	    long g7 = (long)GET_H_GR (i+7);
+	    long long g0 = (long long)GET_H_GR (i);
+	    long long g1 = (long long)GET_H_GR (i+1);
+	    long long g2 = (long long)GET_H_GR (i+2);
+	    long long g3 = (long long)GET_H_GR (i+3);
+	    long long g4 = (long long)GET_H_GR (i+4);
+	    long long g5 = (long long)GET_H_GR (i+5);
+	    long long g6 = (long long)GET_H_GR (i+6);
+	    long long g7 = (long long)GET_H_GR (i+7);
 
 	    if ((g0 | g1 | g2 | g3 | g4 | g5 | g6 | g7) != 0)
 	      sim_io_printf (sd,
@@ -235,14 +235,14 @@ frv_itrap (SIM_CPU *current_cpu, PCADDR pc, USI base, SI offset)
 
 	for (i = 0; i < 64; i += 8)
 	  {
-	    long f0 = (long)GET_H_FR (i);
-	    long f1 = (long)GET_H_FR (i+1);
-	    long f2 = (long)GET_H_FR (i+2);
-	    long f3 = (long)GET_H_FR (i+3);
-	    long f4 = (long)GET_H_FR (i+4);
-	    long f5 = (long)GET_H_FR (i+5);
-	    long f6 = (long)GET_H_FR (i+6);
-	    long f7 = (long)GET_H_FR (i+7);
+	    long long f0 = (long long)GET_H_FR (i);
+	    long long f1 = (long long)GET_H_FR (i+1);
+	    long long f2 = (long long)GET_H_FR (i+2);
+	    long long f3 = (long long)GET_H_FR (i+3);
+	    long long f4 = (long long)GET_H_FR (i+4);
+	    long long f5 = (long long)GET_H_FR (i+5);
+	    long long f6 = (long long)GET_H_FR (i+6);
+	    long long f7 = (long long)GET_H_FR (i+7);
 
 	    if ((f0 | f1 | f2 | f3 | f4 | f5 | f6 | f7) != 0)
 	      sim_io_printf (sd,
@@ -252,10 +252,10 @@ frv_itrap (SIM_CPU *current_cpu, PCADDR pc, USI base, SI offset)
 
 	sim_io_printf (sd,
 		       "\tlr/lcr/cc/ccc: 0x%.8lx 0x%.8lx 0x%.8lx 0x%.8lx\n",
-		       (long)GET_H_SPR (272),
-		       (long)GET_H_SPR (273),
-		       (long)GET_H_SPR (256),
-		       (long)GET_H_SPR (263));
+		       (long long)GET_H_SPR (272),
+		       (long long)GET_H_SPR (273),
+		       (long long)GET_H_SPR (256),
+		       (long long)GET_H_SPR (263));
       }
       break;
 #endif
diff --git a/sim/ft32/interp.c b/sim/ft32/interp.c
index c63b7ee..2ca4d5f 100644
--- a/sim/ft32/interp.c
+++ b/sim/ft32/interp.c
@@ -52,10 +52,10 @@
 
 #define RAM_BIAS  0x800000  /* Bias added to RAM addresses.  */
 
-static unsigned long
+static unsigned long long
 ft32_extract_unsigned_integer (unsigned char *addr, int len)
 {
-  unsigned long retval;
+  unsigned long long retval;
   unsigned char *p;
   unsigned char *startaddr = (unsigned char *) addr;
   unsigned char *endaddr = startaddr + len;
@@ -71,7 +71,7 @@ ft32_extract_unsigned_integer (unsigned char *addr, int len)
 }
 
 static void
-ft32_store_unsigned_integer (unsigned char *addr, int len, unsigned long val)
+ft32_store_unsigned_integer (unsigned char *addr, int len, unsigned long long val)
 {
   unsigned char *p;
   unsigned char *startaddr = (unsigned char *)addr;
diff --git a/sim/h8300/compile.c b/sim/h8300/compile.c
index c1c61d8..2baaa50 100644
--- a/sim/h8300/compile.c
+++ b/sim/h8300/compile.c
@@ -4729,7 +4729,7 @@ sim_info (SIM_DESC sd, int verbose)
    FLAG is non-zero for the H8/300H.  */
 
 void
-set_h8300h (unsigned long machine)
+set_h8300h (unsigned long long machine)
 {
   /* FIXME: Much of the code in sim_load can be moved to sim_open.
      This function being replaced by a sim_open:ARGV configuration
diff --git a/sim/h8300/sim-main.h b/sim/h8300/sim-main.h
index 6dbc1ac..657a2c1 100644
--- a/sim/h8300/sim-main.h
+++ b/sim/h8300/sim-main.h
@@ -138,7 +138,7 @@ struct sim_state {
   unsigned int sim_cache_size;
   decoded_inst *sim_cache;
   unsigned short *cache_idx;
-  unsigned long memory_size;
+  unsigned long long memory_size;
   int cache_top;
   int compiles;
 #ifdef ADEBUG
diff --git a/sim/igen/gen-idecode.c b/sim/igen/gen-idecode.c
index 490838e..e0eeed3 100644
--- a/sim/igen/gen-idecode.c
+++ b/sim/igen/gen-idecode.c
@@ -805,18 +805,18 @@ print_idecode_validate (lf *file,
 	      {
 		lf_printf (file, "if ((instruction_%d\n", word_nr);
 		lf_printf (file, "     & UNSIGNED64 (0x%08lx%08lx))\n",
-			   (unsigned long) (check_mask >> 32),
-			   (unsigned long) (check_mask));
+			   (unsigned long long) (check_mask >> 32),
+			   (unsigned long long) (check_mask));
 		lf_printf (file, "    != UNSIGNED64 (0x%08lx%08lx))\n",
-			   (unsigned long) (check_val >> 32),
-			   (unsigned long) (check_val));
+			   (unsigned long long) (check_val >> 32),
+			   (unsigned long long) (check_val));
 	      }
 	    else
 	      {
 		lf_printf (file,
 			   "if ((instruction_%d & 0x%08lx) != 0x%08lx)\n",
-			   word_nr, (unsigned long) (check_mask),
-			   (unsigned long) (check_val));
+			   word_nr, (unsigned long long) (check_mask),
+			   (unsigned long long) (check_val));
 	      }
 	    lf_indent (file, +2);
 	    print_idecode_invalid (file, "return", invalid_illegal);
diff --git a/sim/igen/gen.c b/sim/igen/gen.c
index f8b37d7..c867a1c 100644
--- a/sim/igen/gen.c
+++ b/sim/igen/gen.c
@@ -1506,7 +1506,7 @@ dump_opcode_field (lf *file,
 		   char *prefix,
 		   opcode_field *field, char *suffix, int levels)
 {
-  lf_printf (file, "%s(opcode_field *) 0x%lx", prefix, (long) field);
+  lf_printf (file, "%s(opcode_field *) 0x%lx", prefix, (long long) field);
   if (levels && field != NULL)
     {
       lf_indent (file, +1);
@@ -1526,7 +1526,7 @@ static void
 dump_opcode_bits (lf *file,
 		  char *prefix, opcode_bits *bits, char *suffix, int levels)
 {
-  lf_printf (file, "%s(opcode_bits *) 0x%lx", prefix, (long) bits);
+  lf_printf (file, "%s(opcode_bits *) 0x%lx", prefix, (long long) bits);
 
   if (levels && bits != NULL)
     {
@@ -1545,13 +1545,13 @@ dump_opcode_bits (lf *file,
 static void
 dump_insn_list (lf *file, char *prefix, insn_list *entry, char *suffix)
 {
-  lf_printf (file, "%s(insn_list *) 0x%lx", prefix, (long) entry);
+  lf_printf (file, "%s(insn_list *) 0x%lx", prefix, (long long) entry);
 
   if (entry != NULL)
     {
       lf_indent (file, +1);
       dump_insn_entry (file, "\n(insn ", entry->insn, ")");
-      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
+      lf_printf (file, "\n(next 0x%lx)", (long long) entry->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", suffix);
@@ -1578,7 +1578,7 @@ dump_gen_entry (lf *file,
 		char *prefix, gen_entry *table, char *suffix, int levels)
 {
 
-  lf_printf (file, "%s(gen_entry *) 0x%lx", prefix, (long) table);
+  lf_printf (file, "%s(gen_entry *) 0x%lx", prefix, (long long) table);
 
   if (levels && table !=NULL)
     {
@@ -1609,9 +1609,9 @@ dump_gen_list (lf *file,
 {
   while (entry != NULL)
     {
-      lf_printf (file, "%s(gen_list *) 0x%lx", prefix, (long) entry);
+      lf_printf (file, "%s(gen_list *) 0x%lx", prefix, (long long) entry);
       dump_gen_entry (file, "\n(", entry->table, ")", levels);
-      lf_printf (file, "\n(next (gen_list *) 0x%lx)", (long) entry->next);
+      lf_printf (file, "\n(next (gen_list *) 0x%lx)", (long long) entry->next);
       lf_printf (file, "%s", suffix);
     }
 }
@@ -1621,9 +1621,9 @@ static void
 dump_gen_table (lf *file,
 		char *prefix, gen_table *gen, char *suffix, int levels)
 {
-  lf_printf (file, "%s(gen_table *) 0x%lx", prefix, (long) gen);
-  lf_printf (file, "\n(isa (insn_table *) 0x%lx)", (long) gen->isa);
-  lf_printf (file, "\n(rules (decode_table *) 0x%lx)", (long) gen->rules);
+  lf_printf (file, "%s(gen_table *) 0x%lx", prefix, (long long) gen);
+  lf_printf (file, "\n(isa (insn_table *) 0x%lx)", (long long) gen->isa);
+  lf_printf (file, "\n(rules (decode_table *) 0x%lx)", (long long) gen->rules);
   dump_gen_list (file, "\n(", gen->tables, ")", levels);
   lf_printf (file, "%s", suffix);
 }
diff --git a/sim/igen/ld-decode.c b/sim/igen/ld-decode.c
index ea6d570..bade211 100644
--- a/sim/igen/ld-decode.c
+++ b/sim/igen/ld-decode.c
@@ -311,15 +311,15 @@ decode_table_max_word_nr (decode_table *entry)
 static void
 dump_decode_cond (lf *file, char *prefix, decode_cond *cond, char *suffix)
 {
-  lf_printf (file, "%s(decode_cond *) 0x%lx", prefix, (long) cond);
+  lf_printf (file, "%s(decode_cond *) 0x%lx", prefix, (long long) cond);
   if (cond != NULL)
     {
       lf_indent (file, +1);
       lf_printf (file, "\n(word_nr %d)", cond->word_nr);
-      lf_printf (file, "\n(mask 0x%lx)", (long) cond->mask);
-      lf_printf (file, "\n(value 0x%lx)", (long) cond->value);
-      lf_printf (file, "\n(is_equal 0x%lx)", (long) cond->is_equal);
-      lf_printf (file, "\n(next (decode_cond *) 0%lx)", (long) cond->next);
+      lf_printf (file, "\n(mask 0x%lx)", (long long) cond->mask);
+      lf_printf (file, "\n(value 0x%lx)", (long long) cond->value);
+      lf_printf (file, "\n(is_equal 0x%lx)", (long long) cond->is_equal);
+      lf_printf (file, "\n(next (decode_cond *) 0%lx)", (long long) cond->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", suffix);
@@ -329,7 +329,7 @@ dump_decode_cond (lf *file, char *prefix, decode_cond *cond, char *suffix)
 static void
 dump_decode_conds (lf *file, char *prefix, decode_cond *cond, char *suffix)
 {
-  lf_printf (file, "%s(decode_cond *) 0x%lx", prefix, (long) cond);
+  lf_printf (file, "%s(decode_cond *) 0x%lx", prefix, (long long) cond);
   while (cond != NULL)
     {
       dump_decode_cond (file, "\n(", cond, ")");
@@ -342,7 +342,7 @@ dump_decode_conds (lf *file, char *prefix, decode_cond *cond, char *suffix)
 void
 dump_decode_rule (lf *file, char *prefix, decode_table *rule, char *suffix)
 {
-  lf_printf (file, "%s(decode_table *) 0x%lx", prefix, (long) rule);
+  lf_printf (file, "%s(decode_table *) 0x%lx", prefix, (long long) rule);
   if (rule != NULL)
     {
       lf_indent (file, +1);
@@ -363,7 +363,7 @@ dump_decode_rule (lf *file, char *prefix, decode_table *rule, char *suffix)
       dump_filter (file, "\n(format_names \"", rule->format_names, "\")");
       dump_filter (file, "\n(model_names \"", rule->model_names, "\")");
       dump_decode_conds (file, "\n(conditions ", rule->conditions, ")");
-      lf_printf (file, "\n(next 0x%lx)", (long) rule->next);
+      lf_printf (file, "\n(next 0x%lx)", (long long) rule->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", suffix);
diff --git a/sim/igen/ld-insn.c b/sim/igen/ld-insn.c
index 19c4cc2..1947aca 100644
--- a/sim/igen/ld-insn.c
+++ b/sim/igen/ld-insn.c
@@ -1302,7 +1302,7 @@ print_insn_words (lf *file, insn_entry * insn)
 		  ASSERT (0);
 		  break;
 		case insn_field_int:
-		  lf_printf (file, "0x%lx", (long) field->val_int);
+		  lf_printf (file, "0x%lx", (long long) field->val_int);
 		  break;
 		case insn_field_reserved:
 		  lf_printf (file, "/");
@@ -1320,7 +1320,7 @@ print_insn_words (lf *file, insn_entry * insn)
 		    {
 		      if (field->conditions->type == insn_field_cond_value)
 			lf_printf (file, "=%ld",
-				   (long) field->conditions->value);
+				   (long long) field->conditions->value);
 		      else
 			lf_printf (file, "=%s", field->conditions->string);
 
@@ -1336,7 +1336,7 @@ print_insn_words (lf *file, insn_entry * insn)
 		      ASSERT (cond->test == insn_field_cond_ne);
 
 		      if (cond->type == insn_field_cond_value)
-			lf_printf (file, "!%ld", (long) cond->value);
+			lf_printf (file, "!%ld", (long long) cond->value);
 		      else
 			lf_printf (file, "!%s", cond->string);
 		    }
@@ -1386,7 +1386,7 @@ static void
 dump_function_entry (lf *file,
 		     char *prefix, function_entry * entry, char *suffix)
 {
-  lf_printf (file, "%s(function_entry *) 0x%lx", prefix, (long) entry);
+  lf_printf (file, "%s(function_entry *) 0x%lx", prefix, (long long) entry);
   if (entry != NULL)
     {
       dump_line_ref (file, "\n(line ", entry->line, ")");
@@ -1396,7 +1396,7 @@ dump_function_entry (lf *file,
       lf_printf (file, "\n(param \"%s\")", entry->param);
       dump_table_entry (file, "\n(code ", entry->code, ")");
       lf_printf (file, "\n(is_internal %d)", entry->is_internal);
-      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
+      lf_printf (file, "\n(next 0x%lx)", (long long) entry->next);
     }
   lf_printf (file, "%s", suffix);
 }
@@ -1435,7 +1435,7 @@ cache_entry_type_to_str (cache_entry_type type)
 static void
 dump_cache_entry (lf *file, char *prefix, cache_entry *entry, char *suffix)
 {
-  lf_printf (file, "%s(cache_entry *) 0x%lx", prefix, (long) entry);
+  lf_printf (file, "%s(cache_entry *) 0x%lx", prefix, (long long) entry);
   if (entry != NULL)
     {
       dump_line_ref (file, "\n(line ", entry->line, ")");
@@ -1446,7 +1446,7 @@ dump_cache_entry (lf *file, char *prefix, cache_entry *entry, char *suffix)
       dump_filter (file, "\n(original_fields ", entry->original_fields, ")");
       lf_printf (file, "\n(type \"%s\")", entry->type);
       lf_printf (file, "\n(expression \"%s\")", entry->expression);
-      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
+      lf_printf (file, "\n(next 0x%lx)", (long long) entry->next);
     }
   lf_printf (file, "%s", suffix);
 }
@@ -1468,7 +1468,7 @@ dump_cache_entries (lf *file, char *prefix, cache_entry *entry, char *suffix)
 static void
 dump_model_data (lf *file, char *prefix, model_data *entry, char *suffix)
 {
-  lf_printf (file, "%s(model_data *) 0x%lx", prefix, (long) entry);
+  lf_printf (file, "%s(model_data *) 0x%lx", prefix, (long long) entry);
   if (entry != NULL)
     {
       lf_indent (file, +1);
@@ -1476,7 +1476,7 @@ dump_model_data (lf *file, char *prefix, model_data *entry, char *suffix)
       dump_filter (file, "\n(flags ", entry->flags, ")");
       dump_table_entry (file, "\n(entry ", entry->entry, ")");
       dump_table_entry (file, "\n(code ", entry->code, ")");
-      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
+      lf_printf (file, "\n(next 0x%lx)", (long long) entry->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", prefix);
@@ -1499,7 +1499,7 @@ dump_model_datas (lf *file, char *prefix, model_data *entry, char *suffix)
 static void
 dump_model_entry (lf *file, char *prefix, model_entry *entry, char *suffix)
 {
-  lf_printf (file, "%s(model_entry *) 0x%lx", prefix, (long) entry);
+  lf_printf (file, "%s(model_entry *) 0x%lx", prefix, (long long) entry);
   if (entry != NULL)
     {
       lf_indent (file, +1);
@@ -1508,7 +1508,7 @@ dump_model_entry (lf *file, char *prefix, model_entry *entry, char *suffix)
       lf_printf (file, "\n(name \"%s\")", entry->name);
       lf_printf (file, "\n(full_name \"%s\")", entry->full_name);
       lf_printf (file, "\n(unit_data \"%s\")", entry->unit_data);
-      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
+      lf_printf (file, "\n(next 0x%lx)", (long long) entry->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", prefix);
@@ -1532,7 +1532,7 @@ dump_model_entries (lf *file, char *prefix, model_entry *entry, char *suffix)
 static void
 dump_model_table (lf *file, char *prefix, model_table *entry, char *suffix)
 {
-  lf_printf (file, "%s(model_table *) 0x%lx", prefix, (long) entry);
+  lf_printf (file, "%s(model_table *) 0x%lx", prefix, (long long) entry);
   if (entry != NULL)
     {
       lf_indent (file, +1);
@@ -1576,7 +1576,7 @@ dump_insn_field (lf *file,
 		 char *prefix, insn_field_entry *field, char *suffix)
 {
   char *sep = " ";
-  lf_printf (file, "%s(insn_field_entry *) 0x%lx", prefix, (long) field);
+  lf_printf (file, "%s(insn_field_entry *) 0x%lx", prefix, (long long) field);
   if (field != NULL)
     {
       lf_indent (file, +1);
@@ -1591,7 +1591,7 @@ dump_insn_field (lf *file,
 	  ASSERT (0);
 	  break;
 	case insn_field_int:
-	  lf_printf (file, "%s(val 0x%lx)", sep, (long) field->val_int);
+	  lf_printf (file, "%s(val 0x%lx)", sep, (long long) field->val_int);
 	  break;
 	case insn_field_reserved:
 	  /* nothing output */
@@ -1603,8 +1603,8 @@ dump_insn_field (lf *file,
 	  lf_printf (file, "%s(val \"%s\")", sep, field->val_string);
 	  break;
 	}
-      lf_printf (file, "%s(next 0x%lx)", sep, (long) field->next);
-      lf_printf (file, "%s(prev 0x%lx)", sep, (long) field->prev);
+      lf_printf (file, "%s(next 0x%lx)", sep, (long long) field->next);
+      lf_printf (file, "%s(prev 0x%lx)", sep, (long long) field->prev);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", suffix);
@@ -1614,24 +1614,24 @@ void
 dump_insn_word_entry (lf *file,
 		      char *prefix, insn_word_entry *word, char *suffix)
 {
-  lf_printf (file, "%s(insn_word_entry *) 0x%lx", prefix, (long) word);
+  lf_printf (file, "%s(insn_word_entry *) 0x%lx", prefix, (long long) word);
   if (word != NULL)
     {
       int i;
       insn_field_entry *field;
       lf_indent (file, +1);
-      lf_printf (file, "\n(first 0x%lx)", (long) word->first);
-      lf_printf (file, "\n(last 0x%lx)", (long) word->last);
+      lf_printf (file, "\n(first 0x%lx)", (long long) word->first);
+      lf_printf (file, "\n(last 0x%lx)", (long long) word->last);
       lf_printf (file, "\n(bit");
       for (i = 0; i < options.insn_bit_size; i++)
 	lf_printf (file, "\n ((value %d) (mask %d) (field 0x%lx))",
 		   word->bit[i]->value, word->bit[i]->mask,
-		   (long) word->bit[i]->field);
+		   (long long) word->bit[i]->field);
       lf_printf (file, ")");
       for (field = word->first; field != NULL; field = field->next)
 	dump_insn_field (file, "\n(", field, ")");
       dump_filter (file, "\n(field_names ", word->field_names, ")");
-      lf_printf (file, "\n(next 0x%lx)", (long) word->next);
+      lf_printf (file, "\n(next 0x%lx)", (long long) word->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", suffix);
@@ -1654,7 +1654,7 @@ static void
 dump_insn_model_entry (lf *file,
 		       char *prefix, insn_model_entry *model, char *suffix)
 {
-  lf_printf (file, "%s(insn_model_entry *) 0x%lx", prefix, (long) model);
+  lf_printf (file, "%s(insn_model_entry *) 0x%lx", prefix, (long long) model);
   if (model != NULL)
     {
       lf_indent (file, +1);
@@ -1662,9 +1662,9 @@ dump_insn_model_entry (lf *file,
       dump_filter (file, "\n(names ", model->names, ")");
       lf_printf (file, "\n(full_name \"%s\")", model->full_name);
       lf_printf (file, "\n(unit_data \"%s\")", model->unit_data);
-      lf_printf (file, "\n(insn (insn_entry *) 0x%lx)", (long) model->insn);
+      lf_printf (file, "\n(insn (insn_entry *) 0x%lx)", (long long) model->insn);
       lf_printf (file, "\n(next (insn_model_entry *) 0x%lx)",
-		 (long) model->next);
+		 (long long) model->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", suffix);
@@ -1690,7 +1690,7 @@ dump_insn_mnemonic_entry (lf *file,
 			  insn_mnemonic_entry *mnemonic, char *suffix)
 {
   lf_printf (file, "%s(insn_mnemonic_entry *) 0x%lx", prefix,
-	     (long) mnemonic);
+	     (long long) mnemonic);
   if (mnemonic != NULL)
     {
       lf_indent (file, +1);
@@ -1698,9 +1698,9 @@ dump_insn_mnemonic_entry (lf *file,
       lf_printf (file, "\n(format \"%s\")", mnemonic->format);
       lf_printf (file, "\n(condition \"%s\")", mnemonic->condition);
       lf_printf (file, "\n(insn (insn_entry *) 0x%lx)",
-		 (long) mnemonic->insn);
+		 (long long) mnemonic->insn);
       lf_printf (file, "\n(next (insn_mnemonic_entry *) 0x%lx)",
-		 (long) mnemonic->next);
+		 (long long) mnemonic->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", suffix);
@@ -1723,7 +1723,7 @@ dump_insn_mnemonic_entries (lf *file,
 void
 dump_insn_entry (lf *file, char *prefix, insn_entry * entry, char *suffix)
 {
-  lf_printf (file, "%s(insn_entry *) 0x%lx", prefix, (long) entry);
+  lf_printf (file, "%s(insn_entry *) 0x%lx", prefix, (long long) entry);
   if (entry != NULL)
     {
       int i;
@@ -1734,7 +1734,7 @@ dump_insn_entry (lf *file, char *prefix, insn_entry * entry, char *suffix)
       dump_insn_word_entries (file, "\n(words ", entry->words, ")");
       lf_printf (file, "\n(word");
       for (i = 0; i < entry->nr_models; i++)
-	lf_printf (file, " 0x%lx", (long) entry->word[i]);
+	lf_printf (file, " 0x%lx", (long long) entry->word[i]);
       lf_printf (file, ")");
       dump_filter (file, "\n(field_names ", entry->field_names, ")");
       lf_printf (file, "\n(format_name \"%s\")", entry->format_name);
@@ -1744,13 +1744,13 @@ dump_insn_entry (lf *file, char *prefix, insn_entry * entry, char *suffix)
       dump_insn_model_entries (file, "\n(models ", entry->models, ")");
       lf_printf (file, "\n(model");
       for (i = 0; i < entry->nr_models; i++)
-	lf_printf (file, " 0x%lx", (long) entry->model[i]);
+	lf_printf (file, " 0x%lx", (long long) entry->model[i]);
       lf_printf (file, ")");
       dump_filter (file, "\n(processors ", entry->processors, ")");
       dump_insn_mnemonic_entries (file, "\n(mnemonics ", entry->mnemonics,
 				  ")");
       dump_table_entry (file, "\n(code ", entry->code, ")");
-      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
+      lf_printf (file, "\n(next 0x%lx)", (long long) entry->next);
       lf_indent (file, -1);
     }
   lf_printf (file, "%s", suffix);
@@ -1775,7 +1775,7 @@ dump_insn_entries (lf *file, char *prefix, insn_entry * entry, char *suffix)
 void
 dump_insn_table (lf *file, char *prefix, insn_table *isa, char *suffix)
 {
-  lf_printf (file, "%s(insn_table *) 0x%lx", prefix, (long) isa);
+  lf_printf (file, "%s(insn_table *) 0x%lx", prefix, (long long) isa);
   if (isa != NULL)
     {
       lf_indent (file, +1);
diff --git a/sim/igen/misc.c b/sim/igen/misc.c
index 22862a1..7e01975 100644
--- a/sim/igen/misc.c
+++ b/sim/igen/misc.c
@@ -78,7 +78,7 @@ notify (const line_ref *line, char *msg, ...)
 }
 
 void *
-zalloc (long size)
+zalloc (long long size)
 {
   void *memory = malloc (size);
   if (memory == NULL)
diff --git a/sim/igen/misc.h b/sim/igen/misc.h
index a49d1fb..b1f0bdb 100644
--- a/sim/igen/misc.h
+++ b/sim/igen/misc.h
@@ -111,7 +111,7 @@ do { \
 #define ZALLOC(TYPE) ((TYPE*) zalloc (sizeof(TYPE)))
 #define NZALLOC(TYPE,N) ((TYPE*) zalloc (sizeof(TYPE) * (N)))
 
-extern void *zalloc (long size);
+extern void *zalloc (long long size);
 
 extern unsigned target_a2i (int ms_bit_nr, const char *a);
 
diff --git a/sim/igen/table.c b/sim/igen/table.c
index a0fda4e..275fc77 100644
--- a/sim/igen/table.c
+++ b/sim/igen/table.c
@@ -538,7 +538,7 @@ table_print_code (lf *file, table_entry *entry)
 void
 dump_line_ref (lf *file, char *prefix, const line_ref *line, char *suffix)
 {
-  lf_printf (file, "%s(line_ref*) 0x%lx", prefix, (long) line);
+  lf_printf (file, "%s(line_ref*) 0x%lx", prefix, (long long) line);
   if (line != NULL)
     {
       lf_indent (file, +1);
@@ -567,7 +567,7 @@ void
 dump_table_entry (lf *file,
 		  char *prefix, const table_entry *entry, char *suffix)
 {
-  lf_printf (file, "%s(table_entry*) 0x%lx", prefix, (long) entry);
+  lf_printf (file, "%s(table_entry*) 0x%lx", prefix, (long long) entry);
   if (entry != NULL)
     {
       int field;
diff --git a/sim/lm32/dv-lm32timer.c b/sim/lm32/dv-lm32timer.c
index bc564d2..350c549 100644
--- a/sim/lm32/dv-lm32timer.c
+++ b/sim/lm32/dv-lm32timer.c
@@ -91,7 +91,7 @@ lm32timer_io_write_buffer (struct hw *me,
   const unsigned char *source_bytes = source;
   int value = 0;
 
-  HW_TRACE ((me, "write to 0x%08lx length %d with 0x%x", (long) base,
+  HW_TRACE ((me, "write to 0x%08lx length %d with 0x%x", (long long) base,
 	     (int) nr_bytes, value));
 
   if (nr_bytes == 4)
@@ -135,7 +135,7 @@ lm32timer_io_read_buffer (struct hw *me,
   int value;
   unsigned char *dest_bytes = dest;
 
-  HW_TRACE ((me, "read 0x%08lx length %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx length %d", (long long) base, (int) nr_bytes));
 
   timer_reg = base - timers->base;
 
diff --git a/sim/lm32/dv-lm32uart.c b/sim/lm32/dv-lm32uart.c
index 768e95c..a2f776a 100644
--- a/sim/lm32/dv-lm32uart.c
+++ b/sim/lm32/dv-lm32uart.c
@@ -128,7 +128,7 @@ lm32uart_io_write_buffer (struct hw *me,
   const unsigned char *source_bytes = source;
   int value = 0;
 
-  HW_TRACE ((me, "write to 0x%08lx length %d with 0x%x", (long) base,
+  HW_TRACE ((me, "write to 0x%08lx length %d with 0x%x", (long long) base,
 	     (int) nr_bytes, value));
 
   if (nr_bytes == 4)
@@ -207,7 +207,7 @@ lm32uart_io_read_buffer (struct hw *me,
   fd_set fd;
   struct timeval tv;
 
-  HW_TRACE ((me, "read 0x%08lx length %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx length %d", (long long) base, (int) nr_bytes));
 
   uart_reg = base - uart->base;
 
diff --git a/sim/lm32/sim-if.c b/sim/lm32/sim-if.c
index 4905dd6..8d7e429 100644
--- a/sim/lm32/sim-if.c
+++ b/sim/lm32/sim-if.c
@@ -40,11 +40,11 @@ free_state (SIM_DESC sd)
 
 /* Find memory range used by program.  */
 
-static unsigned long
+static unsigned long long
 find_base (bfd *prog_bfd)
 {
   int found;
-  unsigned long base = ~(0UL);
+  unsigned long long base = ~(0UL);
   asection *s;
 
   found = 0;
@@ -70,7 +70,7 @@ find_base (bfd *prog_bfd)
   return base & ~(0xffffUL);
 }
 
-static unsigned long
+static unsigned long long
 find_limit (SIM_DESC sd)
 {
   bfd_vma addr;
@@ -94,7 +94,7 @@ sim_open (kind, callback, abfd, argv)
   SIM_DESC sd = sim_state_alloc (kind, callback);
   char c;
   int i;
-  unsigned long base, limit;
+  unsigned long long base, limit;
 
   /* The cpu data is kept in a separately allocated chunk of memory.  */
   if (sim_cpu_alloc_all (sd, 1, cgen_cpu_max_extra_bytes ()) != SIM_RC_OK)
diff --git a/sim/lm32/traps.c b/sim/lm32/traps.c
index 9e7f15a..fc766c3 100644
--- a/sim/lm32/traps.c
+++ b/sim/lm32/traps.c
@@ -132,7 +132,7 @@ lm32bf_scall_insn (SIM_CPU * current_cpu, IADDR pc)
       || (GET_H_GR (8) == TARGET_SYS_exit))
     {
       /* Delegate system call to host O/S.  */
-      long result, result2;
+      long long result, result2;
       int errcode;
 
       /* Perform the system call.  */
@@ -209,8 +209,8 @@ lm32_core_signal (SIM_DESC sd,
     case sim_core_unmapped_signal:
       sim_io_eprintf (sd,
 		      "core: %d byte %s to unmapped address 0x%lx at 0x%lx\n",
-		      nr_bytes, copy, (unsigned long) addr,
-		      (unsigned long) ip);
+		      nr_bytes, copy, (unsigned long long) addr,
+		      (unsigned long long) ip);
       SET_H_GR (30, ip);
       /* Save and clear interrupt enable.  */
       SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 1) << 1);
@@ -221,8 +221,8 @@ lm32_core_signal (SIM_DESC sd,
     case sim_core_unaligned_signal:
       sim_io_eprintf (sd,
 		      "core: %d byte misaligned %s to address 0x%lx at 0x%lx\n",
-		      nr_bytes, copy, (unsigned long) addr,
-		      (unsigned long) ip);
+		      nr_bytes, copy, (unsigned long long) addr,
+		      (unsigned long long) ip);
       SET_H_GR (30, ip);
       /* Save and clear interrupt enable.  */
       SET_H_CSR (LM32_CSR_IE, (GET_H_CSR (LM32_CSR_IE) & 1) << 1);
diff --git a/sim/m32c/cpu.h b/sim/m32c/cpu.h
index 3b6fe5a..5e5bf2d 100644
--- a/sim/m32c/cpu.h
+++ b/sim/m32c/cpu.h
@@ -27,7 +27,7 @@ extern int in_gdb;
 
 typedef unsigned char QI;
 typedef unsigned short HI;
-typedef unsigned long SI;
+typedef unsigned long long SI;
 typedef unsigned long long DI;
 
 #define CPU_R8C		0x11
diff --git a/sim/m32c/load.c b/sim/m32c/load.c
index be2e5ae..c0cc88b 100644
--- a/sim/m32c/load.c
+++ b/sim/m32c/load.c
@@ -33,7 +33,7 @@ int (*decode_opcode) (void) = 0;
 int default_machine = 0;
 
 void
-m32c_set_mach (unsigned long mach)
+m32c_set_mach (unsigned long long mach)
 {
   switch (mach)
     {
@@ -58,8 +58,8 @@ void
 m32c_load (bfd * prog)
 {
   asection *s;
-  unsigned long mach = bfd_get_mach (prog);
-  unsigned long highest_addr_loaded = 0;
+  unsigned long long mach = bfd_get_mach (prog);
+  unsigned long long highest_addr_loaded = 0;
 
   if (mach == 0 && default_machine != 0)
     mach = default_machine;
diff --git a/sim/m32c/load.h b/sim/m32c/load.h
index 70562b6..fbc4e36 100644
--- a/sim/m32c/load.h
+++ b/sim/m32c/load.h
@@ -23,5 +23,5 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 extern int default_machine;
 
-void m32c_set_mach (unsigned long mach);
+void m32c_set_mach (unsigned long long mach);
 void m32c_load (bfd *);
diff --git a/sim/m32c/mem.c b/sim/m32c/mem.c
index b2906ea..0721605 100644
--- a/sim/m32c/mem.c
+++ b/sim/m32c/mem.c
@@ -342,7 +342,7 @@ mem_put_hi (int address, unsigned short value)
 }
 
 void
-mem_put_psi (int address, unsigned long value)
+mem_put_psi (int address, unsigned long long value)
 {
   S ("<=");
   mem_put_byte (address, value & 0xff);
@@ -353,7 +353,7 @@ mem_put_psi (int address, unsigned long value)
 }
 
 void
-mem_put_si (int address, unsigned long value)
+mem_put_si (int address, unsigned long long value)
 {
   S ("<=");
   mem_put_byte (address, value & 0xff);
@@ -505,10 +505,10 @@ mem_get_hi (int address)
   return rv;
 }
 
-unsigned long
+unsigned long long
 mem_get_psi (int address)
 {
-  unsigned long rv;
+  unsigned long long rv;
   S ("=>");
   rv = mem_get_byte (address);
   rv |= mem_get_byte (address + 1) * 256;
@@ -518,10 +518,10 @@ mem_get_psi (int address)
   return rv;
 }
 
-unsigned long
+unsigned long long
 mem_get_si (int address)
 {
-  unsigned long rv;
+  unsigned long long rv;
   S ("=>");
   rv = mem_get_byte (address);
   rv |= mem_get_byte (address + 1) << 8;
diff --git a/sim/m32c/mem.h b/sim/m32c/mem.h
index 9260613..8e88505 100644
--- a/sim/m32c/mem.h
+++ b/sim/m32c/mem.h
@@ -24,8 +24,8 @@ void mem_usage_stats (void);
 
 void mem_put_qi (int address, unsigned char value);
 void mem_put_hi (int address, unsigned short value);
-void mem_put_psi (int address, unsigned long value);
-void mem_put_si (int address, unsigned long value);
+void mem_put_psi (int address, unsigned long long value);
+void mem_put_si (int address, unsigned long long value);
 
 void mem_put_blk (int address, const void *bufptr, int nbytes);
 
@@ -33,8 +33,8 @@ unsigned char mem_get_pc (void);
 
 unsigned char mem_get_qi (int address);
 unsigned short mem_get_hi (int address);
-unsigned long mem_get_psi (int address);
-unsigned long mem_get_si (int address);
+unsigned long long mem_get_psi (int address);
+unsigned long long mem_get_si (int address);
 
 void mem_get_blk (int address, void *bufptr, int nbytes);
 
diff --git a/sim/m32c/trace.c b/sim/m32c/trace.c
index b87f06b..211d9d6 100644
--- a/sim/m32c/trace.c
+++ b/sim/m32c/trace.c
@@ -48,8 +48,8 @@ sim_dis_read (bfd_vma memaddr, bfd_byte * ptr, unsigned int length,
    COUNT is the number of elements in SYMBOLS.
    Return the number of useful symbols. */
 
-static long
-remove_useless_symbols (asymbol ** symbols, long count)
+static long long
+remove_useless_symbols (asymbol ** symbols, long long count)
 {
   register asymbol **in_ptr = symbols, **out_ptr = symbols;
 
diff --git a/sim/m32r/m32r-sim.h b/sim/m32r/m32r-sim.h
index 636c63d..7e122e0 100644
--- a/sim/m32r/m32r-sim.h
+++ b/sim/m32r/m32r-sim.h
@@ -86,10 +86,10 @@ typedef struct {
   unsigned int long_count;
 
   /* Working area for computing cycle counts.  */
-  unsigned long insn_cycles; /* FIXME: delete */
-  unsigned long cti_stall;
-  unsigned long load_stall;
-  unsigned long biggest_cycles;
+  unsigned long long insn_cycles; /* FIXME: delete */
+  unsigned long long cti_stall;
+  unsigned long long load_stall;
+  unsigned long long biggest_cycles;
 
   /* Bitmask of registers loaded by previous insn.  */
   unsigned int load_regs;
diff --git a/sim/m32r/m32r.c b/sim/m32r/m32r.c
index 785ce83..a7b10cd 100644
--- a/sim/m32r/m32r.c
+++ b/sim/m32r/m32r.c
@@ -297,11 +297,11 @@ m32rbf_model_insn_after (SIM_CPU *cpu, int last_p, int cycles)
 {
   PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
   M32R_MISC_PROFILE *mp = CPU_M32R_MISC_PROFILE (cpu);
-  unsigned long total = cycles + mp->cti_stall + mp->load_stall;
+  unsigned long long total = cycles + mp->cti_stall + mp->load_stall;
 
   if (last_p)
     {
-      unsigned long biggest = total > mp->biggest_cycles ? total : mp->biggest_cycles;
+      unsigned long long biggest = total > mp->biggest_cycles ? total : mp->biggest_cycles;
       PROFILE_MODEL_TOTAL_CYCLES (p) += biggest;
       PROFILE_MODEL_CUR_INSN_CYCLES (p) = total;
     }
diff --git a/sim/m32r/traps-linux.c b/sim/m32r/traps-linux.c
index 05ec31c..385ea47 100644
--- a/sim/m32r/traps-linux.c
+++ b/sim/m32r/traps-linux.c
@@ -118,7 +118,7 @@ m32r_core_signal (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia,
 
 static void *
 t2h_addr (host_callback *cb, struct cb_syscall *sc,
-          unsigned long taddr)
+          unsigned long long taddr)
 {
   void *addr;
   SIM_DESC sd = (SIM_DESC) sc->p1;
@@ -201,7 +201,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)
     {
     case TRAP_ELF_SYSCALL :
       {
-	long result, result2;
+	long long result, result2;
 	int errcode;
 
 	sim_syscall_multi (current_cpu,
@@ -640,7 +640,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)
               if (treadfdsp != NULL)
                 {
                   translate_endian((void *) &readfds, sizeof(readfds));
-                  if ((s.write_mem) (cb, &s, (unsigned long) treadfdsp,
+                  if ((s.write_mem) (cb, &s, (unsigned long long) treadfdsp,
                        (char *) &readfds, sizeof(readfds)) != sizeof(readfds))
                     {
                       result = -1;
@@ -651,7 +651,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)
               if (twritefdsp != NULL)
                 {
                   translate_endian((void *) &writefds, sizeof(writefds));
-                  if ((s.write_mem) (cb, &s, (unsigned long) twritefdsp,
+                  if ((s.write_mem) (cb, &s, (unsigned long long) twritefdsp,
                        (char *) &writefds, sizeof(writefds)) != sizeof(writefds))
                     {
                       result = -1;
@@ -662,7 +662,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)
               if (texceptfdsp != NULL)
                 {
                   translate_endian((void *) &exceptfds, sizeof(exceptfds));
-                  if ((s.write_mem) (cb, &s, (unsigned long) texceptfdsp,
+                  if ((s.write_mem) (cb, &s, (unsigned long long) texceptfdsp,
                        (char *) &exceptfds, sizeof(exceptfds)) != sizeof(exceptfds))
                     {
                       result = -1;
@@ -671,7 +671,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)
                 }
 
               translate_endian((void *) &timeout, sizeof(timeout));
-              if ((s.write_mem) (cb, &s, (unsigned long) ttimeoutp,
+              if ((s.write_mem) (cb, &s, (unsigned long long) ttimeoutp,
                    (char *) &timeout, sizeof(timeout)) != sizeof(timeout))
                 {
                   result = -1;
diff --git a/sim/m32r/traps.c b/sim/m32r/traps.c
index 285e7fe..13fe927 100644
--- a/sim/m32r/traps.c
+++ b/sim/m32r/traps.c
@@ -117,7 +117,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)
     {
     case TRAP_SYSCALL :
       {
-	long result, result2;
+	long long result, result2;
 	int errcode;
 
 	sim_syscall_multi (current_cpu,
diff --git a/sim/m68hc11/dv-m68hc11.c b/sim/m68hc11/dv-m68hc11.c
index 5900a22..d92f341 100644
--- a/sim/m68hc11/dv-m68hc11.c
+++ b/sim/m68hc11/dv-m68hc11.c
@@ -220,7 +220,7 @@ dv_m6811_attach_address_callback (struct hw *me,
                                   struct hw *client)
 {
   HW_TRACE ((me, "attach - level=%d, space=%d, addr=0x%lx, sz=%ld, client=%s",
-	     level, space, (unsigned long) addr, (unsigned long) nr_bytes,
+	     level, space, (unsigned long long) addr, (unsigned long long) nr_bytes,
              hw_path (client)));
 
   if (space != io_map)
@@ -839,7 +839,7 @@ m68hc11cpu_io_read_buffer (struct hw *me,
   unsigned byte = 0;
   int result;
   
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd  = hw_system (me);
   cpu = STATE_CPU (sd, 0);
@@ -1087,7 +1087,7 @@ m68hc11cpu_io_write_buffer (struct hw *me,
   sim_cpu *cpu;
   int result;
 
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd = hw_system (me); 
   cpu = STATE_CPU (sd, 0);  
diff --git a/sim/m68hc11/dv-m68hc11eepr.c b/sim/m68hc11/dv-m68hc11eepr.c
index ced3fd4..fdbe14f 100644
--- a/sim/m68hc11/dv-m68hc11eepr.c
+++ b/sim/m68hc11/dv-m68hc11eepr.c
@@ -108,7 +108,7 @@ struct m68hc11eepr
      The CONFIG register is programmed in the same way.  It is physically
      located at the end of the EEPROM (eeprom size + 1).  It is not mapped
      in memory but it's saved in the EEPROM file.  */
-  unsigned long		eeprom_wcycle;
+  unsigned long long		eeprom_wcycle;
   uint16		eeprom_waddr;
   uint8			eeprom_wbyte;
   uint8			eeprom_wmode;
@@ -116,7 +116,7 @@ struct m68hc11eepr
   uint8*		eeprom;
   
   /* Minimum time in CPU cycles for programming the EEPROM.  */
-  unsigned long         eeprom_min_cycles;
+  unsigned long long         eeprom_min_cycles;
 
   const char*           file_name;
 };
@@ -399,7 +399,7 @@ m68hc11eepr_io_read_buffer (struct hw *me,
   struct m68hc11eepr *controller;
   sim_cpu *cpu;
   
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd         = hw_system (me);
   controller = hw_data (me);
@@ -455,7 +455,7 @@ m68hc11eepr_io_write_buffer (struct hw *me,
   sim_cpu *cpu;
   uint8 val;
 
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd         = hw_system (me);
   controller = hw_data (me);
@@ -515,7 +515,7 @@ m68hc11eepr_io_write_buffer (struct hw *me,
       else if (cpu->ios[M6811_PPROG] & M6811_PPROG)
 	{
 	  int i;
-	  unsigned long t = cpu_current_cycle (cpu);
+	  unsigned long long t = cpu_current_cycle (cpu);
 
 	  t -= controller->eeprom_wcycle;
 	  if (t < controller->eeprom_min_cycles)
diff --git a/sim/m68hc11/dv-m68hc11sio.c b/sim/m68hc11/dv-m68hc11sio.c
index e8c7835..fe3d765 100644
--- a/sim/m68hc11/dv-m68hc11sio.c
+++ b/sim/m68hc11/dv-m68hc11sio.c
@@ -80,7 +80,7 @@ struct m68hc11sio
   enum {sio_tcp, sio_stdio} backend; /* backend */
 
   /* Number of cpu cycles to send a bit on the wire.  */
-  unsigned long baud_cycle;
+  unsigned long long baud_cycle;
 
   /* Length in bits of characters sent, this includes the
      start/stop and parity bits.  Together with baud_cycle, this
@@ -298,7 +298,7 @@ m68hc11sio_rx_poll (struct hw *me, void *data)
 
   if (cpu->ios[M6811_SCCR2] & M6811_RE)
     {
-      unsigned long clock_cycle;
+      unsigned long long clock_cycle;
 
       /* Compute CPU clock cycles to wait for the next character.  */
       clock_cycle = controller->data_length * controller->baud_cycle;
@@ -358,7 +358,7 @@ m68hc11sio_tx_poll (struct hw *me, void *data)
   if ((cpu->ios[M6811_SCCR2] & M6811_TE)
       && ((cpu->ios[M6811_SCSR] & M6811_TC) == 0))
     {
-      unsigned long clock_cycle;
+      unsigned long long clock_cycle;
       
       /* Compute CPU clock cycles to wait for the next character.  */
       clock_cycle = controller->data_length * controller->baud_cycle;
@@ -423,7 +423,7 @@ m68hc11sio_info (struct hw *me)
   sim_cpu *cpu;
   struct m68hc11sio *controller;
   uint8 val;
-  long clock_cycle;
+  long long clock_cycle;
   
   sd = hw_system (me);
   cpu = STATE_CPU (sd, 0);
@@ -499,7 +499,7 @@ m68hc11sio_io_read_buffer (struct hw *me,
   sim_cpu *cpu;
   unsigned8 val;
   
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd  = hw_system (me);
   cpu = STATE_CPU (sd, 0);
@@ -544,7 +544,7 @@ m68hc11sio_io_write_buffer (struct hw *me,
   sim_cpu *cpu;
   unsigned8 val;
 
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd  = hw_system (me);
   cpu = STATE_CPU (sd, 0);
@@ -555,8 +555,8 @@ m68hc11sio_io_write_buffer (struct hw *me,
     {
     case M6811_BAUD:
       {
-        long divisor;
-        long baud;
+        long long divisor;
+        long long baud;
 
         cpu->ios[M6811_BAUD] = val;        
         switch (val & (M6811_SCP1|M6811_SCP0))
@@ -614,7 +614,7 @@ m68hc11sio_io_write_buffer (struct hw *me,
       /* Activate reception.  */
       if (controller->rx_poll_event == 0)
         {
-          long clock_cycle;
+          long long clock_cycle;
           
           /* Compute CPU clock cycles to wait for the next character.  */
           clock_cycle = controller->data_length * controller->baud_cycle;
diff --git a/sim/m68hc11/dv-m68hc11spi.c b/sim/m68hc11/dv-m68hc11spi.c
index e3ba278..e8fdbc3 100644
--- a/sim/m68hc11/dv-m68hc11spi.c
+++ b/sim/m68hc11/dv-m68hc11spi.c
@@ -388,7 +388,7 @@ m68hc11spi_io_read_buffer (struct hw *me,
   sim_cpu *cpu;
   unsigned8 val;
   
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd  = hw_system (me);
   cpu = STATE_CPU (sd, 0);
@@ -433,7 +433,7 @@ m68hc11spi_io_write_buffer (struct hw *me,
   sim_cpu *cpu;
   unsigned8 val;
 
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd  = hw_system (me);
   cpu = STATE_CPU (sd, 0);
diff --git a/sim/m68hc11/dv-m68hc11tim.c b/sim/m68hc11/dv-m68hc11tim.c
index d265b23..5be1cdc 100644
--- a/sim/m68hc11/dv-m68hc11tim.c
+++ b/sim/m68hc11/dv-m68hc11tim.c
@@ -79,9 +79,9 @@ static const struct hw_port_descriptor m68hc11tim_ports[] =
 /* Timer Controller information.  */
 struct m68hc11tim 
 {
-  unsigned long cop_delay;
-  unsigned long rti_delay;
-  unsigned long ovf_delay;
+  unsigned long long cop_delay;
+  unsigned long long rti_delay;
+  unsigned long long ovf_delay;
   signed64      clock_prescaler;
   signed64      tcnt_adjust;
   signed64      cop_prev_interrupt;
@@ -243,13 +243,13 @@ m68hc11tim_timer_event (struct hw *me, void *data)
   struct m68hc11tim *controller;
   sim_cpu *cpu;
   enum event_type type;
-  unsigned long delay;
+  unsigned long long delay;
   struct hw_event **eventp;
   int check_interrupt = 0;
   unsigned mask;
   unsigned flags;
-  unsigned long tcnt_internal;
-  unsigned long tcnt, tcnt_prev;
+  unsigned long long tcnt_internal;
+  unsigned long long tcnt, tcnt_prev;
   signed64 tcnt_insn_end;
   signed64 tcnt_insn_start;
   int i;
@@ -258,7 +258,7 @@ m68hc11tim_timer_event (struct hw *me, void *data)
   controller = hw_data (me);
   sd         = hw_system (me);
   cpu        = STATE_CPU (sd, 0);
-  type       = (enum event_type) ((long) data) & 0x0FF;
+  type       = (enum event_type) ((long long) data) & 0x0FF;
   events     = STATE_EVENTS (sd);
 
   delay = 0;
@@ -278,7 +278,7 @@ m68hc11tim_timer_event (struct hw *me, void *data)
       eventp = &controller->rti_timer_event;
       delay  = controller->rti_prev_interrupt + controller->rti_delay;
       
-      if (((long) (data) & 0x0100) == 0)
+      if (((long long) (data) & 0x0100) == 0)
         {
           cpu->ios[M6811_TFLG2] |= M6811_RTIF;
           check_interrupt = 1;
@@ -306,7 +306,7 @@ m68hc11tim_timer_event (struct hw *me, void *data)
       delay += events->nr_ticks_to_process;
 
       eventp = &controller->tof_timer_event;
-      if (((long) (data) & 0x100) == 0)
+      if (((long long) (data) & 0x100) == 0)
         {
           cpu->ios[M6811_TFLG2] |= M6811_TOF;
           check_interrupt = 1;
@@ -339,7 +339,7 @@ m68hc11tim_timer_event (struct hw *me, void *data)
          if the output compare is enabled.  */
       for (i = M6811_TOC1; i <= M6811_TOC5; i += 2, mask >>= 1)
         {
-          unsigned long compare;
+          unsigned long long compare;
 
           compare = (cpu->ios[i] << 8) + cpu->ios[i + 1];
 
@@ -501,7 +501,7 @@ cycle_to_string (sim_cpu *cpu, signed64 t, int flags)
              (t > 1 ? "s" : ""));
 
   if (t < LONG_MAX)
-    sprintf (buf, "%9lu%s%s", (unsigned long) t, cycle_buf, time_buf);
+    sprintf (buf, "%9lu%s%s", (unsigned long long) t, cycle_buf, time_buf);
   else
     sprintf (buf, "%llu%s%s", t, cycle_buf, time_buf);
   return buf;
@@ -646,7 +646,7 @@ m68hc11tim_io_read_buffer (struct hw *me,
   unsigned8 val;
   unsigned cnt = 0;
   
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd  = hw_system (me);
   cpu = STATE_CPU (sd, 0);
@@ -698,7 +698,7 @@ m68hc11tim_io_write_buffer (struct hw *me,
   int reset_overflow = 0;
   int cnt = 0;
   
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   sd  = hw_system (me);
   cpu = STATE_CPU (sd, 0);
@@ -772,7 +772,7 @@ m68hc11tim_io_write_buffer (struct hw *me,
           n = (1 << ((val & (M6811_RTR1 | M6811_RTR0))));
           cpu->ios[base] = val;
 
-          controller->rti_delay = (long) (n) * 8192;
+          controller->rti_delay = (long long) (n) * 8192;
           m68hc11tim_timer_event (me, (void*) (RTI_EVENT| 0x100));
           break;
       
diff --git a/sim/m68hc11/dv-nvram.c b/sim/m68hc11/dv-nvram.c
index c5fd637..0da0f4a 100644
--- a/sim/m68hc11/dv-nvram.c
+++ b/sim/m68hc11/dv-nvram.c
@@ -263,8 +263,8 @@ nvram_io_read_buffer (struct hw *me,
   struct nvram *controller = hw_data (me);
   
   HW_TRACE ((me, "read 0x%08lx %d [%ld]",
-             (long) base, (int) nr_bytes,
-             (long) (base - controller->base_address)));
+             (long long) base, (int) nr_bytes,
+             (long long) (base - controller->base_address)));
 
   base -= controller->base_address;
   if (base + nr_bytes > controller->size)
@@ -286,8 +286,8 @@ nvram_io_write_buffer (struct hw *me,
   struct nvram *controller = hw_data (me);
 
   HW_TRACE ((me, "write 0x%08lx %d [%ld]",
-             (long) base, (int) nr_bytes,
-             (long) (base - controller->base_address)));
+             (long long) base, (int) nr_bytes,
+             (long long) (base - controller->base_address)));
 
   base -= controller->base_address;
   if (base + nr_bytes > controller->size)
diff --git a/sim/m68hc11/interrupts.c b/sim/m68hc11/interrupts.c
index c57443b..8c179ba 100644
--- a/sim/m68hc11/interrupts.c
+++ b/sim/m68hc11/interrupts.c
@@ -282,8 +282,8 @@ interrupts_update_pending (struct interrupts *interrupts)
 {
   int i;
   uint8 *ioregs;
-  unsigned long clear_mask;
-  unsigned long set_mask;
+  unsigned long long clear_mask;
+  unsigned long long set_mask;
 
   clear_mask = 0;
   set_mask = 0;
diff --git a/sim/m68hc11/interrupts.h b/sim/m68hc11/interrupts.h
index 0b47c44..a1d0eda 100644
--- a/sim/m68hc11/interrupts.h
+++ b/sim/m68hc11/interrupts.h
@@ -104,7 +104,7 @@ struct interrupt
   signed64         cpu_cycle;
 
   /* Number of times the interrupt was raised.  */
-  unsigned long    raised_count;
+  unsigned long long    raised_count;
 
   /* Controls whether we must stop the simulator.  */
   int              stop_mode;
@@ -125,7 +125,7 @@ struct interrupts {
   sim_cpu           *cpu;
 
   /* Mask of current pending interrupts.  */
-  unsigned long     pending_mask;
+  unsigned long long     pending_mask;
 
   /* Address of vector table.  This is set depending on the
      68hc11 init mode.  */
@@ -151,7 +151,7 @@ struct interrupts {
   signed64          xirq_last_mask_cycles;
 
   /* - Total number of interrupts raised.  */
-  unsigned long     nb_interrupts_raised;
+  unsigned long long     nb_interrupts_raised;
 
   /* Interrupt history to help understand which interrupts
      were raised recently and in which order.  */
diff --git a/sim/m68hc11/sim-main.h b/sim/m68hc11/sim-main.h
index 61b55f6..048444e 100644
--- a/sim/m68hc11/sim-main.h
+++ b/sim/m68hc11/sim-main.h
@@ -188,7 +188,7 @@ struct _sim_cpu {
   /* CPU frequency.  This is the quartz frequency.  It is divided by 4 to
      get the cycle time.  This is used for the timer rate and for the baud
      rate generation.  */
-  unsigned long         cpu_frequency;
+  unsigned long long         cpu_frequency;
 
   /* The mode in which the CPU is configured (MODA and MODB pins).  */
   unsigned int          cpu_mode;
diff --git a/sim/mcore/interp.c b/sim/mcore/interp.c
index ff4bfdf..82df95e 100644
--- a/sim/mcore/interp.c
+++ b/sim/mcore/interp.c
@@ -37,17 +37,17 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #define target_big_endian (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
 
 
-static unsigned long
+static unsigned long long
 mcore_extract_unsigned_integer (unsigned char *addr, int len)
 {
-  unsigned long retval;
+  unsigned long long retval;
   unsigned char * p;
   unsigned char * startaddr = (unsigned char *)addr;
   unsigned char * endaddr = startaddr + len;
 
-  if (len > (int) sizeof (unsigned long))
+  if (len > (int) sizeof (unsigned long long))
     printf ("That operation is not available on integers of more than %zu bytes.",
-	    sizeof (unsigned long));
+	    sizeof (unsigned long long));
 
   /* Start at the most significant end of the integer, and work towards
      the least significant.  */
@@ -68,7 +68,7 @@ mcore_extract_unsigned_integer (unsigned char *addr, int len)
 }
 
 static void
-mcore_store_unsigned_integer (unsigned char *addr, int len, unsigned long val)
+mcore_store_unsigned_integer (unsigned char *addr, int len, unsigned long long val)
 {
   unsigned char * p;
   unsigned char * startaddr = (unsigned char *)addr;
@@ -232,9 +232,9 @@ util (SIM_DESC sd, SIM_CPU *cpu, unsigned what)
 
 /* For figuring out whether we carried; addc/subc use this. */
 static int
-iu_carry (unsigned long a, unsigned long b, int cin)
+iu_carry (unsigned long long a, unsigned long long b, int cin)
 {
-  unsigned long	x;
+  unsigned long long	x;
 
   x = (a & 0xffff) + (b & 0xffff) + cin;
   x = (x >> 16) + (a >> 16) + (b >> 16);
@@ -626,7 +626,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	      break;
 	    case 0x5:					/* sextb */
 	      {
-		long tmp;
+		long long tmp;
 		tmp = gr[RD];
 		tmp <<= 24;
 		tmp >>= 24;
@@ -638,7 +638,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	      break;
 	    case 0x7:					/* sexth */
 	      {
-		long tmp;
+		long long tmp;
 		tmp = gr[RD];
 		tmp <<= 16;
 		tmp >>= 16;
@@ -647,7 +647,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	      break;
 	    case 0x8:					/* declt */
 	      --gr[RD];
-	      NEW_C ((long)gr[RD] < 0);
+	      NEW_C ((long long)gr[RD] < 0);
 	      break;
 	    case 0x9:					/* tstnbz */
 	      {
@@ -659,11 +659,11 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	      break;
 	    case 0xA:					/* decgt */
 	      --gr[RD];
-	      NEW_C ((long)gr[RD] > 0);
+	      NEW_C ((long long)gr[RD] > 0);
 	      break;
 	    case 0xB:					/* decne */
 	      --gr[RD];
-	      NEW_C ((long)gr[RD] != 0);
+	      NEW_C ((long long)gr[RD] != 0);
 	      break;
 	    case 0xC:					/* clrt */
 	      if (C_ON())
@@ -709,14 +709,14 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	      needfetch = 1;
 	    }
 	  --gr[RS];				/* not RD! */
-	  NEW_C (((long)gr[RS]) > 0);
+	  NEW_C (((long long)gr[RS]) > 0);
 	  break;
 	case 0x05:					/* subu */
 	  gr[RD] -= gr[RS];
 	  break;
 	case 0x06:					/* addc */
 	  {
-	    unsigned long tmp, a, b;
+	    unsigned long long tmp, a, b;
 	    a = gr[RD];
 	    b = gr[RS];
 	    gr[RD] = a + b + C_VALUE ();
@@ -726,7 +726,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	  break;
 	case 0x07:					/* subc */
 	  {
-	    unsigned long tmp, a, b;
+	    unsigned long long tmp, a, b;
 	    a = gr[RD];
 	    b = gr[RS];
 	    gr[RD] = a - b + C_VALUE () - 1;
@@ -744,7 +744,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	  break;
 	case 0x0B:					/* lsr */
 	  {
-	    unsigned long dst, src;
+	    unsigned long long dst, src;
 	    dst = gr[RD];
 	    src = gr[RS];
 	    /* We must not rely solely upon the native shift operations, since they
@@ -754,11 +754,11 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	  }
 	  break;
 	case 0x0C:					/* cmphs */
-	  NEW_C ((unsigned long )gr[RD] >=
-		 (unsigned long)gr[RS]);
+	  NEW_C ((unsigned long long )gr[RD] >=
+		 (unsigned long long)gr[RS]);
 	  break;
 	case 0x0D:					/* cmplt */
-	  NEW_C ((long)gr[RD] < (long)gr[RS]);
+	  NEW_C ((long long)gr[RD] < (long long)gr[RS]);
 	  break;
 	case 0x0E:					/* tst */
 	  NEW_C ((gr[RD] & gr[RS]) != 0);
@@ -824,9 +824,9 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	  /* We must not rely solely upon the native shift operations, since they
 	     may not match the M*Core's behaviour on boundary conditions.  */
 	  if (gr[RS] > 30)
-	    gr[RD] = ((long) gr[RD]) < 0 ? -1 : 0;
+	    gr[RD] = ((long long) gr[RD]) < 0 ? -1 : 0;
 	  else
-	    gr[RD] = (long) gr[RD] >> gr[RS];
+	    gr[RD] = (long long) gr[RD] >> gr[RS];
 	  break;
 
 	case 0x1B:					/* lsl */
@@ -1006,7 +1006,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	case 0x38: case 0x39:				/* xsr, rotli */
 	  {
 	    unsigned imm = IMM5;
-	    unsigned long tmp = gr[RD];
+	    unsigned long long tmp = gr[RD];
 	    if (imm == 0)
 	      {
 		word cbit;
@@ -1021,7 +1021,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	case 0x3A: case 0x3B:				/* asrc, asri */
 	  {
 	    unsigned imm = IMM5;
-	    long tmp = gr[RD];
+	    long long tmp = gr[RD];
 	    if (imm == 0)
 	      {
 		NEW_C (tmp);
@@ -1034,7 +1034,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	case 0x3C: case 0x3D:				/* lslc, lsli */
 	  {
 	    unsigned imm = IMM5;
-	    unsigned long tmp = gr[RD];
+	    unsigned long long tmp = gr[RD];
 	    if (imm == 0)
 	      {
 		NEW_C (tmp >> 31);
@@ -1047,7 +1047,7 @@ step_once (SIM_DESC sd, SIM_CPU *cpu)
 	case 0x3E: case 0x3F:				/* lsrc, lsri */
 	  {
 	    unsigned imm = IMM5;
-	    unsigned long tmp = gr[RD];
+	    unsigned long long tmp = gr[RD];
 	    if (imm == 0)
 	      {
 		NEW_C (tmp);
@@ -1244,7 +1244,7 @@ mcore_reg_store (SIM_CPU *cpu, int rn, unsigned char *memory, int length)
     {
       if (length == 4)
 	{
-	  long ival;
+	  long long ival;
 
 	  /* misalignment safe */
 	  ival = mcore_extract_unsigned_integer (memory, 4);
@@ -1264,7 +1264,7 @@ mcore_reg_fetch (SIM_CPU *cpu, int rn, unsigned char *memory, int length)
     {
       if (length == 4)
 	{
-	  long ival = cpu->asints[rn];
+	  long long ival = cpu->asints[rn];
 
 	  /* misalignment-safe */
 	  mcore_store_unsigned_integer (memory, 4, ival);
@@ -1423,9 +1423,9 @@ sim_create_inferior (SIM_DESC sd, struct bfd *prog_bfd,
   int nenv = 0;
   int s_length;
   int l;
-  unsigned long strings;
-  unsigned long pointers;
-  unsigned long hi_stack;
+  unsigned long long strings;
+  unsigned long long pointers;
+  unsigned long long hi_stack;
 
 
   /* Set the initial register set.  */
diff --git a/sim/mcore/sim-main.h b/sim/mcore/sim-main.h
index 9d63ab8..cdb6b83 100644
--- a/sim/mcore/sim-main.h
+++ b/sim/mcore/sim-main.h
@@ -21,8 +21,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 #include "sim-basics.h"
 
-typedef long int           word;
-typedef unsigned long int  uword;
+typedef long long int           word;
+typedef unsigned long long int  uword;
 
 #include "sim-base.h"
 #include "bfd.h"
diff --git a/sim/microblaze/interp.c b/sim/microblaze/interp.c
index 563bd1a..fb7537d 100644
--- a/sim/microblaze/interp.c
+++ b/sim/microblaze/interp.c
@@ -33,17 +33,17 @@
 
 #define target_big_endian (CURRENT_TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
 
-static unsigned long
+static unsigned long long
 microblaze_extract_unsigned_integer (unsigned char *addr, int len)
 {
-  unsigned long retval;
+  unsigned long long retval;
   unsigned char *p;
   unsigned char *startaddr = (unsigned char *)addr;
   unsigned char *endaddr = startaddr + len;
 
-  if (len > (int) sizeof (unsigned long))
+  if (len > (int) sizeof (unsigned long long))
     printf ("That operation is not available on integers of more than "
-	    "%zu bytes.", sizeof (unsigned long));
+	    "%zu bytes.", sizeof (unsigned long long));
 
   /* Start at the most significant end of the integer, and work towards
      the least significant.  */
@@ -65,7 +65,7 @@ microblaze_extract_unsigned_integer (unsigned char *addr, int len)
 
 static void
 microblaze_store_unsigned_integer (unsigned char *addr, int len,
-				   unsigned long val)
+				   unsigned long long val)
 {
   unsigned char *p;
   unsigned char *startaddr = (unsigned char *)addr;
@@ -93,7 +93,7 @@ static void
 set_initial_gprs (SIM_CPU *cpu)
 {
   int i;
-  long space;
+  long long space;
 
   /* Set up machine just out of reset.  */
   PC = 0;
@@ -128,7 +128,7 @@ sim_engine_run (SIM_DESC sd,
   ubyte carry;
   int imm_unsigned;
   short ra, rb, rd;
-  long immword;
+  long long immword;
   uword oldpc, newpc;
   short delay_slot_enable;
   short branch_taken;
@@ -312,7 +312,7 @@ microblaze_reg_store (SIM_CPU *cpu, int rn, unsigned char *memory, int length)
       if (length == 4)
 	{
 	  /* misalignment safe */
-	  long ival = microblaze_extract_unsigned_integer (memory, 4);
+	  long long ival = microblaze_extract_unsigned_integer (memory, 4);
 	  if (rn < NUM_REGS)
 	    CPU.regs[rn] = ival;
 	  else
@@ -329,7 +329,7 @@ microblaze_reg_store (SIM_CPU *cpu, int rn, unsigned char *memory, int length)
 static int
 microblaze_reg_fetch (SIM_CPU *cpu, int rn, unsigned char *memory, int length)
 {
-  long ival;
+  long long ival;
 
   if (rn < NUM_REGS + NUM_SPECIAL && rn >= 0)
     {
diff --git a/sim/mips/dv-tx3904cpu.c b/sim/mips/dv-tx3904cpu.c
index 44e83e9..a23b628 100644
--- a/sim/mips/dv-tx3904cpu.c
+++ b/sim/mips/dv-tx3904cpu.c
@@ -149,20 +149,20 @@ deliver_tx3904cpu_interrupt (struct hw *me,
   if (controller->pending_reset)
     {
       controller->pending_reset = 0;
-      HW_TRACE ((me, "reset pc=0x%08lx", (long) CPU_PC_GET (cpu)));
+      HW_TRACE ((me, "reset pc=0x%08lx", (long long) CPU_PC_GET (cpu)));
       SignalExceptionNMIReset();
     }
   else if (controller->pending_nmi)
     {
       controller->pending_nmi = 0;
-      HW_TRACE ((me, "nmi pc=0x%08lx", (long) CPU_PC_GET (cpu)));
+      HW_TRACE ((me, "nmi pc=0x%08lx", (long long) CPU_PC_GET (cpu)));
       SignalExceptionNMIReset();
     }
   else if (controller->pending_level)
     {
       HW_TRACE ((me, "interrupt level=%d pc=0x%08lx sr=0x%08lx",
 		 controller->pending_level,
-		 (long) CPU_PC_GET (cpu), (long) SR));
+		 (long long) CPU_PC_GET (cpu), (long long) SR));
 
       /* Clear CAUSE register.  It may stay this way if the interrupt
 	 was cleared with a negative pending_level. */
diff --git a/sim/mips/dv-tx3904irc.c b/sim/mips/dv-tx3904irc.c
index 1a97ab7..1e4b494 100644
--- a/sim/mips/dv-tx3904irc.c
+++ b/sim/mips/dv-tx3904irc.c
@@ -332,7 +332,7 @@ tx3904irc_io_read_buffer (struct hw *me,
   struct tx3904irc *controller = hw_data (me);
   unsigned byte;
 
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
   for (byte = 0; byte < nr_bytes; byte++)
     {
       address_word address = base + byte;
@@ -372,7 +372,7 @@ tx3904irc_io_write_buffer (struct hw *me,
   struct tx3904irc *controller = hw_data (me);
   unsigned byte;
 
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
   for (byte = 0; byte < nr_bytes; byte++)
     {
       address_word address = base + byte;
diff --git a/sim/mips/dv-tx3904sio.c b/sim/mips/dv-tx3904sio.c
index 0dda245..aeb928a 100644
--- a/sim/mips/dv-tx3904sio.c
+++ b/sim/mips/dv-tx3904sio.c
@@ -316,7 +316,7 @@ tx3904sio_io_read_buffer (struct hw *me,
   struct tx3904sio *controller = hw_data (me);
   unsigned byte;
 
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   /* tickle fifos */
   tx3904sio_tickle(me);
@@ -369,7 +369,7 @@ tx3904sio_io_write_buffer (struct hw *me,
   struct tx3904sio *controller = hw_data (me);
   unsigned byte;
 
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
   for (byte = 0; byte < nr_bytes; byte++)
     {
       address_word address = base + byte;
diff --git a/sim/mips/dv-tx3904tmr.c b/sim/mips/dv-tx3904tmr.c
index 4ac2f2e..f553818 100644
--- a/sim/mips/dv-tx3904tmr.c
+++ b/sim/mips/dv-tx3904tmr.c
@@ -325,7 +325,7 @@ tx3904tmr_io_read_buffer (struct hw *me,
   struct tx3904tmr *controller = hw_data (me);
   unsigned byte;
 
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
   for (byte = 0; byte < nr_bytes; byte++)
     {
       address_word address = base + byte;
@@ -367,7 +367,7 @@ tx3904tmr_io_write_buffer (struct hw *me,
   struct tx3904tmr *controller = hw_data (me);
   unsigned byte;
 
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
   for (byte = 0; byte < nr_bytes; byte++)
     {
       address_word address = base + byte;
diff --git a/sim/mips/interp.c b/sim/mips/interp.c
index 9dbac8c..2475c06 100644
--- a/sim/mips/interp.c
+++ b/sim/mips/interp.c
@@ -446,7 +446,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,
 	    mem_size = K1SIZE;
 	  /* memory alias K1BASE@1,K1SIZE%MEMSIZE,K0BASE */
 	  sim_do_commandf (sd, "memory alias 0x%lx@1,0x%lx%%0x%lx,0x%0x",
-			   K1BASE, K1SIZE, (long)mem_size, K0BASE);
+			   K1BASE, K1SIZE, (long long)mem_size, K0BASE);
 	}
 
       device_init(sd);
@@ -2225,7 +2225,7 @@ decode_coproc (SIM_DESC sd,
 		if (STATE_VERBOSE_P(SD))
 		  sim_io_eprintf (SD, 
 				  "Warning: PC 0x%lx:interp.c decode_coproc DEADC0DE\n",
-				  (unsigned long)cia);
+				  (unsigned long long)cia);
 		GPR[rt] = 0xDEADC0DE; /* CPR[0,rd] */
 		/* CPR[0,rd] = GPR[rt]; */
 	      default:
@@ -2369,10 +2369,10 @@ pr_addr (SIM_ADDR addr)
     {
       case 8:
         sprintf(paddr_str,"%08lx%08lx",
-		(unsigned long)(addr>>thirty_two),(unsigned long)(addr&0xffffffff));
+		(unsigned long long)(addr>>thirty_two),(unsigned long long)(addr&0xffffffff));
 	break;
       case 4:
-        sprintf(paddr_str,"%08lx",(unsigned long)addr);
+        sprintf(paddr_str,"%08lx",(unsigned long long)addr);
 	break;
       case 2:
         sprintf(paddr_str,"%04x",(unsigned short)(addr&0xffff));
@@ -2388,7 +2388,7 @@ pr_uword64 (uword64 addr)
 {
   char *paddr_str=get_cell();
   sprintf(paddr_str,"%08lx%08lx",
-          (unsigned long)(addr>>thirty_two),(unsigned long)(addr&0xffffffff));
+          (unsigned long long)(addr>>thirty_two),(unsigned long long)(addr&0xffffffff));
   return paddr_str;
 }
 
@@ -2411,7 +2411,7 @@ mips_core_signal (SIM_DESC sd,
     case sim_core_unmapped_signal:
       sim_io_eprintf (sd, "mips-core: %d byte %s to unmapped address 0x%lx at 0x%lx\n",
                       nr_bytes, copy, 
-		      (unsigned long) addr, (unsigned long) ip);
+		      (unsigned long long) addr, (unsigned long long) ip);
       COP0_BADVADDR = addr;
       SignalExceptionDataReference();
       break;
@@ -2419,7 +2419,7 @@ mips_core_signal (SIM_DESC sd,
     case sim_core_unaligned_signal:
       sim_io_eprintf (sd, "mips-core: %d byte %s to unaligned address 0x%lx at 0x%lx\n",
                       nr_bytes, copy, 
-		      (unsigned long) addr, (unsigned long) ip);
+		      (unsigned long long) addr, (unsigned long long) ip);
       COP0_BADVADDR = addr;
       if(transfer == read_transfer) 
 	SignalExceptionAddressLoad();
diff --git a/sim/mips/sim-main.c b/sim/mips/sim-main.c
index d61ce61..081f1e3 100644
--- a/sim/mips/sim-main.c
+++ b/sim/mips/sim-main.c
@@ -400,7 +400,7 @@ pending_tick (SIM_DESC SD,
 	      address_word cia)
 {
   if (PENDING_TRACE)							
-    sim_io_eprintf (SD, "PENDING_DRAIN - 0x%lx - pending_in = %d, pending_out = %d, pending_total = %d\n", (unsigned long) cia, PENDING_IN, PENDING_OUT, PENDING_TOTAL); 
+    sim_io_eprintf (SD, "PENDING_DRAIN - 0x%lx - pending_in = %d, pending_out = %d, pending_total = %d\n", (unsigned long long) cia, PENDING_IN, PENDING_OUT, PENDING_TOTAL); 
   if (PENDING_OUT != PENDING_IN)					
     {									
       int loop;							
@@ -420,9 +420,9 @@ pending_tick (SIM_DESC SD,
 		  if (PENDING_TRACE)
 		    sim_io_eprintf (SD, "PENDING_DRAIN - drained - index %d, dest 0x%lx, bit %d, val 0x%lx, size %d\n",
 				    index,
-				    (unsigned long) PENDING_SLOT_DEST[index],
+				    (unsigned long long) PENDING_SLOT_DEST[index],
 				    PENDING_SLOT_BIT[index],
-				    (unsigned long) PENDING_SLOT_VALUE[index],
+				    (unsigned long long) PENDING_SLOT_VALUE[index],
 				    PENDING_SLOT_SIZE[index]);
 		  if (PENDING_SLOT_BIT[index] >= 0)			
 		    switch (PENDING_SLOT_SIZE[index])                 
@@ -466,9 +466,9 @@ pending_tick (SIM_DESC SD,
 	      else if (PENDING_TRACE && PENDING_SLOT_DELAY[index] > 0)
 		sim_io_eprintf (SD, "PENDING_DRAIN - queued - index %d, delay %d, dest 0x%lx, bit %d, val 0x%lx, size %d\n",
 				index, PENDING_SLOT_DELAY[index],
-				(unsigned long) PENDING_SLOT_DEST[index],
+				(unsigned long long) PENDING_SLOT_DEST[index],
 				PENDING_SLOT_BIT[index],
-				(unsigned long) PENDING_SLOT_VALUE[index],
+				(unsigned long long) PENDING_SLOT_VALUE[index],
 				PENDING_SLOT_SIZE[index]);
 
 	    }								
diff --git a/sim/mips/sim-main.h b/sim/mips/sim-main.h
index 517b219..b0eb9ca 100644
--- a/sim/mips/sim-main.h
+++ b/sim/mips/sim-main.h
@@ -197,8 +197,8 @@ memset (&(CPU)->pending, 0, sizeof ((CPU)->pending))
 		        "PENDING_SCHED - buffer overflow\n");		\
     if (PENDING_TRACE)							\
       sim_io_eprintf (SD, "PENDING_SCHED - 0x%lx - dest 0x%lx, val 0x%lx, bit %d, size %d, pending_in %d, pending_out %d, pending_total %d\n",			\
-		      (unsigned long) cia, (unsigned long) &(DEST),	\
-		      (unsigned long) (VAL), (BIT), (int) sizeof (DEST),\
+		      (unsigned long long) cia, (unsigned long long) &(DEST),	\
+		      (unsigned long long) (VAL), (BIT), (int) sizeof (DEST),\
 		      PENDING_IN, PENDING_OUT, PENDING_TOTAL);		\
     PENDING_SLOT_DELAY[PENDING_IN] = (DELAY) + 1;			\
     PENDING_SLOT_DEST[PENDING_IN] = &(DEST);				\
diff --git a/sim/mn10300/dv-mn103cpu.c b/sim/mn10300/dv-mn103cpu.c
index 3acc2c8..1f70917 100644
--- a/sim/mn10300/dv-mn103cpu.c
+++ b/sim/mn10300/dv-mn103cpu.c
@@ -233,7 +233,7 @@ deliver_mn103cpu_interrupt (struct hw *me,
       SP = SP - 8;
       CPU_PC_SET (cpu, 0x40000008);
       HW_TRACE ((me, "nmi pc=0x%08lx psw=0x%04x sp=0x%08lx",
-		 (long) CPU_PC_GET (cpu), (unsigned) PSW, (long) SP));
+		 (long long) CPU_PC_GET (cpu), (unsigned) PSW, (long long) SP));
     }
   else if ((controller->pending_level < EXTRACT_PSW_LM)
 	   && (PSW & PSW_IE))
@@ -251,7 +251,7 @@ deliver_mn103cpu_interrupt (struct hw *me,
       hw_port_event (me, ACK_PORT, controller->pending_level);
       HW_TRACE ((me, "int level=%d pc=0x%08lx psw=0x%04x sp=0x%08lx",
 		 controller->pending_level,
-		 (long) CPU_PC_GET (cpu), (unsigned) PSW, (long) SP));
+		 (long long) CPU_PC_GET (cpu), (unsigned) PSW, (long long) SP));
     }
 
   if (controller->pending_level < 7) /* FIXME */
@@ -413,7 +413,7 @@ mn103cpu_io_write_buffer (struct hw *me,
     case IVR5_REG:
     case IVR6_REG:
       controller->interrupt_vector[reg - IVR0_REG] = val;
-      HW_TRACE ((me, "ivr%d = 0x%04lx", reg - IVR0_REG, (long) val));
+      HW_TRACE ((me, "ivr%d = 0x%04lx", reg - IVR0_REG, (long long) val));
       break;
     default:
       /* just ignore the write */
diff --git a/sim/mn10300/dv-mn103int.c b/sim/mn10300/dv-mn103int.c
index 93de69f..f9ce5e2 100644
--- a/sim/mn10300/dv-mn103int.c
+++ b/sim/mn10300/dv-mn103int.c
@@ -660,7 +660,7 @@ read_iagr (struct hw *me,
       break;
     default:
       val = 0;
-      HW_TRACE ((me, "read-iagr 0x%08lx bad offset", (long) offset));
+      HW_TRACE ((me, "read-iagr 0x%08lx bad offset", (long long) offset));
       break;
     }
   return val;
@@ -700,7 +700,7 @@ read_extmd (struct hw *me,
 	  val |= (group[gid].trigger << (gid * 2));
 	}
     }
-  HW_TRACE ((me, "read-extmd 0x%02lx", (long) val));
+  HW_TRACE ((me, "read-extmd 0x%02lx", (long long) val));
   return val;
 }
 
@@ -720,7 +720,7 @@ write_extmd (struct hw *me,
 	  /* MAYBE: interrupts already pending? */
 	}
     }
-  HW_TRACE ((me, "write-extmd 0x%02lx", (long) val));
+  HW_TRACE ((me, "write-extmd 0x%02lx", (long long) val));
 }
 
 
diff --git a/sim/mn10300/dv-mn103iop.c b/sim/mn10300/dv-mn103iop.c
index 44781e5..f026d57 100644
--- a/sim/mn10300/dv-mn103iop.c
+++ b/sim/mn10300/dv-mn103iop.c
@@ -316,7 +316,7 @@ mn103iop_io_read_buffer (struct hw *me,
 {
   struct mn103iop *io_port = hw_data (me);
   enum io_port_register_types io_port_reg;
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   io_port_reg = decode_addr (me, io_port, base);
   switch (io_port_reg)
@@ -499,7 +499,7 @@ mn103iop_io_write_buffer (struct hw *me,
 {
   struct mn103iop *io_port = hw_data (me);
   enum io_port_register_types io_port_reg;
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   io_port_reg = decode_addr (me, io_port, base);
   switch (io_port_reg)
diff --git a/sim/mn10300/dv-mn103ser.c b/sim/mn10300/dv-mn103ser.c
index 96eb44e..6c1162d 100644
--- a/sim/mn10300/dv-mn103ser.c
+++ b/sim/mn10300/dv-mn103ser.c
@@ -235,7 +235,7 @@ do_polling_event (struct hw *me,
 {
   SIM_DESC sd = hw_system (me);
   struct mn103ser *serial = hw_data(me);
-  long serial_reg = (long) data;
+  long long serial_reg = (long long) data;
   char c;
   int count, status;
 
@@ -421,7 +421,7 @@ read_status_reg (struct hw *me,
       serial->device[serial_reg].event
 	= hw_event_queue_schedule (me, 1000,
 				   do_polling_event,
-				   (void *) (long) serial_reg);
+				   (void *) (long long) serial_reg);
     }
 
   if ( nr_bytes == 1 )
@@ -466,7 +466,7 @@ mn103ser_io_read_buffer (struct hw *me,
 {
   struct mn103ser *serial = hw_data (me);
   enum serial_register_types serial_reg;
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   serial_reg = decode_addr (me, serial, base);
   switch (serial_reg)
@@ -650,7 +650,7 @@ mn103ser_io_write_buffer (struct hw *me,
 {
   struct mn103ser *serial = hw_data (me);
   enum serial_register_types serial_reg;
-  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "write 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   serial_reg = decode_addr (me, serial, base);
   switch (serial_reg)
diff --git a/sim/mn10300/dv-mn103tim.c b/sim/mn10300/dv-mn103tim.c
index f0adaf1..632d0ee 100644
--- a/sim/mn10300/dv-mn103tim.c
+++ b/sim/mn10300/dv-mn103tim.c
@@ -531,7 +531,7 @@ mn103tim_io_read_buffer (struct hw *me,
   struct mn103tim *timers = hw_data (me);
   enum timer_register_types timer_reg;
 
-  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));
+  HW_TRACE ((me, "read 0x%08lx %d", (long long) base, (int) nr_bytes));
 
   timer_reg = decode_addr (me, timers, base);
 
@@ -567,7 +567,7 @@ do_counter_event (struct hw *me,
 		  void *data)
 {
   struct mn103tim *timers = hw_data(me);
-  long timer_nr = (long) data;
+  long long timer_nr = (long long) data;
   int next_timer;
 
   /* Check if counting is still enabled. */
@@ -608,7 +608,7 @@ do_counter6_event (struct hw *me,
 		  void *data)
 {
   struct mn103tim *timers = hw_data(me);
-  long timer_nr = (long) data;
+  long long timer_nr = (long long) data;
   int next_timer;
 
   /* Check if counting is still enabled. */
@@ -704,7 +704,7 @@ write_base_reg (struct hw *me,
 static void
 write_mode_reg (struct hw *me,
 		struct mn103tim *timers,
-		long timer_nr,
+		long long timer_nr,
 		const void *source,
 		unsigned nr_bytes)
      /* for timers 0 to 5 */
@@ -839,7 +839,7 @@ write_tm6md (struct hw *me,
 {
   unsigned8 mode_val0 = 0x00, mode_val1 = 0x00;
   unsigned32 div_ratio;
-  long timer_nr = 6;
+  long long timer_nr = 6;
 
   unsigned_word offset = address - timers->block[0].base;
   
@@ -988,7 +988,7 @@ mn103tim_io_write_buffer (struct hw *me,
   struct mn103tim *timers = hw_data (me);
   enum timer_register_types timer_reg;
 
-  HW_TRACE ((me, "write to 0x%08lx length %d with 0x%x", (long) base,
+  HW_TRACE ((me, "write to 0x%08lx length %d with 0x%x", (long long) base,
 	     (int) nr_bytes, *(unsigned32 *)source));
 
   timer_reg = decode_addr (me, timers, base);
diff --git a/sim/mn10300/interp.c b/sim/mn10300/interp.c
index 7f0655f..508ff90 100644
--- a/sim/mn10300/interp.c
+++ b/sim/mn10300/interp.c
@@ -379,14 +379,14 @@ mn10300_core_signal (SIM_DESC sd,
     case sim_core_unmapped_signal:
       sim_io_eprintf (sd, "mn10300-core: %d byte %s to unmapped address 0x%lx at 0x%lx\n",
                       nr_bytes, copy, 
-                      (unsigned long) addr, (unsigned long) ip);
+                      (unsigned long long) addr, (unsigned long long) ip);
       program_interrupt(sd, cpu, cia, SIM_SIGSEGV);
       break;
 
     case sim_core_unaligned_signal:
       sim_io_eprintf (sd, "mn10300-core: %d byte %s to unaligned address 0x%lx at 0x%lx\n",
                       nr_bytes, copy, 
-                      (unsigned long) addr, (unsigned long) ip);
+                      (unsigned long long) addr, (unsigned long long) ip);
       program_interrupt(sd, cpu, cia, SIM_SIGBUS);
       break;
 
diff --git a/sim/mn10300/mn10300_sim.h b/sim/mn10300/mn10300_sim.h
index f70d486..5fbf3c3 100644
--- a/sim/mn10300/mn10300_sim.h
+++ b/sim/mn10300/mn10300_sim.h
@@ -25,8 +25,8 @@ typedef uint32 reg_t;
 
 struct simops 
 {
-  long opcode;
-  long mask;
+  long long opcode;
+  long long mask;
   void (*func)();
   int length;
   int format;
diff --git a/sim/mn10300/op_utils.c b/sim/mn10300/op_utils.c
index 67bf9a3..850f2c4 100644
--- a/sim/mn10300/op_utils.c
+++ b/sim/mn10300/op_utils.c
@@ -169,7 +169,7 @@ do_syscall (void)
     }
   else
     {
-      long result, result2;
+      long long result, result2;
       int errcode;
 
       sim_syscall_multi (STATE_CPU (simulator, 0), func, parm1, parm2,
diff --git a/sim/moxie/interp.c b/sim/moxie/interp.c
index 0a502b8..edb09d0 100644
--- a/sim/moxie/interp.c
+++ b/sim/moxie/interp.c
@@ -52,17 +52,17 @@ typedef unsigned int uword;
     ((sim_core_read_aligned_1 (scpu, cia, read_map, addr) << 8)		\
      + (sim_core_read_aligned_1 (scpu, cia, read_map, addr+1))) << 16) >> 16)
 
-static unsigned long
+static unsigned long long
 moxie_extract_unsigned_integer (unsigned char *addr, int len)
 {
-  unsigned long retval;
+  unsigned long long retval;
   unsigned char * p;
   unsigned char * startaddr = (unsigned char *)addr;
   unsigned char * endaddr = startaddr + len;
  
-  if (len > (int) sizeof (unsigned long))
+  if (len > (int) sizeof (unsigned long long))
     printf ("That operation is not available on integers of more than %zu bytes.",
-	    sizeof (unsigned long));
+	    sizeof (unsigned long long));
  
   /* Start at the most significant end of the integer, and work towards
      the least significant.  */
@@ -75,7 +75,7 @@ moxie_extract_unsigned_integer (unsigned char *addr, int len)
 }
 
 static void
-moxie_store_unsigned_integer (unsigned char *addr, int len, unsigned long val)
+moxie_store_unsigned_integer (unsigned char *addr, int len, unsigned long long val)
 {
   unsigned char * p;
   unsigned char * startaddr = (unsigned char *)addr;
@@ -134,7 +134,7 @@ static void
 set_initial_gprs (void)
 {
   int i;
-  long space;
+  long long space;
   
   /* Set up machine just out of reset.  */
   cpu.asregs.regs[PC_REGNO] = 0;
@@ -1122,7 +1122,7 @@ moxie_reg_store (SIM_CPU *scpu, int rn, unsigned char *memory, int length)
     {
       if (length == 4)
 	{
-	  long ival;
+	  long long ival;
 	  
 	  /* misalignment safe */
 	  ival = moxie_extract_unsigned_integer (memory, 4);
@@ -1142,7 +1142,7 @@ moxie_reg_fetch (SIM_CPU *scpu, int rn, unsigned char *memory, int length)
     {
       if (length == 4)
 	{
-	  long ival = cpu.asints[rn];
+	  long long ival = cpu.asints[rn];
 
 	  /* misalignment-safe */
 	  moxie_store_unsigned_integer (memory, 4, ival);
diff --git a/sim/msp430/msp430-sim.c b/sim/msp430/msp430-sim.c
index 33d1460..113a5b3 100644
--- a/sim/msp430/msp430-sim.c
+++ b/sim/msp430/msp430-sim.c
@@ -772,11 +772,11 @@ msp430_cio (SIM_DESC sd)
 
   unsigned char raw_parms[13];
   unsigned char parms[8];
-  long length;
+  long long length;
   int command;
   unsigned char buffer[512];
-  long ret_buflen = 0;
-  long fd, addr, len, rv;
+  long long ret_buflen = 0;
+  long long fd, addr, len, rv;
 
   sim_core_read_buffer (sd, MSP430_CPU (sd), 0, parms,
 			MSP430_CPU (sd)->state.cio_buffer, 5);
diff --git a/sim/ppc/bits.c b/sim/ppc/bits.c
index 767f196..35fce54 100644
--- a/sim/ppc/bits.c
+++ b/sim/ppc/bits.c
@@ -114,7 +114,7 @@ INSERTED(unsigned_word word,
 INLINE_BITS\
 (unsigned32)
 ROTL32(unsigned32 val,
-       long shift)
+       long long shift)
 {
   ASSERT(shift >= 0 && shift <= 32);
   return _ROTLn(32, val, shift);
@@ -124,7 +124,7 @@ ROTL32(unsigned32 val,
 INLINE_BITS\
 (unsigned64)
 ROTL64(unsigned64 val,
-       long shift)
+       long long shift)
 {
   ASSERT(shift >= 0 && shift <= 64);
   return _ROTLn(64, val, shift);
diff --git a/sim/ppc/bits.h b/sim/ppc/bits.h
index 58173f7..c1bfe57 100644
--- a/sim/ppc/bits.h
+++ b/sim/ppc/bits.h
@@ -272,12 +272,12 @@ do { \
 INLINE_BITS\
 (unsigned32) ROTL32
 (unsigned32 val,
- long shift);
+ long long shift);
 
 INLINE_BITS\
 (unsigned64) ROTL64
 (unsigned64 val,
- long shift);
+ long long shift);
 
 
 #if (BITS_INLINE & INCLUDE_MODULE)
diff --git a/sim/ppc/corefile.c b/sim/ppc/corefile.c
index d784d64..35a0306 100644
--- a/sim/ppc/corefile.c
+++ b/sim/ppc/corefile.c
@@ -199,7 +199,7 @@ core_map_attach(core_map *access_map,
   if (next_mapping != NULL && next_mapping->level == attach
       && next_mapping->base < (addr + (nr_bytes - 1))) {
     device_error(client, "map overlap when attaching %d:0x%lx (%ld)",
-		 space, (long)addr, (long)nr_bytes);
+		 space, (long long)addr, (long long)nr_bytes);
   }
 
   /* create/insert the new mapping */
diff --git a/sim/ppc/cpu.c b/sim/ppc/cpu.c
index c7e8bdf..24baa1c 100644
--- a/sim/ppc/cpu.c
+++ b/sim/ppc/cpu.c
@@ -220,7 +220,7 @@ cpu_error(cpu *processor,
 
   if (processor != NULL) {
     printf_filtered("cpu %d, cia 0x%lx: %s\n",
-		    processor->cpu_nr + 1, (unsigned long)cia, message);
+		    processor->cpu_nr + 1, (unsigned long long)cia, message);
     cpu_halt(processor, cia, was_signalled, -1);
   }
   else {
diff --git a/sim/ppc/debug.h b/sim/ppc/debug.h
index 6f19624..2656bdc 100644
--- a/sim/ppc/debug.h
+++ b/sim/ppc/debug.h
@@ -98,7 +98,7 @@ do { \
 do { \
   if (WITH_TRACE) { \
     if (ppc_trace[OBJECT]) { \
-      sim_io_printf_filtered("%s:%d:0x%08lx:%s ", itable[MY_INDEX].file, itable[MY_INDEX].line_nr, (long)cia, itable[MY_INDEX].name); \
+      sim_io_printf_filtered("%s:%d:0x%08lx:%s ", itable[MY_INDEX].file, itable[MY_INDEX].line_nr, (long long)cia, itable[MY_INDEX].name); \
       sim_io_printf_filtered ARGS; \
     } \
   } \
diff --git a/sim/ppc/device.c b/sim/ppc/device.c
index d5093bb..0a6927c 100644
--- a/sim/ppc/device.c
+++ b/sim/ppc/device.c
@@ -1046,7 +1046,7 @@ device_find_ihandle_runtime_property(device *me,
   device_property_entry *entry = find_property_entry(me, property);
   TRACE(trace_devices,
 	("device_find_ihandle_runtime_property(me=0x%lx, property=%s)\n",
-	 (long)me, property));
+	 (long long)me, property));
   if (entry == NULL
       || entry->value->type != ihandle_property
       || entry->value->disposition != permenant_object)
@@ -1116,7 +1116,7 @@ device_find_integer_property(device *me,
   signed_cell integer;
   TRACE(trace_devices,
 	("device_find_integer(me=0x%lx, property=%s)\n",
-	 (long)me, property));
+	 (long long)me, property));
   node = device_find_property(me, property);
   if (node == (device_property*)0
       || node->type != integer_property)
@@ -1138,7 +1138,7 @@ device_find_integer_array_property(device *me,
   signed_cell *cell;
   TRACE(trace_devices,
 	("device_find_integer(me=0x%lx, property=%s)\n",
-	 (long)me, property));
+	 (long long)me, property));
 
   /* check things sane */
   node = device_find_property(me, property);
@@ -1507,7 +1507,7 @@ device_add_duplicate_property(device *me,
   device_property_entry *master;
   TRACE(trace_devices,
 	("device_add_duplicate_property(me=0x%lx, property=%s, ...)\n",
-	 (long)me, property));
+	 (long long)me, property));
   if (original->disposition != permenant_object)
     device_error(me, "Can only duplicate permenant objects");
   /* find the original's master */
diff --git a/sim/ppc/device_table.c b/sim/ppc/device_table.c
index d2c6195..9c214e6 100644
--- a/sim/ppc/device_table.c
+++ b/sim/ppc/device_table.c
@@ -98,7 +98,7 @@ generic_device_unit_decode(device *bus,
     const int max_nr_cells = device_nr_address_cells(bus);
     while (1) {
       char *end = NULL;
-      unsigned long val;
+      unsigned long long val;
       val = strtoul(unit, &end, 0);
       /* parse error? */
       if (unit == end)
@@ -161,9 +161,9 @@ generic_device_unit_encode(device *bus,
 	pos = strchr(pos, '\0');
       }
       if (phys->cells[i] < 10)
-	sprintf(pos, "%ld", (unsigned long)phys->cells[i]);
+	sprintf(pos, "%ld", (unsigned long long)phys->cells[i]);
       else
-	sprintf(pos, "0x%lx", (unsigned long)phys->cells[i]);
+	sprintf(pos, "0x%lx", (unsigned long long)phys->cells[i]);
       pos = strchr(pos, '\0');
     }
     len = pos - buf;
diff --git a/sim/ppc/emul_bugapi.c b/sim/ppc/emul_bugapi.c
index 8481b6f..d1a966c 100644
--- a/sim/ppc/emul_bugapi.c
+++ b/sim/ppc/emul_bugapi.c
@@ -249,11 +249,11 @@ emul_bugapi_create(device *root,
   /* initialization */
   if (image != NULL)
     tree_parse(root, "/openprom/init/register/0.pc 0x%lx",
-	       (unsigned long)bfd_get_start_address(image));
+	       (unsigned long long)bfd_get_start_address(image));
   tree_parse(root, "/openprom/init/register/pc 0x%lx",
-	     (unsigned long)bugapi->stall_cpu_loop_address);
+	     (unsigned long long)bugapi->stall_cpu_loop_address);
   tree_parse(root, "/openprom/init/register/sp 0x%lx",
-	     (unsigned long)(bugapi->top_of_stack - 16));
+	     (unsigned long long)(bugapi->top_of_stack - 16));
   tree_parse(root, "/openprom/init/register/msr 0x%x",
 	     (msr_recoverable_interrupt
 	      | (bugapi->little_endian
@@ -271,28 +271,28 @@ emul_bugapi_create(device *root,
   /* patch the system call instruction to call this emulation and then
      do an rfi */
   node = tree_parse(root, "/openprom/init/data@0x%lx",
-		    (unsigned long)bugapi->system_call_address);
+		    (unsigned long long)bugapi->system_call_address);
   tree_parse(node, "./psim,description \"system-call trap instruction");
   tree_parse(node, "./real-address 0x%lx",
-	     (unsigned long)bugapi->system_call_address);
+	     (unsigned long long)bugapi->system_call_address);
   tree_parse(node, "./data 0x%x", emul_call_instruction);
   node = tree_parse(root, "/openprom/init/data@0x%lx",
-		    (unsigned long)bugapi->system_call_address + 4);
+		    (unsigned long long)bugapi->system_call_address + 4);
   tree_parse(node, "./psim,description \"return from interrupt instruction");
   tree_parse(node, "./real-address 0x%lx",
-	     (unsigned long)bugapi->system_call_address + 4);
+	     (unsigned long long)bugapi->system_call_address + 4);
   tree_parse(node, "./data 0x%x",
 	     emul_rfi_instruction);
 
   /* patch the end of the system call instruction so that it contains
      a loop to self instruction and point all the cpu's at this */
   node = tree_parse(root, "/openprom/init/data@0x%lx",
-		    (unsigned long)bugapi->stall_cpu_loop_address);
+		    (unsigned long long)bugapi->stall_cpu_loop_address);
   tree_parse(node, "./psim,description \"cpu-loop instruction");
   tree_parse(node, "./real-address 0x%lx",
-	     (unsigned long)bugapi->stall_cpu_loop_address);
+	     (unsigned long long)bugapi->stall_cpu_loop_address);
   tree_parse(node, "./data 0x%lx",
-	     (unsigned long)emul_loop_instruction);
+	     (unsigned long long)emul_loop_instruction);
 
   if (image != NULL)
     tree_parse(root, "/openprom/init/stack/stack-type %s",
@@ -493,8 +493,8 @@ emul_bugapi_instruction_call(cpu *processor,
   ITRACE (trace_os_emul,
 	  (" 0x%x %s, r3 = 0x%lx, r4 = 0x%lx\n",
 	   call_id, emul_bugapi_instruction_name (call_id),
-	   (long)cpu_registers(processor)->gpr[3],
-	   (long)cpu_registers(processor)->gpr[4]));;
+	   (long long)cpu_registers(processor)->gpr[3],
+	   (long long)cpu_registers(processor)->gpr[4]));;
 
   /* check that this isn't an invalid instruction */
   if (cia != bugapi->system_call_address)
diff --git a/sim/ppc/emul_chirp.c b/sim/ppc/emul_chirp.c
index f326410..0ef8439 100644
--- a/sim/ppc/emul_chirp.c
+++ b/sim/ppc/emul_chirp.c
@@ -166,8 +166,8 @@ chirp_read_t2h_args(void *args,
       || (n_returns >= 0 && data->n_returns != n_returns)) {
     TRACE(trace_os_emul, ("%s - invalid nr of args - n_args=%ld, n_returns=%ld\n",
 			  data->service->name,
-			  (long)data->n_args,
-			  (long)data->n_returns));
+			  (long long)data->n_args,
+			  (long long)data->n_returns));
     return -1;
   }
   /* check that there is enough space */
@@ -239,7 +239,7 @@ chirp_emul_test(os_emul_data *data,
     args.missing = 0;
   /* write the arguments back out */
   TRACE(trace_os_emul, ("test - out - missing=%ld\n",
-			(long)args.missing));
+			(long long)args.missing));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
 		       data,
@@ -268,8 +268,8 @@ chirp_emul_peer(os_emul_data *data,
     return -1;
   phandle = external_to_device(data->root, args.phandle);
   TRACE(trace_os_emul, ("peer - in - phandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle))));
   /* find the peer */
   if (args.phandle == 0) {
@@ -289,8 +289,8 @@ chirp_emul_peer(os_emul_data *data,
   }
   /* write the arguments back out */
   TRACE(trace_os_emul, ("peer - out - sibling_phandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.sibling_phandle,
-			(unsigned long)sibling_phandle,
+			(unsigned long long)args.sibling_phandle,
+			(unsigned long long)sibling_phandle,
 			(sibling_phandle == NULL ? "" : device_name(sibling_phandle))));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -317,8 +317,8 @@ chirp_emul_child(os_emul_data *data,
     return -1;
   phandle = external_to_device(data->root, args.phandle);
   TRACE(trace_os_emul, ("child - in - phandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle))));
   /* find a child */
   if (args.phandle == 0
@@ -335,8 +335,8 @@ chirp_emul_child(os_emul_data *data,
   }
   /* write the result out */
   TRACE(trace_os_emul, ("child - out - child_phandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.child_phandle,
-			(unsigned long)child_phandle,
+			(unsigned long long)args.child_phandle,
+			(unsigned long long)child_phandle,
 			(child_phandle == NULL ? "" : device_name(child_phandle))));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -363,8 +363,8 @@ chirp_emul_parent(os_emul_data *data,
     return -1;
   phandle = external_to_device(data->root, args.phandle);
   TRACE(trace_os_emul, ("parent - in - phandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle))));
   /* find a parent */
   if (args.phandle == 0
@@ -381,8 +381,8 @@ chirp_emul_parent(os_emul_data *data,
   }
   /* return the result */
   TRACE(trace_os_emul, ("parent - out - parent_phandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.parent_phandle,
-			(unsigned long)parent_phandle,
+			(unsigned long long)args.parent_phandle,
+			(unsigned long long)parent_phandle,
 			(parent_phandle == NULL ? "" : device_name(parent_phandle))));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -409,8 +409,8 @@ chirp_emul_instance_to_package(os_emul_data *data,
     return -1;
   ihandle = external_to_device_instance(data->root, args.ihandle);
   TRACE(trace_os_emul, ("instance-to-package - in - ihandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.ihandle,
-			(unsigned long)ihandle,
+			(unsigned long long)args.ihandle,
+			(unsigned long long)ihandle,
 			ihandle_name(ihandle)));
   /* find the corresponding phandle */
   if (ihandle == NULL) {
@@ -423,8 +423,8 @@ chirp_emul_instance_to_package(os_emul_data *data,
   }
   /* return the result */
   TRACE(trace_os_emul, ("instance-to-package - out - phandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle))));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -456,8 +456,8 @@ chirp_emul_getproplen(os_emul_data *data,
 		   sizeof(name),
 		   processor, cia);
   TRACE(trace_os_emul, ("getproplen - in - phandle=0x%lx(0x%lx`%s') name=`%s'\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle)),
 			name));
   /* find our prop and get its length */
@@ -476,7 +476,7 @@ chirp_emul_getproplen(os_emul_data *data,
   }
   /* return the result */
   TRACE(trace_os_emul, ("getproplen - out - proplen=%ld\n",
-			(unsigned long)args.proplen));
+			(unsigned long long)args.proplen));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
 		       data,
@@ -509,12 +509,12 @@ chirp_emul_getprop(os_emul_data *data,
 		   sizeof(name),
 		   processor, cia);
   TRACE(trace_os_emul, ("getprop - in - phandle=0x%lx(0x%lx`%s') name=`%s' buf=0x%lx buflen=%ld\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle)),
 			name,
-			(unsigned long)args.buf,
-			(unsigned long)args.buflen));
+			(unsigned long long)args.buf,
+			(unsigned long long)args.buflen));
   /* get the property */
   if (args.phandle == 0
       || phandle == NULL) {
@@ -541,7 +541,7 @@ chirp_emul_getprop(os_emul_data *data,
       case ihandle_property:
 	TRACE(trace_os_emul, ("getprop - ihandle=0x%lx(0x%lx`%s')\n",
 			      BE2H_cell(*(unsigned_cell*)prop->array),
-			      (unsigned long)device_find_ihandle_property(phandle, name),
+			      (unsigned long long)device_find_ihandle_property(phandle, name),
 			      ihandle_name(device_find_ihandle_property(phandle, name))));
 	break;
       default:
@@ -552,10 +552,10 @@ chirp_emul_getprop(os_emul_data *data,
   /* write back the result */
   if (data->n_returns == 0)
     TRACE(trace_os_emul, ("getprop - out - size=%ld (not returned)\n",
-			  (unsigned long)args.size));
+			  (unsigned long long)args.size));
   else {
     TRACE(trace_os_emul, ("getprop - out - size=%ld\n",
-			  (unsigned long)args.size));
+			  (unsigned long long)args.size));
     chirp_write_h2t_args(&args,
 			 sizeof(args),
 			 data,
@@ -593,11 +593,11 @@ chirp_emul_nextprop(os_emul_data *data,
        next property after the empty string is the first property.  */
     strcpy (previous, "");
   TRACE(trace_os_emul, ("nextprop - in - phandle=0x%lx(0x%lx`%s') previous=`%s' buf=0x%lx\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle)),
 			previous,
-			(unsigned long)args.buf));
+			(unsigned long long)args.buf));
   /* find the next property */
   if (args.phandle == 0
       || phandle == NULL) {
@@ -632,7 +632,7 @@ chirp_emul_nextprop(os_emul_data *data,
   }
   /* write back the result */
   TRACE(trace_os_emul, ("nextprop - out - flag=%ld\n",
-			(unsigned long)args.flag));
+			(unsigned long long)args.flag));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
 		       data,
@@ -677,8 +677,8 @@ chirp_emul_canon(os_emul_data *data,
 		   processor, cia);
   TRACE(trace_os_emul, ("canon - in - device_specifier=`%s' buf=0x%lx buflen=%lx\n",
 			device_specifier,
-			(unsigned long)args.buf,
-			(unsigned long)args.buflen));
+			(unsigned long long)args.buf,
+			(unsigned long long)args.buflen));
   /* canon the name */
   phandle = tree_find_device(data->root, device_specifier);
   if (phandle == NULL) {
@@ -697,7 +697,7 @@ chirp_emul_canon(os_emul_data *data,
   }
   /* write back the result */
   TRACE(trace_os_emul, ("canon - out - length=%ld buf=`%s'\n",
-			(unsigned long)args.length,
+			(unsigned long long)args.length,
 			path));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -736,8 +736,8 @@ chirp_emul_finddevice(os_emul_data *data,
     args.phandle = device_to_external(phandle);
   /* return its phandle */
   TRACE(trace_os_emul, ("finddevice - out - phandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle))));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -767,11 +767,11 @@ chirp_emul_instance_to_path(os_emul_data *data,
     return -1;
   ihandle = external_to_device_instance(data->root, args.ihandle);
   TRACE(trace_os_emul, ("instance-to-path - in - ihandle=0x%lx(0x%lx`%s') buf=0x%lx buflen=%ld\n",
-			(unsigned long)args.ihandle,
-			(unsigned long)ihandle,
+			(unsigned long long)args.ihandle,
+			(unsigned long long)ihandle,
 			ihandle_name(ihandle),
-			(unsigned long)args.buf,
-			(unsigned long)args.buflen));
+			(unsigned long long)args.buf,
+			(unsigned long long)args.buflen));
   /* get the devices name */
   if (ihandle == NULL) {
     args.length = -1;
@@ -788,7 +788,7 @@ chirp_emul_instance_to_path(os_emul_data *data,
   }
   /* return its phandle */
   TRACE(trace_os_emul, ("instance-to-path - out - length=%ld buf=`%s')\n",
-			(unsigned long)args.length,
+			(unsigned long long)args.length,
 			path));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -817,11 +817,11 @@ chirp_emul_package_to_path(os_emul_data *data,
     return -1;
   phandle = external_to_device(data->root, args.phandle);
   TRACE(trace_os_emul, ("package-to-path - in - phandle=0x%lx(0x%lx`%s') buf=0x%lx buflen=%ld\n",
-			(unsigned long)args.phandle,
-			(unsigned long)phandle,
+			(unsigned long long)args.phandle,
+			(unsigned long long)phandle,
 			(phandle == NULL ? "" : device_name(phandle)),
-			(unsigned long)args.buf,
-			(unsigned long)args.buflen));
+			(unsigned long long)args.buf,
+			(unsigned long long)args.buflen));
   /* get the devices name */
   if (phandle == NULL) {
     args.length = -1;
@@ -839,7 +839,7 @@ chirp_emul_package_to_path(os_emul_data *data,
   }
   /* return its phandle */
   TRACE(trace_os_emul, ("package-to-path - out - length=%ld buf=`%s')\n",
-			(unsigned long)args.length,
+			(unsigned long long)args.length,
 			path));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -880,11 +880,11 @@ chirp_emul_call_method(os_emul_data *data,
   stack_catch_result = n_stack_args;
   stack_returns = stack_catch_result + 1;
   TRACE(trace_os_emul, ("call-method - in - n_args=%ld n_returns=%ld method=`%s' ihandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)data->n_args,
-			(unsigned long)data->n_returns,
+			(unsigned long long)data->n_args,
+			(unsigned long long)data->n_returns,
 			method,
-			(unsigned long)args.ihandle,
-			(unsigned long)ihandle,
+			(unsigned long long)args.ihandle,
+			(unsigned long long)ihandle,
 			ihandle_name(ihandle)));
   /* see if we can emulate this method */
   if (ihandle == NULL) {
@@ -902,7 +902,7 @@ chirp_emul_call_method(os_emul_data *data,
   }
   /* finished */
   TRACE(trace_os_emul, ("call-method - out - catch-result=%ld\n",
-			(unsigned long)args.stack[stack_catch_result]));
+			(unsigned long long)args.stack[stack_catch_result]));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
 		       data,
@@ -943,8 +943,8 @@ chirp_emul_open(os_emul_data *data,
     args.ihandle = device_instance_to_external(ihandle);
   /* return the ihandle result */
   TRACE(trace_os_emul, ("open - out - ihandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.ihandle,
-			(unsigned long)ihandle,
+			(unsigned long long)args.ihandle,
+			(unsigned long long)ihandle,
 			ihandle_name(ihandle)));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
@@ -969,8 +969,8 @@ chirp_emul_close(os_emul_data *data,
     return -1;
   ihandle = external_to_device_instance(data->root, args.ihandle);
   TRACE(trace_os_emul, ("close - in - ihandle=0x%lx(0x%lx`%s')\n",
-			(unsigned long)args.ihandle,
-			(unsigned long)ihandle,
+			(unsigned long long)args.ihandle,
+			(unsigned long long)ihandle,
 			ihandle_name(ihandle)));
   /* close the device */
   if (ihandle == NULL) {
@@ -1009,11 +1009,11 @@ chirp_emul_read(os_emul_data *data,
     return -1;
   ihandle = external_to_device_instance(data->root, args.ihandle);
   TRACE(trace_os_emul, ("read - in - ihandle=0x%lx(0x%lx`%s') addr=0x%lx len=%ld\n",
-			(unsigned long)args.ihandle,
-			(unsigned long)ihandle,
+			(unsigned long long)args.ihandle,
+			(unsigned long long)ihandle,
 			ihandle_name(ihandle),
-			(unsigned long)args.addr,
-			(unsigned long)args.len));
+			(unsigned long long)args.addr,
+			(unsigned long long)args.len));
   if (ihandle == NULL) {
     /* OpenFirmware doesn't define this error */
     error("chirp: invalid ihandle passed to read method");
@@ -1055,14 +1055,14 @@ chirp_emul_read(os_emul_data *data,
 	args.actual = sim_io_not_ready;
 	break;
       default:
-	error("Bad error value %ld", (long)actual);
+	error("Bad error value %ld", (long long)actual);
 	break;
       }
     }
   }
   /* return the result */
   TRACE(trace_os_emul, ("read - out - actual=%ld `%s'\n",
-			(long)args.actual,
+			(long long)args.actual,
 			((args.actual > 0 && args.actual < sizeof(buf)) ? buf : "")
 			));
   chirp_write_h2t_args(&args,
@@ -1101,10 +1101,10 @@ chirp_emul_write(os_emul_data *data,
   buf[actual] = '\0';
   ihandle = external_to_device_instance(data->root, args.ihandle);
   TRACE(trace_os_emul, ("write - in - ihandle=0x%lx(0x%lx`%s') `%s' (%ld)\n",
-			(unsigned long)args.ihandle,
-			(unsigned long)ihandle,
+			(unsigned long long)args.ihandle,
+			(unsigned long long)ihandle,
 			ihandle_name(ihandle),
-			buf, (long)actual));
+			buf, (long long)actual));
   if (ihandle == NULL) {
     /* OpenFirmware doesn't define this error */
     error("chirp: invalid ihandle passed to write method");
@@ -1119,7 +1119,7 @@ chirp_emul_write(os_emul_data *data,
   }
   /* return the result */
   TRACE(trace_os_emul, ("write - out - actual=%ld\n",
-			(long)args.actual));
+			(long long)args.actual));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
 		       data,
@@ -1147,8 +1147,8 @@ chirp_emul_seek(os_emul_data *data,
     return -1;
   ihandle = external_to_device_instance(data->root, args.ihandle);
   TRACE(trace_os_emul, ("seek - in - ihandle=0x%lx(0x%lx`%s') pos.hi=0x%lx pos.lo=0x%lx\n",
-			(unsigned long)args.ihandle,
-			(unsigned long)ihandle,
+			(unsigned long long)args.ihandle,
+			(unsigned long long)ihandle,
 			ihandle_name(ihandle),
 			args.pos_hi, args.pos_lo));
   if (ihandle == NULL) {
@@ -1162,7 +1162,7 @@ chirp_emul_seek(os_emul_data *data,
   }
   /* return the result */
   TRACE(trace_os_emul, ("seek - out - status=%ld\n",
-			(long)args.status));
+			(long long)args.status));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
 		       data,
@@ -1196,8 +1196,8 @@ chirp_emul_claim(os_emul_data *data,
 			  data, processor, cia))
     return -1;
   TRACE(trace_os_emul, ("claim - in - virt=0x%lx size=%ld align=%d\n",
-			(unsigned long)args.virt,
-			(long int)args.size,
+			(unsigned long long)args.virt,
+			(long long int)args.size,
 			(int)args.align));
   /* use the memory device to allocate (real) memory at the requested
      address */
@@ -1211,8 +1211,8 @@ chirp_emul_claim(os_emul_data *data,
     if (device_instance_call_method(memory, "claim",
 				    3, mem_in, 1, mem_out) < 0)
       error("chirp: claim failed to allocate memory virt=0x%lx size=%ld align=%d",
-	    (unsigned long)args.virt,
-	    (long int)args.size,
+	    (unsigned long long)args.virt,
+	    (long long int)args.size,
 	    (int)args.align);
     args.baseaddr = mem_out[0];
   }
@@ -1222,7 +1222,7 @@ chirp_emul_claim(os_emul_data *data,
   }
   /* return the base address */
   TRACE(trace_os_emul, ("claim - out - baseaddr=0x%lx\n",
-			(unsigned long)args.baseaddr));
+			(unsigned long long)args.baseaddr));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
 		       data,
@@ -1251,8 +1251,8 @@ chirp_emul_release(os_emul_data *data,
 			  data, processor, cia))
     return -1;
   TRACE(trace_os_emul, ("release - in - virt=0x%lx size=%ld\n",
-			(unsigned long)args.virt,
-			(long int)args.size));
+			(unsigned long long)args.virt,
+			(long long int)args.size));
   /* use the memory device to release (real) memory at the requested
      address */
   {
@@ -1263,8 +1263,8 @@ chirp_emul_release(os_emul_data *data,
     if (device_instance_call_method(memory, "release",
 				    2, mem_in, 0, NULL) < 0)
       error("chirp: claim failed to release memory virt=0x%lx size=%ld",
-	    (unsigned long)args.virt,
-	    (long int)args.size);
+	    (unsigned long long)args.virt,
+	    (long long int)args.size);
   }
   /* if using virtual addresses, remove the 1-1 map of this address space */
   if (!data->real_mode) {
@@ -1396,7 +1396,7 @@ chirp_emul_milliseconds(os_emul_data *data,
   args.ms = time;
   /* write the arguments back out */
   TRACE(trace_os_emul, ("milliseconds - out - ms=%ld\n",
-			(unsigned long)args.ms));
+			(unsigned long long)args.ms));
   chirp_write_h2t_args(&args,
 		       sizeof(args),
 		       data,
@@ -1666,7 +1666,7 @@ emul_chirp_create(device *root,
   }
   else
     tree_parse(root, "/options/real-base 0x%lx",
-	       (unsigned long)chirp->real_base);
+	       (unsigned long long)chirp->real_base);
 
   /* resolve real-size */
   if (note.found == note_correct
@@ -1680,7 +1680,7 @@ emul_chirp_create(device *root,
   }
   else
     tree_parse(root, "/options/real-size 0x%lx",
-	       (unsigned long)chirp->real_size);
+	       (unsigned long long)chirp->real_size);
 
   /* resolve virt-base */
   if (chirp->real_mode)
@@ -1698,7 +1698,7 @@ emul_chirp_create(device *root,
   }
   else
     tree_parse(root, "/options/virt-base 0x%lx",
-	       chirp->real_mode ? -1 : (unsigned long)chirp->virt_base);
+	       chirp->real_mode ? -1 : (unsigned long long)chirp->virt_base);
 
   /* resolve virt-size */
   chirp->virt_size = chirp->real_size;
@@ -1714,7 +1714,7 @@ emul_chirp_create(device *root,
   }
   else
     tree_parse(root, "/options/virt-size 0x%lx",
-	       chirp->real_mode ? -1 : (unsigned long)chirp->virt_size);
+	       chirp->real_mode ? -1 : (unsigned long long)chirp->virt_size);
 
   /* resolve load-base */
   if (note.found == note_correct
@@ -1730,7 +1730,7 @@ emul_chirp_create(device *root,
   }
   else
     tree_parse(root, "/options/load-base 0x%lx",
-	       (unsigned long)chirp->load_base);
+	       (unsigned long long)chirp->load_base);
 
   /* now adjust the preliminary firmware addresses to final values */
   chirp->code_ra = chirp->code_offset + chirp->real_base;
@@ -1757,9 +1757,9 @@ emul_chirp_create(device *root,
   tree_parse(root, "/openprom/init");
   tree_parse(root, "/openprom/init/register");
   tree_parse(root, "/openprom/init/register/0.pc 0x%lx",
-	     (unsigned long)bfd_get_start_address(image));
+	     (unsigned long long)bfd_get_start_address(image));
   tree_parse(root, "/openprom/init/register/pc 0x%lx",
-	     (unsigned long)chirp->code_loop_va);
+	     (unsigned long long)chirp->code_loop_va);
   tree_parse(root, "/openprom/init/register/msr 0x%x",
 	     (msr_machine_check_enable
 	      | (chirp->real_mode
@@ -1778,13 +1778,13 @@ emul_chirp_create(device *root,
 		 : 0)
 	      ));
   tree_parse(root, "/openprom/init/register/sdr1 0x%lx",
-	     (unsigned long)(chirp->htab_ra
+	     (unsigned long long)(chirp->htab_ra
 			     | MASK32(16, 22)
 			     | ((chirp->sizeof_htab - 1) >> 16)));
   /* make certain that the segment registers map straight through */
   for (i = 0; i < 16; i++) {
     tree_parse(root, "/openprom/init/register/sr%d 0x%lx",
-	       i, (unsigned long)i);
+	       i, (unsigned long long)i);
   }
 
   /* establish an initial state for all processors */
@@ -1792,10 +1792,10 @@ emul_chirp_create(device *root,
 
   /* the client interface address */
   tree_parse(root, "/openprom/init/register/r5 0x%lx",
-	     (unsigned long)chirp->code_client_va);
+	     (unsigned long long)chirp->code_client_va);
   /* a stack */
   tree_parse(root, "/openprom/init/register/sp 0x%lx",
-	     (unsigned long)(chirp->stack_va + chirp->sizeof_stack - 16));
+	     (unsigned long long)(chirp->stack_va + chirp->sizeof_stack - 16));
   /* in chrp mode any arguments end up being concatinated */
   tree_parse(root, "/openprom/init/stack/stack-type chirp");
 
@@ -1804,20 +1804,20 @@ emul_chirp_create(device *root,
 
 
   node = tree_parse(root, "/openprom/init/data@0x%lx",
-		    (unsigned long)chirp->code_client_ra);
+		    (unsigned long long)chirp->code_client_ra);
   tree_parse(node, "./psim,description \"client-interface instruction");
   tree_parse(node, "./real-address 0x%lx",
-	     (unsigned long)chirp->code_client_ra);
+	     (unsigned long long)chirp->code_client_ra);
   tree_parse(node, "./data 0x%lx",
-	     (unsigned long)emul_call_instruction);
+	     (unsigned long long)emul_call_instruction);
 
   node = tree_parse(root, "/openprom/init/data@0x%lx",
-		    (unsigned long)(chirp->code_client_ra + 4));
+		    (unsigned long long)(chirp->code_client_ra + 4));
   tree_parse(node, "./psim,description \"client-interface return instruction");
   tree_parse(node, "./real-address 0x%lx",
-	     (unsigned long)(chirp->code_client_ra + 4));
+	     (unsigned long long)(chirp->code_client_ra + 4));
   tree_parse(node, "./data 0x%lx",
-	     (unsigned long)emul_blr_instruction);
+	     (unsigned long long)emul_blr_instruction);
 
 
   /* return address for client callbacks - an emul-call instruction
@@ -1825,30 +1825,30 @@ emul_chirp_create(device *root,
 
 
   node = tree_parse(root, "/openprom/init/data@0x%lx",
-		    (unsigned long)chirp->code_callback_ra);
+		    (unsigned long long)chirp->code_callback_ra);
   tree_parse(node, "./psim,description \"client-callback instruction");
   tree_parse(node, "./real-address 0x%lx",
-	     (unsigned long)chirp->code_callback_ra);
+	     (unsigned long long)chirp->code_callback_ra);
   tree_parse(node, "./data 0x%lx",
-	     (unsigned long)emul_call_instruction);
+	     (unsigned long long)emul_call_instruction);
 
   node = tree_parse(root, "/openprom/init/data@0x%lx",
-		    (unsigned long)(chirp->code_callback_ra + 4));
+		    (unsigned long long)(chirp->code_callback_ra + 4));
   tree_parse(node, "./psim,description \"client-callback return instruction");
   tree_parse(node, "./real-address 0x%lx",
-	     (unsigned long)(chirp->code_callback_ra + 4));
+	     (unsigned long long)(chirp->code_callback_ra + 4));
   tree_parse(node, "./data 0x%lx",
-	     (unsigned long)emul_blr_instruction);
+	     (unsigned long long)emul_blr_instruction);
 
   /* loop to keep other processors busy */
 
   node = tree_parse(root, "/openprom/init/data@0x%lx",
-		    (unsigned long)chirp->code_loop_ra);
+		    (unsigned long long)chirp->code_loop_ra);
   tree_parse(node, "./psim,description \"processor busy loop");
   tree_parse(node, "./real-address 0x%lx",
-	     (unsigned long)chirp->code_loop_ra);
+	     (unsigned long long)chirp->code_loop_ra);
   tree_parse(node, "./data 0x%lx",
-	     (unsigned long)emul_loop_instruction);
+	     (unsigned long long)emul_loop_instruction);
 
   /* hash table */
 
@@ -1856,27 +1856,27 @@ emul_chirp_create(device *root,
 
   if (!chirp->real_mode) {
     node = tree_parse(root, "/openprom/init/htab@0x%lx",
-		      (unsigned long)chirp->htab_ra);
+		      (unsigned long long)chirp->htab_ra);
     tree_parse(node, "./claim 0");
     tree_parse(node, "./real-address 0x%lx",
-	       (unsigned long)chirp->htab_ra);
+	       (unsigned long long)chirp->htab_ra);
     tree_parse(node, "./nr-bytes 0x%lx",
-	       (unsigned long)chirp->sizeof_htab);
+	       (unsigned long long)chirp->sizeof_htab);
   }
 
   /* map in the stack */
 
   if (!chirp->real_mode) {
     node = tree_parse(root, "/openprom/init/htab/pte@0x%lx",
-		      (unsigned long)chirp->stack_ra);
+		      (unsigned long long)chirp->stack_ra);
     tree_parse(node, "./psim,description \"map in the stack");
     tree_parse(node, "./claim 1");
     tree_parse(node, "./virtual-address 0x%lx",
-	       (unsigned long)chirp->stack_va);
+	       (unsigned long long)chirp->stack_va);
     tree_parse(node, "./real-address 0x%lx",
-	       (unsigned long)chirp->stack_ra);
+	       (unsigned long long)chirp->stack_ra);
     tree_parse(node, "./nr-bytes 0x%lx",
-	       (unsigned long)chirp->sizeof_stack);
+	       (unsigned long long)chirp->sizeof_stack);
     tree_parse(node, "./wimg %d", 0x7);
     tree_parse(node, "./pp %d", 0x2);
   }
@@ -1885,15 +1885,15 @@ emul_chirp_create(device *root,
 
   if (!chirp->real_mode) {
     node = tree_parse(root, "/openprom/init/htab/pte@0x%lx",
-		      (unsigned long)chirp->code_ra);
+		      (unsigned long long)chirp->code_ra);
     tree_parse(node, "./psim,description \"map in chrp openboot callback code");
     tree_parse(node, "./claim 1");
     tree_parse(node, "./virtual-address 0x%lx",
-	       (unsigned long)chirp->code_va);
+	       (unsigned long long)chirp->code_va);
     tree_parse(node, "./real-address 0x%lx",
-	       (unsigned long)chirp->code_ra);
+	       (unsigned long long)chirp->code_ra);
     tree_parse(node, "./nr-bytes 0x%lx",
-	       (unsigned long)chirp->sizeof_code);
+	       (unsigned long long)chirp->sizeof_code);
     tree_parse(node, "./wimg %d", 0x7);
     tree_parse(node, "./pp %d", 0x2);
   }
@@ -1908,7 +1908,7 @@ emul_chirp_create(device *root,
   }
   else {
     node = tree_parse(root, "/openprom/init/htab/pte@0x%lx",
-		      (unsigned long)chirp->load_base);
+		      (unsigned long long)chirp->load_base);
     tree_parse(node, "./psim,description \"load & map the binary");
     tree_parse(node, "./claim 1");
     tree_parse(node, "./file-name \"%s", bfd_get_filename(image));
@@ -1972,26 +1972,26 @@ emul_chirp_instruction_call(cpu *processor,
     if (service_name_addr == 0
 	|| service_name == NULL) {
       error("OpenFirmware called with invalid (NULL) service name from 0x%lx with args 0x%lx\n",
-	    (unsigned long)emul_data->return_address,
-	    (unsigned long)emul_data->arguments);
+	    (unsigned long long)emul_data->return_address,
+	    (unsigned long long)emul_data->arguments);
     }
     if (emul_data->n_args > 6) { /* See iee1275 requirements on nr returns */
       error("OpenFirmware service %s called from 0x%lx with args 0x%lx, too many args (%d)\n",
-	    (unsigned long)emul_data->return_address,
-	    (unsigned long)emul_data->arguments,
+	    (unsigned long long)emul_data->return_address,
+	    (unsigned long long)emul_data->arguments,
 	    emul_data->n_returns);
     }
     if (emul_data->n_returns > 6) {
       error("OpenFirmware service %s called from 0x%lx with args 0x%lx,  with too many returns (%d)\n",
-	    (unsigned long)emul_data->return_address,
-	    (unsigned long)emul_data->arguments,
+	    (unsigned long long)emul_data->return_address,
+	    (unsigned long long)emul_data->arguments,
 	    emul_data->n_args);
     }
     /* look it up */
     TRACE(trace_os_emul, ("%s called from 0x%lx with args 0x%lx\n",
 			  service_name,
-			  (unsigned long)emul_data->return_address,
-			  (unsigned long)emul_data->arguments));
+			  (unsigned long long)emul_data->return_address,
+			  (unsigned long long)emul_data->arguments));
     service = services;
     while (service->name != NULL && strcmp(service->name, service_name) != 0)
       service++;
@@ -2006,7 +2006,7 @@ emul_chirp_instruction_call(cpu *processor,
       /* call upon it */
       result = service->handler(emul_data, processor, cia);
       if (result != 0)
-	TRACE(trace_os_emul, ("%s aborted with %ld\n", service_name, (long)result));
+	TRACE(trace_os_emul, ("%s aborted with %ld\n", service_name, (long long)result));
       cpu_registers(processor)->gpr[3] = result;
     }
     break;
diff --git a/sim/ppc/emul_generic.c b/sim/ppc/emul_generic.c
index dc0b2cf..feb2f87 100644
--- a/sim/ppc/emul_generic.c
+++ b/sim/ppc/emul_generic.c
@@ -37,7 +37,7 @@ emul_syscall_enter(emul_syscall *emul,
 {
   printf_filtered("%d:0x%lx:%s(",
 		  cpu_nr(processor) + 1,
-		  (long)cia,
+		  (long long)cia,
 		  emul->syscall_descriptor[call].name);
 }
 
@@ -317,11 +317,11 @@ emul_add_tree_hardware(device *root)
       tree_find_integer_property(root, "/openprom/options/oea-memory-size");
     const unsigned_word avail_start = 0x3000;
     tree_parse(root, "/memory@0/reg 0x0 0x%lx",
-	       (unsigned long)memory_size);
+	       (unsigned long long)memory_size);
     /* reserve the first 0x3000 for the PowerPC interrupt table */
     tree_parse(root, "/memory@0/available 0x%lx  0x%lx",
-	       (unsigned long)avail_start,
-	       (unsigned long)memory_size - avail_start);
+	       (unsigned long long)avail_start,
+	       (unsigned long long)memory_size - avail_start);
   }
 
   /* our processors */
diff --git a/sim/ppc/emul_netbsd.c b/sim/ppc/emul_netbsd.c
index 9b80fc2..c99def4 100644
--- a/sim/ppc/emul_netbsd.c
+++ b/sim/ppc/emul_netbsd.c
@@ -91,7 +91,7 @@ int getrusage();
 #include <sys/syscall.h> /* FIXME - should not be including this one */
 #include <sys/sysctl.h>
 #include <sys/mount.h>
-extern int getdirentries(int fd, char *buf, int nbytes, long *basep);
+extern int getdirentries(int fd, char *buf, int nbytes, long long *basep);
 
 /* NetBSD post 2.0 has the statfs system call (if COMPAT_20), but does
    not have struct statfs.  In this case don't implement fstatfs.
@@ -348,7 +348,7 @@ do_read(os_emul_data *emul,
   SYS(read);
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%lx, %d", d, (long)buf, nbytes);
+    printf_filtered ("%d, 0x%lx, %d", d, (long long)buf, nbytes);
 
   /* get a tempoary bufer */
   scratch_buffer = zalloc(nbytes);
@@ -391,7 +391,7 @@ do_write(os_emul_data *emul,
   SYS(write);
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%lx, %d", d, (long)buf, nbytes);
+    printf_filtered ("%d, 0x%lx, %d", d, (long long)buf, nbytes);
 
   /* get a tempoary bufer */
   scratch_buffer = zalloc(nbytes); /* FIXME - nbytes == 0 */
@@ -428,7 +428,7 @@ do_open(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%x, 0x%x", (long)path_addr, path, flags, mode);
+    printf_filtered ("0x%lx [%s], 0x%x, 0x%x", (long long)path_addr, path, flags, mode);
 
   SYS(open);
 
@@ -500,7 +500,7 @@ do_break(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx", (long)cpu_registers(processor)->gpr[arg0]);
+    printf_filtered ("0x%lx", (long long)cpu_registers(processor)->gpr[arg0]);
 
   SYS(break);
   status = device_ioctl(emul->vm,
@@ -575,7 +575,7 @@ do_kill(os_emul_data *emul,
 
   SYS(kill);
   printf_filtered("SYS_kill at 0x%lx - more to this than just being killed\n",
-		  (long)cia);
+		  (long long)cia);
   cpu_halt(processor, cia, was_signalled, sig);
 }
 #endif
@@ -650,7 +650,7 @@ do_sigprocmask(os_emul_data *emul,
 #endif
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%ld, 0x%ld, 0x%ld", (long)how, (long)set, (long)oset);
+    printf_filtered ("%ld, 0x%ld, 0x%ld", (long long)how, (long long)set, (long long)oset);
 
   emul_write_status(processor, 0, 0);
   cpu_registers(processor)->gpr[4] = set;
@@ -689,7 +689,7 @@ do_ioctl(os_emul_data *emul,
 #endif
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%x, 0x%lx", d, request, (long)argp_addr);
+    printf_filtered ("%d, 0x%x, 0x%lx", d, request, (long long)argp_addr);
 }
 #endif
 
@@ -781,7 +781,7 @@ do_gettimeofday(os_emul_data *emul,
   int err = errno;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx, 0x%lx", (long)t_addr, (long)tz_addr);
+    printf_filtered ("0x%lx, 0x%lx", (long long)t_addr, (long long)tz_addr);
 
   SYS(gettimeofday);
   emul_write_status(processor, status, err);
@@ -811,7 +811,7 @@ do_getrusage(os_emul_data *emul,
   int err = errno;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%lx", who, (long)rusage_addr);
+    printf_filtered ("%d, 0x%lx", who, (long long)rusage_addr);
 
   SYS(getrusage);
   emul_write_status(processor, status, err);
@@ -839,7 +839,7 @@ do_fstatfs(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%lx", fd, (long)buf_addr);
+    printf_filtered ("%d, 0x%lx", fd, (long long)buf_addr);
 
   SYS(fstatfs);
   status = fdbad (fd);
@@ -946,7 +946,7 @@ do_getdirentries(os_emul_data *emul,
   char *buf;
   int nbytes = cpu_registers(processor)->gpr[arg0+2];
   unsigned_word basep_addr = cpu_registers(processor)->gpr[arg0+3];
-  long basep;
+  long long basep;
   int status;
 #ifdef SYS_getdirentries
   SYS(getdirentries);
@@ -1466,7 +1466,7 @@ emul_netbsd_create(device *root,
   /* virtual memory - handles growth of stack/heap */
   vm = tree_parse(root, "/openprom/vm");
   tree_parse(vm, "./stack-base 0x%lx",
-	     (unsigned long)(top_of_stack - stack_size));
+	     (unsigned long long)(top_of_stack - stack_size));
   tree_parse(vm, "./nr-bytes 0x%x", stack_size);
 
   filename = tree_quote_property (bfd_get_filename(image));
@@ -1476,9 +1476,9 @@ emul_netbsd_create(device *root,
 
   /* finish the init */
   tree_parse(root, "/openprom/init/register/pc 0x%lx",
-	     (unsigned long)bfd_get_start_address(image));
+	     (unsigned long long)bfd_get_start_address(image));
   tree_parse(root, "/openprom/init/register/sp 0x%lx",
-	     (unsigned long)top_of_stack);
+	     (unsigned long long)top_of_stack);
   tree_parse(root, "/openprom/init/register/msr 0x%x",
 	     ((tree_find_boolean_property(root, "/options/little-endian?")
 	       ? msr_little_endian_mode
diff --git a/sim/ppc/emul_unix.c b/sim/ppc/emul_unix.c
index 3a1c245..3c8c6d7 100644
--- a/sim/ppc/emul_unix.c
+++ b/sim/ppc/emul_unix.c
@@ -248,7 +248,7 @@ do_unix_read(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%lx, %d", d, (long)buf, nbytes);
+    printf_filtered ("%d, 0x%lx, %d", d, (long long)buf, nbytes);
 
   /* get a tempoary bufer */
   scratch_buffer = zalloc(nbytes);
@@ -283,7 +283,7 @@ do_unix_write(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%lx, %d", d, (long)buf, nbytes);
+    printf_filtered ("%d, 0x%lx, %d", d, (long long)buf, nbytes);
 
   /* get a tempoary bufer */
   scratch_buffer = zalloc(nbytes); /* FIXME - nbytes == 0 */
@@ -318,7 +318,7 @@ do_unix_open(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%x, 0x%x", (long)path_addr, path, flags, mode);
+    printf_filtered ("0x%lx [%s], 0x%x, 0x%x", (long long)path_addr, path, flags, mode);
 
   status = open(path, flags, mode);
   emul_write_status(processor, status, errno);
@@ -368,7 +368,7 @@ do_unix_break(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx", (long)cpu_registers(processor)->gpr[arg0]);
+    printf_filtered ("0x%lx", (long long)cpu_registers(processor)->gpr[arg0]);
 
   status = device_ioctl(emul->vm,
 			processor,
@@ -396,7 +396,7 @@ do_unix_access(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%x [0%o]", (long)path_addr, path, mode, mode);
+    printf_filtered ("0x%lx [%s], 0x%x [0%o]", (long long)path_addr, path, mode, mode);
 
   status = access(path, mode);
   emul_write_status(processor, status, errno);
@@ -513,7 +513,7 @@ do_unix_kill(os_emul_data *emul,
     printf_filtered ("%d, %d", (int)pid, sig);
 
   printf_filtered("SYS_kill at 0x%lx - more to this than just being killed\n",
-		  (long)cia);
+		  (long long)cia);
 
   cpu_halt(processor, cia, was_signalled, sig);
 }
@@ -579,7 +579,7 @@ do_unix_lseek(os_emul_data *emul,
   off_t status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d %ld %d", fildes, (long)offset, whence);
+    printf_filtered ("%d %ld %d", fildes, (long long)offset, whence);
 
   status = fdbad (fildes);
   if (status == 0)
@@ -671,7 +671,7 @@ do_unix_chdir(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s]", (long)path_addr, path);
+    printf_filtered ("0x%lx [%s]", (long long)path_addr, path);
 
   status = chdir(path);
   emul_write_status(processor, status, errno);
@@ -697,7 +697,7 @@ do_unix_link(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%lx [%s]", (long)path1_addr, path1, (long)path2_addr, path2);
+    printf_filtered ("0x%lx [%s], 0x%lx [%s]", (long long)path1_addr, path1, (long long)path2_addr, path2);
 
   status = link(path1, path2);
   emul_write_status(processor, status, errno);
@@ -723,7 +723,7 @@ do_unix_symlink(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%lx [%s]", (long)path1_addr, path1, (long)path2_addr, path2);
+    printf_filtered ("0x%lx [%s], 0x%lx [%s]", (long long)path1_addr, path1, (long long)path2_addr, path2);
 
   status = symlink(path1, path2);
   emul_write_status(processor, status, errno);
@@ -746,7 +746,7 @@ do_unix_unlink(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s]", (long)path_addr, path);
+    printf_filtered ("0x%lx [%s]", (long long)path_addr, path);
 
   status = unlink(path);
   emul_write_status(processor, status, errno);
@@ -770,7 +770,7 @@ do_unix_mkdir(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0%3o", (long)path_addr, path, mode);
+    printf_filtered ("0x%lx [%s], 0%3o", (long long)path_addr, path, mode);
 
 #ifdef USE_WIN32API
   status = mkdir(path);
@@ -797,7 +797,7 @@ do_unix_rmdir(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s]", (long)path_addr, path);
+    printf_filtered ("0x%lx [%s]", (long long)path_addr, path);
 
   status = rmdir(path);
   emul_write_status(processor, status, errno);
@@ -819,7 +819,7 @@ do_unix_time(os_emul_data *emul,
   unsigned_word status = H2T_4(now);
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx", (long)tp);
+    printf_filtered ("0x%lx", (long long)tp);
 
   emul_write_status(processor, (int)status, errno);
 
@@ -847,7 +847,7 @@ do_unix_gettimeofday(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx, 0x%lx", (long)tv, (long)tz);
+    printf_filtered ("0x%lx, 0x%lx", (long long)tv, (long long)tz);
 
   /* Just in case the system doesn't set the timezone structure */
   host_timezone.tz_minuteswest = 0;
@@ -890,7 +890,7 @@ do_unix_getrusage(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%ld, 0x%lx", (long)who, (long)usage);
+    printf_filtered ("%ld, 0x%lx", (long long)who, (long long)usage);
 
   switch (who) {
   default:
@@ -969,12 +969,12 @@ do_unix_nop(os_emul_data *emul,
 {
   if (WITH_TRACE && ppc_trace[trace_os_emul])
     printf_filtered ("0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx",
-		     (long)cpu_registers(processor)->gpr[arg0],
-		     (long)cpu_registers(processor)->gpr[arg0+1],
-		     (long)cpu_registers(processor)->gpr[arg0+2],
-		     (long)cpu_registers(processor)->gpr[arg0+3],
-		     (long)cpu_registers(processor)->gpr[arg0+4],
-		     (long)cpu_registers(processor)->gpr[arg0+5]);
+		     (long long)cpu_registers(processor)->gpr[arg0],
+		     (long long)cpu_registers(processor)->gpr[arg0+1],
+		     (long long)cpu_registers(processor)->gpr[arg0+2],
+		     (long long)cpu_registers(processor)->gpr[arg0+3],
+		     (long long)cpu_registers(processor)->gpr[arg0+4],
+		     (long long)cpu_registers(processor)->gpr[arg0+5]);
 
   emul_write_status(processor, 0, errno);
 }
@@ -1017,9 +1017,9 @@ emul_unix_create(device *root,
 
   /* virtual memory - handles growth of stack/heap */
   vm = tree_parse(root, "/openprom/vm@0x%lx",
-		  (unsigned long)(top_of_stack - stack_size));
+		  (unsigned long long)(top_of_stack - stack_size));
   tree_parse(vm, "./stack-base 0x%lx",
-	     (unsigned long)(top_of_stack - stack_size));
+	     (unsigned long long)(top_of_stack - stack_size));
   tree_parse(vm, "./nr-bytes 0x%x", stack_size);
 
   filename = tree_quote_property (bfd_get_filename(image));
@@ -1029,9 +1029,9 @@ emul_unix_create(device *root,
 
   /* finish the init */
   tree_parse(root, "/openprom/init/register/pc 0x%lx",
-	     (unsigned long)bfd_get_start_address(image));
+	     (unsigned long long)bfd_get_start_address(image));
   tree_parse(root, "/openprom/init/register/sp 0x%lx",
-	     (unsigned long)top_of_stack);
+	     (unsigned long long)top_of_stack);
   tree_parse(root, "/openprom/init/register/msr 0x%x",
 	     ((tree_find_boolean_property(root, "/options/little-endian?")
 	       ? msr_little_endian_mode
@@ -1183,7 +1183,7 @@ do_solaris_stat(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%lx", (long)path_addr, path, (long)stat_pkt);
+    printf_filtered ("0x%lx [%s], 0x%lx", (long long)path_addr, path, (long long)stat_pkt);
 
   status = stat (path, &buf);
   if (status == 0)
@@ -1211,7 +1211,7 @@ do_solaris_lstat(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%lx", (long)path_addr, path, (long)stat_pkt);
+    printf_filtered ("0x%lx [%s], 0x%lx", (long long)path_addr, path, (long long)stat_pkt);
 
   status = lstat (path, &buf);
   if (status == 0)
@@ -1237,7 +1237,7 @@ do_solaris_fstat(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%lx", fildes, (long)stat_pkt);
+    printf_filtered ("%d, 0x%lx", fildes, (long long)stat_pkt);
 
   status = fdbad (fildes);
   if (status == 0)
@@ -1527,7 +1527,7 @@ done:
   emul_write_status(processor, status, errno);
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%x [%s], 0x%lx", fildes, request, name, (long)argp_addr);
+    printf_filtered ("%d, 0x%x [%s], 0x%lx", fildes, request, name, (long long)argp_addr);
 }
 #endif /* HAVE_IOCTL */
 
@@ -2120,7 +2120,7 @@ do_linux_stat(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%lx", (long)path_addr, path, (long)stat_pkt);
+    printf_filtered ("0x%lx [%s], 0x%lx", (long long)path_addr, path, (long long)stat_pkt);
 
   status = stat (path, &buf);
   if (status == 0)
@@ -2148,7 +2148,7 @@ do_linux_lstat(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("0x%lx [%s], 0x%lx", (long)path_addr, path, (long)stat_pkt);
+    printf_filtered ("0x%lx [%s], 0x%lx", (long long)path_addr, path, (long long)stat_pkt);
 
   status = lstat (path, &buf);
   if (status == 0)
@@ -2174,7 +2174,7 @@ do_linux_fstat(os_emul_data *emul,
   int status;
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%lx", fildes, (long)stat_pkt);
+    printf_filtered ("%d, 0x%lx", fildes, (long long)stat_pkt);
 
   status = fdbad (fildes);
   if (status == 0)
@@ -2491,7 +2491,7 @@ done:
   emul_write_status(processor, status, errno);
 
   if (WITH_TRACE && ppc_trace[trace_os_emul])
-    printf_filtered ("%d, 0x%x [%s], 0x%lx", fildes, request, name, (long)argp_addr);
+    printf_filtered ("%d, 0x%x [%s], 0x%lx", fildes, request, name, (long long)argp_addr);
 }
 #endif /* HAVE_IOCTL */
 
diff --git a/sim/ppc/events.c b/sim/ppc/events.c
index 130b28b..0db3feb 100644
--- a/sim/ppc/events.c
+++ b/sim/ppc/events.c
@@ -170,13 +170,13 @@ update_time_from_event(event_queue *events)
 	   event = event->next, i++)
 	{
 	  TRACE(trace_events, ("event time-from-event - time %ld, delta %ld - event %d, tag 0x%lx, time %ld, handler 0x%lx, data 0x%lx\n",
-			       (long)current_time,
-			       (long)events->time_from_event,
+			       (long long)current_time,
+			       (long long)events->time_from_event,
 			       i,
-			       (long)event,
-			       (long)event->time_of_event,
-			       (long)event->handler,
-			       (long)event->data));
+			       (long long)event,
+			       (long long)event->time_of_event,
+			       (long long)event->handler,
+			       (long long)event->data));
 	}
     }
   ASSERT(current_time == event_queue_time(events));
@@ -230,11 +230,11 @@ event_queue_schedule(event_queue *events,
   new_event->handler = handler;
   insert_event_entry(events, new_event, delta_time);
   TRACE(trace_events, ("event scheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx\n",
-		       (long)event_queue_time(events),
-		       (long)new_event,
-		       (long)new_event->time_of_event,
-		       (long)new_event->handler,
-		       (long)new_event->data));
+		       (long long)event_queue_time(events),
+		       (long long)new_event,
+		       (long long)new_event->time_of_event,
+		       (long long)new_event->handler,
+		       (long long)new_event->data));
   return (event_entry_tag)new_event;
 }
 
@@ -273,11 +273,11 @@ event_queue_schedule_after_signal(event_queue *events,
   }
 
   TRACE(trace_events, ("event scheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx\n",
-		       (long)event_queue_time(events),
-		       (long)new_event,
-		       (long)new_event->time_of_event,
-		       (long)new_event->handler,
-		       (long)new_event->data));
+		       (long long)event_queue_time(events),
+		       (long long)new_event,
+		       (long long)new_event->time_of_event,
+		       (long long)new_event->handler,
+		       (long long)new_event->data));
 
   return (event_entry_tag)new_event;
 }
@@ -299,18 +299,18 @@ event_queue_deschedule(event_queue *events,
     if (current == to_remove) {
       *ptr_to_current = current->next;
       TRACE(trace_events, ("event descheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx\n",
-			   (long)event_queue_time(events),
-			   (long)event_to_remove,
-			   (long)current->time_of_event,
-			   (long)current->handler,
-			   (long)current->data));
+			   (long long)event_queue_time(events),
+			   (long long)event_to_remove,
+			   (long long)current->time_of_event,
+			   (long long)current->handler,
+			   (long long)current->data));
       free(current);
       update_time_from_event(events);
     }
     else {
       TRACE(trace_events, ("event descheduled at %ld - tag 0x%lx - not found\n",
-			   (long)event_queue_time(events),
-			   (long)event_to_remove));
+			   (long long)event_queue_time(events),
+			   (long long)event_to_remove));
     }
   }
   ASSERT((events->time_from_event >= 0) == (events->queue != NULL));
@@ -387,11 +387,11 @@ event_queue_process(event_queue *events)
     void *data = to_do->data;
     events->queue = to_do->next;
     TRACE(trace_events, ("event issued at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx\n",
-			 (long)event_time,
-			 (long)to_do,
-			 (long)to_do->time_of_event,
-			 (long)handler,
-			 (long)data));
+			 (long long)event_time,
+			 (long long)to_do,
+			 (long long)to_do->time_of_event,
+			 (long long)handler,
+			 (long long)data));
     free(to_do);
     /* Always re-compute the time to the next event so that HANDLER()
        can safely insert new events into the queue. */
diff --git a/sim/ppc/gdb-sim.c b/sim/ppc/gdb-sim.c
index 918ec62..dc839f4 100644
--- a/sim/ppc/gdb-sim.c
+++ b/sim/ppc/gdb-sim.c
@@ -1277,7 +1277,7 @@ sim_fetch_register (SIM_DESC sd, int regno, unsigned char *buf, int length)
     return -1;
 
   TRACE(trace_gdb, ("sim_fetch_register(regno=%d(%s), buf=0x%lx)\n",
-		    regno, regname, (long)buf));
+		    regno, regname, (long long)buf));
   return psim_read_register(simulator, MAX_NR_PROCESSORS,
 			    buf, regname, raw_transfer);
 }
@@ -1292,7 +1292,7 @@ sim_store_register (SIM_DESC sd, int regno, unsigned char *buf, int length)
     return 0;
 
   TRACE(trace_gdb, ("sim_store_register(regno=%d(%s), buf=0x%lx)\n",
-		    regno, regname, (long)buf));
+		    regno, regname, (long long)buf));
   return psim_write_register(simulator, MAX_NR_PROCESSORS,
 			     buf, regname, raw_transfer);
 }
diff --git a/sim/ppc/hw_disk.c b/sim/ppc/hw_disk.c
index a2ea934..d5b1f17 100644
--- a/sim/ppc/hw_disk.c
+++ b/sim/ppc/hw_disk.c
@@ -308,7 +308,7 @@ hw_disk_io_read_buffer(device *me,
   else
     nr_bytes_read = nr_bytes;
   DTRACE(disk, ("io-read - address 0x%lx, nr-bytes-read %d, requested %d\n",
-                (unsigned long) addr, (int)nr_bytes_read, (int)nr_bytes));
+                (unsigned long long) addr, (int)nr_bytes_read, (int)nr_bytes));
   return nr_bytes_read;
 }
 
@@ -337,7 +337,7 @@ hw_disk_io_write_buffer(device *me,
   else
     nr_bytes_written = nr_bytes;
   DTRACE(disk, ("io-write - address 0x%lx, nr-bytes-written %d, requested %d\n",
-                (unsigned long) addr, (int)nr_bytes_written, (int)nr_bytes));
+                (unsigned long long) addr, (int)nr_bytes_written, (int)nr_bytes));
   return nr_bytes_written;
 }
 
@@ -349,7 +349,7 @@ hw_disk_instance_delete(device_instance *instance)
 {
   hw_disk_instance *data = device_instance_data(instance);
   DITRACE(disk, ("delete - instance=%ld\n",
-		 (unsigned long)device_instance_to_external(instance)));
+		 (unsigned long long)device_instance_to_external(instance)));
   free(data);
 }
 
@@ -360,8 +360,8 @@ hw_disk_instance_read(device_instance *instance,
 {
   hw_disk_instance *data = device_instance_data(instance);
   DITRACE(disk, ("read - instance=%ld len=%ld\n",
-		 (unsigned long)device_instance_to_external(instance),
-		 (long)len));
+		 (unsigned long long)device_instance_to_external(instance),
+		 (long long)len));
   if ((data->pos + len) < data->pos)
     return -1; /* overflow */
   if (fseek(data->disk->image, data->pos, SEEK_SET) < 0)
@@ -379,8 +379,8 @@ hw_disk_instance_write(device_instance *instance,
 {
   hw_disk_instance *data = device_instance_data(instance);
   DITRACE(disk, ("write - instance=%ld len=%ld\n",
-		 (unsigned long)device_instance_to_external(instance),
-		 (long)len));
+		 (unsigned long long)device_instance_to_external(instance),
+		 (long long)len));
   if ((data->pos + len) < data->pos)
     return -1; /* overflow */
   if (data->disk->read_only)
@@ -403,8 +403,8 @@ hw_disk_instance_seek(device_instance *instance,
     device_error(device_instance_device(instance),
 		 "seek - extended addressing unimplemented");
   DITRACE(disk, ("seek - instance=%ld pos_hi=%ld pos_lo=%ld\n",
-		 (unsigned long)device_instance_to_external(instance),
-		 (long)pos_hi, (long)pos_lo));
+		 (unsigned long long)device_instance_to_external(instance),
+		 (long long)pos_hi, (long long)pos_lo));
   data->pos = pos_lo;
   return 0;
 }
@@ -429,8 +429,8 @@ hw_disk_max_transfer(device_instance *instance,
     else
       max_transfer = 512;
     DITRACE(disk, ("max-transfer - instance=%ld max-transfer=%ld\n",
-		   (unsigned long)device_instance_to_external(instance),
-		   (long int)max_transfer));
+		   (unsigned long long)device_instance_to_external(instance),
+		   (long long int)max_transfer));
     stack_returns[0] = max_transfer;
     return 0;
   }
@@ -456,8 +456,8 @@ hw_disk_block_size(device_instance *instance,
     else
       block_size = 512;
     DITRACE(disk, ("block-size - instance=%ld block-size=%ld\n",
-		   (unsigned long)device_instance_to_external(instance),
-		   (long int)block_size));
+		   (unsigned long long)device_instance_to_external(instance),
+		   (long long int)block_size));
     stack_returns[0] = block_size;
     return 0;
   }
@@ -483,8 +483,8 @@ hw_disk_nr_blocks(device_instance *instance,
     else
       nr_blocks = -1;
     DITRACE(disk, ("#blocks - instance=%ld #blocks=%ld\n",
-		   (unsigned long)device_instance_to_external(instance),
-		   (long int)nr_blocks));
+		   (unsigned long long)device_instance_to_external(instance),
+		   (long long int)nr_blocks));
     stack_returns[0] = nr_blocks;
     return 0;
   }
@@ -521,7 +521,7 @@ hw_disk_create_instance(device *me,
 					 &hw_disk_instance_callbacks);
   DITRACE(disk, ("create - path=%s(%s) instance=%ld\n",
 		 path, args,
-		 (unsigned long)device_instance_to_external(instance)));
+		 (unsigned long long)device_instance_to_external(instance)));
   return pk_disklabel_create_instance(instance, args);
 }
 
diff --git a/sim/ppc/hw_eeprom.c b/sim/ppc/hw_eeprom.c
index 3406be9..b3aad6e 100644
--- a/sim/ppc/hw_eeprom.c
+++ b/sim/ppc/hw_eeprom.c
@@ -272,7 +272,7 @@ invalid_read(device *me,
 	     const char *reason)
 {
   DTRACE(eeprom, ("Invalid read to 0x%lx while in state %s (%s)\n",
-		  (unsigned long)address,
+		  (unsigned long long)address,
 		  state2a(state),
 		  reason));
 }
@@ -285,8 +285,8 @@ invalid_write(device *me,
 	      const char *reason)
 {
   DTRACE(eeprom, ("Invalid write of 0x%lx to 0x%lx while in state %s (%s)\n",
-		  (unsigned long)data,
-		  (unsigned long)address,
+		  (unsigned long long)data,
+		  (unsigned long long)address,
 		  state2a(state),
 		  reason));
 }
@@ -322,9 +322,9 @@ start_programming_byte(device *me,
 {
   unsigned8 old_byte = eeprom->memory[address];
   DTRACE(eeprom, ("start-programing-byte - address 0x%lx, new 0x%lx, old 0x%lx\n",
-		  (unsigned long)address,
-		  (unsigned long)new_byte,
-		  (unsigned long)old_byte));
+		  (unsigned long long)address,
+		  (unsigned long long)new_byte,
+		  (unsigned long long)old_byte));
   eeprom->byte_program_address = address;
   /* : old new : ~old : new&~old
      :  0   0  :   1  :    0
@@ -350,8 +350,8 @@ finish_programming_byte(device *me,
 			hw_eeprom_device *eeprom)
 {
   DTRACE(eeprom, ("finish-programming-byte - address 0x%lx, byte 0x%lx\n",
-		  (unsigned long)eeprom->byte_program_address,
-		  (unsigned long)eeprom->byte_program_byte));
+		  (unsigned long long)eeprom->byte_program_address,
+		  (unsigned long long)eeprom->byte_program_byte));
   eeprom->memory[eeprom->byte_program_address] = eeprom->byte_program_byte;
   dump_eeprom(me, eeprom);
 }
@@ -389,7 +389,7 @@ start_erasing_sector(device *me,
 {
   int sector = address / eeprom->sizeof_sector;
   DTRACE(eeprom, ("start-erasing-sector - address 0x%lx, sector %d\n",
-		  (unsigned long)address, sector));
+		  (unsigned long long)address, sector));
   ASSERT(sector < eeprom->nr_sectors);
   eeprom->sectors[sector] = 1;
   memset(eeprom->memory + sector * eeprom->sizeof_sector,
@@ -778,7 +778,7 @@ hw_eeprom_instance_seek(device_instance *instance,
   hw_eeprom_instance *data = device_instance_data(instance);
   if (pos_lo >= data->eeprom->sizeof_memory)
     device_error(data->me, "seek value 0x%lx out of range\n",
-		 (unsigned long)pos_lo);
+		 (unsigned long long)pos_lo);
   data->pos = pos_lo;
   return 0;
 }
diff --git a/sim/ppc/hw_glue.c b/sim/ppc/hw_glue.c
index c824773..a10a1fb 100644
--- a/sim/ppc/hw_glue.c
+++ b/sim/ppc/hw_glue.c
@@ -256,10 +256,10 @@ hw_glue_io_read_buffer_callback(device *me,
   if (nr_bytes != sizeof(unsigned_word)
       || (addr % sizeof(unsigned_word)) != 0)
      device_error(me, "missaligned read access (%d:0x%lx:%d) not supported",
-		  space, (unsigned long)addr, nr_bytes);
+		  space, (unsigned long long)addr, nr_bytes);
   *(unsigned_word*)dest = H2BE_4(glue->output[reg]);
   DTRACE(glue, ("read - interrupt %d (0x%lx), level %d\n",
-		reg, (unsigned long) addr, glue->output[reg]));
+		reg, (unsigned long long) addr, glue->output[reg]));
   return nr_bytes;
 }
 
@@ -278,10 +278,10 @@ hw_glue_io_write_buffer_callback(device *me,
   if (nr_bytes != sizeof(unsigned_word)
       || (addr % sizeof(unsigned_word)) != 0)
     device_error(me, "missaligned write access (%d:0x%lx:%d) not supported",
-		 space, (unsigned long)addr, nr_bytes);
+		 space, (unsigned long long)addr, nr_bytes);
   glue->output[reg] = H2BE_4(*(unsigned_word*)source);
   DTRACE(glue, ("write - interrupt %d (0x%lx), level %d\n",
-		reg, (unsigned long) addr, glue->output[reg]));
+		reg, (unsigned long long) addr, glue->output[reg]));
   device_interrupt_event(me, reg, glue->output[reg], processor, cia);
   return nr_bytes;
 }
@@ -308,7 +308,7 @@ hw_glue_interrupt_event(device *me,
       glue->output[port] = level;
       DTRACE(glue, ("input - interrupt %d (0x%lx), level %d\n",
 		    my_port,
-		    (unsigned long)glue->address + port * sizeof(unsigned_word),
+		    (unsigned long long)glue->address + port * sizeof(unsigned_word),
 		    level));
       break;
     }
diff --git a/sim/ppc/hw_htab.c b/sim/ppc/hw_htab.c
index cf275ff..0090c84 100644
--- a/sim/ppc/hw_htab.c
+++ b/sim/ppc/hw_htab.c
@@ -233,10 +233,10 @@ htab_decode_hash_table(device *me,
   /* Check that the MASK and ADDRESS do not overlap.  */
   if ((htab_ra & (*htabmask)) != 0) {
     device_error(parent, "htaborg 0x%lx not aligned to htabmask 0x%lx",
-		 (unsigned long)*htaborg, (unsigned long)*htabmask);
+		 (unsigned long long)*htaborg, (unsigned long long)*htabmask);
   }
   DTRACE(htab, ("htab - htaborg=0x%lx htabmask=0x%lx\n",
-		(unsigned long)*htaborg, (unsigned long)*htabmask));
+		(unsigned long long)*htaborg, (unsigned long long)*htabmask));
 }
 
 static void
@@ -268,7 +268,7 @@ htab_map_page(device *me,
 				 0, /*space*/
 				 pte,
 				 sizeof(current_target_pte0)) != 4)
-	device_error(me, "failed to read a pte at 0x%lx", (unsigned long)pte);
+	device_error(me, "failed to read a pte at 0x%lx", (unsigned long long)pte);
       current_pte0 = T2H_4(current_target_pte0);
       if (MASKED32(current_pte0, 0, 0)) {
 	/* full pte, check it isn't already mapping the same virtual
@@ -280,15 +280,15 @@ htab_map_page(device *me,
 	    && curr_vsid == vsid
 	    && curr_api == MASKED32(vpage, 0, 5))
 	  device_error(me, "duplicate map - va=0x%08lx ra=0x%lx vsid=0x%lx h=%d vpage=0x%lx hash=0x%lx pteg=0x%lx+%2d pte0=0x%lx",
-		       (unsigned long)va,
-		       (unsigned long)ra,
-		       (unsigned long)vsid,
+		       (unsigned long long)va,
+		       (unsigned long long)ra,
+		       (unsigned long long)vsid,
 		       h,
-		       (unsigned long)vpage,
-		       (unsigned long)hash,
-		       (unsigned long)pteg,
+		       (unsigned long long)vpage,
+		       (unsigned long long)hash,
+		       (unsigned long long)pteg,
 		       pti * 8,
-		       (unsigned long)current_pte0);
+		       (unsigned long long)current_pte0);
       }
       else {
 	/* empty pte fill it */
@@ -313,18 +313,18 @@ htab_map_page(device *me,
 				       pte + 4,
 				       sizeof(target_pte1),
 				       1/*ro?*/) != 4)
-	  device_error(me, "failed to write a pte a 0x%lx", (unsigned long)pte);
+	  device_error(me, "failed to write a pte a 0x%lx", (unsigned long long)pte);
 	DTRACE(htab, ("map - va=0x%08lx ra=0x%lx vsid=0x%lx h=%d vpage=0x%lx hash=0x%lx pteg=0x%lx+%2d pte0=0x%lx pte1=0x%lx\n",
-		      (unsigned long)va,
-		      (unsigned long)ra,
-		      (unsigned long)vsid,
+		      (unsigned long long)va,
+		      (unsigned long long)ra,
+		      (unsigned long long)vsid,
 		      h,
-		      (unsigned long)vpage,
-		      (unsigned long)hash,
-		      (unsigned long)pteg,
+		      (unsigned long long)vpage,
+		      (unsigned long long)hash,
+		      (unsigned long long)pteg,
 		      pti * 8,
-		      (unsigned long)pte0,
-		      (unsigned long)pte1));
+		      (unsigned long long)pte0,
+		      (unsigned long long)pte1));
 	return;
       }
     }
@@ -458,10 +458,10 @@ htab_dma_binary(bfd *abfd,
   DTRACE(htab,
 	 ("load - name=%-7s vma=0x%.8lx size=%6ld ra=0x%.8lx flags=%3lx(%s%s%s%s%s )\n",
 	  bfd_get_section_name(abfd, sec),
-	  (long)section_vma,
-	  (long)section_size,
-	  (long)section_ra,
-	  (long)bfd_get_section_flags(abfd, sec),
+	  (long long)section_vma,
+	  (long long)section_size,
+	  (long long)section_ra,
+	  (long long)bfd_get_section_flags(abfd, sec),
 	  bfd_get_section_flags(abfd, sec) & SEC_LOAD ? " LOAD" : "",
 	  bfd_get_section_flags(abfd, sec) & SEC_CODE ? " CODE" : "",
 	  bfd_get_section_flags(abfd, sec) & SEC_DATA ? " DATA" : "",
@@ -536,13 +536,13 @@ htab_map_binary(device *me,
   }
 
   DTRACE(htab, ("text map - base=0x%lx bound=0x%lx-1 ra=0x%lx\n",
-		(unsigned long)sizes.text_base,
-		(unsigned long)sizes.text_bound,
-		(unsigned long)sizes.text_ra));
+		(unsigned long long)sizes.text_base,
+		(unsigned long long)sizes.text_bound,
+		(unsigned long long)sizes.text_ra));
   DTRACE(htab, ("data map - base=0x%lx bound=0x%lx-1 ra=0x%lx\n",
-		(unsigned long)sizes.data_base,
-		(unsigned long)sizes.data_bound,
-		(unsigned long)sizes.data_ra));
+		(unsigned long long)sizes.data_base,
+		(unsigned long long)sizes.data_bound,
+		(unsigned long long)sizes.data_ra));
 
   /* check for and fix a botched image (text and data segments
      overlap) */
@@ -571,9 +571,9 @@ htab_map_binary(device *me,
     sizes.text_bound = 0;
     sizes.text_ra = 0;
     DTRACE(htab, ("common map - base=0x%lx bound=0x%lx-1 ra=0x%lx\n",
-		  (unsigned long)sizes.data_base,
-		  (unsigned long)sizes.data_bound,
-		  (unsigned long)sizes.data_ra));
+		  (unsigned long long)sizes.data_base,
+		  (unsigned long long)sizes.data_bound,
+		  (unsigned long long)sizes.data_ra));
   }
 
   /* set up virtual memory maps for each of the regions */
@@ -628,17 +628,17 @@ htab_init_data_callback(device *me)
       if (device_find_property(me, "real-address") != NULL) {
 	unsigned32 pte_ra = device_find_integer_property(me, "real-address");
 	DTRACE(htab, ("pte - ra=0x%lx, wimg=%ld, pp=%ld, file-name=%s\n",
-		      (unsigned long)pte_ra,
-		      (unsigned long)pte_wimg,
-		      (long)pte_pp,
+		      (unsigned long long)pte_ra,
+		      (unsigned long long)pte_wimg,
+		      (long long)pte_pp,
 		      file_name));
 	htab_map_binary(me, memory, pte_ra, pte_wimg, pte_pp, file_name,
 			htaborg, htabmask);
       }
       else {
 	DTRACE(htab, ("pte - wimg=%ld, pp=%ld, file-name=%s\n",
-		      (unsigned long)pte_wimg,
-		      (long)pte_pp,
+		      (unsigned long long)pte_wimg,
+		      (long long)pte_pp,
 		      file_name));
 	htab_map_binary(me, memory, -1, pte_wimg, pte_pp, file_name,
 			htaborg, htabmask);
@@ -659,11 +659,11 @@ htab_init_data_callback(device *me)
 	pte_va = (pte_va << WITH_TARGET_WORD_BITSIZE) | (unsigned_cell)partial_va;
       }
       DTRACE(htab, ("pte - ra=0x%lx, wimg=%ld, pp=%ld, va=0x%lx, nr_bytes=%ld\n",
-		    (unsigned long)pte_ra,
-		    (long)pte_wimg,
-		    (long)pte_pp,
-		    (unsigned long)pte_va,
-		    (long)pte_nr_bytes));
+		    (unsigned long long)pte_ra,
+		    (long long)pte_wimg,
+		    (long long)pte_pp,
+		    (unsigned long long)pte_va,
+		    (long long)pte_nr_bytes));
       htab_map_region(me, memory, pte_ra, pte_va, pte_nr_bytes, pte_wimg, pte_pp,
 		      htaborg, htabmask);
     }
diff --git a/sim/ppc/hw_ide.c b/sim/ppc/hw_ide.c
index 9d3a711..700293e 100644
--- a/sim/ppc/hw_ide.c
+++ b/sim/ppc/hw_ide.c
@@ -450,12 +450,12 @@ setup_fifo(device *me,
     device_error(me, "controller %d:%d - CHS addressing disabled",
 		 controller->nr, controller->current_drive->nr);
   DTRACE(ide, ("controller %ld:%ld - transfer (%s) %ld blocks of %ld bytes from 0x%lx\n",
-	       (long)controller->nr,
-	       controller->current_drive == NULL ? -1L : (long)controller->current_drive->nr,
+	       (long long)controller->nr,
+	       controller->current_drive == NULL ? -1L : (long long)controller->current_drive->nr,
 	       direction == is_read ? "read" : "write",
-	       (long)controller->current_transfer,
-	       (long)controller->fifo_size,
-	       (unsigned long)controller->current_byte));
+	       (long long)controller->current_transfer,
+	       (long long)controller->fifo_size,
+	       (unsigned long long)controller->current_byte));
   switch (direction) {
   case is_read:
     /* force a primeing read */
@@ -557,7 +557,7 @@ decode_address(device *me,
     }
   }
   device_error(me, "address %d:0x%lx invalid",
-	       space, (unsigned long)address);
+	       space, (unsigned long long)address);
 }
 
 
@@ -592,8 +592,8 @@ build_address_decoder(device *me,
       DTRACE(ide, ("controller %d command register block at %d:0x%lx..0x%lx\n",
 		   decoder->block[reg-1].controller,
 		   decoder->block[reg-1].space,
-		   (unsigned long)decoder->block[reg-1].base_addr,
-		   (unsigned long)decoder->block[reg-1].bound_addr));
+		   (unsigned long long)decoder->block[reg-1].base_addr,
+		   (unsigned long long)decoder->block[reg-1].bound_addr));
       break;
     case 3:
     case 4:
@@ -608,8 +608,8 @@ build_address_decoder(device *me,
       DTRACE(ide, ("controller %d control register block at %d:0x%lx..0x%lx\n",
 		   decoder->block[reg-1].controller,
 		   decoder->block[reg-1].space,
-		   (unsigned long)decoder->block[reg-1].base_addr,
-		   (unsigned long)decoder->block[reg-1].bound_addr));
+		   (unsigned long long)decoder->block[reg-1].base_addr,
+		   (unsigned long long)decoder->block[reg-1].bound_addr));
       break;
     case 5:
       /* dma register block */
@@ -623,8 +623,8 @@ build_address_decoder(device *me,
       DTRACE(ide, ("controller %d dma register block at %d:0x%lx..0x%lx\n",
 		   decoder->block[reg-1].controller,
 		   decoder->block[reg-1].space,
-		   (unsigned long)decoder->block[reg-1].base_addr,
-		   (unsigned long)decoder->block[reg-1].bound_addr));
+		   (unsigned long long)decoder->block[reg-1].base_addr,
+		   (unsigned long long)decoder->block[reg-1].bound_addr));
       decoder->block[reg].space = space;
       decoder->block[reg].base_addr = address + 4;
       decoder->block[reg].bound_addr = address + 8 - 1;
@@ -633,8 +633,8 @@ build_address_decoder(device *me,
       DTRACE(ide, ("controller %d dma register block at %d:0x%lx..0x%lx\n",
 		   decoder->block[reg].controller,
 		   decoder->block[reg-1].space,
-		   (unsigned long)decoder->block[reg].base_addr,
-		   (unsigned long)decoder->block[reg].bound_addr));
+		   (unsigned long long)decoder->block[reg].base_addr,
+		   (unsigned long long)decoder->block[reg].bound_addr));
       break;
     default:
       device_error(me, "internal error - bad switch");
diff --git a/sim/ppc/hw_init.c b/sim/ppc/hw_init.c
index 0e7403b..d4c301c 100644
--- a/sim/ppc/hw_init.c
+++ b/sim/ppc/hw_init.c
@@ -225,13 +225,13 @@ hw_data_init_data_callback(device *me)
 				    sizeof(buf), /*nr-bytes*/
 				    1 /*violate ro*/) != sizeof(buf))
 	  device_error(me, "Problem storing integer 0x%x at 0x%lx\n",
-		       (unsigned)buf, (unsigned long)addr);
+		       (unsigned)buf, (unsigned long long)addr);
       }
       else {
 	if (device_instance_seek(instance, 0, addr) < 0
 	    || device_instance_write(instance, &buf, sizeof(buf)) != sizeof(buf))
 	  device_error(me, "Problem storing integer 0x%x at 0x%lx of instance %s\n",
-		       (unsigned)buf, (unsigned long)addr, instance_spec);
+		       (unsigned)buf, (unsigned long long)addr, instance_spec);
       }
     }
     break;
@@ -338,9 +338,9 @@ update_for_binary_section(bfd *abfd,
   DTRACE(binary,
 	 ("name=%-7s, vma=0x%.8lx, size=%6ld, flags=%3lx(%s%s%s%s%s )\n",
 	  bfd_get_section_name(abfd, the_section),
-	  (long)section_vma,
-	  (long)section_size,
-	  (long)bfd_get_section_flags(abfd, the_section),
+	  (long long)section_vma,
+	  (long long)section_size,
+	  (long long)bfd_get_section_flags(abfd, the_section),
 	  bfd_get_section_flags(abfd, the_section) & SEC_LOAD ? " LOAD" : "",
 	  bfd_get_section_flags(abfd, the_section) & SEC_CODE ? " CODE" : "",
 	  bfd_get_section_flags(abfd, the_section) & SEC_DATA ? " DATA" : "",
@@ -518,7 +518,7 @@ write_stack_arguments(device *me,
 {
   DTRACE(stack,
 	("write_stack_arguments(device=%s, arg=0x%lx, start_block=0x%lx, end_block=0x%lx, start_arg=0x%lx, end_arg=0x%lx)\n",
-	 device_name(me), (long)arg, (long)start_block, (long)end_block, (long)start_arg, (long)end_arg));
+	 device_name(me), (long long)arg, (long long)start_block, (long long)end_block, (long long)start_arg, (long long)end_arg));
   if (arg == NULL)
     device_error(me, "Attempt to write a null array onto the stack\n");
   /* only copy in arguments, memory is already zero */
@@ -527,13 +527,13 @@ write_stack_arguments(device *me,
     unsigned_word target_start_block;
     DTRACE(stack,
 	  ("write_stack_arguments() write %s=%s at %s=0x%lx %s=0x%lx %s=0x%lx\n",
-	   "**arg", *arg, "start_block", (long)start_block,
-	   "len", (long)len, "start_arg", (long)start_arg));
+	   "**arg", *arg, "start_block", (long long)start_block,
+	   "len", (long long)len, "start_arg", (long long)start_arg));
     if (psim_write_memory(device_system(me), 0, *arg,
 			  start_block, len,
 			  0/*violate_readonly*/) != len)
       device_error(me, "Write of **arg (%s) at 0x%lx of stack failed\n",
-		   *arg, (unsigned long)start_block);
+		   *arg, (unsigned long long)start_block);
     target_start_block = H2T_word(start_block);
     if (psim_write_memory(device_system(me), 0, &target_start_block,
 			  start_arg, sizeof(target_start_block),
@@ -672,11 +672,11 @@ hw_stack_ioctl(device *me,
       const char *stack_type;
       DTRACE(stack,
 	     ("stack_ioctl_callback(me=0x%lx:%s processor=0x%lx cia=0x%lx argv=0x%lx envp=0x%lx)\n",
-	      (long)me, device_name(me),
-	      (long)processor,
-	      (long)cia,
-	      (long)argv,
-	      (long)envp));
+	      (long long)me, device_name(me),
+	      (long long)processor,
+	      (long long)cia,
+	      (long long)argv,
+	      (long long)envp));
       stack_type = device_find_string_property(me, "stack-type");
       if (strcmp(stack_type, "ppc-elf") == 0)
 	create_ppc_elf_stack_frame(me, stack_pointer, argv, envp);
diff --git a/sim/ppc/hw_iobus.c b/sim/ppc/hw_iobus.c
index 81ca074..1723136 100644
--- a/sim/ppc/hw_iobus.c
+++ b/sim/ppc/hw_iobus.c
@@ -67,7 +67,7 @@ hw_iobus_attach_address_callback(device *me,
 				   &attach_address,
 				   me);
   if (addr < attach_address)
-    device_error(me, "Invalid attach address 0x%lx", (unsigned long)addr);
+    device_error(me, "Invalid attach address 0x%lx", (unsigned long long)addr);
   device_attach_address(device_parent(me),
 			type,
 			attach_space,
diff --git a/sim/ppc/hw_memory.c b/sim/ppc/hw_memory.c
index 09c331c..8983681 100644
--- a/sim/ppc/hw_memory.c
+++ b/sim/ppc/hw_memory.c
@@ -310,10 +310,10 @@ hw_memory_instance_claim(device_instance *instance,
     }
     if (chunk == NULL || address < chunk->address || !chunk->available)
       device_error(me, "failed to allocate %ld bytes at 0x%lx",
-		   (unsigned long)size, (unsigned long)address);
+		   (unsigned long long)size, (unsigned long long)address);
     DTRACE(memory, ("claim - address=0x%lx size=0x%lx\n",
-		    (unsigned long)address,
-		    (unsigned long)size));
+		    (unsigned long long)address,
+		    (unsigned long long)size));
   }
   else {
     /* adjust the alignment so that it is a power of two */
@@ -321,7 +321,7 @@ hw_memory_instance_claim(device_instance *instance,
     while (align_mask < alignment && align_mask != 0)
       align_mask <<= 1;
     if (align_mask == 0)
-      device_error(me, "alignment 0x%lx is to large", (unsigned long)alignment);
+      device_error(me, "alignment 0x%lx is to large", (unsigned long long)alignment);
     align_mask -= 1;
     /* now find an aligned chunk that fits */
     chunk = hw_memory->heap;
@@ -334,12 +334,12 @@ hw_memory_instance_claim(device_instance *instance,
     }
     if (chunk == NULL)
       device_error(me, "failed to allocate %ld bytes with alignment %ld",
-		   (unsigned long)size, (unsigned long)alignment);
+		   (unsigned long long)size, (unsigned long long)alignment);
     DTRACE(memory, ("claim - size=0x%lx alignment=%ld (0x%lx), address=0x%lx\n",
-		    (unsigned long)size,
-		    (unsigned long)alignment,
-		    (unsigned long)alignment,
-		    (unsigned long)address));
+		    (unsigned long long)size,
+		    (unsigned long long)alignment,
+		    (unsigned long long)alignment,
+		    (unsigned long long)address));
   }
 
   /* break off a bit before this chunk if needed */
@@ -443,13 +443,13 @@ hw_memory_instance_release(device_instance *instance,
       /* an exact match */
       if (chunk->available)
 	device_error(me, "memory chunk 0x%lx (size 0x%lx) already available",
-		     (unsigned long)address,
-		     (unsigned long)length);
+		     (unsigned long long)address,
+		     (unsigned long long)length);
       else {
 	/* free this chunk */
 	DTRACE(memory, ("release - address=0x%lx, length=0x%lx\n",
-			(unsigned long) address,
-			(unsigned long) length));
+			(unsigned long long) address,
+			(unsigned long long) length));
 	chunk->available = 1;
 	break;
       }
@@ -459,10 +459,10 @@ hw_memory_instance_release(device_instance *instance,
       /* a sub region */
       if (!chunk->available) {
 	DTRACE(memory, ("release - address=0x%lx, size=0x%lx within region 0x%lx length 0x%lx\n",
-			(unsigned long) chunk->address,
-			(unsigned long) chunk->size,
-			(unsigned long) address,
-			(unsigned long) length));
+			(unsigned long long) chunk->address,
+			(unsigned long long) chunk->size,
+			(unsigned long long) address,
+			(unsigned long long) length));
 	chunk->available = 1;
       }
     }
@@ -470,8 +470,8 @@ hw_memory_instance_release(device_instance *instance,
   }
   if (chunk == NULL) {
     printf_filtered("warning: released chunks within region 0x%lx..0x%lx\n",
-		    (unsigned long)address,
-		    (unsigned long)(address + length - 1));
+		    (unsigned long long)address,
+		    (unsigned long long)(address + length - 1));
   }
 
   /* check for the chance to merge two adjacent available memory chunks */
diff --git a/sim/ppc/hw_nvram.c b/sim/ppc/hw_nvram.c
index f8caaa8..390f7bb 100644
--- a/sim/ppc/hw_nvram.c
+++ b/sim/ppc/hw_nvram.c
@@ -76,7 +76,7 @@ typedef struct _hw_nvram_device {
 #ifdef HAVE_TIME_H
   time_t host_time;
 #else
-  long host_time;
+  long long host_time;
 #endif
   unsigned timezone;
   /* useful */
diff --git a/sim/ppc/hw_opic.c b/sim/ppc/hw_opic.c
index 69d956b..128c7b4 100644
--- a/sim/ppc/hw_opic.c
+++ b/sim/ppc/hw_opic.c
@@ -548,12 +548,12 @@ hw_opic_init_data(device *me)
       device_error(me, "interrupt source unit %d (reg %d) has an incorrect size, should be 0x%x",
 		   isb, opic->isu_block[isb].reg, correct_size);
     DTRACE(opic, ("interrupt source unit block %ld - address %d:0x%lx, size 0x%lx, int-number %ld, range %ld\n",
-		  (long)isb,
+		  (long long)isb,
 		  (int)opic->isu_block[isb].space,
-		  (unsigned long)opic->isu_block[isb].address,
-		  (unsigned long)opic->isu_block[isb].size,
-		  (long)opic->isu_block[isb].int_number,
-		  (long)opic->isu_block[isb].range));
+		  (unsigned long long)opic->isu_block[isb].address,
+		  (unsigned long long)opic->isu_block[isb].size,
+		  (long long)opic->isu_block[isb].int_number,
+		  (long long)opic->isu_block[isb].range));
   }
 
 
@@ -576,8 +576,8 @@ hw_opic_init_data(device *me)
 		   correct_size, alternate_size);
     DTRACE(opic, ("interrupt delivery unit - address %d:0x%lx, size 0x%lx\n",
 		  (int)opic->idu.space,
-		  (unsigned long)opic->idu.address,
-		  (unsigned long)opic->idu.size));
+		  (unsigned long long)opic->idu.address,
+		  (unsigned long long)opic->idu.size));
   }
 
   /* initialize the init interrupts */
@@ -801,11 +801,11 @@ handle_interrupt(device *me,
     ASSERT(src->pending == 0 || src->pending == src->in_service);
     src->pending = src->in_service;
     DTRACE(opic, ("interrupt %ld - ignore already in service to 0x%lx\n",
-		  (long)src->nr, (long)src->in_service));
+		  (long long)src->nr, (long long)src->in_service));
   }
   else if (src->pending != 0) {
     DTRACE(opic, ("interrupt %ld - ignore still pending to 0x%lx\n",
-		  (long)src->nr, (long)src->pending));
+		  (long long)src->nr, (long long)src->pending));
   }
   else {
     /* delivery is needed */
@@ -819,7 +819,7 @@ handle_interrupt(device *me,
     else {
       src->pending = src->destination; /* any can take this */
       DTRACE(opic, ("interrupt %ld - pending to 0x%lx\n",
-		    (long)src->nr, (long)src->pending));
+		    (long long)src->nr, (long long)src->pending));
     }
   }
 }
@@ -984,7 +984,7 @@ decode_opic_address(device *me,
       break;
     }
     DTRACE(opic, ("per-processor register %d:0x%lx - %s[%d]\n",
-		  space, (unsigned long)address,
+		  space, (unsigned long long)address,
 		  opic_register_name(*type),
 		  *index));
     return;
@@ -1011,7 +1011,7 @@ decode_opic_address(device *me,
 	break;
       }
       DTRACE(opic, ("isu register %d:0x%lx - %s[%d]\n",
-		    space, (unsigned long)address,
+		    space, (unsigned long long)address,
 		    opic_register_name(*type),
 		    *index));
       return;
@@ -1044,7 +1044,7 @@ decode_opic_address(device *me,
       break;
     }
     DTRACE(opic, ("timer register %d:0x%lx - %s[%d]\n",
-		  space, (unsigned long)address,
+		  space, (unsigned long long)address,
 		  opic_register_name(*type),
 		  *index));
     return;
@@ -1093,7 +1093,7 @@ decode_opic_address(device *me,
       break;
     }
     DTRACE(opic, ("global register %d:0x%lx - %s[%d]\n",
-		  space, (unsigned long)address,
+		  space, (unsigned long long)address,
 		  opic_register_name(*type),
 		  *index));
     return;
@@ -1102,7 +1102,7 @@ decode_opic_address(device *me,
   /* nothing matched */
   *type = invalid_opic_register;
   DTRACE(opic, ("invalid register %d:0x%lx\n",
-		space, (unsigned long)address));
+		space, (unsigned long long)address));
   return;
 }
 
@@ -1118,7 +1118,7 @@ do_processor_init_register_read(device *me,
 {
   unsigned reg = opic->init;
   DTRACE(opic, ("processor init register - read 0x%lx\n",
-		(long)reg));
+		(long long)reg));
   return reg;
 }
 
@@ -1133,13 +1133,13 @@ do_processor_init_register_write(device *me,
     if ((reg & dest->bit) != (opic->init & dest->bit)) {
       if (reg & dest->bit) {
 	DTRACE(opic, ("processor init register - write 0x%lx - asserting init%d\n",
-		      (long)reg, i));
+		      (long long)reg, i));
 	opic->init |= dest->bit;
 	device_interrupt_event(me, dest->init_port, 1, NULL, 0);
       }
       else {
 	DTRACE(opic, ("processor init register - write 0x%lx - negating init%d\n",
-		      (long)reg, i));
+		      (long long)reg, i));
 	opic->init &= ~dest->bit;
 	device_interrupt_event(me, dest->init_port, 0, NULL, 0);
       }
@@ -1169,7 +1169,7 @@ read_vector_priority_register(device *me,
   reg |= interrupt->priority << isu_priority_shift;
   reg |= interrupt->vector;
   DTRACE(opic, ("%s %d vector/priority register - read 0x%lx\n",
-		reg_name, reg_index, (unsigned long)reg));
+		reg_name, reg_index, (unsigned long long)reg));
   return reg;
 }
 
@@ -1204,13 +1204,13 @@ write_vector_priority_register(device *me,
   DTRACE(opic, ("%s %d vector/priority register - write 0x%lx - %s%s%s-polarity, %s-triggered, priority %ld vector %ld\n",
 		reg_name,
 		reg_index,
-		(unsigned long)reg,
+		(unsigned long long)reg,
 		interrupt->is_masked ? "masked, " : "",
 		interrupt->is_multicast ? "multicast, " : "",
 		interrupt->is_positive_polarity ? "positive" : "negative",
 		interrupt->is_level_triggered ? "level" : "edge",
-		(long)interrupt->priority,
-		(long)interrupt->vector));
+		(long long)interrupt->priority,
+		(long long)interrupt->vector));
 }
 
 static void
@@ -1237,7 +1237,7 @@ read_destination_register(device *me,
 			  const char *reg_name,
 			  int reg_index)
 {
-  unsigned long reg;
+  unsigned long long reg;
   reg = interrupt->destination;
   DTRACE(opic, ("%s %d destination register - read 0x%lx\n",
 		reg_name, reg_index, reg));
@@ -1289,7 +1289,7 @@ static unsigned
 do_spurious_vector_register_read(device *me,
 				 hw_opic_device *opic)
 {
-  unsigned long reg = opic->spurious_vector;
+  unsigned long long reg = opic->spurious_vector;
   DTRACE(opic, ("spurious vector register - read 0x%lx\n", reg));
   return reg;
 }
@@ -1403,7 +1403,7 @@ timer_event(void *data)
   timer->timeout_event = device_event_queue_schedule(me, timer->base_count,
 						     timer_event, timer);
   DTRACE(opic, ("timer %d - interrupt at %ld, next at %d\n",
-		timer->nr, (long)device_event_queue_time(me), timer->base_count));
+		timer->nr, (long long)device_event_queue_time(me), timer->base_count));
 }
 
 
@@ -1623,7 +1623,7 @@ hw_opic_io_read_buffer(device *me,
   decode_opic_address(me, opic, space, addr, nr_bytes, &type, &index);
   if (type == invalid_opic_register) {
     device_error(me, "invalid opic read access to %d:0x%lx (%d bytes)",
-		 space, (unsigned long)addr, nr_bytes);
+		 space, (unsigned long long)addr, nr_bytes);
   }
   else {
     unsigned reg;
@@ -1699,7 +1699,7 @@ hw_opic_io_write_buffer(device *me,
   decode_opic_address(me, opic, space, addr, nr_bytes, &type, &index);
   if (type == invalid_opic_register) {
     device_error(me, "invalid opic write access to %d:0x%lx (%d bytes)",
-		 space, (unsigned long)addr, nr_bytes);
+		 space, (unsigned long long)addr, nr_bytes);
   }
   else {
     unsigned reg = LE2H_4(*(unsigned_4*)source);
diff --git a/sim/ppc/hw_pal.c b/sim/ppc/hw_pal.c
index 0789929..881125b 100644
--- a/sim/ppc/hw_pal.c
+++ b/sim/ppc/hw_pal.c
@@ -271,7 +271,7 @@ hw_pal_instance_read_callback(device_instance *instance,
 			      void *buf,
 			      unsigned_word len)
 {
-  DITRACE(pal, ("read - %s (%ld)", (const char*)buf, (long int)len));
+  DITRACE(pal, ("read - %s (%ld)", (const char*)buf, (long long int)len));
   return sim_io_read_stdin(buf, len);
 }
 
@@ -283,7 +283,7 @@ hw_pal_instance_write_callback(device_instance *instance,
   int i;
   const char *chp = buf;
   hw_pal_device *hw_pal = device_instance_data(instance);
-  DITRACE(pal, ("write - %s (%ld)", (const char*)buf, (long int)len));
+  DITRACE(pal, ("write - %s (%ld)", (const char*)buf, (long long int)len));
   for (i = 0; i < len; i++)
     write_hw_pal(hw_pal, chp[i]);
   sim_io_flush_stdoutput();
diff --git a/sim/ppc/hw_phb.c b/sim/ppc/hw_phb.c
index 8e3fb17..61ad5f5 100644
--- a/sim/ppc/hw_phb.c
+++ b/sim/ppc/hw_phb.c
@@ -281,10 +281,10 @@ hw_phb_init_address(device *me)
 			    me);
       DTRACE(phb, ("map %d:0x%lx to %s:0x%lx (0x%lx bytes)\n",
 		   (int)parent_attach_space,
-		   (unsigned long)parent_attach_address,
+		   (unsigned long long)parent_attach_address,
 		   pci_space->name,
-		   (unsigned long)my_attach_address,
-		   (unsigned long)size));
+		   (unsigned long long)my_attach_address,
+		   (unsigned long long)size));
     }
     
     if (ranges_entry == 0) {
@@ -314,7 +314,7 @@ hw_phb_attach_address(device *me,
   if (addr + nr_bytes > pci_space->my_base + pci_space->size
       || addr < pci_space->my_base)
     device_error(me, "attach addr (0x%lx) specified by %s outside of bus address range",
-		 (unsigned long)addr, device_path(client));
+		 (unsigned long long)addr, device_path(client));
   if (type != hw_phb_normal_decode
       && type != hw_phb_subtractive_decode)
     device_error(me, "attach type (%d) specified by %s invalid",
@@ -324,8 +324,8 @@ hw_phb_attach_address(device *me,
 	       device_path(client),
 	       hw_phb_decode_name(type),
 	       pci_space->name,
-	       (unsigned long)addr,
-	       (unsigned long)nr_bytes));
+	       (unsigned long long)addr,
+	       (unsigned long long)nr_bytes));
   core_attach(pci_space->map,
 	      type,
 	      space,
@@ -522,7 +522,7 @@ hw_phb_unit_decode(device *me,
 {
   char *end = NULL;
   const char *chp = unit;
-  unsigned long val;
+  unsigned long long val;
 
   if (device_nr_address_cells(me) != 3)
     device_error(me, "PCI bus should have #address-cells == 3");
@@ -606,7 +606,7 @@ hw_phb_unit_decode(device *me,
 		 unit);
   if ((val & 7) != val)
     device_error(me, "Function number (%ld) out of range (0..7) in PCI address %s",
-		 (long)val, unit);
+		 (long long)val, unit);
   set_fff(address, val);
   chp = end;
 
@@ -786,9 +786,9 @@ hw_phb_unit_encode(device *me,
   }
   else {
     device_error(me, "Invalid PCI unit address 0x%08lx 0x%08lx 0x%08lx",
-		 (unsigned long)unit_address->cells[0],
-		 (unsigned long)unit_address->cells[1],
-		 (unsigned long)unit_address->cells[2]);
+		 (unsigned long long)unit_address->cells[0],
+		 (unsigned long long)unit_address->cells[1],
+		 (unsigned long long)unit_address->cells[2]);
   }
   if (strlen(buf) > sizeof_buf)
     error("buffer overflow");
@@ -847,14 +847,14 @@ hw_phb_address_to_attach_address(device *me,
 	if (extract_ss(address) != extract_ss(&assigned.address))
 	  device_error(me, "client %s has conflicting types for base register 0x%lx",
 		       device_path(client),
-		       (unsigned long)extract_rrrrrrrr(address));
+		       (unsigned long long)extract_rrrrrrrr(address));
 	*attach_address += assigned.address.cells[2];
 	return 0;
       }
     }
     device_error(me, "client %s missing base address register 0x%lx in assigned-addresses property",
 		 device_path(client),
-		 (unsigned long)extract_rrrrrrrr(address));
+		 (unsigned long long)extract_rrrrrrrr(address));
   }
   
   return 0;
@@ -919,7 +919,7 @@ hw_phb_io_read_buffer(device *me,
     return 0;
   bus_addr = map_phb_addr(pci_space, addr);
   DTRACE(phb, ("io read - %d:0x%lx -> %s:0x%lx (%u bytes)\n",
-	       space, (unsigned long)addr, pci_space->name, (unsigned long)bus_addr,
+	       space, (unsigned long long)addr, pci_space->name, (unsigned long long)bus_addr,
 	       nr_bytes));
   return core_map_read_buffer(pci_space->readable,
 			      dest, bus_addr, nr_bytes);
@@ -942,7 +942,7 @@ hw_phb_io_write_buffer(device *me,
     return 0;
   bus_addr = map_phb_addr(pci_space, addr);
   DTRACE(phb, ("io write - %d:0x%lx -> %s:0x%lx (%u bytes)\n",
-	       space, (unsigned long)addr, pci_space->name, (unsigned long)bus_addr,
+	       space, (unsigned long long)addr, pci_space->name, (unsigned long long)bus_addr,
 	       nr_bytes));
   return core_map_write_buffer(pci_space->writeable, source,
 			       bus_addr, nr_bytes);
diff --git a/sim/ppc/hw_register.c b/sim/ppc/hw_register.c
index de65c9f..e85e9a2 100644
--- a/sim/ppc/hw_register.c
+++ b/sim/ppc/hw_register.c
@@ -87,7 +87,7 @@ do_register_init(device *me,
 
     if (strchr(name, '.') == NULL) {
       processor = -1;
-      DTRACE(register, ("%s=0x%lx\n", name, (unsigned long)value));
+      DTRACE(register, ("%s=0x%lx\n", name, (unsigned long long)value));
     }
     else {
       char *end;
@@ -95,7 +95,7 @@ do_register_init(device *me,
       ASSERT(end[0] == '.');
       name = end+1;
       DTRACE(register, ("%d.%s=0x%lx\n", processor, name,
-			(unsigned long)value));
+			(unsigned long long)value));
     }    
     if (psim_write_register(system, processor, /* all processors */
 			    &value,
diff --git a/sim/ppc/idecode_expression.h b/sim/ppc/idecode_expression.h
index 13f6020..7b02ede 100644
--- a/sim/ppc/idecode_expression.h
+++ b/sim/ppc/idecode_expression.h
@@ -93,7 +93,7 @@
          XER &= (~xer_carry); */ \
   } \
   TRACE(trace_alu, (" Result = %ld (0x%lx), XER = %ld\n", \
-                    (long)alu_result, (long)alu_result, (long)XER)); \
+                    (long long)alu_result, (long long)alu_result, (long long)XER)); \
   /* Update the Result Conditions if needed */ \
   CR0_COMPARE(alu_result, 0, Rc); \
   /* assign targ same */ \
@@ -290,7 +290,7 @@ do { \
     CR_COMPARE(0, LHS, RHS); \
     TRACE(trace_alu, \
 	  ("CR=0x%08lx, LHS=%ld, RHS=%ld\n", \
-	   (unsigned long)CR, (long)LHS, (long)RHS)); \
+	   (unsigned long long)CR, (long long)LHS, (long long)RHS)); \
   } \
 } while (0)
 
diff --git a/sim/ppc/interrupts.c b/sim/ppc/interrupts.c
index db100fd..429d1c4 100644
--- a/sim/ppc/interrupts.c
+++ b/sim/ppc/interrupts.c
@@ -107,12 +107,12 @@ perform_oea_interrupt(cpu *processor,
   if (!(old_msr & msr_recoverable_interrupt)) {
     cpu_error(processor, cia,
 	      "double interrupt - MSR[RI] bit clear when attempting to deliver interrupt, cia=0x%lx, msr=0x%lx; srr0=0x%lx(cia), srr1=0x%lx(msr); trap-vector=0x%lx, trap-msr=0x%lx",
-	      (unsigned long)cia,
-	      (unsigned long)old_msr,
-	      (unsigned long)SRR0,
-	      (unsigned long)SRR1,
-	      (unsigned long)vector_offset,
-	      (unsigned long)new_msr);
+	      (unsigned long long)cia,
+	      (unsigned long long)old_msr,
+	      (unsigned long long)SRR0,
+	      (unsigned long long)SRR1,
+	      (unsigned long long)vector_offset,
+	      (unsigned long long)new_msr);
   }
   SRR0 = (spreg)(cia);
   SRR1 = interrupt_srr1(old_msr, srr1_clear, srr1_set);
@@ -136,7 +136,7 @@ machine_check_interrupt(cpu *processor,
 
   case OPERATING_ENVIRONMENT:
     TRACE(trace_interrupts, ("machine-check interrupt - cia=0x%lx\n",
-			     (unsigned long)cia));
+			     (unsigned long long)cia));
     cia = perform_oea_interrupt(processor, cia, 0x00200, 0, 0, 0, 0);
     cpu_restart(processor, cia);
 
@@ -190,9 +190,9 @@ data_storage_interrupt(cpu *processor,
       }
       DAR = (spreg)ea;
       TRACE(trace_interrupts, ("data storage interrupt - cia=0x%lx DAR=0x%lx DSISR=0x%lx\n",
-			       (unsigned long)cia,
-			       (unsigned long)DAR,
-			       (unsigned long)DSISR));
+			       (unsigned long long)cia,
+			       (unsigned long long)DAR,
+			       (unsigned long long)DSISR));
       cia = perform_oea_interrupt(processor, cia, 0x00300, 0, 0, 0, 0);
       cpu_restart(processor, cia);
     }
@@ -238,8 +238,8 @@ instruction_storage_interrupt(cpu *processor,
 	break;
       }
       TRACE(trace_interrupts, ("instruction storage interrupt - cia=0x%lx SRR1|=0x%lx\n",
-			       (unsigned long)cia,
-			       (unsigned long)srr1_set));
+			       (unsigned long long)cia,
+			       (unsigned long long)srr1_set));
       cia = perform_oea_interrupt(processor, cia, 0x00400, 0, 0, 0, srr1_set);
       cpu_restart(processor, cia);
     }
@@ -268,9 +268,9 @@ alignment_interrupt(cpu *processor,
     DAR = (spreg)ra;
     DSISR = 0; /* FIXME */
     TRACE(trace_interrupts, ("alignment interrupt - cia=0x%lx DAR=0x%lx DSISR=0x%lx\n",
-			     (unsigned long)cia,
-			     (unsigned long)DAR,
-			     (unsigned long)DSISR));
+			     (unsigned long long)cia,
+			     (unsigned long long)DAR,
+			     (unsigned long long)DSISR));
     cia = perform_oea_interrupt(processor, cia, 0x00600, 0, 0, 0, 0);
     cpu_restart(processor, cia);
 
@@ -350,8 +350,8 @@ program_interrupt(cpu *processor,
 	break;
       }
       TRACE(trace_interrupts, ("program interrupt - cia=0x%lx SRR1|=0x%lx\n",
-			       (unsigned long)cia,
-			       (unsigned long)srr1_set));
+			       (unsigned long long)cia,
+			       (unsigned long long)srr1_set));
       cia = perform_oea_interrupt(processor, cia, 0x00700, 0, 0, 0, srr1_set);
       cpu_restart(processor, cia);
     }
@@ -376,7 +376,7 @@ floating_point_unavailable_interrupt(cpu *processor,
 
   case OPERATING_ENVIRONMENT:
     TRACE(trace_interrupts, ("floating-point unavailable interrupt - cia=0x%lx\n",
-			     (unsigned long)cia));
+			     (unsigned long long)cia));
     cia = perform_oea_interrupt(processor, cia, 0x00800, 0, 0, 0, 0);
     cpu_restart(processor, cia);
 
@@ -392,7 +392,7 @@ INLINE_INTERRUPTS\
 system_call_interrupt(cpu *processor,
 		      unsigned_word cia)
 {
-  TRACE(trace_interrupts, ("system-call interrupt - cia=0x%lx\n", (unsigned long)cia));
+  TRACE(trace_interrupts, ("system-call interrupt - cia=0x%lx\n", (unsigned long long)cia));
 
   switch (CURRENT_ENVIRONMENT) {
 
@@ -423,7 +423,7 @@ floating_point_assist_interrupt(cpu *processor,
     cpu_error(processor, cia, "floating-point assist interrupt");
 
   case OPERATING_ENVIRONMENT:
-    TRACE(trace_interrupts, ("floating-point assist interrupt - cia=0x%lx\n", (unsigned long)cia));
+    TRACE(trace_interrupts, ("floating-point assist interrupt - cia=0x%lx\n", (unsigned long long)cia));
     cia = perform_oea_interrupt(processor, cia, 0x00e00, 0, 0, 0, 0);
     cpu_restart(processor, cia);
 
@@ -460,7 +460,7 @@ deliver_hardware_interrupt(void *data)
       unsigned_word cia = cpu_get_program_counter(processor);
       unsigned_word nia = perform_oea_interrupt(processor,
 						cia, 0x00500, 0, 0, 0, 0);
-      TRACE(trace_interrupts, ("external interrupt - cia=0x%lx\n", (unsigned long)cia));
+      TRACE(trace_interrupts, ("external interrupt - cia=0x%lx\n", (unsigned long long)cia));
       cpu_set_program_counter(processor, nia);
     }
     /* decrementer interrupts have a lower priority and are once only */
@@ -469,8 +469,8 @@ deliver_hardware_interrupt(void *data)
       unsigned_word nia = perform_oea_interrupt(processor,
 						cia, 0x00900, 0, 0, 0, 0);
       TRACE(trace_interrupts, ("decrementer interrupt - cia 0x%lx, time %ld\n",
-			       (unsigned long)cia,
-			       (unsigned long)event_queue_time(psim_event_queue(cpu_system(processor)))
+			       (unsigned long long)cia,
+			       (unsigned long long)event_queue_time(psim_event_queue(cpu_system(processor)))
 			       ));
       cpu_set_program_counter(processor, nia);
       ints->pending_interrupts &= ~decrementer_interrupt_pending;
diff --git a/sim/ppc/main.c b/sim/ppc/main.c
index 667c02f..ecf20d3 100644
--- a/sim/ppc/main.c
+++ b/sim/ppc/main.c
@@ -243,7 +243,7 @@ sim_io_error (SIM_DESC sd, const char *msg, ...)
 
 
 void *
-zalloc(long size)
+zalloc(long long size)
 {
   void *memory = malloc(size);
   if (memory == NULL)
@@ -322,7 +322,7 @@ main(int argc, char **argv)
   case was_signalled:
     printf ("%s: Caught signal %d at address 0x%lx\n",
  	    name_of_file, (int)status.signal,
- 	    (long)status.program_counter);
+ 	    (long long)status.program_counter);
     return status.signal;
   default:
     error("unknown halt condition\n");
diff --git a/sim/ppc/misc.c b/sim/ppc/misc.c
index 8c21bd3..9b5d8a4 100644
--- a/sim/ppc/misc.c
+++ b/sim/ppc/misc.c
@@ -48,7 +48,7 @@ error (char *msg, ...)
 }
 
 void *
-zalloc(long size)
+zalloc(long long size)
 {
   void *memory = malloc(size);
   if (memory == NULL)
diff --git a/sim/ppc/misc.h b/sim/ppc/misc.h
index 232f2ea..459e311 100644
--- a/sim/ppc/misc.h
+++ b/sim/ppc/misc.h
@@ -60,7 +60,7 @@ do { \
 #define NZALLOC(TYPE,N) ((TYPE*) zalloc (sizeof(TYPE) * (N)))
 
 extern void *zalloc
-(long size);
+(long long size);
 
 extern void dumpf
 (int indent, char *msg, ...);
diff --git a/sim/ppc/mon.c b/sim/ppc/mon.c
index 8235b66..ffe4ec4 100644
--- a/sim/ppc/mon.c
+++ b/sim/ppc/mon.c
@@ -232,10 +232,10 @@ mon_print_info(psim *system,
   int len_sub_num[MAX_BYTE_READWRITE];
   int len;
   int i;
-  long total_insns = 0;
-  long cpu_insns_second = 0;
-  long total_sim_cycles = 0;
-  long sim_cycles_second = 0;
+  long long total_insns = 0;
+  long long cpu_insns_second = 0;
+  long long total_sim_cycles = 0;
+  long long sim_cycles_second = 0;
   double cpu_time = 0.0;
 
   for (i = 0; i < MAX_BYTE_READWRITE; i++)
@@ -279,9 +279,9 @@ mon_print_info(psim *system,
     total_sim_cycles = event_queue_time(psim_event_queue(system)) - 1;
   if (cpu_time > 0) {
     if (total_insns > 0)
-      cpu_insns_second = (long)(((double)total_insns / cpu_time) + 0.5);
+      cpu_insns_second = (long long)(((double)total_insns / cpu_time) + 0.5);
     if (total_sim_cycles) {
-      sim_cycles_second = (long)(((double)total_sim_cycles / cpu_time) + 0.5);
+      sim_cycles_second = (long long)(((double)total_sim_cycles / cpu_time) + 0.5);
     }
   }
 #endif
@@ -408,7 +408,7 @@ mon_print_info(psim *system,
 		       (monitor->cpu_monitor[cpu_nr].event_count[mon_event_icache_miss] == 1) ? "" : "es");
 
     {
-      long nr_insns = mon_get_number_of_insns(monitor, cpu_nr);
+      long long nr_insns = mon_get_number_of_insns(monitor, cpu_nr);
       if (nr_insns > 0)
 	printf_filtered("CPU #%*d executed %*s instructions in total.\n",
 			len_cpu, cpu_nr+1,
diff --git a/sim/ppc/mon.h b/sim/ppc/mon.h
index 580c93b..ea77379 100644
--- a/sim/ppc/mon.h
+++ b/sim/ppc/mon.h
@@ -26,7 +26,7 @@
 
 /* monitor/logger: counts what the simulation is up to */
 
-typedef unsigned long count_type;
+typedef unsigned long long count_type;
 
 /* Interfact to model to return model specific information */
 typedef struct _model_print model_print;
diff --git a/sim/ppc/pk_disklabel.c b/sim/ppc/pk_disklabel.c
index fb820fd..152f4ae 100644
--- a/sim/ppc/pk_disklabel.c
+++ b/sim/ppc/pk_disklabel.c
@@ -371,9 +371,9 @@ pk_disklabel_create_instance(device_instance *raw_disk,
 	label->sector_begin = 512 * sector2uw(partition_entry->sector_begin);
 	label->sector_length = 512 * sector2uw(partition_entry->sector_length);
 	PTRACE(disklabel, ("partition %ld, sector-begin %ld, length %ld\n",
-			   (long)partition,
-			   (long)label->sector_begin,
-			   (long)label->sector_length));
+			   (long long)partition,
+			   (long long)label->sector_begin,
+			   (long long)label->sector_length));
 	if (filename != NULL)
 	  device_error(device_instance_device(raw_disk),
 		       "FDISK file names not yet supported");
diff --git a/sim/ppc/psim.c b/sim/ppc/psim.c
index 3e322e3..10cb520 100644
--- a/sim/ppc/psim.c
+++ b/sim/ppc/psim.c
@@ -904,7 +904,7 @@ psim_read_register(psim *system,
 
   default:
     printf_filtered("psim_read_register(processor=0x%lx,buf=0x%lx,reg=%s) %s\n",
-		    (unsigned long)processor, (unsigned long)buf, reg,
+		    (unsigned long long)processor, (unsigned long long)buf, reg,
 		    "read of this register unimplemented");
     break;
 
@@ -1092,7 +1092,7 @@ psim_write_register(psim *system,
 
   default:
     printf_filtered("psim_write_register(processor=0x%lx,cooked_buf=0x%lx,reg=%s) %s\n",
-		    (unsigned long)processor, (unsigned long)cooked_buf, reg,
+		    (unsigned long long)processor, (unsigned long long)cooked_buf, reg,
 		    "read of this register unimplemented");
     break;
 
diff --git a/sim/ppc/registers.c b/sim/ppc/registers.c
index b672f99..b1c6d99 100644
--- a/sim/ppc/registers.c
+++ b/sim/ppc/registers.c
@@ -48,7 +48,7 @@ registers_dump(registers *registers)
   for (i = 0; i < 8; i++) {
     printf_filtered("GPR %2d:", i*4);
     for (j = 0; j < 4; j++) {
-      printf_filtered(" 0x%08lx", (long)registers->gpr[i*4 + j]);
+      printf_filtered(" 0x%08lx", (long long)registers->gpr[i*4 + j]);
     }
     printf_filtered("\n");
   }
diff --git a/sim/ppc/sim_callbacks.h b/sim/ppc/sim_callbacks.h
index 61c6e2f..86af515 100644
--- a/sim/ppc/sim_callbacks.h
+++ b/sim/ppc/sim_callbacks.h
@@ -109,7 +109,7 @@ extern psim *simulator;
 /* Memory management with an allocator that clears memory before use. */
 
 void *zalloc
-(long size);
+(long long size);
 
 #define ZALLOC(TYPE) (TYPE*)zalloc(sizeof (TYPE))
 
diff --git a/sim/ppc/sim_calls.c b/sim/ppc/sim_calls.c
index eb5d1a7..76dd8b3 100644
--- a/sim/ppc/sim_calls.c
+++ b/sim/ppc/sim_calls.c
@@ -138,7 +138,7 @@ sim_read (SIM_DESC sd, SIM_ADDR mem, unsigned char *buf, int length)
   int result = psim_read_memory(simulator, MAX_NR_PROCESSORS,
 				buf, mem, length);
   TRACE(trace_gdb, ("sim_read(mem=0x%lx, buf=0x%lx, length=%d) = %d\n",
-		    (long)mem, (long)buf, length, result));
+		    (long long)mem, (long long)buf, length, result));
   return result;
 }
 
@@ -150,7 +150,7 @@ sim_write (SIM_DESC sd, SIM_ADDR mem, const unsigned char *buf, int length)
 				 buf, mem, length,
 				 1/*violate_ro*/);
   TRACE(trace_gdb, ("sim_write(mem=0x%lx, buf=0x%lx, length=%d) = %d\n",
-		    (long)mem, (long)buf, length, result));
+		    (long long)mem, (long long)buf, length, result));
   return result;
 }
 
@@ -217,7 +217,7 @@ sim_stop_reason (SIM_DESC sd, enum sim_stop *reason, int *sigrc)
   }
 
   TRACE(trace_gdb, ("sim_stop_reason(reason=0x%lx(%ld), sigrc=0x%lx(%ld))\n",
-		    (long)reason, (long)*reason, (long)sigrc, (long)*sigrc));
+		    (long long)reason, (long long)*reason, (long long)sigrc, (long long)*sigrc));
 }
 
 
@@ -397,7 +397,7 @@ error (const char *msg, ...)
 }
 
 void *
-zalloc(long size)
+zalloc(long long size)
 {
   void *memory = (void*)xmalloc(size);
   if (memory == NULL)
diff --git a/sim/ppc/tree.c b/sim/ppc/tree.c
index 5d20bf4..355759c 100644
--- a/sim/ppc/tree.c
+++ b/sim/ppc/tree.c
@@ -404,8 +404,8 @@ tree_init(device *root,
 	  psim *system)
 {
   TRACE(trace_device_tree, ("tree_init(root=0x%lx, system=0x%lx)\n",
-			    (long)root,
-			    (long)system));
+			    (long long)root,
+			    (long long)system));
   /* remove the old, rebuild the new */
   tree_traverse(root, device_clean, NULL, system);
   tree_traverse(root, device_init_static_properties, NULL, system);
@@ -957,10 +957,10 @@ print_size(device *bus,
     if (size->cells[i] != 0)
       break;
   if (i < size->nr_cells) {
-    printf_filtered(" 0x%lx", (unsigned long)size->cells[i]);
+    printf_filtered(" 0x%lx", (unsigned long long)size->cells[i]);
     i++;
     for (; i < size->nr_cells; i++)
-      printf_filtered(",0x%lx", (unsigned long)size->cells[i]);
+      printf_filtered(",0x%lx", (unsigned long long)size->cells[i]);
   }
   else
     printf_filtered(" 0");
@@ -1057,7 +1057,7 @@ print_properties(device *me)
 	  for (cell_nr = 0;
 	       cell_nr < (property->sizeof_array / sizeof(unsigned_cell));
 	       cell_nr++) {
-	    printf_filtered(" 0x%lx", (unsigned long)BE2H_cell(w[cell_nr]));
+	    printf_filtered(" 0x%lx", (unsigned long long)BE2H_cell(w[cell_nr]));
 	  }
 	}
 	else {
@@ -1092,7 +1092,7 @@ print_properties(device *me)
       case integer_property:
 	{
 	  unsigned_word w = device_find_integer_property(me, property->name);
-	  printf_filtered(" 0x%lx", (unsigned long)w);
+	  printf_filtered(" 0x%lx", (unsigned long long)w);
 	}
 	break;
       case range_array_property:
diff --git a/sim/ppc/vm.c b/sim/ppc/vm.c
index 8cf4e8f..a67438b 100644
--- a/sim/ppc/vm.c
+++ b/sim/ppc/vm.c
@@ -309,10 +309,10 @@ om_hash_page(unsigned_word masked_vsid,
   unsigned_word hash = masked_vsid ^ masked_ea;
 #endif
   TRACE(trace_vm, ("ea=0x%lx - masked-vsid=0x%lx masked-ea=0x%lx hash=0x%lx\n",
-		   (unsigned long)ea,
-		   (unsigned long)masked_vsid,
-		   (unsigned long)masked_ea,
-		   (unsigned long)hash));
+		   (unsigned long long)ea,
+		   (unsigned long long)masked_vsid,
+		   (unsigned long long)masked_ea,
+		   (unsigned long long)hash));
   return hash;
 }
 
@@ -524,11 +524,11 @@ om_effective_to_virtual(om_map *map,
 
 #if (WITH_TARGET_WORD_BITSIZE == 32)
   TRACE(trace_vm, ("ea=0x%lx - sr[%ld] - masked-vsid=0x%lx va=0x%lx%07lx\n",
-		   (unsigned long)ea,
-		   (long)om_segment_tlb_index(ea),
-		   (unsigned long)segment_tlb_entry->masked_virtual_segment_id, 
-		   (unsigned long)EXTRACTED32(segment_tlb_entry->masked_virtual_segment_id, 31-6-24+1, 31-6),
-		   (unsigned long)EXTRACTED32(ea, 4, 31)));
+		   (unsigned long long)ea,
+		   (long long)om_segment_tlb_index(ea),
+		   (unsigned long long)segment_tlb_entry->masked_virtual_segment_id, 
+		   (unsigned long long)EXTRACTED32(segment_tlb_entry->masked_virtual_segment_id, 31-6-24+1, 31-6),
+		   (unsigned long long)EXTRACTED32(ea, 4, 31)));
   return segment_tlb_entry;
 #endif
 
@@ -610,7 +610,7 @@ om_virtual_to_real(om_map *map,
       && (page_tlb_entry->masked_page
 	  == om_ea_masked_page(ea))) {
     TRACE(trace_vm, ("ea=0x%lx - tlb hit - tlb=0x%lx\n",
-	       (long)ea, (long)page_tlb_entry));
+	       (long long)ea, (long long)page_tlb_entry));
     return page_tlb_entry;
   }
       
@@ -626,11 +626,11 @@ om_virtual_to_real(om_map *map,
       unsigned_word real_address_of_pte_0;
       TRACE(trace_vm,
 	    ("ea=0x%lx - htab search %d - htab=0x%lx hash=0x%lx mask=0x%lx pteg=0x%lx\n",
-	     (long)ea, current_hash,
+	     (long long)ea, current_hash,
 	     map->real_address_of_page_table,
 	     page_hash,
 	     map->page_table_hash_mask,
-	     (long)real_address_of_pte_group));
+	     (long long)real_address_of_pte_group));
       for (real_address_of_pte_0 = real_address_of_pte_group;
 	   real_address_of_pte_0 < (real_address_of_pte_group
 				    + sizeof_pte_group);
@@ -662,12 +662,12 @@ om_virtual_to_real(om_map *map,
 			  processor, cia);
 	    TRACE(trace_vm,
 		  ("ea=0x%lx - htab hit - set ref - tlb=0x%lx &pte1=0x%lx\n",
-		   (long)ea, (long)page_tlb_entry, (long)real_address_of_pte_1));
+		   (long long)ea, (long long)page_tlb_entry, (long long)real_address_of_pte_1));
 	  }
 	  else {
 	    TRACE(trace_vm,
 		  ("ea=0x%lx - htab hit - tlb=0x%lx &pte1=0x%lx\n",
-		   (long)ea, (long)page_tlb_entry, (long)real_address_of_pte_1));
+		   (long long)ea, (long long)page_tlb_entry, (long long)real_address_of_pte_1));
 	  }
 	  return page_tlb_entry;
 	}
@@ -720,7 +720,7 @@ om_translate_effective_to_real(om_map *map,
   if (!map->is_relocate) {
     ra = ea;
     TRACE(trace_vm, ("ea=0x%lx - direct map - ra=0x%lx\n",
-		     (long)ea, (long)ra));
+		     (long long)ea, (long long)ra));
     return ra;
   }
 
@@ -728,7 +728,7 @@ om_translate_effective_to_real(om_map *map,
   bat = om_effective_to_bat(map, ea);
   if (bat != NULL) {
     if (!om_valid_access[1][bat->protection_bits][access]) {
-      TRACE(trace_vm, ("ea=0x%lx - bat access violation\n", (long)ea));
+      TRACE(trace_vm, ("ea=0x%lx - bat access violation\n", (long long)ea));
       if (abort)
 	om_interrupt(processor, cia, ea, access,
 		     protection_violation_storage_interrupt);
@@ -738,7 +738,7 @@ om_translate_effective_to_real(om_map *map,
 
     ra = ((ea & bat->block_length_mask) | bat->block_real_page_number);
     TRACE(trace_vm, ("ea=0x%lx - bat translation - ra=0x%lx\n",
-		     (long)ea, (long)ra));
+		     (long long)ea, (long long)ra));
     return ra;
   }
 
@@ -746,7 +746,7 @@ om_translate_effective_to_real(om_map *map,
   segment_tlb_entry = om_effective_to_virtual(map, ea, processor, cia);
 #if (WITH_TARGET_WORD_BITSIZE == 64)
   if (segment_tlb_entry == NULL) {
-    TRACE(trace_vm, ("ea=0x%lx - segment tlb miss\n", (long)ea));
+    TRACE(trace_vm, ("ea=0x%lx - segment tlb miss\n", (long long)ea));
     if (abort)
       om_interrupt(processor, cia, ea, access,
 		   segment_table_miss_storage_interrupt);
@@ -756,7 +756,7 @@ om_translate_effective_to_real(om_map *map,
 #endif
   /* check for invalid segment access type */
   if (segment_tlb_entry->invalid_access == access) {
-    TRACE(trace_vm, ("ea=0x%lx - segment access invalid\n", (long)ea));
+    TRACE(trace_vm, ("ea=0x%lx - segment access invalid\n", (long long)ea));
     if (abort)
       om_interrupt(processor, cia, ea, access,
 		   protection_violation_storage_interrupt);
@@ -769,7 +769,7 @@ om_translate_effective_to_real(om_map *map,
 				      access,
 				      processor, cia);
   if (page_tlb_entry == NULL) {
-    TRACE(trace_vm, ("ea=0x%lx - page tlb miss\n", (long)ea));
+    TRACE(trace_vm, ("ea=0x%lx - page tlb miss\n", (long long)ea));
     if (abort)
       om_interrupt(processor, cia, ea, access,
 		   hash_table_miss_storage_interrupt);
@@ -780,7 +780,7 @@ om_translate_effective_to_real(om_map *map,
 	[segment_tlb_entry->key[map->is_problem_state]]
 	[page_tlb_entry->protection]
 	[access])) {
-    TRACE(trace_vm, ("ea=0x%lx - page tlb access violation\n", (long)ea));
+    TRACE(trace_vm, ("ea=0x%lx - page tlb access violation\n", (long long)ea));
     if (abort)
       om_interrupt(processor, cia, ea, access,
 		   protection_violation_storage_interrupt);
@@ -798,13 +798,13 @@ om_translate_effective_to_real(om_map *map,
 		  pte_1 | BIT(56),
 		  processor, cia);
     TRACE(trace_vm, ("ea=0x%lx - set change bit - tlb=0x%lx &pte1=0x%lx\n",
-		     (long)ea, (long)page_tlb_entry,
-		     (long)page_tlb_entry->real_address_of_pte_1));
+		     (long long)ea, (long long)page_tlb_entry,
+		     (long long)page_tlb_entry->real_address_of_pte_1));
   }
 
   ra = (page_tlb_entry->masked_real_page_number | om_ea_masked_byte(ea));
   TRACE(trace_vm, ("ea=0x%lx - page translation - ra=0x%lx\n",
-		   (long)ea, (long)ra));
+		   (long long)ea, (long long)ra));
   return ra;
 }
 
@@ -1003,7 +1003,7 @@ vm_page_tlb_invalidate_entry(vm *memory,
   int i = om_page_tlb_index(ea);
   memory->instruction_tlb.entry[i].masked_virtual_segment_id = MASK(0, 63);
   memory->data_tlb.entry[i].masked_virtual_segment_id = MASK(0, 63);
-  TRACE(trace_vm, ("ea=0x%lx - tlb invalidate entry\n", (long)ea));
+  TRACE(trace_vm, ("ea=0x%lx - tlb invalidate entry\n", (long long)ea));
 }
 
 INLINE_VM\
diff --git a/sim/ppc/vm_n.h b/sim/ppc/vm_n.h
index 563cd1c..8f40ac4 100644
--- a/sim/ppc/vm_n.h
+++ b/sim/ppc/vm_n.h
@@ -46,7 +46,7 @@ vm_data_map_read_N(vm_data_map *map,
     if (WITH_MON & MONITOR_LOAD_STORE_UNIT)
       mon_read(ea, ra, sizeof(unsigned_N), processor, cia);
     TRACE(trace_load_store, ("load cia=0x%lx ea=0x%lx N=%ld val=0x%lx\n",
-			     (long)cia, (long)ea, (long)sizeof(unsigned_N), (long)val));
+			     (long long)cia, (long long)ea, (long long)sizeof(unsigned_N), (long long)val));
     return val;
   }
   else {
@@ -60,7 +60,7 @@ vm_data_map_read_N(vm_data_map *map,
 	if (vm_data_map_read_buffer(map, &val, ea, sizeof(unsigned_N), processor, cia)
 	    != sizeof(unsigned_N)) {
 	  cpu_error(processor, cia, "misaligned %d byte read to 0x%lx failed",
-		    sizeof(unsigned_N), (unsigned long)ea);
+		    sizeof(unsigned_N), (unsigned long long)ea);
 	}
 	val = T2H_N(val);
 	if (WITH_MON & MONITOR_LOAD_STORE_UNIT) {
@@ -69,7 +69,7 @@ vm_data_map_read_N(vm_data_map *map,
 	  mon_read(ea, ra, sizeof(unsigned_N), processor, cia);
 	}
 	TRACE(trace_load_store, ("load cia=0x%lx ea=0x%lx N=%ld data=0x%lx\n",
-				 (long)cia, (long)ea, (long)sizeof(unsigned_N), (long)val));
+				 (long long)cia, (long long)ea, (long long)sizeof(unsigned_N), (long long)val));
 	return val;
       }
     default:
@@ -95,7 +95,7 @@ vm_data_map_write_N(vm_data_map *map,
     if (WITH_MON & MONITOR_LOAD_STORE_UNIT)
       mon_write(ea, ra, sizeof(unsigned_N), processor, cia);
     TRACE(trace_load_store, ("store cia=0x%lx ea=0x%lx N=%ld val=0x%lx\n",
-			     (long)cia, (long)ea, (long)sizeof(unsigned_N), (long)val));
+			     (long long)cia, (long long)ea, (long long)sizeof(unsigned_N), (long long)val));
   }
   else {
     switch (CURRENT_ALIGNMENT) {
@@ -108,7 +108,7 @@ vm_data_map_write_N(vm_data_map *map,
 	if (vm_data_map_write_buffer(map, &data, ea, sizeof(unsigned_N), 0, processor, cia)
 	    != sizeof(unsigned_N)) {
 	  cpu_error(processor, cia, "misaligned %d byte write to 0x%lx failed",
-		    sizeof(unsigned_N), (unsigned long)ea);
+		    sizeof(unsigned_N), (unsigned long long)ea);
 	}
 	if (WITH_MON & MONITOR_LOAD_STORE_UNIT) {
 	  /* YUCK */
@@ -116,7 +116,7 @@ vm_data_map_write_N(vm_data_map *map,
 	  mon_write(ea, ra, sizeof(unsigned_N), processor, cia);
 	}
 	TRACE(trace_load_store, ("store cia=0x%lx ea=0x%lx N=%ld val=0x%lx\n",
-				 (long)cia, (long)ea, (long)sizeof(unsigned_N), (long)val));
+				 (long long)cia, (long long)ea, (long long)sizeof(unsigned_N), (long long)val));
       }
       break;
     default:
diff --git a/sim/rl78/gdb-if.c b/sim/rl78/gdb-if.c
index 4ed180a..36e8939 100644
--- a/sim/rl78/gdb-if.c
+++ b/sim/rl78/gdb-if.c
@@ -285,7 +285,7 @@ reg_size (enum sim_rl78_regnum regno)
 /* Return the register address associated with the register specified by
    REGNO.  */
 
-static unsigned long
+static unsigned long long
 reg_addr (enum sim_rl78_regnum regno)
 {
   if (sim_rl78_bank0_r0_regnum <= regno
diff --git a/sim/rl78/load.c b/sim/rl78/load.c
index 563484c..f5b35ab 100644
--- a/sim/rl78/load.c
+++ b/sim/rl78/load.c
@@ -65,7 +65,7 @@ void
 rl78_load (bfd *prog, host_callback *callbacks, const char * const simname)
 {
   Elf_Internal_Phdr * phdrs;
-  long sizeof_phdrs;
+  long long sizeof_phdrs;
   int num_headers;
   int i;
   int max_rom = 0;
@@ -141,7 +141,7 @@ rl78_load (bfd *prog, host_callback *callbacks, const char * const simname)
       offset = p->p_offset;
       if (bfd_seek (prog, offset, SEEK_SET) != 0)
 	{
-	  fprintf (stderr, "%s, Failed to seek to offset %lx\n", simname, (long) offset);
+	  fprintf (stderr, "%s, Failed to seek to offset %lx\n", simname, (long long) offset);
 	  continue;
 	}
 
diff --git a/sim/rl78/mem.c b/sim/rl78/mem.c
index 9d30407..55e3209 100644
--- a/sim/rl78/mem.c
+++ b/sim/rl78/mem.c
@@ -167,11 +167,11 @@ mem_put_byte (int address, unsigned char value)
       mda_set |= (1 << (address & 3));
       if (mda_set == MDA_SET)
 	{
-	  long als, ahs;
-	  unsigned long alu, ahu;
-	  long rvs;
-	  long mdc;
-	  unsigned long rvu;
+	  long long als, ahs;
+	  unsigned long long alu, ahu;
+	  long long rvs;
+	  long long mdc;
+	  unsigned long long rvu;
 	  mda_set = 0;
 	  switch (memory [MDUC] & 0xc8)
 	    {
@@ -199,7 +199,7 @@ mem_put_byte (int address, unsigned char value)
 	      mem_put_hi (MDBH, rvu >> 16);
 	      mdc = mem_get_si (MDCL);
 	      tprintf  ("MDUC: %lu * %lu + %lu = ", alu, ahu, mdc);
-	      mdc += (long) rvu;
+	      mdc += (long long) rvu;
 	      tprintf ("%lu\n", mdc);
 	      mem_put_si (MDCL, mdc);
 	      break;
@@ -243,7 +243,7 @@ mem_get_byte (int address)
 	if ((mduc & 0x81) == 0x81
 	    && total_clocks > mduc_clock + 16)
 	  {
-	    unsigned long a, b, q, r;
+	    unsigned long long a, b, q, r;
 	    memory [MDUC] &= 0xfe;
 	    a = mem_get_si (MDAL);
 	    b = mem_get_hi (MDBL) | (mem_get_hi (MDBH) << 16);
@@ -328,7 +328,7 @@ mem_put_hi (int address, unsigned short value)
 }
 
 void
-mem_put_psi (int address, unsigned long value)
+mem_put_psi (int address, unsigned long long value)
 {
   tprintf ("\033[34m([%05X]<-%06lX)\033[0m", address, value);
   mem_put_byte (address, value);
@@ -337,7 +337,7 @@ mem_put_psi (int address, unsigned long value)
 }
 
 void
-mem_put_si (int address, unsigned long value)
+mem_put_si (int address, unsigned long long value)
 {
   tprintf ("\033[34m([%05X]<-%08lX)\033[0m", address, value);
   CHECK_ALIGNMENT (address, value, 3);
@@ -398,7 +398,7 @@ mem_get_hi (int address)
   return v;
 }
 
-unsigned long
+unsigned long long
 mem_get_psi (int address)
 {
   int v;
@@ -409,7 +409,7 @@ mem_get_psi (int address)
   return v;
 }
 
-unsigned long
+unsigned long long
 mem_get_si (int address)
 {
   int v;
diff --git a/sim/rl78/mem.h b/sim/rl78/mem.h
index 62a7c57..2189652 100644
--- a/sim/rl78/mem.h
+++ b/sim/rl78/mem.h
@@ -35,8 +35,8 @@ void mem_rom_size (int rom_bytes);
 
 void mem_put_qi (int address, unsigned char value);
 void mem_put_hi (int address, unsigned short value);
-void mem_put_psi (int address, unsigned long value);
-void mem_put_si (int address, unsigned long value);
+void mem_put_psi (int address, unsigned long long value);
+void mem_put_si (int address, unsigned long long value);
 
 void mem_put_blk (int address, const void *bufptr, int nbytes);
 
@@ -44,8 +44,8 @@ unsigned char mem_get_pc (int address);
 
 unsigned char mem_get_qi (int address);
 unsigned short mem_get_hi (int address);
-unsigned long mem_get_psi (int address);
-unsigned long mem_get_si (int address);
+unsigned long long mem_get_psi (int address);
+unsigned long long mem_get_si (int address);
 
 void mem_get_blk (int address, void *bufptr, int nbytes);
 
diff --git a/sim/rl78/rl78.c b/sim/rl78/rl78.c
index 1d03110..8f90e10 100644
--- a/sim/rl78/rl78.c
+++ b/sim/rl78/rl78.c
@@ -50,7 +50,7 @@ jmp_buf decode_jmp_buf;
   } while (0)
 
 typedef struct {
-  unsigned long dpc;
+  unsigned long long dpc;
 } RL78_Data;
 
 static int
@@ -569,7 +569,7 @@ decode_opcode (void)
 
     case RLO_divwu:
       {
-	unsigned long bcax, hlde, quot, rem;
+	unsigned long long bcax, hlde, quot, rem;
 	bcax = get_reg (RL78_Reg_AX) + 65536 * get_reg (RL78_Reg_BC);
 	hlde = get_reg (RL78_Reg_DE) + 65536 * get_reg (RL78_Reg_HL);
 
diff --git a/sim/rl78/trace.c b/sim/rl78/trace.c
index ab78c65..2543e28 100644
--- a/sim/rl78/trace.c
+++ b/sim/rl78/trace.c
@@ -51,8 +51,8 @@ sim_dis_read (bfd_vma memaddr, bfd_byte * ptr, unsigned int length,
    COUNT is the number of elements in SYMBOLS.
    Return the number of useful symbols. */
 
-static long
-remove_useless_symbols (asymbol ** symbols, long count)
+static long long
+remove_useless_symbols (asymbol ** symbols, long long count)
 {
   register asymbol **in_ptr = symbols, **out_ptr = symbols;
 
diff --git a/sim/rx/err.c b/sim/rx/err.c
index f5d7dbd..b42b647 100644
--- a/sim/rx/err.c
+++ b/sim/rx/err.c
@@ -88,7 +88,7 @@ execution_error_ignore_all (void)
 }
 
 void
-execution_error (enum execution_error num, unsigned long address)
+execution_error (enum execution_error num, unsigned long long address)
 {
   if (ee_actions[num] != SIM_ERRACTION_IGNORE)
     last_error = num;
diff --git a/sim/rx/err.h b/sim/rx/err.h
index e4b4bbb..c534da1 100644
--- a/sim/rx/err.h
+++ b/sim/rx/err.h
@@ -35,7 +35,7 @@ enum execution_error_action {
   SIM_ERRACTION_NUM_ACTIONS
 };
 
-void execution_error (enum execution_error num, unsigned long address);
+void execution_error (enum execution_error num, unsigned long long address);
 void execution_error_init_standalone (void);
 void execution_error_init_debugger (void);
 void execution_error_error_all (void);
diff --git a/sim/rx/fpu.c b/sim/rx/fpu.c
index 0e229c0..b53af00 100644
--- a/sim/rx/fpu.c
+++ b/sim/rx/fpu.c
@@ -641,7 +641,7 @@ rxfp_cmp (fp_t fa, fp_t fb)
   set_flags (FLAGBIT_Z | FLAGBIT_S | FLAGBIT_O, flags);
 }
 
-long
+long long
 rxfp_ftoi (fp_t fa, int round_mode)
 {
   FP_Parts a;
@@ -726,7 +726,7 @@ rxfp_ftoi (fp_t fa, int round_mode)
 }
 
 fp_t
-rxfp_itof (long fa, int round_mode)
+rxfp_itof (long long fa, int round_mode)
 {
   fp_t rv;
   int sign = 0;
diff --git a/sim/rx/fpu.h b/sim/rx/fpu.h
index 6ea3ef9..2a1785e 100644
--- a/sim/rx/fpu.h
+++ b/sim/rx/fpu.h
@@ -25,5 +25,5 @@ extern fp_t rxfp_sub (fp_t fa, fp_t fb);
 extern fp_t rxfp_mul (fp_t fa, fp_t fb);
 extern fp_t rxfp_div (fp_t fa, fp_t fb);
 extern void rxfp_cmp (fp_t fa, fp_t fb);
-extern long rxfp_ftoi (fp_t fa, int round_mode);
-extern fp_t rxfp_itof (long fa, int round_mode);
+extern long long rxfp_ftoi (fp_t fa, int round_mode);
+extern fp_t rxfp_itof (long long fa, int round_mode);
diff --git a/sim/rx/load.c b/sim/rx/load.c
index 71e6b6f..6943a43 100644
--- a/sim/rx/load.c
+++ b/sim/rx/load.c
@@ -84,9 +84,9 @@ find_section_name_by_offset (bfd *abfd, file_ptr filepos)
 void
 rx_load (bfd *prog, host_callback *callback)
 {
-  unsigned long highest_addr_loaded = 0;
+  unsigned long long highest_addr_loaded = 0;
   Elf_Internal_Phdr * phdrs;
-  long sizeof_phdrs;
+  long long sizeof_phdrs;
   int num_headers;
   int i;
 
@@ -147,7 +147,7 @@ rx_load (bfd *prog, host_callback *callback)
       offset = p->p_offset;
       if (bfd_seek (prog, offset, SEEK_SET) != 0)
 	{
-	  fprintf (stderr, "Failed to seek to offset %lx\n", (long) offset);
+	  fprintf (stderr, "Failed to seek to offset %lx\n", (long long) offset);
 	  continue;
 	}
       if (bfd_bread (buf, size, prog) != size)
diff --git a/sim/rx/mem.c b/sim/rx/mem.c
index 3ca0a4c..c61500a 100644
--- a/sim/rx/mem.c
+++ b/sim/rx/mem.c
@@ -74,7 +74,7 @@ init_mem (void)
 }
 
 unsigned char *
-rx_mem_ptr (unsigned long address, enum mem_ptr_action action)
+rx_mem_ptr (unsigned long long address, enum mem_ptr_action action)
 {
   int pt1 = (address >> (L2_BITS + OFF_BITS)) & ((1 << L1_BITS) - 1);
   int pt2 = (address >> OFF_BITS) & ((1 << L2_BITS) - 1);
@@ -130,7 +130,7 @@ rx_mem_ptr (unsigned long address, enum mem_ptr_action action)
 }
 
 RX_Opcode_Decoded **
-rx_mem_decode_cache (unsigned long address)
+rx_mem_decode_cache (unsigned long long address)
 {
   return (RX_Opcode_Decoded **) rx_mem_ptr (address, MPA_DECODE_CACHE);
 }
@@ -218,10 +218,10 @@ mem_usage_stats ()
     }
 }
 
-unsigned long
+unsigned long long
 mem_usage_cycles (void)
 {
-  unsigned long rv = mem_counters[0][0];
+  unsigned long long rv = mem_counters[0][0];
   rv += mem_counters[0][1] * 1;
   rv += mem_counters[0][2] * 2;
   rv += mem_counters[0][3] * 3;
@@ -392,7 +392,7 @@ mem_put_hi (int address, unsigned short value)
 }
 
 void
-mem_put_psi (int address, unsigned long value)
+mem_put_psi (int address, unsigned long long value)
 {
   S ("<=");
   if (rx_big_endian)
@@ -412,7 +412,7 @@ mem_put_psi (int address, unsigned long value)
 }
 
 void
-mem_put_si (int address, unsigned long value)
+mem_put_si (int address, unsigned long long value)
 {
   S ("<=");
   if (rx_big_endian)
@@ -520,10 +520,10 @@ mem_get_hi (int address)
   return rv;
 }
 
-unsigned long
+unsigned long long
 mem_get_psi (int address)
 {
-  unsigned long rv;
+  unsigned long long rv;
   S ("=>");
   if (rx_big_endian)
     {
@@ -542,10 +542,10 @@ mem_get_psi (int address)
   return rv;
 }
 
-unsigned long
+unsigned long long
 mem_get_si (int address)
 {
-  unsigned long rv;
+  unsigned long long rv;
   S ("=>");
   if (rx_big_endian)
     {
diff --git a/sim/rx/mem.h b/sim/rx/mem.h
index 0c2fb15..a89ade9 100644
--- a/sim/rx/mem.h
+++ b/sim/rx/mem.h
@@ -35,7 +35,7 @@ enum mem_ptr_action
 
 void init_mem (void);
 void mem_usage_stats (void);
-unsigned long mem_usage_cycles (void);
+unsigned long long mem_usage_cycles (void);
 
 /* rx_mem_ptr returns a pointer which is valid as long as the address
    requested remains within the same page.  */
@@ -43,15 +43,15 @@ unsigned long mem_usage_cycles (void);
 #define PAGE_SIZE (1 << PAGE_BITS)
 #define NONPAGE_MASK (~(PAGE_SIZE-1))
 
-unsigned char *rx_mem_ptr (unsigned long address, enum mem_ptr_action action);
+unsigned char *rx_mem_ptr (unsigned long long address, enum mem_ptr_action action);
 #ifdef RXC_never
-RX_Opcode_Decoded **rx_mem_decode_cache (unsigned long address);
+RX_Opcode_Decoded **rx_mem_decode_cache (unsigned long long address);
 #endif
 
 void mem_put_qi (int address, unsigned char value);
 void mem_put_hi (int address, unsigned short value);
-void mem_put_psi (int address, unsigned long value);
-void mem_put_si (int address, unsigned long value);
+void mem_put_psi (int address, unsigned long long value);
+void mem_put_si (int address, unsigned long long value);
 
 void mem_put_blk (int address, void *bufptr, int nbytes);
 
@@ -59,8 +59,8 @@ unsigned char mem_get_pc (int address);
 
 unsigned char mem_get_qi (int address);
 unsigned short mem_get_hi (int address);
-unsigned long mem_get_psi (int address);
-unsigned long mem_get_si (int address);
+unsigned long long mem_get_psi (int address);
+unsigned long long mem_get_si (int address);
 
 void mem_get_blk (int address, void *bufptr, int nbytes);
 
diff --git a/sim/rx/rx.c b/sim/rx/rx.c
index 02848c5..672c21c 100644
--- a/sim/rx/rx.c
+++ b/sim/rx/rx.c
@@ -203,7 +203,7 @@ static unsigned long long branch_stalls;
 static unsigned long long branch_alignment_stalls;
 static unsigned long long fast_returns;
 
-static unsigned long times_per_pair[N_RXO][N_MAP][N_RXO][N_MAP];
+static unsigned long long times_per_pair[N_RXO][N_MAP][N_RXO][N_MAP];
 static int prev_opcode_id = RXO_unknown;
 static int po0;
 
@@ -270,11 +270,11 @@ cycles (int throughput)
     }
 
 static int
-lsb_count (unsigned long v, int is_signed)
+lsb_count (unsigned long long v, int is_signed)
 {
   int i, lsb;
   if (is_signed && (v & 0x80000000U))
-    v = (unsigned long)(long)(-v);
+    v = (unsigned long long)(long long)(-v);
   for (i=31; i>=0; i--)
     if (v & (1 << i))
       {
@@ -286,7 +286,7 @@ lsb_count (unsigned long v, int is_signed)
 }
 
 static int
-divu_cycles(unsigned long num, unsigned long den)
+divu_cycles(unsigned long long num, unsigned long long den)
 {
   int nb = lsb_count (num, 0);
   int db = lsb_count (den, 0);
@@ -301,10 +301,10 @@ divu_cycles(unsigned long num, unsigned long den)
 }
 
 static int
-div_cycles(long num, long den)
+div_cycles(long long num, long long den)
 {
-  int nb = lsb_count ((unsigned long)num, 1);
-  int db = lsb_count ((unsigned long)den, 1);
+  int nb = lsb_count ((unsigned long long)num, 1);
+  int db = lsb_count ((unsigned long long)den, 1);
   int rv;
 
   if (nb < db)
@@ -335,7 +335,7 @@ static int size2bytes[] = {
 };
 
 typedef struct {
-  unsigned long dpc;
+  unsigned long long dpc;
 } RX_Data;
 
 #define rx_abort() _rx_abort(__FILE__, __LINE__)
@@ -825,7 +825,7 @@ fop_fsub (fp_t s1, fp_t s2, fp_t *d)
 #define carry (FLAG_C ? 1 : 0)
 
 static struct {
-  unsigned long vaddr;
+  unsigned long long vaddr;
   const char *str;
   int signal;
 } exception_info[] = {
@@ -846,7 +846,7 @@ static struct {
     EXCEPTION (EX_PRIVILEDGED)
 
 static int
-generate_exception (unsigned long type, SI opcode_pc)
+generate_exception (unsigned long long type, SI opcode_pc)
 {
   SI old_psw, old_pc, new_pc;
 
@@ -862,7 +862,7 @@ generate_exception (unsigned long type, SI opcode_pc)
 	return RX_MAKE_STOPPED (exception_info[type].signal);
 
       fprintf(stderr, "Unhandled %s exception at pc = %#lx\n",
-	      exception_info[type].str, (unsigned long) opcode_pc);
+	      exception_info[type].str, (unsigned long long) opcode_pc);
       if (type == EX_FLOATING)
 	{
 	  int mask = FPPENDING ();
@@ -906,7 +906,7 @@ generate_access_exception (void)
 }
 
 static int
-do_fp_exception (unsigned long opcode_pc)
+do_fp_exception (unsigned long long opcode_pc)
 {
   while (FPPENDING())
     EXCEPTION (EX_FLOATING);
@@ -938,7 +938,7 @@ decode_opcode ()
   int opcode_size, v;
   unsigned long long ll;
   long long sll;
-  unsigned long opcode_pc;
+  unsigned long long opcode_pc;
   RX_Data rx_data;
   const RX_Opcode_Decoded *opcode;
 #ifdef CYCLE_STATS
@@ -1652,9 +1652,9 @@ decode_opcode ()
 	  tmp += regs.r[6] + (sll & 0xffffffffUL);
 	  regs.r[6] = tmp & 0xffffffffUL;
 	  tprintf("%08lx\033[36m%08lx\033[0m%08lx\n",
-		  (unsigned long) regs.r[6],
-		  (unsigned long) regs.r[5],
-		  (unsigned long) regs.r[4]);
+		  (unsigned long long) regs.r[6],
+		  (unsigned long long) regs.r[5],
+		  (unsigned long long) regs.r[4]);
 
 	  regs.r[3] --;
 	}
diff --git a/sim/rx/trace.c b/sim/rx/trace.c
index ee0e15b..a1ec08e 100644
--- a/sim/rx/trace.c
+++ b/sim/rx/trace.c
@@ -56,8 +56,8 @@ sim_dis_read (bfd_vma memaddr, bfd_byte * ptr, unsigned int length,
    COUNT is the number of elements in SYMBOLS.
    Return the number of useful symbols. */
 
-static long
-remove_useless_symbols (asymbol ** symbols, long count)
+static long long
+remove_useless_symbols (asymbol ** symbols, long long count)
 {
   register asymbol **in_ptr = symbols, **out_ptr = symbols;
 
diff --git a/sim/sh/interp.c b/sim/sh/interp.c
index c77cf3b..11c6920 100644
--- a/sim/sh/interp.c
+++ b/sim/sh/interp.c
@@ -582,7 +582,7 @@ rbat_fast (unsigned char *memory, int x, int maskb)
 
 #define RUWAT(x)  (RWAT (x) & 0xffff)
 #define RSWAT(x)  ((short) (RWAT (x)))
-#define RSLAT(x)  ((long) (RLAT (x)))
+#define RSLAT(x)  ((long long) (RLAT (x)))
 #define RSBAT(x)  (SEXT (RBAT (x)))
 
 #define RDAT(x, n) (do_rdat (memory, (x), (n), (maskl)))
@@ -711,7 +711,7 @@ do { \
 #else
 
 #define MA(n) \
-  do { memstalls += ((((long) PC & 3) != 0) ? (n) : ((n) - 1)); } while (0)
+  do { memstalls += ((((long long) PC & 3) != 0) ? (n) : ((n) - 1)); } while (0)
 
 #define L(x)   thislock = x;
 #define TL(x)  if ((x) == prevlock) stalls++;
@@ -771,7 +771,7 @@ IOMEM (int addr, int write, int value)
 static int
 get_now (void)
 {
-  return time ((long *) 0);
+  return time ((long long *) 0);
 }
 
 static int
@@ -1102,13 +1102,13 @@ trap (SIM_DESC sd, int i, int *regs, unsigned char *insn_ptr,
 static void
 div1 (int *R, int iRn2, int iRn1/*, int T*/)
 {
-  unsigned long tmp0;
+  unsigned long long tmp0;
   unsigned char old_q, tmp1;
 
   old_q = Q;
   SET_SR_Q ((unsigned char) ((0x80000000 & R[iRn1]) != 0));
   R[iRn1] <<= 1;
-  R[iRn1] |= (unsigned long) T;
+  R[iRn1] |= (unsigned long long) T;
 
   switch (old_q)
     {
@@ -1203,14 +1203,14 @@ dmul_u (uint32_t rm, uint32_t rn)
 static void
 macw (int *regs, unsigned char *memory, int n, int m, int endianw)
 {
-  long tempm, tempn;
-  long prod, macl, sum;
+  long long tempm, tempn;
+  long long prod, macl, sum;
 
   tempm=RSWAT (regs[m]); regs[m]+=2;
   tempn=RSWAT (regs[n]); regs[n]+=2;
 
   macl = MACL;
-  prod = (long) (short) tempm * (long) (short) tempn;
+  prod = (long long) (short) tempm * (long long) (short) tempn;
   sum = prod + macl;
   if (S)
     {
@@ -1225,9 +1225,9 @@ macw (int *regs, unsigned char *memory, int n, int m, int endianw)
     }
   else
     {
-      long mach;
+      long long mach;
       /* Add to MACH the sign extended product, and carry from low sum.  */
-      mach = MACH + (-(prod < 0)) + ((unsigned long) sum < prod);
+      mach = MACH + (-(prod < 0)) + ((unsigned long long) sum < prod);
       /* Sign extend at 10:th bit in MACH.  */
       MACH = (mach & 0x1ff) | -(mach & 0x200);
     }
@@ -1237,8 +1237,8 @@ macw (int *regs, unsigned char *memory, int n, int m, int endianw)
 static void
 macl (int *regs, unsigned char *memory, int n, int m)
 {
-  long tempm, tempn;
-  long macl, mach;
+  long long tempm, tempn;
+  long long macl, mach;
   long long ans;
   long long mac64;
 
@@ -1258,8 +1258,8 @@ macl (int *regs, unsigned char *memory, int n, int m)
 
   mac64 += ans; /* Accumulate 64bit + 64 bit */
 
-  macl = (long) (mac64 & 0xffffffff);
-  mach = (long) ((mac64 >> 32) & 0xffffffff);
+  macl = (long long) (mac64 & 0xffffffff);
+  mach = (long long) ((mac64 >> 32) & 0xffffffff);
 
   if (S)  /* Store only 48 bits of the result */
     {
@@ -1578,7 +1578,7 @@ static void
 init_dsp (struct bfd *abfd)
 {
   int was_dsp = target_dsp;
-  unsigned long mach = bfd_get_mach (abfd);
+  unsigned long long mach = bfd_get_mach (abfd);
 
   if (mach == bfd_mach_sh_dsp  || 
       mach == bfd_mach_sh4al_dsp ||
diff --git a/sim/sh/sim-main.h b/sim/sh/sim-main.h
index 832e076..e92242a 100644
--- a/sim/sh/sim-main.h
+++ b/sim/sh/sim-main.h
@@ -117,7 +117,7 @@ typedef union
     unsigned char *ymem;
     unsigned char *xmem_offset;
     unsigned char *ymem_offset;
-    unsigned long bfd_mach;
+    unsigned long long bfd_mach;
     regstacktype *regstack;
   } asregs;
   int asints[40];
diff --git a/sim/sh64/sh-opc.h b/sim/sh64/sh-opc.h
index a714621..d609ab4 100644
--- a/sim/sh64/sh-opc.h
+++ b/sim/sh64/sh-opc.h
@@ -139,62 +139,62 @@ typedef enum cgen_insn_type {
 struct cgen_fields
 {
   int length;
-  long f_nil;
-  long f_anyof;
-  long f_op4;
-  long f_op8;
-  long f_op16;
-  long f_sub4;
-  long f_sub8;
-  long f_sub10;
-  long f_rn;
-  long f_rm;
-  long f_7_1;
-  long f_11_1;
-  long f_16_4;
-  long f_disp8;
-  long f_disp12;
-  long f_imm8;
-  long f_imm4;
-  long f_imm4x2;
-  long f_imm4x4;
-  long f_imm8x2;
-  long f_imm8x4;
-  long f_imm12x4;
-  long f_imm12x8;
-  long f_dn;
-  long f_dm;
-  long f_vn;
-  long f_vm;
-  long f_xn;
-  long f_xm;
-  long f_imm20_hi;
-  long f_imm20_lo;
-  long f_imm20;
-  long f_op;
-  long f_ext;
-  long f_rsvd;
-  long f_left;
-  long f_right;
-  long f_dest;
-  long f_left_right;
-  long f_tra;
-  long f_trb;
-  long f_likely;
-  long f_6_3;
-  long f_23_2;
-  long f_imm6;
-  long f_imm10;
-  long f_imm16;
-  long f_uimm6;
-  long f_uimm16;
-  long f_disp6;
-  long f_disp6x32;
-  long f_disp10;
-  long f_disp10x8;
-  long f_disp10x4;
-  long f_disp10x2;
-  long f_disp16;
+  long long f_nil;
+  long long f_anyof;
+  long long f_op4;
+  long long f_op8;
+  long long f_op16;
+  long long f_sub4;
+  long long f_sub8;
+  long long f_sub10;
+  long long f_rn;
+  long long f_rm;
+  long long f_7_1;
+  long long f_11_1;
+  long long f_16_4;
+  long long f_disp8;
+  long long f_disp12;
+  long long f_imm8;
+  long long f_imm4;
+  long long f_imm4x2;
+  long long f_imm4x4;
+  long long f_imm8x2;
+  long long f_imm8x4;
+  long long f_imm12x4;
+  long long f_imm12x8;
+  long long f_dn;
+  long long f_dm;
+  long long f_vn;
+  long long f_vm;
+  long long f_xn;
+  long long f_xm;
+  long long f_imm20_hi;
+  long long f_imm20_lo;
+  long long f_imm20;
+  long long f_op;
+  long long f_ext;
+  long long f_rsvd;
+  long long f_left;
+  long long f_right;
+  long long f_dest;
+  long long f_left_right;
+  long long f_tra;
+  long long f_trb;
+  long long f_likely;
+  long long f_6_3;
+  long long f_23_2;
+  long long f_imm6;
+  long long f_imm10;
+  long long f_imm16;
+  long long f_uimm6;
+  long long f_uimm16;
+  long long f_disp6;
+  long long f_disp6x32;
+  long long f_disp10;
+  long long f_disp10x8;
+  long long f_disp10x4;
+  long long f_disp10x2;
+  long long f_disp16;
 };
 
 #define CGEN_INIT_PARSE(od) \
diff --git a/sim/sh64/sh64.c b/sim/sh64/sh64.c
index bd1e2e2..a8dec92 100644
--- a/sim/sh64/sh64.c
+++ b/sim/sh64/sh64.c
@@ -207,7 +207,7 @@ sh64_fcnvds(SIM_CPU *current_cpu, DF drgh)
   } f1;
 
   union {
-    unsigned long l;
+    unsigned long long l;
     float f;
   } f2;
 
diff --git a/sim/testsuite/common/alu-tst.c b/sim/testsuite/common/alu-tst.c
index e7fffe5..1781614 100644
--- a/sim/testsuite/common/alu-tst.c
+++ b/sim/testsuite/common/alu-tst.c
@@ -53,18 +53,18 @@ print_hex (unsigned64 val, int nr_bits)
   switch (nr_bits)
     {
     case 8:
-      printf ("0x%02lx", (long) (unsigned8) (val));
+      printf ("0x%02lx", (long long) (unsigned8) (val));
       break;
     case 16:
-      printf ("0x%04lx", (long) (unsigned16) (val));
+      printf ("0x%04lx", (long long) (unsigned16) (val));
       break;
     case 32:
-      printf ("0x%08lx", (long) (unsigned32) (val));
+      printf ("0x%08lx", (long long) (unsigned32) (val));
       break;
     case 64:
       printf ("0x%08lx%08lx",
-	      (long) (unsigned32) (val >> 32),
-	      (long) (unsigned32) (val));
+	      (long long) (unsigned32) (val >> 32),
+	      (long long) (unsigned32) (val));
       break;
     default:
       abort ();
diff --git a/sim/testsuite/common/bits-gen.c b/sim/testsuite/common/bits-gen.c
index 5394038..08974b1 100644
--- a/sim/testsuite/common/bits-gen.c
+++ b/sim/testsuite/common/bits-gen.c
@@ -68,7 +68,7 @@ gen_bit (int bitsize,
       printf ("%d, %2d, ", -1, i);
       printf ("%s (%2d), ", macro, i);
       printf ("UNSIGNED64 (0x%08lx%08lx), ",
-	      (long) (bit >> 32), (long) bit);
+	      (long long) (bit >> 32), (long long) bit);
       printf ("},\n");
     }
   printf ("};\n");
@@ -141,11 +141,11 @@ gen_mask (int bitsize,
 		  mask |= bit;
 		}
 	      if (bitsize == 32)
-		mask = (unsigned long) mask;
+		mask = (unsigned long long) mask;
 	      printf ("%d, %d, ", l, h);
 	      printf ("%s%s (%2d, %2d), ", msb, macro, l, h);
 	      printf ("UNSIGNED64 (0x%08lx%08lx), ",
-		      (long) (mask >> 32), (long) mask);
+		      (long long) (mask >> 32), (long long) mask);
 	    }
 	  else
 	    printf ("-1, -1, ");
diff --git a/sim/testsuite/common/bits-tst.c b/sim/testsuite/common/bits-tst.c
index 5a4210a..94a247e 100644
--- a/sim/testsuite/common/bits-tst.c
+++ b/sim/testsuite/common/bits-tst.c
@@ -154,7 +154,7 @@ calc (const char *call,
     {
       fprintf (stderr,
 	       "Unknown call passed to calc (%s, 0x%08lx%08lx, %d, %d)\n",
-	       call, (long)(val >> 32), (long)val, row, col);
+	       call, (long long)(val >> 32), (long long)val, row, col);
       abort ();
       return val;
     }
@@ -186,9 +186,9 @@ check_sext (int nr_bits,
 		   "%s:%d: ", __FILE__, __LINE__);
 	  fprintf (stderr,
 		   " %s(0x%08lx%08lx,%d) == 0x%08lx%08lx wrong, != 0x%08lx%08lx\n",
-		   sexted, (long)(mask_0 >> 32), (long)mask_0, col,
-		   (long)(sext_0 >> 32), (long)sext_0,
-		   (long)(mask_1 >> 32), (long)mask_1);
+		   sexted, (long long)(mask_0 >> 32), (long long)mask_0, col,
+		   (long long)(sext_0 >> 32), (long long)sext_0,
+		   (long long)(mask_1 >> 32), (long long)mask_1);
 	  errors ++;
 	}
       if (sext_1 != mask_1)
@@ -197,9 +197,9 @@ check_sext (int nr_bits,
 		   "%s:%d: ", __FILE__, __LINE__);
 	  fprintf (stderr,
 		   " %s(0x%08lx%08lx,%d) == 0x%08lx%08lx wrong, != 0x%08lx%08lx\n",
-		   sexted, (long)(mask_1 >> 32), (long)mask_1, col,
-		   (long)(sext_1 >> 32), (long)sext_1,
-		   (long)(mask_1 >> 32), (long)mask_1);
+		   sexted, (long long)(mask_1 >> 32), (long long)mask_1, col,
+		   (long long)(sext_1 >> 32), (long long)sext_1,
+		   (long long)(mask_1 >> 32), (long long)mask_1);
 	  errors ++;
 	}
       if (sext != msmask)
@@ -208,9 +208,9 @@ check_sext (int nr_bits,
 		   "%s:%d: ", __FILE__, __LINE__);
 	  fprintf (stderr,
 		   " %s(0x%08lx%08lx,%d) == 0x%08lx%08lx wrong, != 0x%08lx%08lx (%s(%d,%d))\n",
-		   sexted, (long)(mask >> 32), (long)mask, col,
-		   (long)(sext >> 32), (long)sext,
-		   (long)(msmask >> 32), (long)msmask,
+		   sexted, (long long)(mask >> 32), (long long)mask, col,
+		   (long long)(sext >> 32), (long long)sext,
+		   (long long)(msmask >> 32), (long long)msmask,
 		   msmasked, 0, (msb_nr ? nr_bits - col - 1 : col));
 	  errors ++;
 	}
@@ -246,8 +246,8 @@ check_rot (int nr_bits,
 		  fprintf (stderr, "%s:%d: ", __FILE__, __LINE__);
 		  fprintf (stderr, " %s(%s(0x%08lx%08lx,%d) == 0x%08lx%08lx, %d) failed\n",
 			   roted, roted,
-			   (long)(mask >> 32), (long)mask, shift,
-			   (long)(urot >> 32), (long)urot, -shift);
+			   (long long)(mask >> 32), (long long)mask, shift,
+			   (long long)(urot >> 32), (long long)urot, -shift);
 		  errors ++;
 		}
 	    }
@@ -277,9 +277,9 @@ check_extract (int nr_bits,
 	    {
 	      fprintf (stderr, "%s:%d: ", __FILE__, __LINE__);
 	      fprintf (stderr, " %s(%d,%d)=0x%08lx%08lx -> %s=0x%08lx%08lx -> %s=0x%08lx%08lx failed\n",
-		       masked, row, col, (long)(mask >> 32), (long)mask,
-		       extracted, (long)(extr >> 32), (long)extr,
-		       inserted, (long)(inst >> 32), (long)inst);
+		       masked, row, col, (long long)(mask >> 32), (long long)mask,
+		       extracted, (long long)(extr >> 32), (long long)extr,
+		       inserted, (long long)(inst >> 32), (long long)inst);
 	      errors ++;
 	    }
 	}
@@ -318,8 +318,8 @@ check_bits (int call,
 		    else
 		      fprintf (stderr, " (%d)", tuple->col);
 		    fprintf (stderr, " == 0x%08lx%08lx wrong, != 0x%08lx%08lx\n",
-			     (long) (val >> 32), (long) val,
-			     (long) (check >> 32), (long) check);
+			     (long long) (val >> 32), (long long) val,
+			     (long long) (check >> 32), (long long) check);
 		    errors ++;
 		  }
 	      }
diff --git a/sim/testsuite/sim/bfin/test.h b/sim/testsuite/sim/bfin/test.h
index 38788f8..e4981b8 100644
--- a/sim/testsuite/sim/bfin/test.h
+++ b/sim/testsuite/sim/bfin/test.h
@@ -1,6 +1,6 @@
 #ifndef __ASSEMBLER__
-typedef unsigned long bu32;
-typedef long bs32;
+typedef unsigned long long bu32;
+typedef long long bs32;
 typedef unsigned short bu16;
 typedef short bs16;
 typedef unsigned char bu8;
diff --git a/sim/testsuite/sim/cris/c/clone1.c b/sim/testsuite/sim/cris/c/clone1.c
index 163b186..538596e 100644
--- a/sim/testsuite/sim/cris/c/clone1.c
+++ b/sim/testsuite/sim/cris/c/clone1.c
@@ -33,7 +33,7 @@ main (void)
   int retcode;
   int pid;
   int st;
-  long stack[16384];
+  long long stack[16384];
   char buf[10] = {0};
 
   retcode = pipe (pip);
diff --git a/sim/testsuite/sim/cris/c/clone3.c b/sim/testsuite/sim/cris/c/clone3.c
index 0a97484..8fd3f10 100644
--- a/sim/testsuite/sim/cris/c/clone3.c
+++ b/sim/testsuite/sim/cris/c/clone3.c
@@ -30,7 +30,7 @@ int
 main (void)
 {
   int pid;
-  long stack[16384];
+  long long stack[16384];
 
   pid = clone (process, (char *) stack + sizeof (stack) - 64,
 	       (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND)
diff --git a/sim/testsuite/sim/cris/c/clone5.c b/sim/testsuite/sim/cris/c/clone5.c
index 9380a1e..a963b07 100644
--- a/sim/testsuite/sim/cris/c/clone5.c
+++ b/sim/testsuite/sim/cris/c/clone5.c
@@ -25,7 +25,7 @@ int
 main (void)
 {
   int retcode;
-  long stack[16384];
+  long long stack[16384];
 
   retcode = clone (process, (char *) stack + sizeof (stack) - 64, 0, "cba");
   if (retcode == -1 && errno == ENOSYS)
diff --git a/sim/testsuite/sim/cris/c/pipe2.c b/sim/testsuite/sim/cris/c/pipe2.c
index 18ccf38..1ba6dbd 100644
--- a/sim/testsuite/sim/cris/c/pipe2.c
+++ b/sim/testsuite/sim/cris/c/pipe2.c
@@ -62,7 +62,7 @@ main (void)
   int retcode;
   int pid;
   int st = 0;
-  long stack[16384];
+  long long stack[16384];
   char buf[1];
 
   /* We need to turn this off because we don't want (to have to model) a
diff --git a/sim/testsuite/sim/cris/c/pipe6.c b/sim/testsuite/sim/cris/c/pipe6.c
index a8830cc..bc021a2 100644
--- a/sim/testsuite/sim/cris/c/pipe6.c
+++ b/sim/testsuite/sim/cris/c/pipe6.c
@@ -48,7 +48,7 @@ main (void)
   int retcode;
   int pid;
   int st = 0;
-  long stack[16384];
+  long long stack[16384];
   char buf[1];
 
   retcode = pipe (pip);
diff --git a/sim/testsuite/sim/cris/c/sysctl1.c b/sim/testsuite/sim/cris/c/sysctl1.c
index 6646fac..cc44301 100644
--- a/sim/testsuite/sim/cris/c/sysctl1.c
+++ b/sim/testsuite/sim/cris/c/sysctl1.c
@@ -21,7 +21,7 @@ int main (void)
     size_t *oldlenp;
     void *newval;
     size_t newlen;
-    unsigned long __unused[4];
+    unsigned long long __unused[4];
   } scargs
       =
     {
diff --git a/sim/testsuite/sim/cris/c/sysctl2.c b/sim/testsuite/sim/cris/c/sysctl2.c
index f27c37c..f17d772 100644
--- a/sim/testsuite/sim/cris/c/sysctl2.c
+++ b/sim/testsuite/sim/cris/c/sysctl2.c
@@ -24,7 +24,7 @@ int main (void)
     size_t *oldlenp;
     void *newval;
     size_t newlen;
-    unsigned long __unused[4];
+    unsigned long long __unused[4];
   } scargs
       =
    {
diff --git a/sim/v850/sim-main.h b/sim/v850/sim-main.h
index e7276a6..43910a9 100644
--- a/sim/v850/sim-main.h
+++ b/sim/v850/sim-main.h
@@ -650,15 +650,15 @@ do { \
 #define GPR_CLEAR(N)    (State.regs[(N)] = 0)
 
 extern void divun ( unsigned int       N,
-		    unsigned long int  als,
-		    unsigned long int  sfi,
+		    unsigned long long int  als,
+		    unsigned long long int  sfi,
 		    unsigned32 /*unsigned long int*/ *  quotient_ptr,
 		    unsigned32 /*unsigned long int*/ *  remainder_ptr,
 		    int *overflow_ptr
 		    );
 extern void divn ( unsigned int       N,
-		   unsigned long int  als,
-		   unsigned long int  sfi,
+		   unsigned long long int  als,
+		   unsigned long long int  sfi,
 		   signed32 /*signed long int*/ *  quotient_ptr,
 		   signed32 /*signed long int*/ *  remainder_ptr,
 		   int *overflow_ptr
diff --git a/sim/v850/simops.c b/sim/v850/simops.c
index 40d578e..bd0a774 100644
--- a/sim/v850/simops.c
+++ b/sim/v850/simops.c
@@ -210,7 +210,7 @@ trace_result (int has_result, unsigned32 result)
     for (i = 0; i < trace_num_values; i++)
       {
 	sprintf (chp, "%*s0x%.8lx", SIZE_VALUES - 10, "",
-		 (long) trace_values[i]);
+		 (long long) trace_values[i]);
 	chp = strchr (chp, '\0');
       }
     while (i++ < 3)
@@ -222,7 +222,7 @@ trace_result (int has_result, unsigned32 result)
 
   /* append any result to the end of the buffer */
   if (has_result)
-    sprintf (chp, " :: 0x%.8lx", (unsigned long) result);
+    sprintf (chp, " :: 0x%.8lx", (unsigned long long) result);
   
   trace_generic (simulator, STATE_CPU (simulator, 0), trace_module, "%s", buf);
 }
@@ -315,10 +315,10 @@ condition_met (unsigned code)
   return 1;
 }
 
-unsigned long
-Add32 (unsigned long a1, unsigned long a2, int * carry)
+unsigned long long
+Add32 (unsigned long long a1, unsigned long long a2, int * carry)
 {
-  unsigned long result = (a1 + a2);
+  unsigned long long result = (a1 + a2);
 
   * carry = (result < a1);
 
@@ -326,15 +326,15 @@ Add32 (unsigned long a1, unsigned long a2, int * carry)
 }
 
 static void
-Multiply64 (int sign, unsigned long op0)
-{
-  unsigned long op1;
-  unsigned long lo;
-  unsigned long mid1;
-  unsigned long mid2;
-  unsigned long hi;
-  unsigned long RdLo;
-  unsigned long RdHi;
+Multiply64 (int sign, unsigned long long op0)
+{
+  unsigned long long op1;
+  unsigned long long lo;
+  unsigned long long mid1;
+  unsigned long long mid2;
+  unsigned long long hi;
+  unsigned long long RdLo;
+  unsigned long long RdHi;
   int           carry;
   
   op1 = State.regs[ OP[1] ];
@@ -345,10 +345,10 @@ Multiply64 (int sign, unsigned long op0)
 	  
       sign = (op0 ^ op1) & 0x80000000;
 	  
-      if (((signed long) op0) < 0)
+      if (((signed long long) op0) < 0)
 	op0 = - op0;
 	  
-      if (((signed long) op1) < 0)
+      if (((signed long long) op1) < 0)
 	op1 = - op1;
     }
       
@@ -2065,22 +2065,22 @@ void
 divun
 (
   unsigned int       N,
-  unsigned long int  als,
-  unsigned long int  sfi,
+  unsigned long long int  als,
+  unsigned long long int  sfi,
   unsigned32 /*unsigned long int*/ *  quotient_ptr,
   unsigned32 /*unsigned long int*/ *  remainder_ptr,
   int *          overflow_ptr
 )
 {
-  unsigned long   ald = sfi >> (N - 1);
-  unsigned long   alo = als;
+  unsigned long long   ald = sfi >> (N - 1);
+  unsigned long long   alo = als;
   unsigned int    Q   = 1;
   unsigned int    C;
   unsigned int    S   = 0;
   unsigned int    i;
   unsigned int    R1  = 1;
   unsigned int    DBZ = (als == 0) ? 1 : 0;
-  unsigned long   alt = Q ? ~als : als;
+  unsigned long long   alt = Q ? ~als : als;
 
   /* 1st Loop */
   alo = ald + alt + Q;
@@ -2139,15 +2139,15 @@ void
 divn
 (
   unsigned int       N,
-  unsigned long int  als,
-  unsigned long int  sfi,
+  unsigned long long int  als,
+  unsigned long long int  sfi,
   signed32 /*signed long int*/ *  quotient_ptr,
   signed32 /*signed long int*/ *  remainder_ptr,
   int *          overflow_ptr
 )
 {
-  unsigned long	  ald = (signed long) sfi >> (N - 1);
-  unsigned long   alo = als;
+  unsigned long long	  ald = (signed long long) sfi >> (N - 1);
+  unsigned long long   alo = als;
   unsigned int    SS  = als >> 31;
   unsigned int	  SD  = sfi >> 31;
   unsigned int    R1  = 1;
@@ -2157,7 +2157,7 @@ divn
   unsigned int    C;
   unsigned int    S;
   unsigned int    i;
-  unsigned long   alt = Q ? ~als : als;
+  unsigned long long   alt = Q ? ~als : als;
 
 
   /* 1st Loop */
@@ -2213,7 +2213,7 @@ divn
   R1  = R1 & ((~alo >> 31) ^ SD);
   if ((alo != 0) && ((Q ^ (SS ^ SD)) ^ R1)) alo = ald;
   if (N != 32)
-    ald = sfi = (long) ((sfi >> 1) | (SS ^ SD) << 31) >> (32-N-1) | Q;
+    ald = sfi = (long long) ((sfi >> 1) | (SS ^ SD) << 31) >> (32-N-1) | Q;
   else
     ald = sfi = sfi | Q;
   
@@ -2240,8 +2240,8 @@ OP_1C207E0 (void)
 {
   unsigned32 /*unsigned long int*/  quotient;
   unsigned32 /*unsigned long int*/  remainder;
-  unsigned long int  divide_by;
-  unsigned long int  divide_this;
+  unsigned long long int  divide_by;
+  unsigned long long int  divide_this;
   int            overflow = 0;
   unsigned int       imm5;
       
@@ -2275,8 +2275,8 @@ OP_1C007E0 (void)
 {
   signed32 /*signed long int*/  quotient;
   signed32 /*signed long int*/  remainder;
-  signed long int  divide_by;
-  signed long int  divide_this;
+  signed long long int  divide_by;
+  signed long long int  divide_this;
   int          overflow = 0;
   unsigned int     imm5;
       
@@ -2310,8 +2310,8 @@ OP_18207E0 (void)
 {
   unsigned32 /*unsigned long int*/  quotient;
   unsigned32 /*unsigned long int*/  remainder;
-  unsigned long int  divide_by;
-  unsigned long int  divide_this;
+  unsigned long long int  divide_by;
+  unsigned long long int  divide_this;
   int            overflow = 0;
   unsigned int       imm5;
       
@@ -2345,8 +2345,8 @@ OP_18007E0 (void)
 {
   signed32 /*signed long int*/  quotient;
   signed32 /*signed long int*/  remainder;
-  signed long int  divide_by;
-  signed long int  divide_this;
+  signed long long int  divide_by;
+  signed long long int  divide_this;
   int          overflow = 0;
   unsigned int     imm5;
       
@@ -2378,10 +2378,10 @@ OP_18007E0 (void)
 int
 OP_2C207E0 (void)
 {
-  unsigned long int quotient;
-  unsigned long int remainder;
-  unsigned long int divide_by;
-  unsigned long int divide_this;
+  unsigned long long int quotient;
+  unsigned long long int remainder;
+  unsigned long long int divide_by;
+  unsigned long long int divide_this;
   int           overflow = 0;
   
   trace_input ("divu", OP_REG_REG_REG, 0);
@@ -2417,10 +2417,10 @@ OP_2C207E0 (void)
 int
 OP_2C007E0 (void)
 {
-  signed long int quotient;
-  signed long int remainder;
-  signed long int divide_by;
-  signed long int divide_this;
+  signed long long int quotient;
+  signed long long int remainder;
+  signed long long int divide_by;
+  signed long long int divide_this;
   
   trace_input ("div", OP_REG_REG_REG, 0);
   
@@ -2462,10 +2462,10 @@ OP_2C007E0 (void)
 int
 OP_28207E0 (void)
 {
-  unsigned long int quotient;
-  unsigned long int remainder;
-  unsigned long int divide_by;
-  unsigned long int divide_this;
+  unsigned long long int quotient;
+  unsigned long long int remainder;
+  unsigned long long int divide_by;
+  unsigned long long int divide_this;
   int           overflow = 0;
   
   trace_input ("divhu", OP_REG_REG_REG, 0);
@@ -2501,10 +2501,10 @@ OP_28207E0 (void)
 int
 OP_28007E0 (void)
 {
-  signed long int quotient;
-  signed long int remainder;
-  signed long int divide_by;
-  signed long int divide_this;
+  signed long long int quotient;
+  signed long long int remainder;
+  signed long long int divide_by;
+  signed long long int divide_this;
   int         overflow = 0;
   
   trace_input ("divh", OP_REG_REG_REG, 0);
@@ -3178,10 +3178,10 @@ v850_float_compare (SIM_DESC sd, int cmp, sim_fpu wop1, sim_fpu wop2, int double
 void
 v850_div (SIM_DESC sd, unsigned int op0, unsigned int op1, unsigned int *op2p, unsigned int *op3p)
 {
-  signed long int quotient;
-  signed long int remainder;
-  signed long int divide_by;
-  signed long int divide_this;
+  signed long long int quotient;
+  signed long long int remainder;
+  signed long long int divide_by;
+  signed long long int divide_this;
   bfd_boolean     overflow = FALSE;
   
   /* Compute the result.  */
@@ -3211,10 +3211,10 @@ v850_div (SIM_DESC sd, unsigned int op0, unsigned int op1, unsigned int *op2p, u
 void
 v850_divu (SIM_DESC sd, unsigned int op0, unsigned int op1, unsigned int *op2p, unsigned int *op3p)
 {
-  unsigned long int quotient;
-  unsigned long int remainder;
-  unsigned long int divide_by;
-  unsigned long int divide_this;
+  unsigned long long int quotient;
+  unsigned long long int remainder;
+  unsigned long long int divide_by;
+  unsigned long long int divide_this;
   bfd_boolean       overflow = FALSE;
   
   /* Compute the result.  */
diff --git a/sim/v850/simops.h b/sim/v850/simops.h
index 1b6b407..00ebceb 100644
--- a/sim/v850/simops.h
+++ b/sim/v850/simops.h
@@ -82,7 +82,7 @@ int v850_float_compare(SIM_DESC sd, int cmp, sim_fpu wop1, sim_fpu wop2, int dou
 unsigned32 load_data_mem(SIM_DESC sd, SIM_ADDR addr, int len);
 void store_data_mem(SIM_DESC sd, SIM_ADDR addr, int len, unsigned32 data);
 
-unsigned long Add32 (unsigned long a1, unsigned long a2, int * carry);
+unsigned long long Add32 (unsigned long long a1, unsigned long long a2, int * carry);
 
 /* FPU */
 
diff --git a/sim/v850/v850_sim.h b/sim/v850/v850_sim.h
index b1dddfd..a7f19ff 100644
--- a/sim/v850/v850_sim.h
+++ b/sim/v850/v850_sim.h
@@ -1,7 +1,7 @@
 struct simops 
 {
-  unsigned long   opcode;
-  unsigned long   mask;
+  unsigned long long   opcode;
+  unsigned long long   mask;
   int (* func) (void);
   int    numops;
   int    operands[12];
diff --git a/zlib/adler32.c b/zlib/adler32.c
index b3d35e2..3688d30 100644
--- a/zlib/adler32.c
+++ b/zlib/adler32.c
@@ -26,7 +26,7 @@ local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));
    (thank you to John Reiser for pointing this out) */
 #  define CHOP(a) \
     do { \
-        unsigned long tmp = a >> 16; \
+        unsigned long long tmp = a >> 16; \
         a &= 0xffffUL; \
         a += (tmp << 4) - tmp; \
     } while (0)
@@ -65,7 +65,7 @@ uLong ZEXPORT adler32_z(adler, buf, len)
     const Bytef *buf;
     z_size_t len;
 {
-    unsigned long sum2;
+    unsigned long long sum2;
     unsigned n;
 
     /* split Adler-32 into component sums */
@@ -145,8 +145,8 @@ local uLong adler32_combine_(adler1, adler2, len2)
     uLong adler2;
     z_off64_t len2;
 {
-    unsigned long sum1;
-    unsigned long sum2;
+    unsigned long long sum1;
+    unsigned long long sum2;
     unsigned rem;
 
     /* for negative len, return invalid adler32 as a clue for debugging */
@@ -163,7 +163,7 @@ local uLong adler32_combine_(adler1, adler2, len2)
     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
     if (sum1 >= BASE) sum1 -= BASE;
     if (sum1 >= BASE) sum1 -= BASE;
-    if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
+    if (sum2 >= ((unsigned long long)BASE << 1)) sum2 -= ((unsigned long long)BASE << 1);
     if (sum2 >= BASE) sum2 -= BASE;
     return sum1 | (sum2 << 16);
 }
diff --git a/zlib/contrib/infback9/infback9.c b/zlib/contrib/infback9/infback9.c
index 05fb3e3..be726ad 100644
--- a/zlib/contrib/infback9/infback9.c
+++ b/zlib/contrib/infback9/infback9.c
@@ -140,7 +140,7 @@ void makefixed9(void)
     do { \
         PULL(); \
         have--; \
-        hold += (unsigned long)(*next++) << bits; \
+        hold += (unsigned long long)(*next++) << bits; \
         bits += 8; \
     } while (0)
 
@@ -225,17 +225,17 @@ void FAR *out_desc;
     z_const unsigned char FAR *next;    /* next input */
     unsigned char FAR *put;     /* next output */
     unsigned have;              /* available input */
-    unsigned long left;         /* available output */
+    unsigned long long left;         /* available output */
     inflate_mode mode;          /* current inflate mode */
     int lastblock;              /* true if processing last block */
     int wrap;                   /* true if the window has wrapped */
     unsigned char FAR *window;  /* allocated sliding window, if needed */
-    unsigned long hold;         /* bit buffer */
+    unsigned long long hold;         /* bit buffer */
     unsigned bits;              /* bits in bit buffer */
     unsigned extra;             /* extra bits needed */
-    unsigned long length;       /* literal or length of data to copy */
-    unsigned long offset;       /* distance back to copy string from */
-    unsigned long copy;         /* number of stored or match bytes to copy */
+    unsigned long long length;       /* literal or length of data to copy */
+    unsigned long long offset;       /* distance back to copy string from */
+    unsigned long long copy;         /* number of stored or match bytes to copy */
     unsigned char FAR *from;    /* where to copy match bytes from */
     code const FAR *lencode;    /* starting table for length/literal codes */
     code const FAR *distcode;   /* starting table for distance codes */
diff --git a/zlib/contrib/inflate86/inffas86.c b/zlib/contrib/inflate86/inffas86.c
index 7292f67..4e0afcf 100644
--- a/zlib/contrib/inflate86/inffas86.c
+++ b/zlib/contrib/inflate86/inffas86.c
@@ -86,7 +86,7 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
 /* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
 /* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
 /* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
-/* 80   40 */ unsigned long hold;       /* edx rdx  local strm->hold */
+/* 80   40 */ unsigned long long hold;       /* edx rdx  local strm->hold */
 /* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
 /* 92   48 */ unsigned wsize;           /*          window size */
 /* 96   52 */ unsigned write;           /*          window write index */
@@ -126,8 +126,8 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
        input data or output space */
 
     /* align in on 1/2 hold size boundary */
-    while (((unsigned long)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
-        ar.hold += (unsigned long)*ar.in++ << ar.bits;
+    while (((unsigned long long)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
+        ar.hold += (unsigned long long)*ar.in++ << ar.bits;
         ar.bits += 8;
     }
 
diff --git a/zlib/contrib/masmx64/inffas8664.c b/zlib/contrib/masmx64/inffas8664.c
index e8af06f..5d5413d 100644
--- a/zlib/contrib/masmx64/inffas8664.c
+++ b/zlib/contrib/masmx64/inffas8664.c
@@ -144,7 +144,7 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
 
     /* align in on 1/2 hold size boundary */
     while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
-        ar.hold += (unsigned long)*ar.in++ << ar.bits;
+        ar.hold += (unsigned long long)*ar.in++ << ar.bits;
         ar.bits += 8;
     }
 
@@ -178,7 +178,7 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
     strm->avail_out = (unsigned)(ar.out < ar.end ?
                                  PAD_AVAIL_OUT + (ar.end - ar.out) :
                                  PAD_AVAIL_OUT - (ar.out - ar.end));
-    state->hold = (unsigned long)ar.hold;
+    state->hold = (unsigned long long)ar.hold;
     state->bits = ar.bits;
     return;
 }
diff --git a/zlib/contrib/minizip/crypt.h b/zlib/contrib/minizip/crypt.h
index 1e9e820..76ee977 100644
--- a/zlib/contrib/minizip/crypt.h
+++ b/zlib/contrib/minizip/crypt.h
@@ -32,7 +32,7 @@
 /***********************************************************************
  * Return the next byte in the pseudo-random sequence
  */
-static int decrypt_byte(unsigned long* pkeys, const z_crc_t* pcrc_32_tab)
+static int decrypt_byte(unsigned long long* pkeys, const z_crc_t* pcrc_32_tab)
 {
     unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
                      * unpredictable manner on 16-bit systems; not a problem
@@ -45,7 +45,7 @@ static int decrypt_byte(unsigned long* pkeys, const z_crc_t* pcrc_32_tab)
 /***********************************************************************
  * Update the encryption keys with the next byte of plain text
  */
-static int update_keys(unsigned long* pkeys,const z_crc_t* pcrc_32_tab,int c)
+static int update_keys(unsigned long long* pkeys,const z_crc_t* pcrc_32_tab,int c)
 {
     (*(pkeys+0)) = CRC32((*(pkeys+0)), c);
     (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
@@ -62,7 +62,7 @@ static int update_keys(unsigned long* pkeys,const z_crc_t* pcrc_32_tab,int c)
  * Initialize the encryption keys and the random header according to
  * the given password.
  */
-static void init_keys(const char* passwd,unsigned long* pkeys,const z_crc_t* pcrc_32_tab)
+static void init_keys(const char* passwd,unsigned long long* pkeys,const z_crc_t* pcrc_32_tab)
 {
     *(pkeys+0) = 305419896L;
     *(pkeys+1) = 591751049L;
@@ -90,9 +90,9 @@ static void init_keys(const char* passwd,unsigned long* pkeys,const z_crc_t* pcr
 static int crypthead(const char* passwd,      /* password string */
                      unsigned char* buf,      /* where to write header */
                      int bufSize,
-                     unsigned long* pkeys,
+                     unsigned long long* pkeys,
                      const z_crc_t* pcrc_32_tab,
-                     unsigned long crcForCrypting)
+                     unsigned long long crcForCrypting)
 {
     int n;                       /* index in random header */
     int t;                       /* temporary */
diff --git a/zlib/contrib/minizip/ioapi.c b/zlib/contrib/minizip/ioapi.c
index 7f5c191..6fcbe99 100644
--- a/zlib/contrib/minizip/ioapi.c
+++ b/zlib/contrib/minizip/ioapi.c
@@ -38,7 +38,7 @@ voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,const void*filename
     }
 }
 
-long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)
+long long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)
 {
     if (pfilefunc->zfile_func64.zseek64_file != NULL)
         return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);
@@ -88,7 +88,7 @@ static voidpf  ZCALLBACK fopen_file_func OF((voidpf opaque, const char* filename
 static uLong   ZCALLBACK fread_file_func OF((voidpf opaque, voidpf stream, void* buf, uLong size));
 static uLong   ZCALLBACK fwrite_file_func OF((voidpf opaque, voidpf stream, const void* buf,uLong size));
 static ZPOS64_T ZCALLBACK ftell64_file_func OF((voidpf opaque, voidpf stream));
-static long    ZCALLBACK fseek64_file_func OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
+static long long    ZCALLBACK fseek64_file_func OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
 static int     ZCALLBACK fclose_file_func OF((voidpf opaque, voidpf stream));
 static int     ZCALLBACK ferror_file_func OF((voidpf opaque, voidpf stream));
 
@@ -143,9 +143,9 @@ static uLong ZCALLBACK fwrite_file_func (voidpf opaque, voidpf stream, const voi
     return ret;
 }
 
-static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)
+static long long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)
 {
-    long ret;
+    long long ret;
     ret = ftell((FILE *)stream);
     return ret;
 }
@@ -158,10 +158,10 @@ static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)
     return ret;
 }
 
-static long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offset, int origin)
+static long long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offset, int origin)
 {
     int fseek_origin=0;
-    long ret;
+    long long ret;
     switch (origin)
     {
     case ZLIB_FILEFUNC_SEEK_CUR :
@@ -181,10 +181,10 @@ static long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offs
     return ret;
 }
 
-static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)
+static long long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)
 {
     int fseek_origin=0;
-    long ret;
+    long long ret;
     switch (origin)
     {
     case ZLIB_FILEFUNC_SEEK_CUR :
diff --git a/zlib/contrib/minizip/ioapi.h b/zlib/contrib/minizip/ioapi.h
index 8dcbdb0..69ca74c 100644
--- a/zlib/contrib/minizip/ioapi.h
+++ b/zlib/contrib/minizip/ioapi.h
@@ -138,8 +138,8 @@ typedef uLong    (ZCALLBACK *write_file_func)     OF((voidpf opaque, voidpf stre
 typedef int      (ZCALLBACK *close_file_func)     OF((voidpf opaque, voidpf stream));
 typedef int      (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
 
-typedef long     (ZCALLBACK *tell_file_func)      OF((voidpf opaque, voidpf stream));
-typedef long     (ZCALLBACK *seek_file_func)      OF((voidpf opaque, voidpf stream, uLong offset, int origin));
+typedef long long     (ZCALLBACK *tell_file_func)      OF((voidpf opaque, voidpf stream));
+typedef long long     (ZCALLBACK *seek_file_func)      OF((voidpf opaque, voidpf stream, uLong offset, int origin));
 
 
 /* here is the "old" 32 bits structure structure */
@@ -156,7 +156,7 @@ typedef struct zlib_filefunc_def_s
 } zlib_filefunc_def;
 
 typedef ZPOS64_T (ZCALLBACK *tell64_file_func)    OF((voidpf opaque, voidpf stream));
-typedef long     (ZCALLBACK *seek64_file_func)    OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
+typedef long long     (ZCALLBACK *seek64_file_func)    OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
 typedef voidpf   (ZCALLBACK *open64_file_func)    OF((voidpf opaque, const void* filename, int mode));
 
 typedef struct zlib_filefunc64_def_s
@@ -192,7 +192,7 @@ typedef struct zlib_filefunc64_32_def_s
 #define ZERROR64(filefunc,filestream)             ((*((filefunc).zfile_func64.zerror_file))  ((filefunc).zfile_func64.opaque,filestream))
 
 voidpf call_zopen64 OF((const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode));
-long    call_zseek64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin));
+long long    call_zseek64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin));
 ZPOS64_T call_ztell64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream));
 
 void    fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32);
diff --git a/zlib/contrib/minizip/iowin32.c b/zlib/contrib/minizip/iowin32.c
index 274f39e..c2d513d 100644
--- a/zlib/contrib/minizip/iowin32.c
+++ b/zlib/contrib/minizip/iowin32.c
@@ -37,7 +37,7 @@ voidpf  ZCALLBACK win32_open_file_func  OF((voidpf opaque, const char* filename,
 uLong   ZCALLBACK win32_read_file_func  OF((voidpf opaque, voidpf stream, void* buf, uLong size));
 uLong   ZCALLBACK win32_write_file_func OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
 ZPOS64_T ZCALLBACK win32_tell64_file_func  OF((voidpf opaque, voidpf stream));
-long    ZCALLBACK win32_seek64_file_func  OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
+long long    ZCALLBACK win32_seek64_file_func  OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
 int     ZCALLBACK win32_close_file_func OF((voidpf opaque, voidpf stream));
 int     ZCALLBACK win32_error_file_func OF((voidpf opaque, voidpf stream));
 
@@ -258,9 +258,9 @@ static BOOL MySetFilePointerEx(HANDLE hFile, LARGE_INTEGER pos, LARGE_INTEGER *n
 #endif
 }
 
-long ZCALLBACK win32_tell_file_func (voidpf opaque,voidpf stream)
+long long ZCALLBACK win32_tell_file_func (voidpf opaque,voidpf stream)
 {
-    long ret=-1;
+    long long ret=-1;
     HANDLE hFile = NULL;
     if (stream!=NULL)
         hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
@@ -276,7 +276,7 @@ long ZCALLBACK win32_tell_file_func (voidpf opaque,voidpf stream)
             ret = -1;
         }
         else
-            ret=(long)pos.LowPart;
+            ret=(long long)pos.LowPart;
     }
     return ret;
 }
@@ -306,12 +306,12 @@ ZPOS64_T ZCALLBACK win32_tell64_file_func (voidpf opaque, voidpf stream)
 }
 
 
-long ZCALLBACK win32_seek_file_func (voidpf opaque,voidpf stream,uLong offset,int origin)
+long long ZCALLBACK win32_seek_file_func (voidpf opaque,voidpf stream,uLong offset,int origin)
 {
     DWORD dwMoveMethod=0xFFFFFFFF;
     HANDLE hFile = NULL;
 
-    long ret=-1;
+    long long ret=-1;
     if (stream!=NULL)
         hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
     switch (origin)
@@ -344,11 +344,11 @@ long ZCALLBACK win32_seek_file_func (voidpf opaque,voidpf stream,uLong offset,in
     return ret;
 }
 
-long ZCALLBACK win32_seek64_file_func (voidpf opaque, voidpf stream,ZPOS64_T offset,int origin)
+long long ZCALLBACK win32_seek64_file_func (voidpf opaque, voidpf stream,ZPOS64_T offset,int origin)
 {
     DWORD dwMoveMethod=0xFFFFFFFF;
     HANDLE hFile = NULL;
-    long ret=-1;
+    long long ret=-1;
 
     if (stream!=NULL)
         hFile = ((WIN32FILE_IOWIN*)stream)->hf;
diff --git a/zlib/contrib/minizip/minizip.c b/zlib/contrib/minizip/minizip.c
index 4288962..5aa37aa 100644
--- a/zlib/contrib/minizip/minizip.c
+++ b/zlib/contrib/minizip/minizip.c
@@ -182,14 +182,14 @@ void do_help()
 
 /* calculate the CRC32 of a file,
    because to encrypt a file, we need known the CRC32 of the file before */
-int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)
+int getFileCrc(const char* filenameinzip,void*buf,unsigned long long size_buf,unsigned long long* result_crc)
 {
-   unsigned long calculate_crc=0;
+   unsigned long long calculate_crc=0;
    int err=ZIP_OK;
    FILE * fin = FOPEN_FUNC(filenameinzip,"rb");
 
-   unsigned long size_read = 0;
-   unsigned long total_read = 0;
+   unsigned long long size_read = 0;
+   unsigned long long total_read = 0;
    if (fin==NULL)
    {
        err = ZIP_ERRNO;
@@ -400,7 +400,7 @@ int main(argc,argv)
                 const char* filenameinzip = argv[i];
                 const char *savefilenameinzip;
                 zip_fileinfo zi;
-                unsigned long crcFile=0;
+                unsigned long long crcFile=0;
                 int zip64 = 0;
 
                 zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour =
diff --git a/zlib/contrib/minizip/unzip.c b/zlib/contrib/minizip/unzip.c
index bcfb941..565fa38 100644
--- a/zlib/contrib/minizip/unzip.c
+++ b/zlib/contrib/minizip/unzip.c
@@ -187,7 +187,7 @@ typedef struct
     int isZip64;
 
 #    ifndef NOUNCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
+    unsigned long long keys[3];     /* keys defining the pseudo-random sequence */
     const z_crc_t* pcrc_32_tab;
 #    endif
 } unz64_s;
@@ -892,7 +892,7 @@ local int unz64local_GetCurrentFileInfoInternal (unzFile file,
     unz_file_info64_internal file_info_internal;
     int err=UNZ_OK;
     uLong uMagic;
-    long lSeek=0;
+    long long lSeek=0;
     uLong uL;
 
     if (file==NULL)
diff --git a/zlib/contrib/minizip/zip.c b/zlib/contrib/minizip/zip.c
index 44e88a9..2e371da 100644
--- a/zlib/contrib/minizip/zip.c
+++ b/zlib/contrib/minizip/zip.c
@@ -74,7 +74,7 @@
 
 
 // NOT sure that this work on ALL platform
-#define MAKEULONG64(a, b) ((ZPOS64_T)(((unsigned long)(a)) | ((ZPOS64_T)((unsigned long)(b))) << 32))
+#define MAKEULONG64(a, b) ((ZPOS64_T)(((unsigned long long)(a)) | ((ZPOS64_T)((unsigned long long)(b))) << 32))
 
 #ifndef SEEK_CUR
 #define SEEK_CUR    1
@@ -156,7 +156,7 @@ typedef struct
     ZPOS64_T totalCompressedData;
     ZPOS64_T totalUncompressedData;
 #ifndef NOCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
+    unsigned long long keys[3];     /* keys defining the pseudo-random sequence */
     const z_crc_t* pcrc_32_tab;
     int crypt_header_size;
 #endif
diff --git a/zlib/contrib/puff/puff.c b/zlib/contrib/puff/puff.c
index c6c90d7..22b8e93 100644
--- a/zlib/contrib/puff/puff.c
+++ b/zlib/contrib/puff/puff.c
@@ -98,13 +98,13 @@
 struct state {
     /* output state */
     unsigned char *out;         /* output buffer */
-    unsigned long outlen;       /* available space at out */
-    unsigned long outcnt;       /* bytes written to out so far */
+    unsigned long long outlen;       /* available space at out */
+    unsigned long long outcnt;       /* bytes written to out so far */
 
     /* input state */
     const unsigned char *in;    /* input buffer */
-    unsigned long inlen;        /* available input at in */
-    unsigned long incnt;        /* bytes read so far */
+    unsigned long long inlen;        /* available input at in */
+    unsigned long long incnt;        /* bytes read so far */
     int bitbuf;                 /* bit buffer */
     int bitcnt;                 /* number of bits in bit buffer */
 
@@ -125,14 +125,14 @@ struct state {
  */
 local int bits(struct state *s, int need)
 {
-    long val;           /* bit accumulator (can use up to 20 bits) */
+    long long val;           /* bit accumulator (can use up to 20 bits) */
 
     /* load at least need bits into val */
     val = s->bitbuf;
     while (s->bitcnt < need) {
         if (s->incnt == s->inlen)
             longjmp(s->env, 1);         /* out of input */
-        val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */
+        val |= (long long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */
         s->bitcnt += 8;
     }
 
@@ -791,9 +791,9 @@ local int dynamic(struct state *s)
  *   expected values to check.
  */
 int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
+         unsigned long long *destlen,        /* amount of output space */
          const unsigned char *source,   /* pointer to source data pointer */
-         unsigned long *sourcelen)      /* amount of input available */
+         unsigned long long *sourcelen)      /* amount of input available */
 {
     struct state s;             /* input/output state */
     int last, type;             /* block information */
diff --git a/zlib/contrib/puff/puff.h b/zlib/contrib/puff/puff.h
index e23a245..1b88666 100644
--- a/zlib/contrib/puff/puff.h
+++ b/zlib/contrib/puff/puff.h
@@ -30,6 +30,6 @@
 #endif
 
 int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
+         unsigned long long *destlen,        /* amount of output space */
          const unsigned char *source,   /* pointer to source data pointer */
-         unsigned long *sourcelen);     /* amount of input available */
+         unsigned long long *sourcelen);     /* amount of input available */
diff --git a/zlib/contrib/puff/pufftest.c b/zlib/contrib/puff/pufftest.c
index 7764814..eb06cca 100644
--- a/zlib/contrib/puff/pufftest.c
+++ b/zlib/contrib/puff/pufftest.c
@@ -92,7 +92,7 @@ int main(int argc, char **argv)
     char *arg, *name = NULL;
     unsigned char *source = NULL, *dest;
     size_t len = 0;
-    unsigned long sourcelen, destlen;
+    unsigned long long sourcelen, destlen;
 
     /* process arguments */
     while (arg = *++argv, --argc)
@@ -133,7 +133,7 @@ int main(int argc, char **argv)
 
     /* test inflate data with offset skip */
     len -= skip;
-    sourcelen = (unsigned long)len;
+    sourcelen = (unsigned long long)len;
     ret = puff(NIL, &destlen, source + skip, &sourcelen);
     if (ret)
         fprintf(stderr, "puff() failed with return code %d\n", ret);
diff --git a/zlib/contrib/testzlib/testzlib.c b/zlib/contrib/testzlib/testzlib.c
index 5f659de..759e38e 100644
--- a/zlib/contrib/testzlib/testzlib.c
+++ b/zlib/contrib/testzlib/testzlib.c
@@ -116,7 +116,7 @@ DWORD GetMsecSincePerfCounter(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPe
     return dwRet;
 }
 
-int ReadFileMemory(const char* filename,long* plFileSize,unsigned char** pFilePtr)
+int ReadFileMemory(const char* filename,long long* plFileSize,unsigned char** pFilePtr)
 {
     FILE* stream;
     unsigned char* ptr;
@@ -147,14 +147,14 @@ int main(int argc, char *argv[])
     int BlockSizeCompress=0x8000;
     int BlockSizeUncompress=0x8000;
     int cprLevel=Z_DEFAULT_COMPRESSION ;
-    long lFileSize;
+    long long lFileSize;
     unsigned char* FilePtr;
-    long lBufferSizeCpr;
-    long lBufferSizeUncpr;
-    long lCompressedSize=0;
+    long long lBufferSizeCpr;
+    long long lBufferSizeUncpr;
+    long long lCompressedSize=0;
     unsigned char* CprPtr;
     unsigned char* UncprPtr;
-    long lSizeCpr,lSizeUncpr;
+    long long lSizeCpr,lSizeUncpr;
     DWORD dwGetTick,dwMsecQP;
     LARGE_INTEGER li_qp,li_rdtsc,dwResRdtsc;
 
@@ -191,8 +191,8 @@ int main(int argc, char *argv[])
     {
         z_stream zcpr;
         int ret=Z_OK;
-        long lOrigToDo = lFileSize;
-        long lOrigDone = 0;
+        long long lOrigToDo = lFileSize;
+        long long lOrigDone = 0;
         int step=0;
         memset(&zcpr,0,sizeof(z_stream));
         deflateInit(&zcpr,cprLevel);
@@ -203,7 +203,7 @@ int main(int argc, char *argv[])
 
         do
         {
-            long all_read_before = zcpr.total_in;
+            long long all_read_before = zcpr.total_in;
             zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);
             zcpr.avail_out = BlockSizeCompress;
             ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);
@@ -232,8 +232,8 @@ int main(int argc, char *argv[])
     {
         z_stream zcpr;
         int ret=Z_OK;
-        long lOrigToDo = lSizeCpr;
-        long lOrigDone = 0;
+        long long lOrigToDo = lSizeCpr;
+        long long lOrigDone = 0;
         int step=0;
         memset(&zcpr,0,sizeof(z_stream));
         inflateInit(&zcpr);
@@ -244,7 +244,7 @@ int main(int argc, char *argv[])
 
         do
         {
-            long all_read_before = zcpr.total_in;
+            long long all_read_before = zcpr.total_in;
             zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);
             zcpr.avail_out = BlockSizeUncompress;
             ret=inflate(&zcpr,Z_SYNC_FLUSH);
diff --git a/zlib/crc32.c b/zlib/crc32.c
index affcd46..bdf1ef7 100644
--- a/zlib/crc32.c
+++ b/zlib/crc32.c
@@ -35,9 +35,9 @@
 #  define BYFOUR
 #endif
 #ifdef BYFOUR
-   local unsigned long crc32_little OF((unsigned long,
+   local unsigned long long crc32_little OF((unsigned long long,
                         const unsigned char FAR *, z_size_t));
-   local unsigned long crc32_big OF((unsigned long,
+   local unsigned long long crc32_big OF((unsigned long long,
                         const unsigned char FAR *, z_size_t));
 #  define TBLS 8
 #else
@@ -45,9 +45,9 @@
 #endif /* BYFOUR */
 
 /* Local functions for crc concatenation */
-local unsigned long gf2_matrix_times OF((unsigned long *mat,
-                                         unsigned long vec));
-local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
+local unsigned long long gf2_matrix_times OF((unsigned long long *mat,
+                                         unsigned long long vec));
+local void gf2_matrix_square OF((unsigned long long *square, unsigned long long *mat));
 local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));
 
 
@@ -170,7 +170,7 @@ local void write_table(out, table)
 
     for (n = 0; n < 256; n++)
         fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
-                (unsigned long)(table[n]),
+                (unsigned long long)(table[n]),
                 n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
 }
 #endif /* MAKECRCH */
@@ -199,8 +199,8 @@ const z_crc_t FAR * ZEXPORT get_crc_table()
 #define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
 
 /* ========================================================================= */
-unsigned long ZEXPORT crc32_z(crc, buf, len)
-    unsigned long crc;
+unsigned long long ZEXPORT crc32_z(crc, buf, len)
+    unsigned long long crc;
     const unsigned char FAR *buf;
     z_size_t len;
 {
@@ -234,8 +234,8 @@ unsigned long ZEXPORT crc32_z(crc, buf, len)
 }
 
 /* ========================================================================= */
-unsigned long ZEXPORT crc32(crc, buf, len)
-    unsigned long crc;
+unsigned long long ZEXPORT crc32(crc, buf, len)
+    unsigned long long crc;
     const unsigned char FAR *buf;
     uInt len;
 {
@@ -263,8 +263,8 @@ unsigned long ZEXPORT crc32(crc, buf, len)
 #define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
 
 /* ========================================================================= */
-local unsigned long crc32_little(crc, buf, len)
-    unsigned long crc;
+local unsigned long long crc32_little(crc, buf, len)
+    unsigned long long crc;
     const unsigned char FAR *buf;
     z_size_t len;
 {
@@ -293,7 +293,7 @@ local unsigned long crc32_little(crc, buf, len)
         c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
     } while (--len);
     c = ~c;
-    return (unsigned long)c;
+    return (unsigned long long)c;
 }
 
 /* ========================================================================= */
@@ -303,8 +303,8 @@ local unsigned long crc32_little(crc, buf, len)
 #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
 
 /* ========================================================================= */
-local unsigned long crc32_big(crc, buf, len)
-    unsigned long crc;
+local unsigned long long crc32_big(crc, buf, len)
+    unsigned long long crc;
     const unsigned char FAR *buf;
     z_size_t len;
 {
@@ -333,7 +333,7 @@ local unsigned long crc32_big(crc, buf, len)
         c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
     } while (--len);
     c = ~c;
-    return (unsigned long)(ZSWAP32(c));
+    return (unsigned long long)(ZSWAP32(c));
 }
 
 #endif /* BYFOUR */
@@ -341,11 +341,11 @@ local unsigned long crc32_big(crc, buf, len)
 #define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
 
 /* ========================================================================= */
-local unsigned long gf2_matrix_times(mat, vec)
-    unsigned long *mat;
-    unsigned long vec;
+local unsigned long long gf2_matrix_times(mat, vec)
+    unsigned long long *mat;
+    unsigned long long vec;
 {
-    unsigned long sum;
+    unsigned long long sum;
 
     sum = 0;
     while (vec) {
@@ -359,8 +359,8 @@ local unsigned long gf2_matrix_times(mat, vec)
 
 /* ========================================================================= */
 local void gf2_matrix_square(square, mat)
-    unsigned long *square;
-    unsigned long *mat;
+    unsigned long long *square;
+    unsigned long long *mat;
 {
     int n;
 
@@ -375,9 +375,9 @@ local uLong crc32_combine_(crc1, crc2, len2)
     z_off64_t len2;
 {
     int n;
-    unsigned long row;
-    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
-    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
+    unsigned long long row;
+    unsigned long long even[GF2_DIM];    /* even-power-of-two zeros operator */
+    unsigned long long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
 
     /* degenerate case (also disallow negative lengths) */
     if (len2 <= 0)
diff --git a/zlib/deflate.c b/zlib/deflate.c
index 586cd15..08ba957 100644
--- a/zlib/deflate.c
+++ b/zlib/deflate.c
@@ -430,7 +430,7 @@ int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
         fill_window(s);
     }
     s->strstart += s->lookahead;
-    s->block_start = (long)s->strstart;
+    s->block_start = (long long)s->strstart;
     s->insert = s->lookahead;
     s->lookahead = 0;
     s->match_length = s->prev_length = MIN_MATCH-1;
@@ -1512,7 +1512,7 @@ local void fill_window(s)
             zmemcpy(s->window, s->window+wsize, (unsigned)wsize - more);
             s->match_start -= wsize;
             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
+            s->block_start -= (long long) wsize;
             slide_hash(s);
             more += wsize;
         }
@@ -1606,7 +1606,7 @@ local void fill_window(s)
    _tr_flush_block(s, (s->block_start >= 0L ? \
                    (charf *)&s->window[(unsigned)s->block_start] : \
                    (charf *)Z_NULL), \
-                (ulg)((long)s->strstart - s->block_start), \
+                (ulg)((long long)s->strstart - s->block_start), \
                 (last)); \
    s->block_start = s->strstart; \
    flush_pending(s->strm); \
@@ -1766,12 +1766,12 @@ local block_state deflate_stored(s, flush)
 
     /* If flushing and all input has been consumed, then done. */
     if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
-        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
+        s->strm->avail_in == 0 && (long long)s->strstart == s->block_start)
         return block_done;
 
     /* Fill the window with any remaining input. */
     have = s->window_size - s->strstart - 1;
-    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
+    if (s->strm->avail_in > have && s->block_start >= (long long)s->w_size) {
         /* Slide the window down. */
         s->block_start -= s->w_size;
         s->strstart -= s->w_size;
diff --git a/zlib/deflate.h b/zlib/deflate.h
index 360ca23..f80823a 100644
--- a/zlib/deflate.h
+++ b/zlib/deflate.h
@@ -151,7 +151,7 @@ typedef struct internal_state {
      *   hash_shift * MIN_MATCH >= hash_bits
      */
 
-    long block_start;
+    long long block_start;
     /* Window position at the beginning of the current output block. Gets
      * negative when the window is moved backwards.
      */
diff --git a/zlib/example.c b/zlib/example.c
index e303897..fe118de 100644
--- a/zlib/example.c
+++ b/zlib/example.c
@@ -133,7 +133,7 @@ void test_gzio(fname, uncompr, uncomprLen)
     pos = gzseek(file, -8L, SEEK_CUR);
     if (pos != 6 || gztell(file) != pos) {
         fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
-                (long)pos, (long)gztell(file));
+                (long long)pos, (long long)gztell(file));
         exit(1);
     }
 
diff --git a/zlib/examples/gun.c b/zlib/examples/gun.c
index be44fa5..38342a9 100644
--- a/zlib/examples/gun.c
+++ b/zlib/examples/gun.c
@@ -119,8 +119,8 @@ local unsigned in(void *in_desc, z_const unsigned char **buf)
 struct outd {
     int outfile;
     int check;                  /* true if checking crc and total */
-    unsigned long crc;
-    unsigned long total;
+    unsigned long long crc;
+    unsigned long long total;
 };
 
 /* Write output buffer and update the CRC-32 and total bytes written.  write()
diff --git a/zlib/examples/gzappend.c b/zlib/examples/gzappend.c
index 662dec3..354f858 100644
--- a/zlib/examples/gzappend.c
+++ b/zlib/examples/gzappend.c
@@ -220,14 +220,14 @@ local void skip(file *in, unsigned n)
 }
 
 /* read a four-byte unsigned integer, little-endian, from in */
-unsigned long read4(file *in)
+unsigned long long read4(file *in)
 {
-    unsigned long val;
+    unsigned long long val;
 
     val = read1(in);
     val += (unsigned)read1(in) << 8;
-    val += (unsigned long)read1(in) << 16;
-    val += (unsigned long)read1(in) << 24;
+    val += (unsigned long long)read1(in) << 16;
+    val += (unsigned long long)read1(in) << 24;
     return val;
 }
 
@@ -260,7 +260,7 @@ local int gzscan(char *name, z_stream *strm, int level)
 {
     int ret, lastbit, left, full;
     unsigned have;
-    unsigned long crc, tot;
+    unsigned long long crc, tot;
     unsigned char *window;
     off_t lastoff, end;
     file gz;
diff --git a/zlib/examples/gzjoin.c b/zlib/examples/gzjoin.c
index 89e8098..de8e963 100644
--- a/zlib/examples/gzjoin.c
+++ b/zlib/examples/gzjoin.c
@@ -120,7 +120,7 @@ local bin *bopen(char *name)
    1 indicating that end-of-file was reached */
 local int bload(bin *in)
 {
-    long len;
+    long long len;
 
     if (in == NULL)
         return -1;
@@ -128,7 +128,7 @@ local int bload(bin *in)
         return 0;
     in->next = in->buf;
     do {
-        len = (long)read(in->fd, in->buf + in->left, CHUNK - in->left);
+        len = (long long)read(in->fd, in->buf + in->left, CHUNK - in->left);
         if (len < 0)
             return -1;
         in->left += (unsigned)len;
@@ -142,14 +142,14 @@ local int bload(bin *in)
                     bail("unexpected end of file on ", in->name))
 
 /* get a four-byte little-endian unsigned integer from file */
-local unsigned long bget4(bin *in)
+local unsigned long long bget4(bin *in)
 {
-    unsigned long val;
+    unsigned long long val;
 
     val = bget(in);
-    val += (unsigned long)(bget(in)) << 8;
-    val += (unsigned long)(bget(in)) << 16;
-    val += (unsigned long)(bget(in)) << 24;
+    val += (unsigned long long)(bget(in)) << 8;
+    val += (unsigned long long)(bget(in)) << 16;
+    val += (unsigned long long)(bget(in)) << 24;
     return val;
 }
 
@@ -242,7 +242,7 @@ local void gzhead(bin *in)
 }
 
 /* write a four-byte little-endian unsigned integer to out */
-local void put4(unsigned long val, FILE *out)
+local void put4(unsigned long long val, FILE *out)
 {
     putc(val & 0xff, out);
     putc((val >> 8) & 0xff, out);
@@ -262,7 +262,7 @@ local void zpull(z_streamp strm, bin *in)
 }
 
 /* Write header for gzip file to out and initialize trailer. */
-local void gzinit(unsigned long *crc, unsigned long *tot, FILE *out)
+local void gzinit(unsigned long long *crc, unsigned long long *tot, FILE *out)
 {
     fwrite("\x1f\x8b\x08\0\0\0\0\0\0\xff", 1, 10, out);
     *crc = crc32(0L, Z_NULL, 0);
@@ -276,7 +276,7 @@ local void gzinit(unsigned long *crc, unsigned long *tot, FILE *out)
    crc and length (modulo 2^32) of the output for the trailer.  The resulting
    gzip file is written to out.  gzinit() must be called before the first call
    of gzcopy() to write the gzip header and to initialize crc and tot. */
-local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,
+local void gzcopy(char *name, int clr, unsigned long long *crc, unsigned long long *tot,
                   FILE *out)
 {
     int ret;                /* return value from zlib functions */
@@ -409,7 +409,7 @@ local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,
 
     /* update crc and tot */
     *crc = crc32_combine(*crc, bget4(in), len);
-    *tot += (unsigned long)len;
+    *tot += (unsigned long long)len;
 
     /* clean up */
     inflateEnd(&strm);
@@ -426,7 +426,7 @@ local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,
 /* join the gzip files on the command line, write result to stdout */
 int main(int argc, char **argv)
 {
-    unsigned long crc, tot;     /* running crc and total uncompressed length */
+    unsigned long long crc, tot;     /* running crc and total uncompressed length */
 
     /* skip command name */
     argc--;
diff --git a/zlib/examples/gzlog.c b/zlib/examples/gzlog.c
index b8c2927..b25c411 100644
--- a/zlib/examples/gzlog.c
+++ b/zlib/examples/gzlog.c
@@ -240,7 +240,7 @@
 
 #define local static
 typedef unsigned int uint;
-typedef unsigned long ulong;
+typedef unsigned long long ulong;
 
 /* Macro for debugging to deterministically force recovery operations */
 #ifdef GZLOG_DEBUG
diff --git a/zlib/infback.c b/zlib/infback.c
index 59679ec..271f32e 100644
--- a/zlib/infback.c
+++ b/zlib/infback.c
@@ -173,7 +173,7 @@ struct inflate_state FAR *state;
     do { \
         PULL(); \
         have--; \
-        hold += (unsigned long)(*next++) << bits; \
+        hold += (unsigned long long)(*next++) << bits; \
         bits += 8; \
     } while (0)
 
@@ -258,7 +258,7 @@ void FAR *out_desc;
     z_const unsigned char FAR *next;    /* next input */
     unsigned char FAR *put;     /* next output */
     unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
+    unsigned long long hold;         /* bit buffer */
     unsigned bits;              /* bits in bit buffer */
     unsigned copy;              /* number of stored or match bytes to copy */
     unsigned char FAR *from;    /* where to copy match bytes from */
diff --git a/zlib/inffast.c b/zlib/inffast.c
index 0dbd1db..b901f56 100644
--- a/zlib/inffast.c
+++ b/zlib/inffast.c
@@ -64,7 +64,7 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
     unsigned whave;             /* valid bytes in the window */
     unsigned wnext;             /* window write index */
     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
-    unsigned long hold;         /* local strm->hold */
+    unsigned long long hold;         /* local strm->hold */
     unsigned bits;              /* local strm->bits */
     code const FAR *lcode;      /* local strm->lencode */
     code const FAR *dcode;      /* local strm->distcode */
@@ -102,9 +102,9 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
        input data or output space */
     do {
         if (bits < 15) {
-            hold += (unsigned long)(*in++) << bits;
+            hold += (unsigned long long)(*in++) << bits;
             bits += 8;
-            hold += (unsigned long)(*in++) << bits;
+            hold += (unsigned long long)(*in++) << bits;
             bits += 8;
         }
         here = lcode[hold & lmask];
@@ -124,7 +124,7 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
             op &= 15;                           /* number of extra bits */
             if (op) {
                 if (bits < op) {
-                    hold += (unsigned long)(*in++) << bits;
+                    hold += (unsigned long long)(*in++) << bits;
                     bits += 8;
                 }
                 len += (unsigned)hold & ((1U << op) - 1);
@@ -133,9 +133,9 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
             }
             Tracevv((stderr, "inflate:         length %u\n", len));
             if (bits < 15) {
-                hold += (unsigned long)(*in++) << bits;
+                hold += (unsigned long long)(*in++) << bits;
                 bits += 8;
-                hold += (unsigned long)(*in++) << bits;
+                hold += (unsigned long long)(*in++) << bits;
                 bits += 8;
             }
             here = dcode[hold & dmask];
@@ -148,10 +148,10 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */
                 dist = (unsigned)(here.val);
                 op &= 15;                       /* number of extra bits */
                 if (bits < op) {
-                    hold += (unsigned long)(*in++) << bits;
+                    hold += (unsigned long long)(*in++) << bits;
                     bits += 8;
                     if (bits < op) {
-                        hold += (unsigned long)(*in++) << bits;
+                        hold += (unsigned long long)(*in++) << bits;
                         bits += 8;
                     }
                 }
diff --git a/zlib/inflate.c b/zlib/inflate.c
index ac333e8..28e80cd 100644
--- a/zlib/inflate.c
+++ b/zlib/inflate.c
@@ -507,7 +507,7 @@ unsigned copy;
     do { \
         if (have == 0) goto inf_leave; \
         have--; \
-        hold += (unsigned long)(*next++) << bits; \
+        hold += (unsigned long long)(*next++) << bits; \
         bits += 8; \
     } while (0)
 
@@ -627,7 +627,7 @@ int flush;
     z_const unsigned char FAR *next;    /* next input */
     unsigned char FAR *put;     /* next output */
     unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
+    unsigned long long hold;         /* bit buffer */
     unsigned bits;              /* bits in bit buffer */
     unsigned in, out;           /* save starting available input and output */
     unsigned copy;              /* number of stored or match bytes to copy */
@@ -1317,7 +1317,7 @@ const Bytef *dictionary;
 uInt dictLength;
 {
     struct inflate_state FAR *state;
-    unsigned long dictid;
+    unsigned long long dictid;
     int ret;
 
     /* check state */
@@ -1401,7 +1401,7 @@ int ZEXPORT inflateSync(strm)
 z_streamp strm;
 {
     unsigned len;               /* number of bytes to look at or looked at */
-    unsigned long in, out;      /* temporary to save total_in and total_out */
+    unsigned long long in, out;      /* temporary to save total_in and total_out */
     unsigned char buf[4];       /* to restore bit buffer to byte string */
     struct inflate_state FAR *state;
 
@@ -1538,7 +1538,7 @@ int check;
     return Z_OK;
 }
 
-long ZEXPORT inflateMark(strm)
+long long ZEXPORT inflateMark(strm)
 z_streamp strm;
 {
     struct inflate_state FAR *state;
@@ -1546,16 +1546,16 @@ z_streamp strm;
     if (inflateStateCheck(strm))
         return -(1L << 16);
     state = (struct inflate_state FAR *)strm->state;
-    return (long)(((unsigned long)((long)state->back)) << 16) +
+    return (long long)(((unsigned long long)((long long)state->back)) << 16) +
         (state->mode == COPY ? state->length :
             (state->mode == MATCH ? state->was - state->length : 0));
 }
 
-unsigned long ZEXPORT inflateCodesUsed(strm)
+unsigned long long ZEXPORT inflateCodesUsed(strm)
 z_streamp strm;
 {
     struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return (unsigned long)-1;
+    if (inflateStateCheck(strm)) return (unsigned long long)-1;
     state = (struct inflate_state FAR *)strm->state;
-    return (unsigned long)(state->next - state->codes);
+    return (unsigned long long)(state->next - state->codes);
 }
diff --git a/zlib/inflate.h b/zlib/inflate.h
index a46cce6..27571ce 100644
--- a/zlib/inflate.h
+++ b/zlib/inflate.h
@@ -88,8 +88,8 @@ struct inflate_state {
     int havedict;               /* true if dictionary provided */
     int flags;                  /* gzip header method and flags (0 if zlib) */
     unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
-    unsigned long check;        /* protected copy of check value */
-    unsigned long total;        /* protected copy of output count */
+    unsigned long long check;        /* protected copy of check value */
+    unsigned long long total;        /* protected copy of output count */
     gz_headerp head;            /* where to save gzip header information */
         /* sliding window */
     unsigned wbits;             /* log base 2 of requested window size */
@@ -98,7 +98,7 @@ struct inflate_state {
     unsigned wnext;             /* window write index */
     unsigned char FAR *window;  /* allocated sliding window, if needed */
         /* bit accumulator */
-    unsigned long hold;         /* input bit accumulator */
+    unsigned long long hold;         /* input bit accumulator */
     unsigned bits;              /* number of bits in "in" */
         /* for string and stored block copying */
     unsigned length;            /* literal or length of data to copy */
diff --git a/zlib/test/example.c b/zlib/test/example.c
index eee17ce..6520c32 100644
--- a/zlib/test/example.c
+++ b/zlib/test/example.c
@@ -162,7 +162,7 @@ void test_gzio(fname, uncompr, uncomprLen)
     pos = gzseek(file, -8L, SEEK_CUR);
     if (pos != 6 || gztell(file) != pos) {
         fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
-                (long)pos, (long)gztell(file));
+                (long long)pos, (long long)gztell(file));
         exit(1);
     }
 
diff --git a/zlib/trees.c b/zlib/trees.c
index d0a09b1..19764c4 100644
--- a/zlib/trees.c
+++ b/zlib/trees.c
@@ -1038,7 +1038,7 @@ int ZLIB_INTERNAL _tr_tally (s, dist, lc)
     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
         /* Compute an upper bound for the compressed length */
         ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
+        ulg in_length = (ulg)((long long)s->strstart - s->block_start);
         int dcode;
         for (dcode = 0; dcode < D_CODES; dcode++) {
             out_length += (ulg)s->dyn_dtree[dcode].Freq *
@@ -1128,7 +1128,7 @@ local int detect_data_type(s)
      * set bits 0..6, 14..25, and 28..31
      * 0xf3ffc07f = binary 11110011111111111100000001111111
      */
-    unsigned long black_mask = 0xf3ffc07fUL;
+    unsigned long long black_mask = 0xf3ffc07fUL;
     int n;
 
     /* Check for non-textual ("black-listed") bytes. */
diff --git a/zlib/zconf.h b/zlib/zconf.h
index b399839..74f18c3 100644
--- a/zlib/zconf.h
+++ b/zlib/zconf.h
@@ -238,7 +238,7 @@
 #endif
 
 #ifdef Z_SOLO
-   typedef unsigned long z_size_t;
+   typedef unsigned long long z_size_t;
 #else
 #  define z_longlong long long
 #  if defined(NO_SIZE_T)
@@ -247,7 +247,7 @@
 #    include <stddef.h>
      typedef size_t z_size_t;
 #  else
-     typedef unsigned long z_size_t;
+     typedef unsigned long long z_size_t;
 #  endif
 #  undef z_longlong
 #endif
@@ -391,7 +391,7 @@
 typedef unsigned char  Byte;  /* 8 bits */
 #endif
 typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
+typedef unsigned long long  uLong; /* 32 bits or more */
 
 #ifdef SMALL_MEDIUM
    /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
@@ -419,7 +419,7 @@ typedef uLong FAR uLongf;
 #  if (UINT_MAX == 0xffffffffUL)
 #    define Z_U4 unsigned
 #  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
+#    define Z_U4 unsigned long long
 #  elif (USHRT_MAX == 0xffffffffUL)
 #    define Z_U4 unsigned short
 #  endif
@@ -428,7 +428,7 @@ typedef uLong FAR uLongf;
 #ifdef Z_U4
    typedef Z_U4 z_crc_t;
 #else
-   typedef unsigned long z_crc_t;
+   typedef unsigned long long z_crc_t;
 #endif
 
 #ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
@@ -501,7 +501,7 @@ typedef uLong FAR uLongf;
 #endif
 
 #ifndef z_off_t
-#  define z_off_t long
+#  define z_off_t long long
 #endif
 
 #if !defined(_WIN32) && defined(Z_LARGE64)
diff --git a/zlib/zlib.h b/zlib/zlib.h
index 49dfcec..68b9599 100644
--- a/zlib/zlib.h
+++ b/zlib/zlib.h
@@ -999,7 +999,7 @@ ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
    stream state was inconsistent.
 */
 
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
+ZEXTERN long long ZEXPORT inflateMark OF((z_streamp strm));
 /*
      This function returns two values, one in the lower 16 bits of the return
    value, and the other in the remaining upper bits, obtained by shifting the
@@ -1890,7 +1890,7 @@ ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
 ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
 ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
 ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
-ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF ((z_streamp));
+ZEXTERN unsigned long long  ZEXPORT inflateCodesUsed OF ((z_streamp));
 ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
 ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
 #if defined(_WIN32) && !defined(Z_SOLO)
diff --git a/zlib/zutil.c b/zlib/zutil.c
index 08787c6..5b25138 100644
--- a/zlib/zutil.c
+++ b/zlib/zutil.c
@@ -280,7 +280,7 @@ void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
 voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
 {
     (void)opaque;
-    return _halloc((long)items, size);
+    return _halloc((long long)items, size);
 }
 
 void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
diff --git a/zlib/zutil.h b/zlib/zutil.h
index 4b596ad..137c29b 100644
--- a/zlib/zutil.h
+++ b/zlib/zutil.h
@@ -30,7 +30,7 @@
 #endif
 
 #ifdef Z_SOLO
-   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
+   typedef long long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
 #endif
 
 #ifndef local
@@ -44,7 +44,7 @@ typedef unsigned char  uch;
 typedef uch FAR uchf;
 typedef unsigned short ush;
 typedef ush FAR ushf;
-typedef unsigned long  ulg;
+typedef unsigned long long  ulg;
 
 extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
 /* (size given to avoid silly warnings with Visual C++) */
@@ -89,7 +89,7 @@ extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
 #      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
          /* Allow compilation with ANSI keywords only enabled */
          void _Cdecl farfree( void *block );
-         void *_Cdecl farmalloc( unsigned long nbytes );
+         void *_Cdecl farmalloc( unsigned long long nbytes );
 #      else
 #        include <alloc.h>
 #      endif
